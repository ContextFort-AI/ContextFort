try {
  let A = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {}, t = new A.Error().stack;
  t && (A._sentryDebugIds = A._sentryDebugIds || {}, A._sentryDebugIds[t] = "61c50a9b-1a44-498f-98c1-e2f91be942e6", A._sentryDebugIdIdentifier = "sentry-dbid-61c50a9b-1a44-498f-98c1-e2f91be942e6");
} catch {
}
function cp(A) {
  return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
}
var ec = {}, gi = {}, A0;
function hp() {
  if (A0) return gi;
  A0 = 1;
  let A;
  const t = globalThis.process?.release?.name === "node", e = typeof window < "u";
  async function i(S, R = {}) {
    const { getDocument: x } = await s();
    return await x({
      data: S,
      isEvalSupported: !1,
      // See: https://github.com/mozilla/pdf.js/issues/4244#issuecomment-1479534301
      useSystemFonts: !0,
      ...R
    }).promise;
  }
  async function s() {
    return A || await n(), A;
  }
  async function n(S, { force: R = !1 } = {}) {
    if (!(A && !R)) {
      if (S)
        try {
          A = await r(S()), A && "resolvePDFJS" in A && (A = await A.resolvePDFJS());
          return;
        } catch (x) {
          throw console.error(x), new Error("Resolving failed. Please check the provided configuration.");
        }
      try {
        const { resolvePDFJS: x } = await Promise.resolve().then(() => QD);
        A = await x();
      } catch (x) {
        throw console.error(x), new Error("PDF.js is not available. Please add the package as a dependency.");
      }
    }
  }
  function o(S) {
    return typeof S == "object" && S !== null && "_pdfInfo" in S;
  }
  async function r(S) {
    const R = await S;
    return R.default || R;
  }
  async function c(S, R) {
    const x = o(S) ? S : await i(S), N = await x.getPage(R);
    if (R < 1 || R > x.numPages)
      throw new Error(`Invalid page number. Must be between 1 and ${x.numPages}.`);
    const U = await N.getOperatorList(), { OPS: T } = await s(), q = [];
    for (let _ = 0; _ < U.fnArray.length; _++) {
      if (U.fnArray[_] !== T.paintImageXObject)
        continue;
      const ht = U.argsArray[_][0], ut = await N.objs.get(ht);
      q.push(ut.data);
    }
    return q;
  }
  async function h(S, R, x = {}) {
    const N = await I(x.canvas), U = o(S) ? S : await i(S, { canvasFactory: N }), T = await U.getPage(R);
    if (R < 1 || R > U.numPages)
      throw new Error(`Invalid page number. Must be between 1 and ${U.numPages}.`);
    let q = x.scale || 1, _ = T.getViewport({ scale: q });
    x.width ? q = x.width / _.width : x.height && (q = x.height / _.height), q !== 1 && q > 0 && (_ = T.getViewport({ scale: q }));
    const Y = N.create(_.width, _.height);
    await T.render({
      canvasContext: Y.context,
      viewport: _
    }).promise;
    const ht = Y.canvas.toDataURL();
    return await (await fetch(ht)).arrayBuffer();
  }
  async function I(S) {
    const R = S ? await r(S()) : void 0;
    return {
      _createCanvas(x, N) {
        if (e) {
          const U = document.createElement("canvas");
          return U.width = x, U.height = N, U;
        }
        if (t) {
          if (!R)
            throw new Error('Failed to resolve "canvas" package.');
          return R.createCanvas(x, N);
        }
        throw new Error("Unsupported environment for canvas creation.");
      },
      create(x, N) {
        const U = this._createCanvas(x, N), T = U.getContext(
          "2d"
        );
        return {
          canvas: U,
          context: T
        };
      },
      reset(x, N, U) {
        x.canvas && (x.canvas.width = N, x.canvas.height = U);
      },
      destroy(x) {
        x.canvas && (x.canvas.width = 0, x.canvas.height = 0), x.canvas = void 0, x.context = void 0;
      }
    };
  }
  async function C(S) {
    const x = await (o(S) ? S : await i(S)).getMetadata();
    return {
      info: x?.info ?? {},
      metadata: x?.metadata?.getAll() ?? {}
    };
  }
  async function d(S, R = {}) {
    const { mergePages: x = !1 } = { ...R }, N = o(S) ? S : await i(S), U = await Promise.all(
      Array.from({ length: N.numPages }, (T, q) => u(N, q + 1))
    );
    return {
      totalPages: N.numPages,
      text: x ? U.join(`
`).replace(/\s+/g, " ") : U
    };
  }
  async function u(S, R) {
    return (await (await S.getPage(R)).getTextContent()).items.filter((U) => U.str != null).map((U) => U.str + (U.hasEOL ? `
` : "")).join("");
  }
  async function E(S) {
    const { pdfjs: R } = { ...S };
    R && await n(R, { force: !0 });
  }
  const p = async (...S) => (await n(), await C(...S)), y = async (...S) => (await n(), await d(...S)), b = async (...S) => (await n(), await c(...S)), D = async (...S) => (await n(), await h(...S));
  return gi.configureUnPDF = E, gi.createIsomorphicCanvasFactory = I, gi.extractImages = b, gi.extractText = y, gi.getDocumentProxy = i, gi.getMeta = p, gi.getResolvedPDFJS = s, gi.renderPageAsImage = D, gi.resolvePDFJSImports = n, gi;
}
var mn = {}, ic = {}, e0;
function Ca() {
  return e0 || (e0 = 1, (function(A) {
    A.removeLeadingWhitespaces = function(r) {
      for (; r.charCodeAt(0) === 32; )
        r = r.substring(1, r.length);
      return r;
    }, A.removeTrailingWhitespaces = function(r) {
      for (; r.charCodeAt(r.length - 1) === 32; )
        r = r.substring(0, r.length - 1);
      return r;
    }, A.isDigit = function(r) {
      return r >= 48 && r <= 57;
    }, A.isNumber = function(r) {
      for (var c = 0; c < r.length; c++) {
        const h = r.charCodeAt(c);
        if (!A.isDigit(h))
          return !1;
      }
      return !0;
    }, A.hasOnly = function(r, c) {
      const h = c.charCodeAt(0);
      for (var I = 0; I < r.length; I++)
        if (r.charCodeAt(I) !== h)
          return !1;
      return !0;
    }, A.hasUpperCaseCharacterInMiddleOfWord = function(r) {
      for (var c = !0, h = 0; h < r.length; h++) {
        const I = r.charAt(h);
        if (I === " ")
          c = !0;
        else {
          if (!c && isNaN(I * 1) && I === I.toUpperCase() && I.toUpperCase() !== I.toLowerCase())
            return !0;
          c = !1;
        }
      }
      return !1;
    }, A.normalizedCharCodeArray = function(r) {
      return r = r.toUpperCase(), A.charCodeArray(r).filter((c) => c !== 32 && c !== 9 && c !== 46);
    }, A.charCodeArray = function(r) {
      const c = [];
      for (var h = 0; h < r.length; h++)
        c.push(r.charCodeAt(h));
      return c;
    }, A.prefixAfterWhitespace = function(r, c) {
      return c.charCodeAt(0) === 32 ? (c = A.removeLeadingWhitespaces(c), " " + r + c) : r + c;
    }, A.suffixBeforeWhitespace = function(r, c) {
      return r.charCodeAt(r.length - 1) === 32 ? (r = A.removeTrailingWhitespaces(r), r + c + " ") : r + c;
    }, A.isListItemCharacter = function(r) {
      if (r.length > 1)
        return !1;
      const c = r.charAt(0);
      return c === "-" || c === "•" || c === "–";
    }, A.isListItem = function(r) {
      return /^[\s]*[-•–][\s].*$/g.test(r);
    }, A.isNumberedListItem = function(r) {
      return /^[\s]*[\d]*[.][\s].*$/g.test(r);
    }, A.wordMatch = function(r, c) {
      const h = new Set(r.toUpperCase().split(" ")), I = new Set(c.toUpperCase().split(" "));
      return new Set(
        [...h].filter((d) => I.has(d))
      ).size / Math.max(h.size, I.size);
    };
  })(ic)), ic;
}
var i0;
function lp() {
  if (i0) return mn;
  i0 = 1;
  const { removeLeadingWhitespaces: A, removeTrailingWhitespaces: t, isNumber: e } = Ca(), i = (n, o, r) => Math.floor(n / o * r), s = (n, o, r) => {
    for (const { str: c } of n) {
      const h = A(c), I = t(h);
      e(I) && (o[r] || (o[r] = []), o[r].push(Number(I)));
    }
    return o;
  };
  return mn.findPageNumbers = (n, o, r) => {
    const c = i(1, 6, r.length), h = i(5, 6, r.length), I = s(r.slice(0, c), n, o);
    return s(r.slice(h), I, o);
  }, mn.findFirstPage = (n) => {
    let o = 0;
    const r = Object.keys(n);
    if (!(r.length === 0 || r.length === 1))
      for (let c = 0; c < r.length - 1; c++) {
        const h = n[r[c]], I = n[r[c + 1]], C = o;
        for (let u = 0; u < h.length && o < 2; u++)
          for (let E = 0; E < I.length && o < 2; E++) {
            const p = r[c + 1] - r[c];
            (h[u] + 1 === I[E] || p > 1 && h[u] + p === I[E]) && o++;
          }
        let d = c > 0 ? Object.entries(n)[c - 1] : Object.entries(n)[c];
        if (C === o)
          o = 0, d = Object.entries(n)[c];
        else if (o >= 2)
          return { pageIndex: Number(d[0]), pageNum: d[1][0] };
      }
  }, mn.removePageNumber = (n, o) => {
    const r = { items: [...n.items] }, c = i(1, 6, r.items.length), h = i(5, 6, r.items.length);
    return r.items = r.items.filter((I, C) => {
      const d = C > 0 && C < c, u = C > h && C < r.items.length;
      return d || u ? Number(I.str) !== Number(o) : I;
    }), r;
  }, mn;
}
var sc, s0;
function nl() {
  return s0 || (s0 = 1, sc = class nu {
    constructor(t) {
      if (this.constructor === nu)
        throw new TypeError("Can not construct abstract class.");
      this.type = t.type, this.annotation = t.annotation, this.parsedElements = t.parsedElements;
    }
  }), sc;
}
var ac, a0;
function rl() {
  if (a0) return ac;
  a0 = 1;
  const A = nl();
  return ac = class extends A {
    constructor(e) {
      super(e), this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this.text = e.text, this.font = e.font, this.lineFormat = e.lineFormat, this.unopenedFormat = e.unopenedFormat, this.unclosedFormat = e.unclosedFormat;
    }
  }, ac;
}
var nc, n0;
function Ip() {
  return n0 || (n0 = 1, nc = class {
    constructor(t) {
      this.index = t.index, this.items = t.items || [];
    }
  }), nc;
}
var r0;
function Cp() {
  if (r0) return ec;
  r0 = 1;
  const { getDocumentProxy: A, getResolvedPDFJS: t } = /* @__PURE__ */ hp(), { findPageNumbers: e, findFirstPage: i, removePageNumber: s } = lp(), n = rl(), o = Ip(), r = () => {
  };
  return ec.parse = async function(h, I) {
    const { metadataParsed: C, pageParsed: d, fontParsed: u, documentParsed: E } = {
      metadataParsed: r,
      pageParsed: r,
      fontParsed: r,
      documentParsed: r,
      ...I || {}
    }, p = await A(new Uint8Array(h), {
      verbosity: 0
    }), y = await p.getMetadata();
    C(y);
    const b = [...Array(p.numPages).keys()].map(
      (N) => new o({ index: N })
    );
    E(p, b);
    const D = {
      ids: /* @__PURE__ */ new Set(),
      map: /* @__PURE__ */ new Map()
    };
    let S = {}, R;
    for (let N = 1; N <= p.numPages; N++) {
      const U = await p.getPage(N), T = await U.getTextContent();
      if (Object.keys(S).length < 10)
        S = e(S, U.pageNumber - 1, T.items);
      else {
        R = i(S);
        break;
      }
    }
    let x = R ? R.pageNum : 0;
    for (let N = 1; N <= p.numPages; N++) {
      const U = await p.getPage(N);
      await U.getOperatorList();
      const q = U.getViewport({ scale: 1 });
      let _ = await U.getTextContent();
      R && U.pageIndex >= R.pageIndex && (_ = s(_, x), x++);
      const Y = await t(), ht = _.items.map((j) => {
        const it = Y.Util.transform(
          q.transform,
          j.transform
        ), tt = Math.sqrt(it[2] * it[2] + it[3] * it[3]), Z = j.height / tt;
        return new n({
          x: Math.round(j.transform[4]),
          y: Math.round(j.transform[5]),
          width: Math.round(j.width),
          height: Math.round(Z <= 1 ? j.height : Z),
          text: j.str,
          font: j.fontName
        });
      });
      b[U.pageNumber - 1].items = ht, d(b);
      const ut = new Set(ht.map((j) => j.font));
      for (const j of ut)
        if (!D.ids.has(j) && j.startsWith("g_d")) {
          const it = p.transport || p._transport, tt = await new Promise(
            (Z) => it.commonObjs.get(j, Z)
          );
          D.ids.add(j), D.map.set(j, tt), u(D);
        }
    }
    return {
      fonts: D,
      metadata: y,
      pages: b,
      pdfDocument: p
    };
  }, ec;
}
var Pr = {}, rc, o0;
function pr() {
  return o0 || (o0 = 1, rc = class Eh {
    constructor(t, e) {
      if (this.constructor === Eh)
        throw new TypeError("Can not construct abstract class.");
      if (this.transform === Eh.prototype.transform)
        throw new TypeError("Please implement abstract method 'transform()'.");
      this.name = t, this.itemType = e;
    }
    // Transform an incoming ParseResult into an outgoing ParseResult
    transform(t) {
      throw new TypeError("Do not call abstract method foo from child.");
    }
    // Sometimes the transform() does only visualize a change. This methods then does the actual change.
    completeTransform(t) {
      return t.messages = [], t;
    }
  }), rc;
}
var gs = {}, g0;
function ai() {
  if (g0) return gs;
  g0 = 1;
  class A {
    constructor(e) {
      this.category = e.category, this.color = e.color;
    }
  }
  return gs.default = A, gs.ADDED_ANNOTATION = new A({
    category: "Added",
    color: "green"
  }), gs.REMOVED_ANNOTATION = new A({
    category: "Removed",
    color: "red"
  }), gs.UNCHANGED_ANNOTATION = new A({
    category: "Unchanged",
    color: "brown"
  }), gs.DETECTED_ANNOTATION = new A({
    category: "Detected",
    color: "green"
  }), gs.MODIFIED_ANNOTATION = new A({
    category: "Modified",
    color: "green"
  }), gs;
}
var oc, c0;
function up() {
  if (c0) return oc;
  c0 = 1;
  const A = pr(), t = rl(), { REMOVED_ANNOTATION: e } = ai();
  return oc = class ru extends A {
    constructor(s) {
      if (super(s, t.name), this.constructor === ru)
        throw new TypeError("Can not construct abstract class.");
    }
    completeTransform(s) {
      return s.messages = [], s.pages.forEach((n) => {
        n.items = n.items.filter((o) => !o.annotation || o.annotation !== e), n.items.forEach((o) => o.annotation = null);
      }), s;
    }
  }, oc;
}
var gc, h0;
function Oe() {
  return h0 || (h0 = 1, gc = class {
    constructor(t) {
      this.pages = t.pages, this.globals = t.globals, this.messages = t.messages;
    }
  }), gc;
}
var yn = {}, l0;
function ol() {
  if (l0) return yn;
  l0 = 1;
  var A = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(n) {
    return typeof n;
  } : function(n) {
    return n && typeof Symbol == "function" && n.constructor === Symbol ? "symbol" : typeof n;
  }, t = /* @__PURE__ */ (function() {
    function n(o, r) {
      for (var c = 0; c < r.length; c++) {
        var h = r[c];
        h.enumerable = h.enumerable || !1, h.configurable = !0, "value" in h && (h.writable = !0), Object.defineProperty(o, h.key, h);
      }
    }
    return function(o, r, c) {
      return r && n(o.prototype, r), c && n(o, c), o;
    };
  })();
  Object.defineProperty(yn, "__esModule", {
    value: !0
  }), yn.copyProperties = s;
  function e(n, o) {
    if (!(n instanceof o))
      throw new TypeError("Cannot call a class as a function");
  }
  var i = Symbol();
  yn.Enum = (function() {
    function n() {
      var o = arguments.length <= 0 || arguments[0] === void 0 ? void 0 : arguments[0];
      if (e(this, n), {}.hasOwnProperty.call(this.constructor, i))
        throw new Error("Enum classes can’t be instantiated");
      (typeof o > "u" ? "undefined" : A(o)) === "object" && o !== null && s(this, o);
    }
    return t(n, [{
      key: "toString",
      /**
       * Default `toString()` method for enum constant.
       */
      value: function() {
        return this.constructor.name + "." + this.name;
      }
    }], [{
      key: "initEnum",
      value: function(r) {
        return Object.defineProperty(this, "enumValues", {
          value: [],
          configurable: !1,
          writable: !1,
          enumerable: !0
        }), Array.isArray(r) ? this._enumValuesFromArray(r) : this._enumValuesFromObject(r), Object.freeze(this.enumValues), this[i] = !0, this;
      }
    }, {
      key: "_enumValuesFromArray",
      value: function(r) {
        var c = !0, h = !1, I = void 0;
        try {
          for (var C = r[Symbol.iterator](), d; !(c = (d = C.next()).done); c = !0) {
            var u = d.value;
            this._pushEnumValue(new this(), u);
          }
        } catch (E) {
          h = !0, I = E;
        } finally {
          try {
            !c && C.return && C.return();
          } finally {
            if (h)
              throw I;
          }
        }
      }
    }, {
      key: "_enumValuesFromObject",
      value: function(r) {
        var c = !0, h = !1, I = void 0;
        try {
          for (var C = Object.keys(r)[Symbol.iterator](), d; !(c = (d = C.next()).done); c = !0) {
            var u = d.value, E = new this(r[u]);
            this._pushEnumValue(E, u);
          }
        } catch (p) {
          h = !0, I = p;
        } finally {
          try {
            !c && C.return && C.return();
          } finally {
            if (h)
              throw I;
          }
        }
      }
    }, {
      key: "_pushEnumValue",
      value: function(r, c) {
        r.name = c, r.ordinal = this.enumValues.length, Object.defineProperty(this, c, {
          value: r,
          configurable: !1,
          writable: !1,
          enumerable: !0
        }), this.enumValues.push(r);
      }
      /**
       * Given the name of an enum constant, return its value.
       */
    }, {
      key: "enumValueOf",
      value: function(r) {
        return this.enumValues.find(function(c) {
          return c.name === r;
        });
      }
      /**
       * Make enum classes iterable
       */
    }, {
      key: Symbol.iterator,
      value: function() {
        return this.enumValues[Symbol.iterator]();
      }
    }]), n;
  })();
  function s(n, o) {
    var r = !0, c = !1, h = void 0;
    try {
      for (var I = Object.getOwnPropertyNames(o)[Symbol.iterator](), C; !(r = (C = I.next()).done); r = !0) {
        var d = C.value, u = Object.getOwnPropertyDescriptor(o, d);
        Object.defineProperty(n, d, u);
      }
    } catch (E) {
      c = !0, h = E;
    } finally {
      try {
        !r && I.return && I.return();
      } finally {
        if (c)
          throw h;
      }
    }
    return n;
  }
  return yn;
}
var cc, I0;
function ou() {
  if (I0) return cc;
  I0 = 1;
  const { Enum: A } = ol();
  class t extends A {
  }
  return cc = t, t.initEnum({
    BOLD: {
      startSymbol: "**",
      endSymbol: "**"
    },
    OBLIQUE: {
      startSymbol: "_",
      endSymbol: "_"
    },
    BOLD_OBLIQUE: {
      startSymbol: "**_",
      endSymbol: "_**"
    }
  }), cc;
}
var hc, C0;
function Bp() {
  if (C0) return hc;
  C0 = 1;
  const A = up(), t = Oe(), e = ou();
  hc = class extends A {
    constructor(n) {
      super("$1"), this.fontMap = n;
    }
    transform(n) {
      const o = {}, r = {};
      var c = 0, h;
      n.pages.forEach((b) => {
        b.items.forEach((D) => {
          D.height && (o[D.height] = o[D.height] ? o[D.height] + 1 : 1, r[D.font] = r[D.font] ? r[D.font] + 1 : 1, D.height > c && (c = D.height, h = D.font));
        });
      });
      const I = parseInt(i(o)), C = i(r), d = {};
      n.pages.forEach((b) => {
        var D;
        b.items.forEach((S) => {
          if (S.height === I && S.text.trim().length > 0) {
            if (D && S.y !== D.y) {
              const R = D.y - S.y;
              R > 0 && (d[R] = d[R] ? d[R] + 1 : 1);
            }
            D = S;
          } else
            D = null;
        });
      });
      const u = parseInt(i(d)), E = [], p = /* @__PURE__ */ new Map();
      this.fontMap.forEach(function(b, D) {
        E.push(D + " = " + b.name);
        const S = b.name.toLowerCase();
        var R;
        D === C ? R = null : S.includes("bold") && (S.includes("oblique") || S.includes("italic")) ? R = e.BOLD_OBLIQUE : S.includes("bold") ? R = e.BOLD : S.includes("oblique") || S.includes("italic") ? R = e.OBLIQUE : S === h && (R = e.BOLD), R && p.set(D, R.name);
      }), E.sort();
      const y = n.pages.map((b) => ({
        ...b,
        items: b.items.map((D) => ({ ...D }))
      }));
      return new t({
        ...n,
        pages: y,
        globals: {
          mostUsedHeight: I,
          mostUsedFont: C,
          mostUsedDistance: u,
          maxHeight: c,
          maxHeightFont: h,
          fontToFormats: p
        },
        messages: [
          "Items per height: " + JSON.stringify(o),
          "Items per font: " + JSON.stringify(r),
          "Items per distance: " + JSON.stringify(d),
          "Fonts:" + JSON.stringify(E)
        ]
      });
    }
  };
  function i(s) {
    var n = 0, o;
    return Object.keys(s).map((r) => {
      (!o || s[r] > n) && (n = s[r], o = r);
    }), o;
  }
  return hc;
}
var lc, u0;
function mr() {
  return u0 || (u0 = 1, lc = class {
    constructor(t) {
      this.string = t.string, this.type = t.type, this.format = t.format;
    }
  }), lc;
}
var Ic, B0;
function ua() {
  if (B0) return Ic;
  B0 = 1;
  const A = nl(), t = mr();
  return Ic = class extends A {
    constructor(i) {
      super(i), this.x = i.x, this.y = i.y, this.width = i.width, this.height = i.height, this.words = i.words || [], i.text && !i.words && (this.words = i.text.split(" ").filter((s) => s.trim().length > 0).map((s) => new t({
        string: s
      })));
    }
    text() {
      return this.wordStrings().join(" ");
    }
    wordStrings() {
      return this.words.map((i) => i.string);
    }
  }, Ic;
}
var Cc, d0;
function sn() {
  if (d0) return Cc;
  d0 = 1;
  const A = pr(), t = ua(), { REMOVED_ANNOTATION: e } = ai();
  return Cc = class gu extends A {
    constructor(s) {
      if (super(s, t.name), this.constructor === gu)
        throw new TypeError("Can not construct abstract class.");
    }
    completeTransform(s) {
      return s.messages = [], s.pages.forEach((n) => {
        n.items = n.items.filter((o) => !o.annotation || o.annotation !== e), n.items.forEach((o) => o.annotation = null);
      }), s;
    }
  }, Cc;
}
var wn = {}, Q0;
function hg() {
  return Q0 || (Q0 = 1, wn.minXFromBlocks = function(t) {
    var e = 999;
    return t.forEach((i) => {
      i.items.forEach((s) => {
        e = Math.min(e, s.x);
      });
    }), e === 999 ? null : e;
  }, wn.minXFromPageItems = function(t) {
    var e = 999;
    return t.forEach((i) => {
      e = Math.min(e, i.x);
    }), e === 999 ? null : e;
  }, wn.sortByX = function(t) {
    t.sort((e, i) => e.x - i.x);
  }), wn;
}
var uc, E0;
function dp() {
  if (E0) return uc;
  E0 = 1;
  const { sortByX: A } = hg();
  return uc = class {
    constructor(e) {
      this.mostUsedDistance = e.mostUsedDistance || 12;
    }
    // returns a CombineResult
    group(e) {
      const i = [];
      var s = [];
      return e.forEach((n) => {
        s.length > 0 && Math.abs(s[0].y - n.y) >= this.mostUsedDistance / 2 && (i.push(s), s = []), s.push(n);
      }), i.push(s), i.forEach((n) => {
        A(n);
      }), i;
    }
  }, uc;
}
var Bc, f0;
function Qp() {
  if (f0) return Bc;
  f0 = 1;
  const { Enum: A } = ol();
  class t extends A {
  }
  return Bc = t, t.initEnum({
    LINK: {
      toText(e) {
        return `[${e}](${e})`;
      }
    },
    FOOTNOTE_LINK: {
      attachWithoutWhitespace: !0,
      plainTextFormat: !0,
      toText(e) {
        return `^${e}`;
      }
    },
    FOOTNOTE: {
      toText(e) {
        return `(^${e})`;
      }
    }
  }), Bc;
}
var dc, p0;
function hu() {
  return p0 || (p0 = 1, dc = class cu {
    constructor() {
      if (this.constructor === cu)
        throw new TypeError("Can not construct abstract class.");
      this.results = [], this.stash = [];
    }
    consumeAll(t) {
      t.forEach((e) => this.consume(e));
    }
    consume(t) {
      this.shouldStash(t) ? (this.matchesStash(t) || this.flushStash(), this.pushOnStash(t)) : (this.stash.length > 0 && this.flushStash(), this.results.push(t));
    }
    pushOnStash(t) {
      this.onPushOnStash(t), this.stash.push(t);
    }
    complete() {
      return this.stash.length > 0 && this.flushStash(), this.results;
    }
    // return true if the item matches the items of the stack
    matchesStash(t) {
      if (this.stash.length === 0)
        return !0;
      const e = this.stash[this.stash.length - 1];
      return this.doMatchesStash(e, t);
    }
    flushStash() {
      this.stash.length > 0 && (this.doFlushStash(this.stash, this.results), this.stash = []);
    }
    onPushOnStash(t) {
    }
    shouldStash(t) {
      throw new TypeError(" Do not call abstract method foo from child." + t);
    }
    doMatchesStash(t, e) {
      throw new TypeError(" Do not call abstract method foo from child." + t + e);
    }
    doFlushStash(t, e) {
      throw new TypeError(" Do not call abstract method foo from child." + t + e);
    }
  }), dc;
}
var Qc, m0;
function Ep() {
  return m0 || (m0 = 1, Qc = class {
    constructor(t) {
      this.footnoteLinks = t.footnoteLinks || [], this.footnotes = t.footnotes || [], this.containLinks = t.containLinks, this.formattedWords = t.formattedWords;
    }
    add(t) {
      this.footnoteLinks = this.footnoteLinks.concat(t.footnoteLinks), this.footnotes = this.footnotes.concat(t.footnotes), this.containLinks = this.containLinks || t.containLinks, this.formattedWords += t.formattedWords;
    }
  }), Qc;
}
var Ec, y0;
function fp() {
  if (y0) return Ec;
  y0 = 1;
  const A = rl(), t = mr(), e = Qp(), i = ou(), s = ua(), n = hu(), o = Ep(), { isNumber: r, isListItemCharacter: c } = Ca(), { sortByX: h } = hg();
  Ec = class {
    constructor(u) {
      this.fontToFormats = u;
    }
    // returns a CombineResult
    compact(u) {
      h(u);
      const E = new I(this.fontToFormats);
      E.consumeAll(u.map((D) => new A({ ...D })));
      const p = E.complete();
      var y = 0, b = 0;
      return u.forEach((D) => {
        y = Math.max(y, D.height), b += D.width;
      }), new s({
        x: u[0].x,
        y: u[0].y,
        height: y,
        width: b,
        words: p,
        parsedElements: new o({
          footnoteLinks: E.footnoteLinks,
          footnotes: E.footnotes,
          containLinks: E.containLinks,
          formattedWords: E.formattedWords
        })
      });
    }
  };
  class I extends n {
    constructor(u) {
      super(), this.fontToFormats = u, this.footnoteLinks = [], this.footnotes = [], this.formattedWords = 0, this.containLinks = !1, this.stashedNumber = !1;
    }
    shouldStash(u) {
      return this.firstY || (this.firstY = u.y), this.currentItem = u, !0;
    }
    onPushOnStash(u) {
      this.stashedNumber = r(u.text.trim());
    }
    doMatchesStash(u, E) {
      const p = this.fontToFormats.get(u.font), y = this.fontToFormats.get(E.font);
      if (p !== y)
        return !1;
      const b = r(E.text.trim());
      return this.stashedNumber === b;
    }
    doFlushStash(u, E) {
      if (this.stashedNumber) {
        const p = u.map((y) => y.text).join("").trim();
        u[0].y > this.firstY ? (E.push(new t({
          string: `${p}`,
          type: e.FOOTNOTE_LINK
        })), this.footnoteLinks.push(parseInt(p))) : this.currentItem && this.currentItem.y < u[0].y ? (E.push(new t({
          string: `${p}`,
          type: e.FOOTNOTE
        })), this.footnotes.push(p)) : this.copyStashItemsAsText(u, E);
      } else
        this.copyStashItemsAsText(u, E);
    }
    copyStashItemsAsText(u, E) {
      const p = this.fontToFormats.get(u[0].font);
      E.push(...this.itemsToWords(u, p));
    }
    itemsToWords(u, E) {
      const y = C(u).split(" "), b = E ? i.enumValueOf(E) : null;
      return y.filter((D) => D.trim().length > 0).map((D) => {
        var S = null;
        return D.startsWith("http:") ? (this.containLinks = !0, S = e.LINK) : D.startsWith("www.") && (this.containLinks = !0, D = `http://${D}`, S = e.LINK), b && this.formattedWords++, new t({ string: D, type: S, format: b });
      });
    }
  }
  function C(d) {
    var u = "", E;
    return d.forEach((p) => {
      var y = p.text;
      !u.endsWith(" ") && !y.startsWith(" ") && (E ? p.x - E.x - E.width > 5 && (u += " ") : c(p.text) && (y += " ")), u += y, E = p;
    }), u;
  }
  return Ec;
}
var wa = { exports: {} }, w0;
function ts() {
  if (w0) return wa.exports;
  w0 = 1;
  const { Enum: A } = ol();
  function t(n) {
    return n.words.length === 0 ? null : n.words[0].format;
  }
  function e(n) {
    return n.length !== 1 ? !1 : n[0] === "." || n[0] === "!" || n[0] === "?";
  }
  function i(n, o) {
    var r = "", c;
    const h = () => {
      r += c.endSymbol, c = null;
    };
    return n.forEach((I, C) => {
      I.words.forEach((d, u) => {
        const E = d.type, p = d.format;
        c && (!p || p !== c) && h(), u > 0 && !(E && E.attachWithoutWhitespace) && !e(d.string) && (r += " "), p && !c && !o && (c = p, r += c.startSymbol), E && (!o || E.plainTextFormat) ? r += E.toText(d.string) : r += d.string;
      }), c && (C === n.length - 1 || t(n[C + 1]) !== c) && h(), r += `
`;
    }), r;
  }
  let s = class extends A {
  };
  return wa.exports = s, s.initEnum({
    H1: {
      headline: !0,
      headlineLevel: 1,
      toText(n) {
        return "# " + i(n.items, !0);
      }
    },
    H2: {
      headline: !0,
      headlineLevel: 2,
      toText(n) {
        return "## " + i(n.items, !0);
      }
    },
    H3: {
      headline: !0,
      headlineLevel: 3,
      toText(n) {
        return "### " + i(n.items, !0);
      }
    },
    H4: {
      headline: !0,
      headlineLevel: 4,
      toText(n) {
        return "#### " + i(n.items, !0);
      }
    },
    H5: {
      headline: !0,
      headlineLevel: 5,
      toText(n) {
        return "##### " + i(n.items, !0);
      }
    },
    H6: {
      headline: !0,
      headlineLevel: 6,
      toText(n) {
        return "###### " + i(n.items, !0);
      }
    },
    TOC: {
      mergeToBlock: !0,
      toText(n) {
        return i(n.items, !0);
      }
    },
    FOOTNOTES: {
      mergeToBlock: !0,
      mergeFollowingNonTypedItems: !0,
      toText(n) {
        return i(n.items, !1);
      }
    },
    CODE: {
      mergeToBlock: !0,
      toText(n) {
        return "```\n" + i(n.items, !0) + "```";
      }
    },
    LIST: {
      mergeToBlock: !1,
      mergeFollowingNonTypedItemsWithSmallDistance: !0,
      toText(n) {
        return i(n.items, !1);
      }
    },
    PARAGRAPH: {
      toText(n) {
        return i(n.items, !1);
      }
    }
  }), wa.exports.isHeadline = function(o) {
    return o && o.name.length === 2 && o.name[0] === "H";
  }, wa.exports.blockToText = function(o) {
    return o.type ? o.type.toText(o) : i(o.items, !1);
  }, wa.exports.headlineByLevel = function(o) {
    return o === 1 ? s.H1 : o === 2 ? s.H2 : o === 3 ? s.H3 : o === 4 ? s.H4 : o === 5 ? s.H5 : (o === 6 || console.warn("Unsupported headline level: " + o + " (supported are 1-6), defaulting to level 6"), s.H6);
  }, wa.exports;
}
var fc, b0;
function pp() {
  if (b0) return fc;
  b0 = 1;
  const A = sn(), t = Oe(), e = ua(), i = dp(), s = fp(), n = ts(), { REMOVED_ANNOTATION: o, ADDED_ANNOTATION: r } = ai();
  return fc = class extends A {
    constructor() {
      super("Compact To Lines");
    }
    transform(h) {
      const { mostUsedDistance: I, fontToFormats: C } = h.globals, d = [], u = [];
      var E = 0, p = 0;
      const y = new i({
        mostUsedDistance: I
      }), b = new s(C);
      return h.pages.forEach((D) => {
        if (D.items.length > 0) {
          const S = [];
          y.group(D.items).forEach((x) => {
            const N = b.compact(x);
            if (x.length > 1 && (N.annotation = r, x.forEach((U) => {
              U.annotation = o, S.push(new e({
                ...U
              }));
            })), N.words.length === 0 && (N.annotation = o), S.push(N), N.parsedElements.formattedWords && (p += N.parsedElements.formattedWords), N.parsedElements.containLinks > 0 && E++, N.parsedElements.footnoteLinks.length > 0) {
              const U = N.parsedElements.footnoteLinks.map((T) => ({ footnoteLink: T, page: D.index + 1 }));
              u.push.apply(u, U);
            }
            if (N.parsedElements.footnotes.length > 0) {
              N.type = n.FOOTNOTES;
              const U = N.parsedElements.footnotes.map((T) => ({ footnote: T, page: D.index + 1 }));
              d.push.apply(d, U);
            }
          }), D.items = S;
        }
      }), new t({
        ...h,
        messages: [
          "Detected " + p + " formatted words",
          "Found " + E + " links",
          "Detected " + u.length + " footnotes links",
          "Detected " + d.length + " footnotes"
        ]
      });
    }
  }, fc;
}
var pc, D0;
function mp() {
  if (D0) return pc;
  D0 = 1;
  const A = sn(), t = Oe(), { REMOVED_ANNOTATION: e } = ai(), { isDigit: i } = Ca();
  function s(n) {
    var o = 0;
    if (n.trim().length === 0) return o;
    for (var r = 0; r < n.length; r++) {
      const c = n.charCodeAt(r);
      !i(c) && c !== 32 && c !== 160 && (o = (o << 5) - o + c, o |= 0);
    }
    return o;
  }
  return pc = class extends A {
    constructor() {
      super("Remove Repetitive Elements");
    }
    // The idea is the following:
    // - For each page, collect all items of the first, and all items of the last line
    // - Calculate how often these items occur accros all pages (hash ignoring numbers, whitespace, upper/lowercase)
    // - Delete items occuring on more then 2/3 of all pages
    transform(o) {
      const r = [], c = {}, h = {};
      o.pages.forEach((d) => {
        const u = d.items.reduce((y, b) => (b.y < y.minY ? (y.minElements = [b], y.minY = b.y) : b.y === y.minY && y.minElements.push(b), b.y > y.maxY ? (y.maxElements = [b], y.maxY = b.y) : b.y === y.maxY && y.maxElements.push(b), y), {
          minY: 999,
          maxY: 0,
          minElements: [],
          maxElements: []
        }), E = s(u.minElements.reduce((y, b) => y + b.text().toUpperCase(), "")), p = s(u.maxElements.reduce((y, b) => y + b.text().toUpperCase(), ""));
        r.push({
          minElements: u.minElements,
          maxElements: u.maxElements,
          minLineHash: E,
          maxLineHash: p
        }), c[E] = c[E] ? c[E] + 1 : 1, h[p] = h[p] ? h[p] + 1 : 1;
      });
      var I = 0, C = 0;
      return o.pages.forEach((d, u) => {
        c[r[u].minLineHash] >= Math.max(3, o.pages.length * 2 / 3) && (r[u].minElements.forEach((E) => {
          E.annotation = e;
        }), C++), h[r[u].maxLineHash] >= Math.max(3, o.pages.length * 2 / 3) && (r[u].maxElements.forEach((E) => {
          E.annotation = e;
        }), I++);
      }), new t({
        ...o,
        messages: [
          "Removed Header: " + I,
          "Removed Footers: " + C
        ]
      });
    }
  }, pc;
}
var mc, k0;
function yp() {
  if (k0) return mc;
  k0 = 1;
  const A = sn(), t = Oe(), e = ua(), i = hu(), { REMOVED_ANNOTATION: s, ADDED_ANNOTATION: n } = ai();
  mc = class extends A {
    constructor() {
      super("Vertical to Horizontal Text");
    }
    transform(c) {
      var h = 0;
      return c.pages.forEach((I) => {
        const C = new o();
        C.consumeAll(I.items), I.items = C.complete(), h += C.foundVerticals;
      }), new t({
        ...c,
        messages: ["Converted " + h + " verticals"]
      });
    }
  };
  class o extends i {
    constructor() {
      super(), this.foundVerticals = 0;
    }
    shouldStash(c) {
      return c.words.length === 1 && c.words[0].string.length === 1;
    }
    doMatchesStash(c, h) {
      return c.y - h.y > 5 && c.words[0].type === h.words[0].type;
    }
    doFlushStash(c, h) {
      if (c.length > 5) {
        var I = [], C = 999, d = 0, u = 0, E = 0;
        c.forEach((p) => {
          p.annotation = s, h.push(p), I.push(p.words[0]), C = Math.min(C, p.x), d = Math.max(d, p.y), u += p.width, E = Math.max(E, p.height);
        }), h.push(new e({
          ...c[0],
          x: C,
          y: d,
          width: u,
          height: E,
          words: I,
          annotation: n
        })), this.foundVerticals++;
      } else
        h.push(...c);
    }
  }
  return mc;
}
var yc, S0;
function wp() {
  if (S0) return yc;
  S0 = 1;
  const { normalizedCharCodeArray: A } = Ca();
  return yc = class {
    constructor(e) {
      this.headlineCharCodes = A(e.headline), this.stackedLineItems = [], this.stackedChars = 0;
    }
    consume(e) {
      const i = A(e.text());
      if (this.matchAll(i)) {
        if (this.stackedLineItems.push(e), this.stackedChars += i.length, this.stackedChars === this.headlineCharCodes.length)
          return this.stackedLineItems;
      } else
        this.stackedChars > 0 && (this.stackedChars = 0, this.stackedLineItems = [], this.consume(e));
      return null;
    }
    matchAll(e) {
      for (var i = 0; i < e.length; i++) {
        const s = this.headlineCharCodes[this.stackedChars + i];
        if (e[i] !== s)
          return !1;
      }
      return !0;
    }
  }, yc;
}
var wc, F0;
function bp() {
  if (F0) return wc;
  F0 = 1;
  const A = sn(), t = Oe(), e = ua(), i = mr(), s = wp(), { REMOVED_ANNOTATION: n, ADDED_ANNOTATION: o } = ai(), r = ts(), { headlineByLevel: c } = ts(), { isDigit: h, isNumber: I, wordMatch: C, hasOnly: d } = Ca();
  wc = class extends A {
    constructor() {
      super("Detect TOC");
    }
    transform(x) {
      const N = [], U = Math.min(20, x.pages.length), T = new D();
      var q = [], _, Y;
      x.pages.slice(0, U).forEach((dt) => {
        var ct = 0;
        const M = /* @__PURE__ */ new Set(), H = [];
        var W, lt;
        if (dt.items.filter((ot) => ot.words.includes((V) => d(V.string, "."))).forEach((ot) => {
          var V = ot.words.filter((Rt) => !d(Rt.string, "."));
          const rt = [];
          for (; V.length > 0 && I(V[V.length - 1].string); ) {
            const Rt = V.pop();
            rt.unshift(Rt.string);
          }
          if (rt.length === 0 && V.length > 0) {
            const Rt = V[V.length - 1];
            for (; h(Rt.string.charCodeAt(Rt.string.length - 1)); )
              rt.unshift(Rt.string.charAt(Rt.string.length - 1)), Rt.string = Rt.string.substring(0, Rt.string.length - 1);
          }
          var Bt = rt.length > 0;
          Bt ? (Bt = !0, W && (V.push(...W), W = null), H.push(new S({
            pageNumber: parseInt(rt.join("")),
            lineItem: new e({ ...ot, words: V })
          })), ct++) : Y ? (W && M.add(lt), W = V, lt = ot) : Y = ot;
        }), ct * 100 / dt.items.length > 75) {
          N.push(dt.index + 1), _ = dt, T.levelPageItems(H), q.push(...H);
          const ot = [];
          dt.items.forEach((V) => {
            M.has(V) || (V.annotation = n), ot.push(V), V === Y && ot.push(new e({
              ...V,
              type: r.H2,
              annotation: o
            }));
          }), dt.items = ot;
        } else
          Y = null;
      });
      var ht = q.length;
      const ut = [], j = [], it = {};
      if (N.length > 0) {
        q.forEach((M) => {
          _.items.push(new e({
            words: [new i({
              string: " ".repeat(M.level * 3) + "-"
            })].concat(M.lineItem.words),
            type: r.TOC,
            annotation: o
          }));
        });
        const dt = u(x.pages.filter((M) => M.index > _.index), q);
        q.forEach((M) => {
          var H = x.pages[M.pageNumber + dt], W;
          H && (W = p(H, M.lineItem.text()), W || (H = x.pages[M.pageNumber + dt + 1], H && (W = p(H, M.lineItem.text())))), W ? y(H, M, W, it) : ut.push(M);
        });
        var tt = _.index + 2, Z = [];
        const ct = (M) => {
          Z.length > 0 && (Z.forEach((H) => {
            const W = c(H.level + 2), lt = it[W.name];
            if (lt) {
              const [$, ot] = b(x.pages, H, lt, tt, M);
              if (ot > -1) {
                const V = x.pages[$];
                V.items[ot].annotation = n, V.items.splice(ot + 1, 0, new e({
                  ...H.lineItem,
                  type: W,
                  annotation: o
                })), j.push(H);
              }
            }
          }), Z = []);
        };
        ut.length > 0 && (q.forEach((M) => {
          ut.includes(M) ? Z.push(M) : (ct(M.pageNumber), tt = M.pageNumber);
        }), Z.length > 0 && ct(x.pages.length));
      }
      const st = [];
      return st.push("Detected " + N.length + " table of content pages"), N.length > 0 && (st.push("TOC headline heights: " + JSON.stringify(it)), st.push("Found TOC headlines: " + (ht - ut.length + j.length) + "/" + ht)), ut.length > 0 && (st.push("Found TOC headlines (by size): " + j.map((dt) => dt.lineItem.text())), st.push("Missing TOC headlines: " + ut.filter((dt) => !j.includes(dt)).map((dt) => dt.lineItem.text() + "=>" + dt.pageNumber))), new t({
        ...x,
        globals: {
          ...x.globals,
          tocPages: N,
          headlineTypeToHeightRange: it
        },
        messages: st
      });
    }
  };
  function u(R, x) {
    for (var N of x) {
      const U = E(R, N.lineItem.text());
      if (U)
        return U.index - N.pageNumber;
    }
    return null;
  }
  function E(R, x) {
    for (var N of R)
      if (p(N, x))
        return N;
    return null;
  }
  function p(R, x) {
    const N = new s({ headline: x });
    var U = 0;
    for (var T of R.items) {
      const q = N.consume(T);
      if (q)
        return { lineIndex: U, headlineItems: q };
      U++;
    }
    return null;
  }
  function y(R, x, N, U) {
    N.headlineItems.forEach((Y) => Y.annotation = n);
    const T = c(x.level + 2), q = N.headlineItems.reduce((Y, ht) => Math.max(Y, ht.height), 0);
    R.items.splice(N.lineIndex + 1, 0, new e({
      ...N.headlineItems[0],
      words: x.lineItem.words,
      height: q,
      type: T,
      annotation: o
    }));
    var _ = U[T.name];
    _ ? (_.min = Math.min(_.min, q), _.max = Math.max(_.max, q)) : (_ = {
      min: q,
      max: q
    }, U[T.name] = _);
  }
  function b(R, x, N, U, T) {
    const q = x.lineItem.text().toUpperCase();
    for (var _ = U; _ <= T; _++) {
      const Y = R[_ - 1];
      if (Y) {
        const ht = Y.items.findIndex((ut) => !ut.type && !ut.annotation && ut.height >= N.min && ut.height <= N.max ? C(q, ut.text()) >= 0.5 : !1);
        if (ht > -1) return [_ - 1, ht];
      }
    }
    return [-1, -1];
  }
  class D {
    constructor() {
      this.levelByMethod = null, this.uniqueFonts = [];
    }
    levelPageItems(x) {
      if (!this.levelByMethod)
        if (this.calculateUniqueX(x).length > 1)
          this.levelByMethod = this.levelByXDiff;
        else {
          const U = this.calculateUniqueFonts(x);
          U.length > 1 ? (this.uniqueFonts = U, this.levelByMethod = this.levelByFont) : this.levelByMethod = this.levelToZero;
        }
      this.levelByMethod(x);
    }
    levelByXDiff(x) {
      const N = this.calculateUniqueX(x);
      x.forEach((U) => {
        U.level = N.indexOf(U.lineItem.x);
      });
    }
    levelByFont(x) {
      x.forEach((N) => {
        N.level = this.uniqueFonts.indexOf(N.lineItem.font);
      });
    }
    levelToZero(x) {
      x.forEach((N) => {
        N.level = 0;
      });
    }
    calculateUniqueX(x) {
      var N = x.reduce(function(U, T) {
        return U.indexOf(T.lineItem.x) < 0 && U.push(T.lineItem.x), U;
      }, []);
      return N.sort((U, T) => U - T), N;
    }
    calculateUniqueFonts(x) {
      var N = x.reduce(function(U, T) {
        return U.indexOf(T.lineItem.font) < 0 && U.push(T.lineItem.font), U;
      }, []);
      return N;
    }
  }
  class S {
    constructor(x) {
      this.lineItem = x.lineItem, this.pageNumber = x.pageNumber, this.level = 0;
    }
  }
  return wc;
}
var bc, R0;
function Dp() {
  if (R0) return bc;
  R0 = 1;
  const A = sn(), t = Oe(), e = ua(), i = mr(), { REMOVED_ANNOTATION: s, ADDED_ANNOTATION: n, DETECTED_ANNOTATION: o } = ai(), r = ts(), { isListItemCharacter: c, isNumberedListItem: h } = Ca();
  return bc = class extends A {
    constructor() {
      super("Detect List Items");
    }
    transform(C) {
      var d = 0, u = 0;
      return C.pages.forEach((E) => {
        const p = [];
        E.items.forEach((y) => {
          if (p.push(y), !y.type) {
            var b = y.text();
            if (c(y.words[0].string))
              if (d++, y.words[0].string === "-")
                y.annotation = o, y.type = r.LIST;
              else {
                y.annotation = s;
                const D = y.words.map((S) => new i({
                  ...S
                }));
                D[0].string = "-", p.push(new e({
                  ...y,
                  words: D,
                  annotation: n,
                  type: r.LIST
                }));
              }
            else h(b) && (u++, y.annotation = o, y.type = r.LIST);
          }
        }), E.items = p;
      }), new t({
        ...C,
        messages: [
          "Detected " + d + " plain list items.",
          "Detected " + u + " numbered list items."
        ]
      });
    }
  }, bc;
}
var Dc, x0;
function kp() {
  if (x0) return Dc;
  x0 = 1;
  const A = sn(), t = Oe(), { DETECTED_ANNOTATION: e } = ai(), i = ts(), { headlineByLevel: s } = ts(), { isListItem: n } = Ca();
  Dc = class extends A {
    constructor() {
      super("Detect Headers");
    }
    transform(c) {
      const { tocPages: h, headlineTypeToHeightRange: I, mostUsedHeight: C, mostUsedDistance: d, mostUsedFont: u, maxHeight: E } = c.globals, p = h.length > 0;
      var y = 0;
      const b = o(c.pages, E), D = C + (E - C) / 4;
      if (b.forEach((x) => {
        x.items.forEach((N) => {
          const U = N.height;
          !N.type && U > D && (U === E ? N.type = i.H1 : N.type = i.H2, N.annotation = e, y++);
        });
      }), p)
        Object.keys(I).forEach((N) => {
          var U = I[N];
          U.max > C && c.pages.forEach((T) => {
            T.items.forEach((q) => {
              !q.type && q.height === U.max && (q.annotation = e, q.type = i.enumValueOf(N), y++);
            });
          });
        });
      else {
        const x = [];
        var S;
        c.pages.forEach((N) => {
          N.items.forEach((U) => {
            !U.type && U.height > C && !n(U.text()) && !x.includes(U.height) && (!S || S > U.height) && x.push(U.height);
          });
        }), x.sort((N, U) => U - N), x.forEach((N, U) => {
          if (U + 2 <= 6) {
            const q = s(2 + U);
            c.pages.forEach((_) => {
              _.items.forEach((Y) => {
                !Y.type && Y.height === N && !n(Y.text()) && (y++, Y.annotation = e, Y.type = q);
              });
            });
          }
        });
      }
      var R = 1;
      if (c.pages.forEach((x) => {
        x.items.forEach((N) => {
          N.type && N.type.headline && (R = Math.max(R, N.type.headlineLevel));
        });
      }), R < 6) {
        const x = s(R + 1);
        c.pages.forEach((N) => {
          var U;
          N.items.forEach((T) => {
            !T.type && T.height === C && T.font !== u && (!U || U.y < T.y || U.type && U.type.headline || U.y - T.y > d * 2) && T.text() === T.text().toUpperCase() && (y++, T.annotation = e, T.type = x), U = T;
          });
        });
      }
      return new t({
        ...c,
        messages: [
          "Detected " + y + " headlines."
        ]
      });
    }
  };
  function o(r, c) {
    const h = /* @__PURE__ */ new Set();
    return r.forEach((I) => {
      I.items.forEach((C) => {
        !C.type && C.height === c && h.add(I);
      });
    }), h;
  }
  return Dc;
}
var kc, N0;
function lu() {
  if (N0) return kc;
  N0 = 1;
  const A = nl(), t = ua();
  return kc = class extends A {
    constructor(i) {
      super(i), this.items = [], i.items && i.items.forEach((s) => this.addItem(s));
    }
    addItem(i) {
      if (this.type && i.type && this.type !== i.type)
        throw new Error(`Adding item of type ${i.type} to block of type ${this.type}`);
      this.type || (this.type = i.type), i.parsedElements && (this.parsedElements ? this.parsedElements.add(i.parsedElements) : this.parsedElements = i.parsedElements);
      const s = new t({ ...i });
      s.type = null, this.items.push(s);
    }
  }, kc;
}
var Sc, G0;
function gl() {
  if (G0) return Sc;
  G0 = 1;
  const A = pr(), t = lu(), { REMOVED_ANNOTATION: e } = ai();
  return Sc = class Iu extends A {
    constructor(s) {
      if (super(s, t.name), this.constructor === Iu)
        throw new TypeError("Can not construct abstract class.");
    }
    completeTransform(s) {
      return s.messages = [], s.pages.forEach((n) => {
        n.items = n.items.filter((o) => !o.annotation || o.annotation !== e), n.items.forEach((o) => o.annotation = null);
      }), s;
    }
  }, Sc;
}
var Fc, v0;
function Sp() {
  if (v0) return Fc;
  v0 = 1;
  const A = gl(), t = Oe(), e = lu(), { DETECTED_ANNOTATION: i } = ai(), { minXFromPageItems: s } = hg();
  Fc = class extends A {
    constructor() {
      super("Gather Blocks");
    }
    transform(c) {
      const { mostUsedDistance: h } = c.globals;
      var I = 0, C = 0;
      return c.pages.map((d) => {
        C += d.items.length;
        const u = [];
        var E = new e({});
        const p = () => {
          E.items.length > 1 && (E.annotation = i), u.push(E), E = new e({}), I++;
        };
        var y = s(d.items);
        d.items.forEach((b) => {
          E.items.length > 0 && n(E, b, y, h) && p(), E.addItem(b);
        }), E.items.length > 0 && p(), d.items = u;
      }), new t({
        ...c,
        messages: ["Gathered " + I + " blocks out of " + C + " line items"]
      });
    }
  };
  function n(r, c, h, I) {
    if (r.type && r.type.mergeFollowingNonTypedItems && !c.type)
      return !1;
    const C = r.items[r.items.length - 1], d = o(C, c, h, I);
    return r.type && r.type.mergeFollowingNonTypedItemsWithSmallDistance && !c.type && !d ? !1 : c.type !== r.type ? !0 : c.type ? !c.type.mergeToBlock : d;
  }
  function o(r, c, h, I) {
    const C = r.y - c.y;
    if (C < 0 - I / 2)
      return !0;
    var d = I + 1;
    return r.x > h && c.x > h && (d = I + I / 2), C > d;
  }
  return Fc;
}
var Rc, M0;
function Fp() {
  if (M0) return Rc;
  M0 = 1;
  const A = gl(), t = Oe(), { DETECTED_ANNOTATION: e } = ai(), i = ts(), { minXFromBlocks: s } = hg();
  Rc = class extends A {
    constructor() {
      super("$1");
    }
    transform(r) {
      const { mostUsedHeight: c } = r.globals;
      var h = 0;
      return r.pages.forEach((I) => {
        var C = s(I.items);
        I.items.forEach((d) => {
          !d.type && n(C, d.items, c) && (d.annotation = e, d.type = i.CODE, h++);
        });
      }), new t({
        ...r,
        messages: [
          "Detected " + h + " code/quote items."
        ]
      });
    }
  };
  function n(o, r, c) {
    if (r.length === 0)
      return !1;
    if (r.length === 1)
      return r[0].x > o && r[0].height <= c + 1;
    for (var h of r)
      if (h.x === o)
        return !1;
    return !0;
  }
  return Rc;
}
var xc, L0;
function Rp() {
  if (L0) return xc;
  L0 = 1;
  const A = gl(), t = Oe(), e = mr(), { MODIFIED_ANNOTATION: i, UNCHANGED_ANNOTATION: s } = ai(), n = ts();
  return xc = class extends A {
    constructor() {
      super("Level Lists");
    }
    transform(r) {
      var c = 0, h = 0;
      return r.pages.forEach((I) => {
        I.items.filter((C) => C.type === n.LIST).forEach((C) => {
          var d, u = 0;
          const E = {};
          var p = !1;
          C.items.forEach((y) => {
            d ? y.x > d ? (u++, E[y.x] = u) : y.x < d && (u = E[y.x]) : E[y.x] = 0, u > 0 && (y.words = [
              new e({ string: " ".repeat(u * 3) })
            ].concat(y.words), p = !0), d = y.x;
          }), c++, p ? (h++, C.annotation = i) : C.annotation = s;
        });
      }), new t({
        ...r,
        messages: ["Modified " + h + " / " + c + " list blocks."]
      });
    }
  }, xc;
}
var Nc, U0;
function xp() {
  if (U0) return Nc;
  U0 = 1;
  const A = pr(), t = Oe(), { blockToText: e } = ts();
  return Nc = class extends A {
    constructor() {
      super("To Text Blocks", "TextBlock");
    }
    transform(s) {
      return s.pages.forEach((n) => {
        const o = [];
        n.items.forEach((r) => {
          const c = r.type ? r.type.name : "Unknown";
          o.push({
            category: c,
            text: e(r)
          });
        }), n.items = o;
      }), new t({
        ...s
      });
    }
  }, Nc;
}
var Gc, H0;
function Np() {
  if (H0) return Gc;
  H0 = 1;
  const A = pr(), t = Oe();
  return Gc = class extends A {
    constructor() {
      super("To Markdown", "String");
    }
    transform(i) {
      return i.pages.forEach((s) => {
        var n = "";
        s.items.forEach((o) => {
          let r;
          o.category === "TOC" ? r = o.text : r = o.text.replace(/(\r\n|\n|\r)/gm, " "), o.category !== "LIST" && (r = r.split("- ").join("")), o.category === "CODE" && (r = r.split("`").join("")), n += r + `

`;
        }), s.items = [n];
      }), new t({
        ...i
      });
    }
  }, Gc;
}
var J0;
function Gp() {
  if (J0) return Pr;
  J0 = 1;
  const A = Bp(), t = pp(), e = mp(), i = yp(), s = bp(), n = Dp(), o = kp(), r = Sp(), c = Fp(), h = Rp(), I = xp(), C = Np(), d = Oe();
  return Pr.makeTransformations = (u) => [
    new A(u),
    new t(),
    new e(),
    new i(),
    new s(),
    new o(),
    new n(),
    new r(),
    new c(),
    new h(),
    new I(),
    new C()
  ], Pr.transform = (u, E) => {
    var p = new d({ pages: u });
    let y;
    return E.forEach((b) => {
      y && (p = y.completeTransform(p)), p = b.transform(p), y = b;
    }), p;
  }, Pr;
}
var vc, Y0;
function vp() {
  if (Y0) return vc;
  Y0 = 1;
  const { parse: A } = Cp(), { makeTransformations: t, transform: e } = Gp();
  return vc = async function(i, s) {
    const n = await A(i, s), { fonts: o, pages: r } = n, c = t(o.map);
    return e(r, c).pages.map((C) => C.items.join(`
`) + `
`).join("");
  }, vc;
}
var Mp = vp();
const Lp = /* @__PURE__ */ cp(Mp);
self.onmessage = async (A) => {
  if (!(A.data instanceof ArrayBuffer)) throw new Error("Invalid data");
  const t = await Lp(A.data);
  self.postMessage(t.replace(/\u0000/g, ""));
};
function Up(A, t) {
  for (var e = 0; e < t.length; e++) {
    const i = t[e];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const s in i) if (s !== "default" && !(s in A)) {
        const n = Object.getOwnPropertyDescriptor(i, s);
        n && Object.defineProperty(A, s, n.get ? n : { enumerable: !0, get: function() {
          return i[s];
        } });
      }
    }
  }
  return Object.freeze(A);
}
const T0 = function() {
}, ni = (function A(t, e = {}) {
  T0.prototype.name = t;
  const i = {};
  return new Proxy(T0, { get: (s, n) => n === "caller" ? null : n === "__createMock__" ? A : n === "__unenv__" || (n in e ? e[n] : i[n] = i[n] || A(`${t}.${n.toString()}`)), apply: (s, n, o) => A(`${t}()`), construct: (s, n, o) => A(`[${t}]`), enumerate: () => [] });
})("mock"), Cu = ni.__createMock__("fs.Dir"), uu = ni.__createMock__("fs.Dirent"), Bu = ni.__createMock__("fs.Stats"), du = ni.__createMock__("fs.ReadStream"), Qu = ni.__createMock__("fs.WriteStream"), Eu = ni.__createMock__("fs.FileReadStream"), fu = ni.__createMock__("fs.FileWriteStream"), pu = ni.__createMock__("fs.StatsFs"), Hp = Object.freeze({ __proto__: null, Dir: Cu, Dirent: uu, FileReadStream: Eu, FileWriteStream: fu, ReadStream: du, Stats: Bu, StatsFs: pu, WriteStream: Qu }), cl = /* @__PURE__ */ Object.create({ UV_FS_SYMLINK_DIR: 1, UV_FS_SYMLINK_JUNCTION: 2, O_RDONLY: 0, O_WRONLY: 1, O_RDWR: 2, UV_DIRENT_UNKNOWN: 0, UV_DIRENT_FILE: 1, UV_DIRENT_DIR: 2, UV_DIRENT_LINK: 3, UV_DIRENT_FIFO: 4, UV_DIRENT_SOCKET: 5, UV_DIRENT_CHAR: 6, UV_DIRENT_BLOCK: 7, S_IFMT: 61440, S_IFREG: 32768, S_IFDIR: 16384, S_IFCHR: 8192, S_IFBLK: 24576, S_IFIFO: 4096, S_IFLNK: 40960, S_IFSOCK: 49152, O_CREAT: 64, O_EXCL: 128, UV_FS_O_FILEMAP: 0, O_NOCTTY: 256, O_TRUNC: 512, O_APPEND: 1024, O_DIRECTORY: 65536, O_NOATIME: 262144, O_NOFOLLOW: 131072, O_SYNC: 1052672, O_DSYNC: 4096, O_DIRECT: 16384, O_NONBLOCK: 2048, S_IRWXU: 448, S_IRUSR: 256, S_IWUSR: 128, S_IXUSR: 64, S_IRWXG: 56, S_IRGRP: 32, S_IWGRP: 16, S_IXGRP: 8, S_IRWXO: 7, S_IROTH: 4, S_IWOTH: 2, S_IXOTH: 1, F_OK: 0, R_OK: 4, W_OK: 2, X_OK: 1, UV_FS_COPYFILE_EXCL: 1, COPYFILE_EXCL: 1, UV_FS_COPYFILE_FICLONE: 2, COPYFILE_FICLONE: 2, UV_FS_COPYFILE_FICLONE_FORCE: 4, COPYFILE_FICLONE_FORCE: 4 }), Jp = Object.freeze({ __proto__: null, F_OK: 0, R_OK: 4, W_OK: 2, X_OK: 1, constants: cl });
function he(A) {
  throw new Error(`[unenv] ${A} is not implemented yet!`);
}
function Lt(A) {
  return Object.assign((() => {
    throw he(A);
  }), { __unenv__: !0 });
}
const mu = Lt("fs.access"), yu = Lt("fs.copyFile"), wu = Lt("fs.cp"), bu = Lt("fs.open"), Du = Lt("fs.opendir"), ku = Lt("fs.rename"), Su = Lt("fs.truncate"), Fu = Lt("fs.rm"), Ru = Lt("fs.rmdir"), xu = Lt("fs.mkdir"), Nu = Lt("fs.readdir"), Gu = Lt("fs.readlink"), vu = Lt("fs.symlink"), Mu = Lt("fs.lstat"), Lu = Lt("fs.stat"), Uu = Lt("fs.link"), Hu = Lt("fs.unlink"), Ju = Lt("fs.chmod"), Yu = Lt("fs.lchmod"), Tu = Lt("fs.lchown"), Ku = Lt("fs.chown"), qu = Lt("fs.utimes"), Pu = Lt("fs.lutimes"), _u = Lt("fs.realpath"), Ou = Lt("fs.mkdtemp"), Wu = Lt("fs.writeFile"), ju = Lt("fs.appendFile"), Zu = Lt("fs.readFile"), Yp = Lt("fs.watch"), Vu = Lt("fs.statfs"), Tp = Object.freeze({ __proto__: null, access: mu, appendFile: ju, chmod: Ju, chown: Ku, constants: cl, copyFile: yu, cp: wu, default: {}, lchmod: Yu, lchown: Tu, link: Uu, lstat: Mu, lutimes: Pu, mkdir: xu, mkdtemp: Ou, open: bu, opendir: Du, readFile: Zu, readdir: Nu, readlink: Gu, realpath: _u, rename: ku, rm: Fu, rmdir: Ru, stat: Lu, statfs: Vu, symlink: vu, truncate: Su, unlink: Hu, utimes: qu, watch: Yp, writeFile: Wu });
function MA(A) {
  const t = Lt(A);
  return t.__promisify__ = () => Lt(A + ".__promisify__"), t.native = t, t;
}
function pA(A) {
  const t = function(...e) {
    const i = e.pop();
    A().catch(((s) => i(s))).then(((s) => i(void 0, s)));
  };
  return t.__promisify__ = A, t.native = t, t;
}
const Xu = pA(mu), zu = pA(ju), $u = pA(Ku), tB = pA(Ju), AB = pA(yu), eB = pA(wu), iB = pA(Tu), sB = pA(Yu), aB = pA(Uu), nB = pA(Mu), rB = pA(Pu), oB = pA(xu), gB = pA(Ou), cB = pA(_u), hB = pA(bu), lB = pA(Du), IB = pA(Nu), CB = pA(Zu), uB = pA(Gu), BB = pA(ku), dB = pA(Fu), QB = pA(Ru), EB = pA(Lu), fB = pA(vu), pB = pA(Su), mB = pA(Hu), yB = pA(qu), wB = pA(Wu), bB = pA(Vu), DB = MA("fs.close"), kB = MA("fs.createReadStream"), SB = MA("fs.createWriteStream"), FB = MA("fs.exists"), RB = MA("fs.fchown"), xB = MA("fs.fchmod"), NB = MA("fs.fdatasync"), GB = MA("fs.fstat"), vB = MA("fs.fsync"), MB = MA("fs.ftruncate"), LB = MA("fs.futimes"), UB = MA("fs.lstatSync"), HB = MA("fs.read"), JB = MA("fs.readv"), YB = MA("fs.realpathSync"), TB = MA("fs.statSync"), KB = MA("fs.unwatchFile"), qB = MA("fs.watch"), PB = MA("fs.watchFile"), _B = MA("fs.write"), OB = MA("fs.writev"), WB = MA("fs._toUnixTimestamp"), jB = MA("fs.openAsBlob"), ZB = Lt("fs.appendFileSync"), VB = Lt("fs.accessSync"), XB = Lt("fs.chownSync"), zB = Lt("fs.chmodSync"), $B = Lt("fs.closeSync"), td = Lt("fs.copyFileSync"), Ad = Lt("fs.cpSync"), ed = () => !1, id = Lt("fs.fchownSync"), sd = Lt("fs.fchmodSync"), ad = Lt("fs.fdatasyncSync"), nd = Lt("fs.fstatSync"), rd = Lt("fs.fsyncSync"), od = Lt("fs.ftruncateSync"), gd = Lt("fs.futimesSync"), cd = Lt("fs.lchownSync"), hd = Lt("fs.lchmodSync"), ld = Lt("fs.linkSync"), Id = Lt("fs.lutimesSync"), Cd = Lt("fs.mkdirSync"), ud = Lt("fs.mkdtempSync"), Bd = Lt("fs.openSync"), dd = Lt("fs.opendirSync"), Qd = Lt("fs.readdirSync"), Ed = Lt("fs.readSync"), fd = Lt("fs.readvSync"), pd = Lt("fs.readFileSync"), md = Lt("fs.readlinkSync"), yd = Lt("fs.renameSync"), wd = Lt("fs.rmSync"), bd = Lt("fs.rmdirSync"), Dd = Lt("fs.symlinkSync"), kd = Lt("fs.truncateSync"), Sd = Lt("fs.unlinkSync"), Fd = Lt("fs.utimesSync"), Rd = Lt("fs.writeFileSync"), xd = Lt("fs.writeSync"), Nd = Lt("fs.writevSync"), Gd = Lt("fs.statfsSync"), vd = Tp, Kp = { ...Hp, ...Jp, ...Object.freeze({ __proto__: null, _toUnixTimestamp: WB, access: Xu, accessSync: VB, appendFile: zu, appendFileSync: ZB, chmod: tB, chmodSync: zB, chown: $u, chownSync: XB, close: DB, closeSync: $B, copyFile: AB, copyFileSync: td, cp: eB, cpSync: Ad, createReadStream: kB, createWriteStream: SB, exists: FB, existsSync: ed, fchmod: xB, fchmodSync: sd, fchown: RB, fchownSync: id, fdatasync: NB, fdatasyncSync: ad, fstat: GB, fstatSync: nd, fsync: vB, fsyncSync: rd, ftruncate: MB, ftruncateSync: od, futimes: LB, futimesSync: gd, lchmod: sB, lchmodSync: hd, lchown: iB, lchownSync: cd, link: aB, linkSync: ld, lstat: nB, lstatSync: UB, lutimes: rB, lutimesSync: Id, mkdir: oB, mkdirSync: Cd, mkdtemp: gB, mkdtempSync: ud, open: hB, openAsBlob: jB, openSync: Bd, opendir: lB, opendirSync: dd, read: HB, readFile: CB, readFileSync: pd, readSync: Ed, readdir: IB, readdirSync: Qd, readlink: uB, readlinkSync: md, readv: JB, readvSync: fd, realpath: cB, realpathSync: YB, rename: BB, renameSync: yd, rm: dB, rmSync: wd, rmdir: QB, rmdirSync: bd, stat: EB, statSync: TB, statfs: bB, statfsSync: Gd, symlink: fB, symlinkSync: Dd, truncate: pB, truncateSync: kd, unlink: mB, unlinkSync: Sd, unwatchFile: KB, utimes: yB, utimesSync: Fd, watch: qB, watchFile: PB, write: _B, writeFile: wB, writeFileSync: Rd, writeSync: xd, writev: OB, writevSync: Nd }), promises: vd }, qp = Object.freeze({ __proto__: null, Dir: Cu, Dirent: uu, F_OK: 0, FileReadStream: Eu, FileWriteStream: fu, R_OK: 4, ReadStream: du, Stats: Bu, StatsFs: pu, W_OK: 2, WriteStream: Qu, X_OK: 1, _toUnixTimestamp: WB, access: Xu, accessSync: VB, appendFile: zu, appendFileSync: ZB, chmod: tB, chmodSync: zB, chown: $u, chownSync: XB, close: DB, closeSync: $B, constants: cl, copyFile: AB, copyFileSync: td, cp: eB, cpSync: Ad, createReadStream: kB, createWriteStream: SB, default: Kp, exists: FB, existsSync: ed, fchmod: xB, fchmodSync: sd, fchown: RB, fchownSync: id, fdatasync: NB, fdatasyncSync: ad, fstat: GB, fstatSync: nd, fsync: vB, fsyncSync: rd, ftruncate: MB, ftruncateSync: od, futimes: LB, futimesSync: gd, lchmod: sB, lchmodSync: hd, lchown: iB, lchownSync: cd, link: aB, linkSync: ld, lstat: nB, lstatSync: UB, lutimes: rB, lutimesSync: Id, mkdir: oB, mkdirSync: Cd, mkdtemp: gB, mkdtempSync: ud, open: hB, openAsBlob: jB, openSync: Bd, opendir: lB, opendirSync: dd, promises: vd, read: HB, readFile: CB, readFileSync: pd, readSync: Ed, readdir: IB, readdirSync: Qd, readlink: uB, readlinkSync: md, readv: JB, readvSync: fd, realpath: cB, realpathSync: YB, rename: BB, renameSync: yd, rm: dB, rmSync: wd, rmdir: QB, rmdirSync: bd, stat: EB, statSync: TB, statfs: bB, statfsSync: Gd, symlink: fB, symlinkSync: Dd, truncate: pB, truncateSync: kd, unlink: mB, unlinkSync: Sd, unwatchFile: KB, utimes: yB, utimesSync: Fd, watch: qB, watchFile: PB, write: _B, writeFile: wB, writeFileSync: Rd, writeSync: xd, writev: OB, writevSync: Nd }), Md = ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PRI", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE"], Ld = { 100: "Continue", 101: "Switching Protocols", 102: "Processing", 103: "Early Hints", 200: "OK", 201: "Created", 202: "Accepted", 203: "Non-Authoritative Information", 204: "No Content", 205: "Reset Content", 206: "Partial Content", 207: "Multi-Status", 208: "Already Reported", 226: "IM Used", 300: "Multiple Choices", 301: "Moved Permanently", 302: "Found", 303: "See Other", 304: "Not Modified", 305: "Use Proxy", 307: "Temporary Redirect", 308: "Permanent Redirect", 400: "Bad Request", 401: "Unauthorized", 402: "Payment Required", 403: "Forbidden", 404: "Not Found", 405: "Method Not Allowed", 406: "Not Acceptable", 407: "Proxy Authentication Required", 408: "Request Timeout", 409: "Conflict", 410: "Gone", 411: "Length Required", 412: "Precondition Failed", 413: "Payload Too Large", 414: "URI Too Long", 415: "Unsupported Media Type", 416: "Range Not Satisfiable", 417: "Expectation Failed", 418: "I'm a Teapot", 421: "Misdirected Request", 422: "Unprocessable Entity", 423: "Locked", 424: "Failed Dependency", 425: "Too Early", 426: "Upgrade Required", 428: "Precondition Required", 429: "Too Many Requests", 431: "Request Header Fields Too Large", 451: "Unavailable For Legal Reasons", 500: "Internal Server Error", 501: "Not Implemented", 502: "Bad Gateway", 503: "Service Unavailable", 504: "Gateway Timeout", 505: "HTTP Version Not Supported", 506: "Variant Also Negotiates", 507: "Insufficient Storage", 508: "Loop Detected", 509: "Bandwidth Limit Exceeded", 510: "Not Extended", 511: "Network Authentication Required" }, Pp = Object.freeze({ __proto__: null, METHODS: Md, STATUS_CODES: Ld, maxHeaderSize: 16384 });
let K0 = 10, Ud = class {
  __unenv__ = !0;
  _events = /* @__PURE__ */ Object.create(null);
  _maxListeners;
  static get defaultMaxListeners() {
    return K0;
  }
  static set defaultMaxListeners(A) {
    if (typeof A != "number" || A < 0 || Number.isNaN(A)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + A + ".");
    K0 = A;
  }
  setMaxListeners(A) {
    if (typeof A != "number" || A < 0 || Number.isNaN(A)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + A + ".");
    return this._maxListeners = A, this;
  }
  getMaxListeners() {
    return Hd(this);
  }
  emit(A, ...t) {
    if (!this._events[A] || this._events[A].length === 0) return !1;
    if (A === "error") {
      let e;
      if (t.length > 0 && (e = t[0]), e instanceof Error) throw e;
      const i = new Error("Unhandled error." + (e ? " (" + e.message + ")" : ""));
      throw i.context = e, i;
    }
    for (const e of this._events[A]) (e.listener || e).apply(this, t);
    return !0;
  }
  addListener(A, t) {
    return Mc(this, A, t, !1);
  }
  on(A, t) {
    return Mc(this, A, t, !1);
  }
  prependListener(A, t) {
    return Mc(this, A, t, !0);
  }
  once(A, t) {
    return this.on(A, q0(this, A, t));
  }
  prependOnceListener(A, t) {
    return this.prependListener(A, q0(this, A, t));
  }
  removeListener(A, t) {
    return (function(e, i, s) {
      if (Jd(s), !e._events[i] || e._events[i].length === 0) return e;
      const n = e._events[i].length;
      return e._events[i] = e._events[i].filter(((o) => o !== s)), n === e._events[i].length || (e._events.removeListener && e.emit("removeListener", i, s.listener || s), e._events[i].length === 0 && delete e._events[i]), e;
    })(this, A, t);
  }
  off(A, t) {
    return this.removeListener(A, t);
  }
  removeAllListeners(A) {
    return (function(t, e) {
      if (!t._events[e] || t._events[e].length === 0) return t;
      if (t._events.removeListener) for (const i of t._events[e]) t.emit("removeListener", e, i.listener || i);
      return delete t._events[e], t;
    })(this, A);
  }
  listeners(A) {
    return P0(this, A, !0);
  }
  rawListeners(A) {
    return P0(this, A, !1);
  }
  listenerCount(A) {
    return this.rawListeners(A).length;
  }
  eventNames() {
    return Object.keys(this._events);
  }
};
function Mc(A, t, e, i) {
  Jd(e), A._events.newListener !== void 0 && A.emit("newListener", t, e.listener || e), A._events[t] || (A._events[t] = []), i ? A._events[t].unshift(e) : A._events[t].push(e);
  const s = Hd(A);
  if (s > 0 && A._events[t].length > s && !A._events[t].warned) {
    A._events[t].warned = !0;
    const n = new Error(`[unenv] Possible EventEmitter memory leak detected. ${A._events[t].length} ${t} listeners added. Use emitter.setMaxListeners() to increase limit`);
    n.name = "MaxListenersExceededWarning", n.emitter = A, n.type = t, n.count = A._events[t]?.length, console.warn(n);
  }
  return A;
}
function q0(A, t, e) {
  let i = !1;
  const s = (...n) => {
    if (!i) return A.removeListener(t, s), i = !0, n.length === 0 ? e.call(A) : e.apply(A, n);
  };
  return s.listener = e, s;
}
function Hd(A) {
  return A._maxListeners ?? Ud.defaultMaxListeners;
}
function P0(A, t, e) {
  let i = A._events[t];
  return typeof i == "function" && (i = [i]), e ? i.map(((s) => s.listener || s)) : i;
}
function Jd(A) {
  if (typeof A != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof A);
}
const Yd = globalThis.EventEmitter || Ud;
class hl extends Yd {
  __unenv__ = !0;
  readableEncoding = null;
  readableEnded = !0;
  readableFlowing = !1;
  readableHighWaterMark = 0;
  readableLength = 0;
  readableObjectMode = !1;
  readableAborted = !1;
  readableDidRead = !1;
  closed = !1;
  errored = null;
  readable = !1;
  destroyed = !1;
  static from(t, e) {
    return new hl(e);
  }
  constructor(t) {
    super();
  }
  _read(t) {
  }
  read(t) {
  }
  setEncoding(t) {
    return this;
  }
  pause() {
    return this;
  }
  resume() {
    return this;
  }
  isPaused() {
    return !0;
  }
  unpipe(t) {
    return this;
  }
  unshift(t, e) {
  }
  wrap(t) {
    return this;
  }
  push(t, e) {
    return !1;
  }
  _destroy(t, e) {
    this.removeAllListeners();
  }
  destroy(t) {
    return this.destroyed = !0, this._destroy(t), this;
  }
  pipe(t, e) {
    return {};
  }
  compose(t, e) {
    throw new Error("[unenv] Method not implemented.");
  }
  [Symbol.asyncDispose]() {
    return this.destroy(), Promise.resolve();
  }
  async *[Symbol.asyncIterator]() {
    throw he("Readable.asyncIterator");
  }
  iterator(t) {
    throw he("Readable.iterator");
  }
  map(t, e) {
    throw he("Readable.map");
  }
  filter(t, e) {
    throw he("Readable.filter");
  }
  forEach(t, e) {
    throw he("Readable.forEach");
  }
  reduce(t, e, i) {
    throw he("Readable.reduce");
  }
  find(t, e) {
    throw he("Readable.find");
  }
  findIndex(t, e) {
    throw he("Readable.findIndex");
  }
  some(t, e) {
    throw he("Readable.some");
  }
  toArray(t) {
    throw he("Readable.toArray");
  }
  every(t, e) {
    throw he("Readable.every");
  }
  flatMap(t, e) {
    throw he("Readable.flatMap");
  }
  drop(t, e) {
    throw he("Readable.drop");
  }
  take(t, e) {
    throw he("Readable.take");
  }
  asIndexedPairs(t) {
    throw he("Readable.asIndexedPairs");
  }
}
const ll = globalThis.Readable || hl, Si = [], $e = [], _p = typeof Uint8Array > "u" ? Array : Uint8Array, _0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (let A = 0, t = 64; A < t; ++A) Si[A] = _0[A], $e[_0.charCodeAt(A)] = A;
function Op(A) {
  let t;
  const e = (function(h) {
    const I = h.length;
    if (I % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    let C = h.indexOf("=");
    return C === -1 && (C = I), [C, C === I ? 0 : 4 - C % 4];
  })(A), i = e[0], s = e[1], n = new _p((function(h, I, C) {
    return 3 * (I + C) / 4 - C;
  })(0, i, s));
  let o = 0;
  const r = s > 0 ? i - 4 : i;
  let c;
  for (c = 0; c < r; c += 4) t = $e[A.charCodeAt(c)] << 18 | $e[A.charCodeAt(c + 1)] << 12 | $e[A.charCodeAt(c + 2)] << 6 | $e[A.charCodeAt(c + 3)], n[o++] = t >> 16 & 255, n[o++] = t >> 8 & 255, n[o++] = 255 & t;
  return s === 2 && (t = $e[A.charCodeAt(c)] << 2 | $e[A.charCodeAt(c + 1)] >> 4, n[o++] = 255 & t), s === 1 && (t = $e[A.charCodeAt(c)] << 10 | $e[A.charCodeAt(c + 1)] << 4 | $e[A.charCodeAt(c + 2)] >> 2, n[o++] = t >> 8 & 255, n[o++] = 255 & t), n;
}
function Wp(A, t, e) {
  let i;
  const s = [];
  for (let o = t; o < e; o += 3) i = (A[o] << 16 & 16711680) + (A[o + 1] << 8 & 65280) + (255 & A[o + 2]), s.push(Si[(n = i) >> 18 & 63] + Si[n >> 12 & 63] + Si[n >> 6 & 63] + Si[63 & n]);
  var n;
  return s.join("");
}
function O0(A) {
  let t;
  const e = A.length, i = e % 3, s = [], n = 16383;
  for (let o = 0, r = e - i; o < r; o += n) s.push(Wp(A, o, o + n > r ? r : o + n));
  return i === 1 ? (t = A[e - 1], s.push(Si[t >> 2] + Si[t << 4 & 63] + "==")) : i === 2 && (t = (A[e - 2] << 8) + A[e - 1], s.push(Si[t >> 10] + Si[t >> 4 & 63] + Si[t << 2 & 63] + "=")), s.join("");
}
function _r(A, t, e, i, s) {
  let n, o;
  const r = 8 * s - i - 1, c = (1 << r) - 1, h = c >> 1;
  let I = -7, C = e ? s - 1 : 0;
  const d = e ? -1 : 1;
  let u = A[t + C];
  for (C += d, n = u & (1 << -I) - 1, u >>= -I, I += r; I > 0; ) n = 256 * n + A[t + C], C += d, I -= 8;
  for (o = n & (1 << -I) - 1, n >>= -I, I += i; I > 0; ) o = 256 * o + A[t + C], C += d, I -= 8;
  if (n === 0) n = 1 - h;
  else {
    if (n === c) return o ? Number.NaN : (u ? -1 : 1) * Number.POSITIVE_INFINITY;
    o += Math.pow(2, i), n -= h;
  }
  return (u ? -1 : 1) * o * Math.pow(2, n - i);
}
function Td(A, t, e, i, s, n) {
  let o, r, c, h = 8 * n - s - 1;
  const I = (1 << h) - 1, C = I >> 1, d = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  let u = i ? 0 : n - 1;
  const E = i ? 1 : -1, p = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), Number.isNaN(t) || t === Number.POSITIVE_INFINITY ? (r = Number.isNaN(t) ? 1 : 0, o = I) : (o = Math.floor(Math.log2(t)), t * (c = Math.pow(2, -o)) < 1 && (o--, c *= 2), (t += o + C >= 1 ? d / c : d * Math.pow(2, 1 - C)) * c >= 2 && (o++, c /= 2), o + C >= I ? (r = 0, o = I) : o + C >= 1 ? (r = (t * c - 1) * Math.pow(2, s), o += C) : (r = t * Math.pow(2, C - 1) * Math.pow(2, s), o = 0)); s >= 8; ) A[e + u] = 255 & r, u += E, r /= 256, s -= 8;
  for (o = o << s | r, h += s; h > 0; ) A[e + u] = 255 & o, u += E, o /= 256, h -= 8;
  A[e + u - E] |= 128 * p;
}
$e[45] = 62, $e[95] = 63;
const W0 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null, fh = 2147483647;
function Oi(A) {
  if (A > fh) throw new RangeError('The value "' + A + '" is invalid for option "size"');
  const t = new Uint8Array(A);
  return Object.setPrototypeOf(t, mt.prototype), t;
}
function mt(A, t, e) {
  if (typeof A == "number") {
    if (typeof t == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
    return ph(A);
  }
  return Kd(A, t, e);
}
function Kd(A, t, e) {
  if (typeof A == "string") return (function(n, o) {
    if (typeof o == "string" && o !== "" || (o = "utf8"), !mt.isEncoding(o)) throw new TypeError("Unknown encoding: " + o);
    const r = 0 | Pd(n, o);
    let c = Oi(r);
    const h = c.write(n, o);
    return h !== r && (c = c.slice(0, h)), c;
  })(A, t);
  if (ArrayBuffer.isView(A)) return (function(n) {
    if (Fi(n, Uint8Array)) {
      const o = new Uint8Array(n);
      return Uc(o.buffer, o.byteOffset, o.byteLength);
    }
    return Lc(n);
  })(A);
  if (A == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof A);
  if (Fi(A, ArrayBuffer) || A && Fi(A.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Fi(A, SharedArrayBuffer) || A && Fi(A.buffer, SharedArrayBuffer))) return Uc(A, t, e);
  if (typeof A == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
  const i = A.valueOf && A.valueOf();
  if (i != null && i !== A) return mt.from(i, t, e);
  const s = (function(n) {
    if (mt.isBuffer(n)) {
      const o = 0 | Il(n.length), r = Oi(o);
      return r.length === 0 || n.copy(r, 0, 0, o), r;
    }
    if (n.length !== void 0) return typeof n.length != "number" || Cl(n.length) ? Oi(0) : Lc(n);
    if (n.type === "Buffer" && Array.isArray(n.data)) return Lc(n.data);
  })(A);
  if (s) return s;
  if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof A[Symbol.toPrimitive] == "function") return mt.from(A[Symbol.toPrimitive]("string"), t, e);
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof A);
}
function qd(A) {
  if (typeof A != "number") throw new TypeError('"size" argument must be of type number');
  if (A < 0) throw new RangeError('The value "' + A + '" is invalid for option "size"');
}
function ph(A) {
  return qd(A), Oi(A < 0 ? 0 : 0 | Il(A));
}
function Lc(A) {
  const t = A.length < 0 ? 0 : 0 | Il(A.length), e = Oi(t);
  for (let i = 0; i < t; i += 1) e[i] = 255 & A[i];
  return e;
}
function Uc(A, t, e) {
  if (t < 0 || A.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds');
  if (A.byteLength < t + (e || 0)) throw new RangeError('"length" is outside of buffer bounds');
  let i;
  return i = t === void 0 && e === void 0 ? new Uint8Array(A) : e === void 0 ? new Uint8Array(A, t) : new Uint8Array(A, t, e), Object.setPrototypeOf(i, mt.prototype), i;
}
function Il(A) {
  if (A >= fh) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + fh.toString(16) + " bytes");
  return 0 | A;
}
function Pd(A, t) {
  if (mt.isBuffer(A)) return A.length;
  if (ArrayBuffer.isView(A) || Fi(A, ArrayBuffer)) return A.byteLength;
  if (typeof A != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof A);
  const e = A.length, i = arguments.length > 2 && arguments[2] === !0;
  if (!i && e === 0) return 0;
  let s = !1;
  for (; ; ) switch (t) {
    case "ascii":
    case "latin1":
    case "binary":
      return e;
    case "utf8":
    case "utf-8":
      return mh(A).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return 2 * e;
    case "hex":
      return e >>> 1;
    case "base64":
      return jd(A).length;
    default:
      if (s) return i ? -1 : mh(A).length;
      t = ("" + t).toLowerCase(), s = !0;
  }
}
function jp(A, t, e) {
  let i = !1;
  if ((t === void 0 || t < 0) && (t = 0), t > this.length || ((e === void 0 || e > this.length) && (e = this.length), e <= 0) || (e >>>= 0) <= (t >>>= 0)) return "";
  for (A || (A = "utf8"); ; ) switch (A) {
    case "hex":
      return i9(this, t, e);
    case "utf8":
    case "utf-8":
      return _d(this, t, e);
    case "ascii":
      return A9(this, t, e);
    case "latin1":
    case "binary":
      return e9(this, t, e);
    case "base64":
      return t9(this, t, e);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return s9(this, t, e);
    default:
      if (i) throw new TypeError("Unknown encoding: " + A);
      A = (A + "").toLowerCase(), i = !0;
  }
}
function qs(A, t, e) {
  const i = A[t];
  A[t] = A[e], A[e] = i;
}
function j0(A, t, e, i, s) {
  if (A.length === 0) return -1;
  if (typeof e == "string" ? (i = e, e = 0) : e > 2147483647 ? e = 2147483647 : e < -2147483648 && (e = -2147483648), Cl(e = +e) && (e = s ? 0 : A.length - 1), e < 0 && (e = A.length + e), e >= A.length) {
    if (s) return -1;
    e = A.length - 1;
  } else if (e < 0) {
    if (!s) return -1;
    e = 0;
  }
  if (typeof t == "string" && (t = mt.from(t, i)), mt.isBuffer(t)) return t.length === 0 ? -1 : Z0(A, t, e, i, s);
  if (typeof t == "number") return t &= 255, typeof Uint8Array.prototype.indexOf == "function" ? s ? Uint8Array.prototype.indexOf.call(A, t, e) : Uint8Array.prototype.lastIndexOf.call(A, t, e) : Z0(A, [t], e, i, s);
  throw new TypeError("val must be string, number or Buffer");
}
function Z0(A, t, e, i, s) {
  let n, o = 1, r = A.length, c = t.length;
  if (i !== void 0 && ((i = String(i).toLowerCase()) === "ucs2" || i === "ucs-2" || i === "utf16le" || i === "utf-16le")) {
    if (A.length < 2 || t.length < 2) return -1;
    o = 2, r /= 2, c /= 2, e /= 2;
  }
  function h(I, C) {
    return o === 1 ? I[C] : I.readUInt16BE(C * o);
  }
  if (s) {
    let I = -1;
    for (n = e; n < r; n++) if (h(A, n) === h(t, I === -1 ? 0 : n - I)) {
      if (I === -1 && (I = n), n - I + 1 === c) return I * o;
    } else I !== -1 && (n -= n - I), I = -1;
  } else for (e + c > r && (e = r - c), n = e; n >= 0; n--) {
    let I = !0;
    for (let C = 0; C < c; C++) if (h(A, n + C) !== h(t, C)) {
      I = !1;
      break;
    }
    if (I) return n;
  }
  return -1;
}
function Zp(A, t, e, i) {
  e = Number(e) || 0;
  const s = A.length - e;
  i ? (i = Number(i)) > s && (i = s) : i = s;
  const n = t.length;
  let o;
  for (i > n / 2 && (i = n / 2), o = 0; o < i; ++o) {
    const r = Number.parseInt(t.slice(2 * o, 2 * o + 2), 16);
    if (Cl(r)) return o;
    A[e + o] = r;
  }
  return o;
}
function Vp(A, t, e, i) {
  return lg(mh(t, A.length - e), A, e, i);
}
function Xp(A, t, e, i) {
  return lg((function(s) {
    const n = [];
    for (let o = 0; o < s.length; ++o) n.push(255 & s.charCodeAt(o));
    return n;
  })(t), A, e, i);
}
function zp(A, t, e, i) {
  return lg(jd(t), A, e, i);
}
function $p(A, t, e, i) {
  return lg((function(s, n) {
    let o, r, c;
    const h = [];
    for (let I = 0; I < s.length && !((n -= 2) < 0); ++I) o = s.charCodeAt(I), r = o >> 8, c = o % 256, h.push(c, r);
    return h;
  })(t, A.length - e), A, e, i);
}
function t9(A, t, e) {
  return t === 0 && e === A.length ? O0(A) : O0(A.slice(t, e));
}
function _d(A, t, e) {
  e = Math.min(A.length, e);
  const i = [];
  let s = t;
  for (; s < e; ) {
    const n = A[s];
    let o = null, r = n > 239 ? 4 : n > 223 ? 3 : n > 191 ? 2 : 1;
    if (s + r <= e) {
      let c, h, I, C;
      switch (r) {
        case 1:
          n < 128 && (o = n);
          break;
        case 2:
          c = A[s + 1], (192 & c) == 128 && (C = (31 & n) << 6 | 63 & c, C > 127 && (o = C));
          break;
        case 3:
          c = A[s + 1], h = A[s + 2], (192 & c) == 128 && (192 & h) == 128 && (C = (15 & n) << 12 | (63 & c) << 6 | 63 & h, C > 2047 && (C < 55296 || C > 57343) && (o = C));
          break;
        case 4:
          c = A[s + 1], h = A[s + 2], I = A[s + 3], (192 & c) == 128 && (192 & h) == 128 && (192 & I) == 128 && (C = (15 & n) << 18 | (63 & c) << 12 | (63 & h) << 6 | 63 & I, C > 65535 && C < 1114112 && (o = C));
      }
    }
    o === null ? (o = 65533, r = 1) : o > 65535 && (o -= 65536, i.push(o >>> 10 & 1023 | 55296), o = 56320 | 1023 & o), i.push(o), s += r;
  }
  return (function(n) {
    const o = n.length;
    if (o <= V0) return String.fromCharCode.apply(String, n);
    let r = "", c = 0;
    for (; c < o; ) r += String.fromCharCode.apply(String, n.slice(c, c += V0));
    return r;
  })(i);
}
mt.TYPED_ARRAY_SUPPORT = (function() {
  try {
    const A = new Uint8Array(1), t = { foo: function() {
      return 42;
    } };
    return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(A, t), A.foo() === 42;
  } catch {
    return !1;
  }
})(), mt.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This environment lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(mt.prototype, "parent", { enumerable: !0, get: function() {
  if (mt.isBuffer(this)) return this.buffer;
} }), Object.defineProperty(mt.prototype, "offset", { enumerable: !0, get: function() {
  if (mt.isBuffer(this)) return this.byteOffset;
} }), mt.poolSize = 8192, mt.from = function(A, t, e) {
  return Kd(A, t, e);
}, Object.setPrototypeOf(mt.prototype, Uint8Array.prototype), Object.setPrototypeOf(mt, Uint8Array), mt.alloc = function(A, t, e) {
  return (function(i, s, n) {
    return qd(i), i <= 0 ? Oi(i) : s !== void 0 ? typeof n == "string" ? Oi(i).fill(s, n) : Oi(i).fill(s) : Oi(i);
  })(A, t, e);
}, mt.allocUnsafe = function(A) {
  return ph(A);
}, mt.allocUnsafeSlow = function(A) {
  return ph(A);
}, mt.isBuffer = function(A) {
  return A != null && A._isBuffer === !0 && A !== mt.prototype;
}, mt.compare = function(A, t) {
  if (Fi(A, Uint8Array) && (A = mt.from(A, A.offset, A.byteLength)), Fi(t, Uint8Array) && (t = mt.from(t, t.offset, t.byteLength)), !mt.isBuffer(A) || !mt.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  if (A === t) return 0;
  let e = A.length, i = t.length;
  for (let s = 0, n = Math.min(e, i); s < n; ++s) if (A[s] !== t[s]) {
    e = A[s], i = t[s];
    break;
  }
  return e < i ? -1 : i < e ? 1 : 0;
}, mt.isEncoding = function(A) {
  switch (String(A).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
}, mt.concat = function(A, t) {
  if (!Array.isArray(A)) throw new TypeError('"list" argument must be an Array of Buffers');
  if (A.length === 0) return mt.alloc(0);
  let e;
  if (t === void 0) for (t = 0, e = 0; e < A.length; ++e) t += A[e].length;
  const i = mt.allocUnsafe(t);
  let s = 0;
  for (e = 0; e < A.length; ++e) {
    let n = A[e];
    if (Fi(n, Uint8Array)) s + n.length > i.length ? (mt.isBuffer(n) || (n = mt.from(n.buffer, n.byteOffset, n.byteLength)), n.copy(i, s)) : Uint8Array.prototype.set.call(i, n, s);
    else {
      if (!mt.isBuffer(n)) throw new TypeError('"list" argument must be an Array of Buffers');
      n.copy(i, s);
    }
    s += n.length;
  }
  return i;
}, mt.byteLength = Pd, mt.prototype._isBuffer = !0, mt.prototype.swap16 = function() {
  const A = this.length;
  if (A % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (let t = 0; t < A; t += 2) qs(this, t, t + 1);
  return this;
}, mt.prototype.swap32 = function() {
  const A = this.length;
  if (A % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (let t = 0; t < A; t += 4) qs(this, t, t + 3), qs(this, t + 1, t + 2);
  return this;
}, mt.prototype.swap64 = function() {
  const A = this.length;
  if (A % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (let t = 0; t < A; t += 8) qs(this, t, t + 7), qs(this, t + 1, t + 6), qs(this, t + 2, t + 5), qs(this, t + 3, t + 4);
  return this;
}, mt.prototype.toString = function() {
  const A = this.length;
  return A === 0 ? "" : arguments.length === 0 ? _d(this, 0, A) : Reflect.apply(jp, this, arguments);
}, mt.prototype.toLocaleString = mt.prototype.toString, mt.prototype.equals = function(A) {
  if (!mt.isBuffer(A)) throw new TypeError("Argument must be a Buffer");
  return this === A || mt.compare(this, A) === 0;
}, mt.prototype.inspect = function() {
  let A = "";
  return A = this.toString("hex", 0, 50).replace(/(.{2})/g, "$1 ").trim(), this.length > 50 && (A += " ... "), "<Buffer " + A + ">";
}, W0 && (mt.prototype[W0] = mt.prototype.inspect), mt.prototype.compare = function(A, t, e, i, s) {
  if (Fi(A, Uint8Array) && (A = mt.from(A, A.offset, A.byteLength)), !mt.isBuffer(A)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof A);
  if (t === void 0 && (t = 0), e === void 0 && (e = A ? A.length : 0), i === void 0 && (i = 0), s === void 0 && (s = this.length), t < 0 || e > A.length || i < 0 || s > this.length) throw new RangeError("out of range index");
  if (i >= s && t >= e) return 0;
  if (i >= s) return -1;
  if (t >= e) return 1;
  if (this === A) return 0;
  let n = (s >>>= 0) - (i >>>= 0), o = (e >>>= 0) - (t >>>= 0);
  const r = Math.min(n, o), c = this.slice(i, s), h = A.slice(t, e);
  for (let I = 0; I < r; ++I) if (c[I] !== h[I]) {
    n = c[I], o = h[I];
    break;
  }
  return n < o ? -1 : o < n ? 1 : 0;
}, mt.prototype.includes = function(A, t, e) {
  return this.indexOf(A, t, e) !== -1;
}, mt.prototype.indexOf = function(A, t, e) {
  return j0(this, A, t, e, !0);
}, mt.prototype.lastIndexOf = function(A, t, e) {
  return j0(this, A, t, e, !1);
}, mt.prototype.write = function(A, t, e, i) {
  if (t === void 0) i = "utf8", e = this.length, t = 0;
  else if (e === void 0 && typeof t == "string") i = t, e = this.length, t = 0;
  else {
    if (!Number.isFinite(t)) throw new TypeError("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    t >>>= 0, Number.isFinite(e) ? (e >>>= 0, i === void 0 && (i = "utf8")) : (i = e, e = void 0);
  }
  const s = this.length - t;
  if ((e === void 0 || e > s) && (e = s), A.length > 0 && (e < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
  i || (i = "utf8");
  let n = !1;
  for (; ; ) switch (i) {
    case "hex":
      return Zp(this, A, t, e);
    case "utf8":
    case "utf-8":
      return Vp(this, A, t, e);
    case "ascii":
    case "latin1":
    case "binary":
      return Xp(this, A, t, e);
    case "base64":
      return zp(this, A, t, e);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return $p(this, A, t, e);
    default:
      if (n) throw new TypeError("Unknown encoding: " + i);
      i = ("" + i).toLowerCase(), n = !0;
  }
}, mt.prototype.toJSON = function() {
  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
};
const V0 = 4096;
function A9(A, t, e) {
  let i = "";
  e = Math.min(A.length, e);
  for (let s = t; s < e; ++s) i += String.fromCharCode(127 & A[s]);
  return i;
}
function e9(A, t, e) {
  let i = "";
  e = Math.min(A.length, e);
  for (let s = t; s < e; ++s) i += String.fromCharCode(A[s]);
  return i;
}
function i9(A, t, e) {
  const i = A.length;
  (!t || t < 0) && (t = 0), (!e || e < 0 || e > i) && (e = i);
  let s = "";
  for (let n = t; n < e; ++n) s += n9[A[n]];
  return s;
}
function s9(A, t, e) {
  const i = A.slice(t, e);
  let s = "";
  for (let n = 0; n < i.length - 1; n += 2) s += String.fromCharCode(i[n] + 256 * i[n + 1]);
  return s;
}
function te(A, t, e) {
  if (A % 1 != 0 || A < 0) throw new RangeError("offset is not uint");
  if (A + t > e) throw new RangeError("Trying to access beyond buffer length");
}
function Se(A, t, e, i, s, n) {
  if (!mt.isBuffer(A)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t > s || t < n) throw new RangeError('"value" argument is out of bounds');
  if (e + i > A.length) throw new RangeError("Index out of range");
}
function X0(A, t, e, i, s) {
  Wd(t, i, s, A, e, 7);
  let n = Number(t & BigInt(4294967295));
  A[e++] = n, n >>= 8, A[e++] = n, n >>= 8, A[e++] = n, n >>= 8, A[e++] = n;
  let o = Number(t >> BigInt(32) & BigInt(4294967295));
  return A[e++] = o, o >>= 8, A[e++] = o, o >>= 8, A[e++] = o, o >>= 8, A[e++] = o, e;
}
function z0(A, t, e, i, s) {
  Wd(t, i, s, A, e, 7);
  let n = Number(t & BigInt(4294967295));
  A[e + 7] = n, n >>= 8, A[e + 6] = n, n >>= 8, A[e + 5] = n, n >>= 8, A[e + 4] = n;
  let o = Number(t >> BigInt(32) & BigInt(4294967295));
  return A[e + 3] = o, o >>= 8, A[e + 2] = o, o >>= 8, A[e + 1] = o, o >>= 8, A[e] = o, e + 8;
}
function Od(A, t, e, i, s, n) {
  if (e + i > A.length) throw new RangeError("Index out of range");
  if (e < 0) throw new RangeError("Index out of range");
}
function $0(A, t, e, i, s) {
  return t = +t, e >>>= 0, s || Od(A, 0, e, 4), Td(A, t, e, i, 23, 4), e + 4;
}
function tC(A, t, e, i, s) {
  return t = +t, e >>>= 0, s || Od(A, 0, e, 8), Td(A, t, e, i, 52, 8), e + 8;
}
mt.prototype.slice = function(A, t) {
  const e = this.length;
  (A = Math.trunc(A)) < 0 ? (A += e) < 0 && (A = 0) : A > e && (A = e), (t = t === void 0 ? e : Math.trunc(t)) < 0 ? (t += e) < 0 && (t = 0) : t > e && (t = e), t < A && (t = A);
  const i = this.subarray(A, t);
  return Object.setPrototypeOf(i, mt.prototype), i;
}, mt.prototype.readUintLE = mt.prototype.readUIntLE = function(A, t, e) {
  A >>>= 0, t >>>= 0, e || te(A, t, this.length);
  let i = this[A], s = 1, n = 0;
  for (; ++n < t && (s *= 256); ) i += this[A + n] * s;
  return i;
}, mt.prototype.readUintBE = mt.prototype.readUIntBE = function(A, t, e) {
  A >>>= 0, t >>>= 0, e || te(A, t, this.length);
  let i = this[A + --t], s = 1;
  for (; t > 0 && (s *= 256); ) i += this[A + --t] * s;
  return i;
}, mt.prototype.readUint8 = mt.prototype.readUInt8 = function(A, t) {
  return A >>>= 0, t || te(A, 1, this.length), this[A];
}, mt.prototype.readUint16LE = mt.prototype.readUInt16LE = function(A, t) {
  return A >>>= 0, t || te(A, 2, this.length), this[A] | this[A + 1] << 8;
}, mt.prototype.readUint16BE = mt.prototype.readUInt16BE = function(A, t) {
  return A >>>= 0, t || te(A, 2, this.length), this[A] << 8 | this[A + 1];
}, mt.prototype.readUint32LE = mt.prototype.readUInt32LE = function(A, t) {
  return A >>>= 0, t || te(A, 4, this.length), (this[A] | this[A + 1] << 8 | this[A + 2] << 16) + 16777216 * this[A + 3];
}, mt.prototype.readUint32BE = mt.prototype.readUInt32BE = function(A, t) {
  return A >>>= 0, t || te(A, 4, this.length), 16777216 * this[A] + (this[A + 1] << 16 | this[A + 2] << 8 | this[A + 3]);
}, mt.prototype.readBigUInt64LE = cs((function(A) {
  va(A >>>= 0, "offset");
  const t = this[A], e = this[A + 7];
  t !== void 0 && e !== void 0 || Hn(A, this.length - 8);
  const i = t + 256 * this[++A] + 65536 * this[++A] + this[++A] * 2 ** 24, s = this[++A] + 256 * this[++A] + 65536 * this[++A] + e * 2 ** 24;
  return BigInt(i) + (BigInt(s) << BigInt(32));
})), mt.prototype.readBigUInt64BE = cs((function(A) {
  va(A >>>= 0, "offset");
  const t = this[A], e = this[A + 7];
  t !== void 0 && e !== void 0 || Hn(A, this.length - 8);
  const i = t * 2 ** 24 + 65536 * this[++A] + 256 * this[++A] + this[++A], s = this[++A] * 2 ** 24 + 65536 * this[++A] + 256 * this[++A] + e;
  return (BigInt(i) << BigInt(32)) + BigInt(s);
})), mt.prototype.readIntLE = function(A, t, e) {
  A >>>= 0, t >>>= 0, e || te(A, t, this.length);
  let i = this[A], s = 1, n = 0;
  for (; ++n < t && (s *= 256); ) i += this[A + n] * s;
  return s *= 128, i >= s && (i -= Math.pow(2, 8 * t)), i;
}, mt.prototype.readIntBE = function(A, t, e) {
  A >>>= 0, t >>>= 0, e || te(A, t, this.length);
  let i = t, s = 1, n = this[A + --i];
  for (; i > 0 && (s *= 256); ) n += this[A + --i] * s;
  return s *= 128, n >= s && (n -= Math.pow(2, 8 * t)), n;
}, mt.prototype.readInt8 = function(A, t) {
  return A >>>= 0, t || te(A, 1, this.length), 128 & this[A] ? -1 * (255 - this[A] + 1) : this[A];
}, mt.prototype.readInt16LE = function(A, t) {
  A >>>= 0, t || te(A, 2, this.length);
  const e = this[A] | this[A + 1] << 8;
  return 32768 & e ? 4294901760 | e : e;
}, mt.prototype.readInt16BE = function(A, t) {
  A >>>= 0, t || te(A, 2, this.length);
  const e = this[A + 1] | this[A] << 8;
  return 32768 & e ? 4294901760 | e : e;
}, mt.prototype.readInt32LE = function(A, t) {
  return A >>>= 0, t || te(A, 4, this.length), this[A] | this[A + 1] << 8 | this[A + 2] << 16 | this[A + 3] << 24;
}, mt.prototype.readInt32BE = function(A, t) {
  return A >>>= 0, t || te(A, 4, this.length), this[A] << 24 | this[A + 1] << 16 | this[A + 2] << 8 | this[A + 3];
}, mt.prototype.readBigInt64LE = cs((function(A) {
  va(A >>>= 0, "offset");
  const t = this[A], e = this[A + 7];
  t !== void 0 && e !== void 0 || Hn(A, this.length - 8);
  const i = this[A + 4] + 256 * this[A + 5] + 65536 * this[A + 6] + (e << 24);
  return (BigInt(i) << BigInt(32)) + BigInt(t + 256 * this[++A] + 65536 * this[++A] + this[++A] * 2 ** 24);
})), mt.prototype.readBigInt64BE = cs((function(A) {
  va(A >>>= 0, "offset");
  const t = this[A], e = this[A + 7];
  t !== void 0 && e !== void 0 || Hn(A, this.length - 8);
  const i = (t << 24) + 65536 * this[++A] + 256 * this[++A] + this[++A];
  return (BigInt(i) << BigInt(32)) + BigInt(this[++A] * 2 ** 24 + 65536 * this[++A] + 256 * this[++A] + e);
})), mt.prototype.readFloatLE = function(A, t) {
  return A >>>= 0, t || te(A, 4, this.length), _r(this, A, !0, 23, 4);
}, mt.prototype.readFloatBE = function(A, t) {
  return A >>>= 0, t || te(A, 4, this.length), _r(this, A, !1, 23, 4);
}, mt.prototype.readDoubleLE = function(A, t) {
  return A >>>= 0, t || te(A, 8, this.length), _r(this, A, !0, 52, 8);
}, mt.prototype.readDoubleBE = function(A, t) {
  return A >>>= 0, t || te(A, 8, this.length), _r(this, A, !1, 52, 8);
}, mt.prototype.writeUintLE = mt.prototype.writeUIntLE = function(A, t, e, i) {
  A = +A, t >>>= 0, e >>>= 0, !i && Se(this, A, t, e, Math.pow(2, 8 * e) - 1, 0);
  let s = 1, n = 0;
  for (this[t] = 255 & A; ++n < e && (s *= 256); ) this[t + n] = A / s & 255;
  return t + e;
}, mt.prototype.writeUintBE = mt.prototype.writeUIntBE = function(A, t, e, i) {
  A = +A, t >>>= 0, e >>>= 0, !i && Se(this, A, t, e, Math.pow(2, 8 * e) - 1, 0);
  let s = e - 1, n = 1;
  for (this[t + s] = 255 & A; --s >= 0 && (n *= 256); ) this[t + s] = A / n & 255;
  return t + e;
}, mt.prototype.writeUint8 = mt.prototype.writeUInt8 = function(A, t, e) {
  return A = +A, t >>>= 0, e || Se(this, A, t, 1, 255, 0), this[t] = 255 & A, t + 1;
}, mt.prototype.writeUint16LE = mt.prototype.writeUInt16LE = function(A, t, e) {
  return A = +A, t >>>= 0, e || Se(this, A, t, 2, 65535, 0), this[t] = 255 & A, this[t + 1] = A >>> 8, t + 2;
}, mt.prototype.writeUint16BE = mt.prototype.writeUInt16BE = function(A, t, e) {
  return A = +A, t >>>= 0, e || Se(this, A, t, 2, 65535, 0), this[t] = A >>> 8, this[t + 1] = 255 & A, t + 2;
}, mt.prototype.writeUint32LE = mt.prototype.writeUInt32LE = function(A, t, e) {
  return A = +A, t >>>= 0, e || Se(this, A, t, 4, 4294967295, 0), this[t + 3] = A >>> 24, this[t + 2] = A >>> 16, this[t + 1] = A >>> 8, this[t] = 255 & A, t + 4;
}, mt.prototype.writeUint32BE = mt.prototype.writeUInt32BE = function(A, t, e) {
  return A = +A, t >>>= 0, e || Se(this, A, t, 4, 4294967295, 0), this[t] = A >>> 24, this[t + 1] = A >>> 16, this[t + 2] = A >>> 8, this[t + 3] = 255 & A, t + 4;
}, mt.prototype.writeBigUInt64LE = cs((function(A, t = 0) {
  return X0(this, A, t, BigInt(0), BigInt("0xffffffffffffffff"));
})), mt.prototype.writeBigUInt64BE = cs((function(A, t = 0) {
  return z0(this, A, t, BigInt(0), BigInt("0xffffffffffffffff"));
})), mt.prototype.writeIntLE = function(A, t, e, i) {
  if (A = +A, t >>>= 0, !i) {
    const r = Math.pow(2, 8 * e - 1);
    Se(this, A, t, e, r - 1, -r);
  }
  let s = 0, n = 1, o = 0;
  for (this[t] = 255 & A; ++s < e && (n *= 256); ) A < 0 && o === 0 && this[t + s - 1] !== 0 && (o = 1), this[t + s] = Math.trunc(A / n) - o & 255;
  return t + e;
}, mt.prototype.writeIntBE = function(A, t, e, i) {
  if (A = +A, t >>>= 0, !i) {
    const r = Math.pow(2, 8 * e - 1);
    Se(this, A, t, e, r - 1, -r);
  }
  let s = e - 1, n = 1, o = 0;
  for (this[t + s] = 255 & A; --s >= 0 && (n *= 256); ) A < 0 && o === 0 && this[t + s + 1] !== 0 && (o = 1), this[t + s] = Math.trunc(A / n) - o & 255;
  return t + e;
}, mt.prototype.writeInt8 = function(A, t, e) {
  return A = +A, t >>>= 0, e || Se(this, A, t, 1, 127, -128), A < 0 && (A = 255 + A + 1), this[t] = 255 & A, t + 1;
}, mt.prototype.writeInt16LE = function(A, t, e) {
  return A = +A, t >>>= 0, e || Se(this, A, t, 2, 32767, -32768), this[t] = 255 & A, this[t + 1] = A >>> 8, t + 2;
}, mt.prototype.writeInt16BE = function(A, t, e) {
  return A = +A, t >>>= 0, e || Se(this, A, t, 2, 32767, -32768), this[t] = A >>> 8, this[t + 1] = 255 & A, t + 2;
}, mt.prototype.writeInt32LE = function(A, t, e) {
  return A = +A, t >>>= 0, e || Se(this, A, t, 4, 2147483647, -2147483648), this[t] = 255 & A, this[t + 1] = A >>> 8, this[t + 2] = A >>> 16, this[t + 3] = A >>> 24, t + 4;
}, mt.prototype.writeInt32BE = function(A, t, e) {
  return A = +A, t >>>= 0, e || Se(this, A, t, 4, 2147483647, -2147483648), A < 0 && (A = 4294967295 + A + 1), this[t] = A >>> 24, this[t + 1] = A >>> 16, this[t + 2] = A >>> 8, this[t + 3] = 255 & A, t + 4;
}, mt.prototype.writeBigInt64LE = cs((function(A, t = 0) {
  return X0(this, A, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
})), mt.prototype.writeBigInt64BE = cs((function(A, t = 0) {
  return z0(this, A, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
})), mt.prototype.writeFloatLE = function(A, t, e) {
  return $0(this, A, t, !0, e);
}, mt.prototype.writeFloatBE = function(A, t, e) {
  return $0(this, A, t, !1, e);
}, mt.prototype.writeDoubleLE = function(A, t, e) {
  return tC(this, A, t, !0, e);
}, mt.prototype.writeDoubleBE = function(A, t, e) {
  return tC(this, A, t, !1, e);
}, mt.prototype.copy = function(A, t, e, i) {
  if (!mt.isBuffer(A)) throw new TypeError("argument should be a Buffer");
  if (e || (e = 0), i || i === 0 || (i = this.length), t >= A.length && (t = A.length), t || (t = 0), i > 0 && i < e && (i = e), i === e || A.length === 0 || this.length === 0) return 0;
  if (t < 0) throw new RangeError("targetStart out of bounds");
  if (e < 0 || e >= this.length) throw new RangeError("Index out of range");
  if (i < 0) throw new RangeError("sourceEnd out of bounds");
  i > this.length && (i = this.length), A.length - t < i - e && (i = A.length - t + e);
  const s = i - e;
  return this === A && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, e, i) : Uint8Array.prototype.set.call(A, this.subarray(e, i), t), s;
}, mt.prototype.fill = function(A, t, e, i) {
  if (typeof A == "string") {
    if (typeof t == "string" ? (i = t, t = 0, e = this.length) : typeof e == "string" && (i = e, e = this.length), i !== void 0 && typeof i != "string") throw new TypeError("encoding must be a string");
    if (typeof i == "string" && !mt.isEncoding(i)) throw new TypeError("Unknown encoding: " + i);
    if (A.length === 1) {
      const n = A.charCodeAt(0);
      (i === "utf8" && n < 128 || i === "latin1") && (A = n);
    }
  } else typeof A == "number" ? A &= 255 : typeof A == "boolean" && (A = Number(A));
  if (t < 0 || this.length < t || this.length < e) throw new RangeError("Out of range index");
  if (e <= t) return this;
  let s;
  if (t >>>= 0, e = e === void 0 ? this.length : e >>> 0, A || (A = 0), typeof A == "number") for (s = t; s < e; ++s) this[s] = A;
  else {
    const n = mt.isBuffer(A) ? A : mt.from(A, i), o = n.length;
    if (o === 0) throw new TypeError('The value "' + A + '" is invalid for argument "value"');
    for (s = 0; s < e - t; ++s) this[s + t] = n[s % o];
  }
  return this;
};
const Ka = {};
function Hc(A, t, e) {
  Ka[A] = class extends e {
    constructor() {
      super(), Object.defineProperty(this, "message", { value: Reflect.apply(t, this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${A}]`, this.stack, delete this.name;
    }
    get code() {
      return A;
    }
    set code(i) {
      Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: i, writable: !0 });
    }
    toString() {
      return `${this.name} [${A}]: ${this.message}`;
    }
  };
}
function AC(A) {
  let t = "", e = A.length;
  const i = A[0] === "-" ? 1 : 0;
  for (; e >= i + 4; e -= 3) t = `_${A.slice(e - 3, e)}${t}`;
  return `${A.slice(0, e)}${t}`;
}
function Wd(A, t, e, i, s, n) {
  if (A > e || A < t) {
    const o = typeof t == "bigint" ? "n" : "";
    let r;
    throw r = t === 0 || t === BigInt(0) ? `>= 0${o} and < 2${o} ** ${8 * (n + 1)}${o}` : `>= -(2${o} ** ${8 * (n + 1) - 1}${o}) and < 2 ** ${8 * (n + 1) - 1}${o}`, new Ka.ERR_OUT_OF_RANGE("value", r, A);
  }
  (function(o, r, c) {
    va(r, "offset"), o[r] !== void 0 && o[r + c] !== void 0 || Hn(r, o.length - (c + 1));
  })(i, s, n);
}
function va(A, t) {
  if (typeof A != "number") throw new Ka.ERR_INVALID_ARG_TYPE(t, "number", A);
}
function Hn(A, t, e) {
  throw Math.floor(A) !== A ? (va(A, e), new Ka.ERR_OUT_OF_RANGE("offset", "an integer", A)) : t < 0 ? new Ka.ERR_BUFFER_OUT_OF_BOUNDS() : new Ka.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${t}`, A);
}
Hc("ERR_BUFFER_OUT_OF_BOUNDS", (function(A) {
  return A ? `${A} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
}), RangeError), Hc("ERR_INVALID_ARG_TYPE", (function(A, t) {
  return `The "${A}" argument must be of type number. Received type ${typeof t}`;
}), TypeError), Hc("ERR_OUT_OF_RANGE", (function(A, t, e) {
  let i = `The value of "${A}" is out of range.`, s = e;
  return Number.isInteger(e) && Math.abs(e) > 2 ** 32 ? s = AC(String(e)) : typeof e == "bigint" && (s = String(e), (e > BigInt(2) ** BigInt(32) || e < -(BigInt(2) ** BigInt(32))) && (s = AC(s)), s += "n"), i += ` It must be ${t}. Received ${s}`, i;
}), RangeError);
const a9 = /[^\w+/-]/g;
function mh(A, t) {
  let e;
  t = t || Number.POSITIVE_INFINITY;
  const i = A.length;
  let s = null;
  const n = [];
  for (let o = 0; o < i; ++o) {
    if (e = A.charCodeAt(o), e > 55295 && e < 57344) {
      if (!s) {
        if (e > 56319) {
          (t -= 3) > -1 && n.push(239, 191, 189);
          continue;
        }
        if (o + 1 === i) {
          (t -= 3) > -1 && n.push(239, 191, 189);
          continue;
        }
        s = e;
        continue;
      }
      if (e < 56320) {
        (t -= 3) > -1 && n.push(239, 191, 189), s = e;
        continue;
      }
      e = 65536 + (s - 55296 << 10 | e - 56320);
    } else s && (t -= 3) > -1 && n.push(239, 191, 189);
    if (s = null, e < 128) {
      if ((t -= 1) < 0) break;
      n.push(e);
    } else if (e < 2048) {
      if ((t -= 2) < 0) break;
      n.push(e >> 6 | 192, 63 & e | 128);
    } else if (e < 65536) {
      if ((t -= 3) < 0) break;
      n.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128);
    } else {
      if (!(e < 1114112)) throw new Error("Invalid code point");
      if ((t -= 4) < 0) break;
      n.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128);
    }
  }
  return n;
}
function jd(A) {
  return Op((function(t) {
    if ((t = (t = t.split("=")[0]).trim().replace(a9, "")).length < 2) return "";
    for (; t.length % 4 != 0; ) t += "=";
    return t;
  })(A));
}
function lg(A, t, e, i) {
  let s;
  for (s = 0; s < i && !(s + e >= t.length || s >= A.length); ++s) t[s + e] = A[s];
  return s;
}
function Fi(A, t) {
  return A instanceof t || A != null && A.constructor != null && A.constructor.name != null && A.constructor.name === t.name;
}
function Cl(A) {
  return A != A;
}
const n9 = (function() {
  const A = "0123456789abcdef", t = Array.from({ length: 256 });
  for (let e = 0; e < 16; ++e) {
    const i = 16 * e;
    for (let s = 0; s < 16; ++s) t[i + s] = A[e] + A[s];
  }
  return t;
})();
function cs(A) {
  return typeof BigInt > "u" ? r9 : A;
}
function r9() {
  throw new Error("BigInt not supported");
}
const Pn = globalThis.Buffer || mt;
Lt("buffer.resolveObjectURL"), Lt("buffer.transcode"), Lt("buffer.isUtf8"), Lt("buffer.isAscii");
const ul = globalThis.Writable || class extends Yd {
  __unenv__ = !0;
  writable = !0;
  writableEnded = !1;
  writableFinished = !1;
  writableHighWaterMark = 0;
  writableLength = 0;
  writableObjectMode = !1;
  writableCorked = 0;
  closed = !1;
  errored = null;
  writableNeedDrain = !1;
  destroyed = !1;
  _data;
  _encoding = "utf-8";
  constructor(A) {
    super();
  }
  pipe(A, t) {
    return {};
  }
  _write(A, t, e) {
    if (this.writableEnded) e && e();
    else {
      if (this._data === void 0) this._data = A;
      else {
        const i = typeof this._data == "string" ? Pn.from(this._data, this._encoding || t || "utf8") : this._data, s = typeof A == "string" ? Pn.from(A, t || this._encoding || "utf8") : A;
        this._data = Pn.concat([i, s]);
      }
      this._encoding = t, e && e();
    }
  }
  _writev(A, t) {
  }
  _destroy(A, t) {
  }
  _final(A) {
  }
  write(A, t, e) {
    const i = typeof t == "string" ? this._encoding : "utf-8", s = typeof t == "function" ? t : typeof e == "function" ? e : void 0;
    return this._write(A, i, s), !0;
  }
  setDefaultEncoding(A) {
    return this;
  }
  end(A, t, e) {
    const i = typeof A == "function" ? A : typeof t == "function" ? t : typeof e == "function" ? e : void 0;
    if (this.writableEnded) return i && i(), this;
    const s = A === i ? void 0 : A;
    if (s) {
      const n = t === i ? void 0 : t;
      this.write(s, n, i);
    }
    return this.writableEnded = !0, this.writableFinished = !0, this.emit("close"), this.emit("finish"), this;
  }
  cork() {
  }
  uncork() {
  }
  destroy(A) {
    return this.destroyed = !0, delete this._data, this.removeAllListeners(), this;
  }
  compose(A, t) {
    throw new Error("[h3] Method not implemented.");
  }
}, Jc = class {
  allowHalfOpen = !0;
  _destroy;
  constructor(A = new ll(), t = new ul()) {
    Object.assign(this, A), Object.assign(this, t), this._destroy = /* @__PURE__ */ (function(...e) {
      return function(...i) {
        for (const s of e) s(...i);
      };
    })(A._destroy, t._destroy);
  }
};
function o9() {
  return Object.assign(Jc.prototype, ll.prototype), Object.assign(Jc.prototype, ul.prototype), Jc;
}
const g9 = o9(), c9 = globalThis.Duplex || g9;
class h9 extends c9 {
  __unenv__ = !0;
  bufferSize = 0;
  bytesRead = 0;
  bytesWritten = 0;
  connecting = !1;
  destroyed = !1;
  pending = !1;
  localAddress = "";
  localPort = 0;
  remoteAddress = "";
  remoteFamily = "";
  remotePort = 0;
  autoSelectFamilyAttemptedAddresses = [];
  readyState = "readOnly";
  constructor(t) {
    super();
  }
  write(t, e, i) {
    return !1;
  }
  connect(t, e, i) {
    return this;
  }
  end(t, e, i) {
    return this;
  }
  setEncoding(t) {
    return this;
  }
  pause() {
    return this;
  }
  resume() {
    return this;
  }
  setTimeout(t, e) {
    return this;
  }
  setNoDelay(t) {
    return this;
  }
  setKeepAlive(t, e) {
    return this;
  }
  address() {
    return {};
  }
  unref() {
    return this;
  }
  ref() {
    return this;
  }
  destroySoon() {
    this.destroy();
  }
  resetAndDestroy() {
    const t = new Error("ERR_SOCKET_CLOSED");
    return t.code = "ERR_SOCKET_CLOSED", this.destroy(t), this;
  }
}
class Zd extends ll {
  __unenv__ = {};
  aborted = !1;
  httpVersion = "1.1";
  httpVersionMajor = 1;
  httpVersionMinor = 1;
  complete = !0;
  connection;
  socket;
  headers = {};
  trailers = {};
  method = "GET";
  url = "/";
  statusCode = 200;
  statusMessage = "";
  closed = !1;
  errored = null;
  readable = !1;
  constructor(t) {
    super(), this.socket = this.connection = t || new h9();
  }
  get rawHeaders() {
    return (function(t) {
      const e = [];
      for (const i in t) if (Array.isArray(t[i])) for (const s of t[i]) e.push(i, s);
      else e.push(i, t[i]);
      return e;
    })(this.headers);
  }
  get rawTrailers() {
    return [];
  }
  setTimeout(t, e) {
    return this;
  }
  get headersDistinct() {
    return eC(this.headers);
  }
  get trailersDistinct() {
    return eC(this.trailers);
  }
}
function eC(A) {
  const t = {};
  for (const [e, i] of Object.entries(A)) e && (t[e] = (Array.isArray(i) ? i : [i]).filter(Boolean));
  return t;
}
class Vd extends ul {
  __unenv__ = !0;
  statusCode = 200;
  statusMessage = "";
  upgrading = !1;
  chunkedEncoding = !1;
  shouldKeepAlive = !1;
  useChunkedEncodingByDefault = !1;
  sendDate = !1;
  finished = !1;
  headersSent = !1;
  strictContentLength = !1;
  connection = null;
  socket = null;
  req;
  _headers = {};
  constructor(t) {
    super(), this.req = t;
  }
  assignSocket(t) {
    t._httpMessage = this, this.socket = t, this.connection = t, this.emit("socket", t), this._flush();
  }
  _flush() {
    this.flushHeaders();
  }
  detachSocket(t) {
  }
  writeContinue(t) {
  }
  writeHead(t, e, i) {
    t && (this.statusCode = t), typeof e == "string" && (this.statusMessage = e, e = void 0);
    const s = i || e;
    if (s && !Array.isArray(s)) for (const n in s) this.setHeader(n, s[n]);
    return this.headersSent = !0, this;
  }
  writeProcessing() {
  }
  setTimeout(t, e) {
    return this;
  }
  appendHeader(t, e) {
    t = t.toLowerCase();
    const i = this._headers[t], s = [...Array.isArray(i) ? i : [i], ...Array.isArray(e) ? e : [e]].filter(Boolean);
    return this._headers[t] = s.length > 1 ? s : s[0], this;
  }
  setHeader(t, e) {
    return this._headers[t.toLowerCase()] = e, this;
  }
  getHeader(t) {
    return this._headers[t.toLowerCase()];
  }
  getHeaders() {
    return this._headers;
  }
  getHeaderNames() {
    return Object.keys(this._headers);
  }
  hasHeader(t) {
    return t.toLowerCase() in this._headers;
  }
  removeHeader(t) {
    delete this._headers[t.toLowerCase()];
  }
  addTrailers(t) {
  }
  flushHeaders() {
  }
  writeEarlyHints(t, e) {
    typeof e == "function" && e();
  }
}
const Xd = Lt("http.createServer"), zd = Lt("http.request"), $d = Lt("http.get"), tQ = ni.__createMock__("http.Server"), AQ = ni.__createMock__("http.OutgoingMessage"), eQ = ni.__createMock__("http.ClientRequest"), Bl = ni.__createMock__("http.Agent"), iQ = new Bl(), sQ = Lt("http.validateHeaderName"), aQ = Lt("http.validateHeaderValue"), nQ = Lt("http.setMaxIdleHTTPParsers"), l9 = { ...Pp, IncomingMessage: Zd, ServerResponse: Vd, createServer: Xd, request: zd, get: $d, Server: tQ, OutgoingMessage: AQ, ClientRequest: eQ, Agent: Bl, globalAgent: iQ, validateHeaderName: sQ, validateHeaderValue: aQ, setMaxIdleHTTPParsers: nQ }, I9 = Object.freeze({ __proto__: null, Agent: Bl, ClientRequest: eQ, IncomingMessage: Zd, METHODS: Md, OutgoingMessage: AQ, STATUS_CODES: Ld, Server: tQ, ServerResponse: Vd, createServer: Xd, default: l9, get: $d, globalAgent: iQ, maxHeaderSize: 16384, request: zd, setMaxIdleHTTPParsers: nQ, validateHeaderName: sQ, validateHeaderValue: aQ });
function C9(A) {
  return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
}
var iC, uo = { exports: {} }, u9 = uo.exports;
function B9() {
  if (iC) return uo.exports;
  iC = 1, Object.defineProperty(u9, "__esModule", { value: !0 });
  const A = function() {
  };
  return uo.exports = (function t(e, i = {}) {
    A.prototype.name = e;
    const s = {};
    return new Proxy(A, { get: (n, o) => o === "caller" ? null : o === "__createMock__" ? t : o === "__unenv__" || (o in i ? i[o] : s[o] = s[o] || t(`${e}.${o.toString()}`)), apply: (n, o, r) => t(`${e}()`), construct: (n, o, r) => t(`[${e}]`), enumerate: () => [] });
  })("mock"), uo.exports;
}
var sC = B9();
const d9 = Up({ __proto__: null, default: C9(sC) }, [sC]), As = globalThis.URL, rQ = globalThis.URLSearchParams, oQ = function(A, t, e) {
  const i = new As(A);
  if (!t && !e) return i;
  throw new Error("parseQueryString and slashesDenoteHost are unsupported");
}, gQ = function(A, t) {
  const e = new As(t, new As(A, "resolve://"));
  if (e.protocol === "resolve:") {
    const { pathname: i, search: s, hash: n } = e;
    return i + s + n;
  }
  return e.toString();
}, cQ = function(A) {
  return { protocol: A.protocol, hostname: A.hostname, hash: A.hash, search: A.search, pathname: A.pathname, path: A.pathname + A.search || "", href: A.href, port: A.port, auth: A.username && A.username + A.password ? ":" + A.password : "" };
}, hQ = function(A, t) {
  let e;
  if (typeof A == "string") e = new As(A);
  else {
    if (!(A instanceof As)) throw new TypeError("format urlObject is not supported");
    e = A;
  }
  return t && (t.auth === !1 && (e.username = "", e.password = ""), t.fragment === !1 && (e.hash = ""), t.search === !1 && (e.search = "")), e.toString();
}, lQ = function(A) {
  return A;
}, IQ = function(A) {
  return A;
}, CQ = function(A) {
  return new As(A);
}, uQ = function(A) {
  return typeof A == "string" && (A = new As(A)), A.pathname;
}, Q9 = { URL: As, URLSearchParams: rQ, domainToASCII: lQ, domainToUnicode: IQ, fileURLToPath: uQ, format: hQ, parse: oQ, pathToFileURL: CQ, resolve: gQ, urlToHttpOptions: cQ }, E9 = Object.freeze({ __proto__: null, URL: As, URLSearchParams: rQ, default: Q9, domainToASCII: lQ, domainToUnicode: IQ, fileURLToPath: uQ, format: hQ, parse: oQ, pathToFileURL: CQ, resolve: gQ, urlToHttpOptions: cQ });
var yh = { d: (A, t) => {
  for (var e in t) yh.o(t, e) && !yh.o(A, e) && Object.defineProperty(A, e, { enumerable: !0, get: t[e] });
}, o: (A, t) => Object.prototype.hasOwnProperty.call(A, t) }, f9 = globalThis.pdfjsWorker = {};
yh.d(f9, { WorkerMessageHandler: () => fr });
const p9 = typeof document > "u", Ci = [1, 0, 0, 1, 0, 0], aa = [1e-3, 0, 0, 1e-3, 0, 0], na = 1.35, aC = 0.35, nC = 0.25925925925925924, rC = 1, Ro = 2, oC = 4, gC = 8, BQ = 16, m9 = 64, y9 = 128, w9 = 256, dQ = "pdfjs_internal_editor_", cC = 3, hC = 9, lC = 13, IC = 15, CC = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 }, b9 = 0, D9 = 4, xo = 1, _n = 2, ds = 3, k9 = 1, S9 = 2, F9 = 3, R9 = 4, x9 = 5, N9 = 6, G9 = 7, v9 = 8, M9 = 9, L9 = 10, U9 = 11, H9 = 12, J9 = 13, Y9 = 14, T9 = 15, K9 = 16, q9 = 17, P9 = 20, QQ = "Group", _9 = "R", Or = 1, No = 2, O9 = 4, W9 = 16, wh = 32, j9 = 128, Z9 = 512, V9 = 1, X9 = 2, uC = 4096, bh = 8192, BC = 32768, Yc = 65536, z9 = 131072, $9 = 1048576, tm = 2097152, Am = 8388608, em = 16777216, dC = 1, im = 2, sm = 3, am = 4, nm = 5, EQ = { E: "Mouse Enter", X: "Mouse Exit", D: "Mouse Down", U: "Mouse Up", Fo: "Focus", Bl: "Blur", PO: "PageOpen", PC: "PageClose", PV: "PageVisible", PI: "PageInvisible", K: "Keystroke", F: "Format", V: "Validate", C: "Calculate" }, rm = { WC: "WillClose", WS: "WillSave", DS: "DidSave", WP: "WillPrint", DP: "DidPrint" }, om = { O: "PageOpen", C: "PageClose" }, fQ = 1, Dh = 5, pQ = 0, mQ = 1, gm = 1, cm = 2, hm = 3, lm = 4, Im = 5, Cm = 6, yQ = 7, um = 8, Ma = 9, yi = 10, Te = 11, Qs = 12, On = 13, Bo = 14, wQ = 15, bQ = 16, DQ = 17, kQ = 18, Qo = 19, Bm = 20, dm = 21, QC = 22, Qm = 23, Em = 24, fm = 25, pm = 26, mm = 27, EC = 28, ym = 29, wm = 30, er = 31, ir = 32, kh = 33, Sh = 34, SQ = 35, FQ = 36, xs = 37, RQ = 38, xQ = 39, NQ = 40, GQ = 41, sr = 42, Eo = 43, Pi = 44, Go = 45, vo = 46, Mo = 47, bm = 48, Fh = 49, dl = 50, Ig = 51, Ql = 52, Lo = 53, Cg = 54, Uo = 55, El = 56, yr = 57, ta = 58, _i = 59, fl = 60, wr = 61, Ho = 62, Dm = 63, km = 64, vQ = 65, Rh = 66, MQ = 67, LQ = 68, UQ = 69, wi = 70, Wa = 71, HQ = 72, JQ = 73, Sm = 74, Fm = 75, Rm = 76, xm = 77, YQ = 80, TQ = 81, bs = 83, Nm = 84, Aa = 85, Jo = 86, KQ = 87, Gm = 88, vm = 89, fC = 90, pC = 91, Mm = 92, Lm = 93, Um = 1, Hm = 2;
let ug = fQ;
function Jm() {
  return ug;
}
function tA(A) {
  ug >= Dh && console.log(`Info: ${A}`);
}
function O(A) {
  ug >= fQ && console.log(`Warning: ${A}`);
}
function oA(A) {
  throw new Error(A);
}
function pe(A, t) {
  A || oA(t);
}
function Yo(A, t = null, e = null) {
  if (!A) return null;
  try {
    if (e && typeof A == "string" && (e.addDefaultProtocol && A.startsWith("www.") && A.match(/\./g)?.length >= 2 && (A = `http://${A}`), e.tryConvertEncoding))
      try {
        A = ar(A);
      } catch {
      }
    const i = t ? new URL(A, t) : new URL(A);
    if ((function(s) {
      switch (s?.protocol) {
        case "http:":
        case "https:":
        case "ftp:":
        case "mailto:":
        case "tel:":
          return !0;
        default:
          return !1;
      }
    })(i)) return i;
  } catch {
  }
  return null;
}
function bt(A, t, e, i = !1) {
  return Object.defineProperty(A, t, { value: e, enumerable: !i, configurable: !0, writable: !1 }), e;
}
const de = (function() {
  function A(t, e) {
    this.message = t, this.name = e;
  }
  return A.prototype = new Error(), A.constructor = A, A;
})();
class To extends de {
  constructor(t, e) {
    super(t, "PasswordException"), this.code = e;
  }
}
class Ko extends de {
  constructor(t, e) {
    super(t, "UnknownErrorException"), this.details = e;
  }
}
class qo extends de {
  constructor(t) {
    super(t, "InvalidPDFException");
  }
}
class qQ extends de {
  constructor(t) {
    super(t, "MissingPDFException");
  }
}
class PQ extends de {
  constructor(t, e) {
    super(t, "UnexpectedResponseException"), this.status = e;
  }
}
class Ct extends de {
  constructor(t) {
    super(t, "FormatError");
  }
}
class fe extends de {
  constructor(t) {
    super(t, "AbortException");
  }
}
function Re(A) {
  typeof A == "object" && A?.length !== void 0 || oA("Invalid argument for bytesToString");
  const t = A.length, e = 8192;
  if (t < e) return String.fromCharCode.apply(null, A);
  const i = [];
  for (let s = 0; s < t; s += e) {
    const n = Math.min(s + e, t), o = A.subarray(s, n);
    i.push(String.fromCharCode.apply(null, o));
  }
  return i.join("");
}
function re(A) {
  typeof A != "string" && oA("Invalid argument for stringToBytes");
  const t = A.length, e = new Uint8Array(t);
  for (let i = 0; i < t; ++i) e[i] = 255 & A.charCodeAt(i);
  return e;
}
function ne(A) {
  return String.fromCharCode(A >> 24 & 255, A >> 16 & 255, A >> 8 & 255, 255 & A);
}
function _Q(A) {
  return Object.keys(A).length;
}
class es {
  static get isLittleEndian() {
    return bt(this, "isLittleEndian", (function() {
      const t = new Uint8Array(4);
      return t[0] = 1, new Uint32Array(t.buffer, 0, 1)[0] === 1;
    })());
  }
  static get isEvalSupported() {
    return bt(this, "isEvalSupported", (function() {
      try {
        return new Function(""), !0;
      } catch {
        return !1;
      }
    })());
  }
  static get isOffscreenCanvasSupported() {
    return bt(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
  }
  static get platform() {
    return typeof navigator < "u" && typeof navigator?.platform == "string" ? bt(this, "platform", { isMac: navigator.platform.includes("Mac") }) : bt(this, "platform", { isMac: !1 });
  }
  static get isCSSRoundSupported() {
    return bt(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
  }
}
const Tc = Array.from(Array(256).keys(), ((A) => A.toString(16).padStart(2, "0")));
class PA {
  static makeHexColor(t, e, i) {
    return `#${Tc[t]}${Tc[e]}${Tc[i]}`;
  }
  static scaleMinMax(t, e) {
    let i;
    t[0] ? (t[0] < 0 && (i = e[0], e[0] = e[2], e[2] = i), e[0] *= t[0], e[2] *= t[0], t[3] < 0 && (i = e[1], e[1] = e[3], e[3] = i), e[1] *= t[3], e[3] *= t[3]) : (i = e[0], e[0] = e[1], e[1] = i, i = e[2], e[2] = e[3], e[3] = i, t[1] < 0 && (i = e[1], e[1] = e[3], e[3] = i), e[1] *= t[1], e[3] *= t[1], t[2] < 0 && (i = e[0], e[0] = e[2], e[2] = i), e[0] *= t[2], e[2] *= t[2]), e[0] += t[4], e[1] += t[5], e[2] += t[4], e[3] += t[5];
  }
  static transform(t, e) {
    return [t[0] * e[0] + t[2] * e[1], t[1] * e[0] + t[3] * e[1], t[0] * e[2] + t[2] * e[3], t[1] * e[2] + t[3] * e[3], t[0] * e[4] + t[2] * e[5] + t[4], t[1] * e[4] + t[3] * e[5] + t[5]];
  }
  static applyTransform(t, e) {
    return [t[0] * e[0] + t[1] * e[2] + e[4], t[0] * e[1] + t[1] * e[3] + e[5]];
  }
  static applyInverseTransform(t, e) {
    const i = e[0] * e[3] - e[1] * e[2];
    return [(t[0] * e[3] - t[1] * e[2] + e[2] * e[5] - e[4] * e[3]) / i, (-t[0] * e[1] + t[1] * e[0] + e[4] * e[1] - e[5] * e[0]) / i];
  }
  static getAxialAlignedBoundingBox(t, e) {
    const i = this.applyTransform(t, e), s = this.applyTransform(t.slice(2, 4), e), n = this.applyTransform([t[0], t[3]], e), o = this.applyTransform([t[2], t[1]], e);
    return [Math.min(i[0], s[0], n[0], o[0]), Math.min(i[1], s[1], n[1], o[1]), Math.max(i[0], s[0], n[0], o[0]), Math.max(i[1], s[1], n[1], o[1])];
  }
  static inverseTransform(t) {
    const e = t[0] * t[3] - t[1] * t[2];
    return [t[3] / e, -t[1] / e, -t[2] / e, t[0] / e, (t[2] * t[5] - t[4] * t[3]) / e, (t[4] * t[1] - t[5] * t[0]) / e];
  }
  static singularValueDecompose2dScale(t) {
    const e = [t[0], t[2], t[1], t[3]], i = t[0] * e[0] + t[1] * e[2], s = t[0] * e[1] + t[1] * e[3], n = t[2] * e[0] + t[3] * e[2], o = t[2] * e[1] + t[3] * e[3], r = (i + o) / 2, c = Math.sqrt((i + o) ** 2 - 4 * (i * o - n * s)) / 2, h = r + c || 1, I = r - c || 1;
    return [Math.sqrt(h), Math.sqrt(I)];
  }
  static normalizeRect(t) {
    const e = t.slice(0);
    return t[0] > t[2] && (e[0] = t[2], e[2] = t[0]), t[1] > t[3] && (e[1] = t[3], e[3] = t[1]), e;
  }
  static intersect(t, e) {
    const i = Math.max(Math.min(t[0], t[2]), Math.min(e[0], e[2])), s = Math.min(Math.max(t[0], t[2]), Math.max(e[0], e[2]));
    if (i > s) return null;
    const n = Math.max(Math.min(t[1], t[3]), Math.min(e[1], e[3])), o = Math.min(Math.max(t[1], t[3]), Math.max(e[1], e[3]));
    return n > o ? null : [i, n, s, o];
  }
  static #t(t, e, i, s, n, o, r, c, h, I) {
    if (h <= 0 || h >= 1) return;
    const C = 1 - h, d = h * h, u = d * h, E = C * (C * (C * t + 3 * h * e) + 3 * d * i) + u * s, p = C * (C * (C * n + 3 * h * o) + 3 * d * r) + u * c;
    I[0] = Math.min(I[0], E), I[1] = Math.min(I[1], p), I[2] = Math.max(I[2], E), I[3] = Math.max(I[3], p);
  }
  static #A(t, e, i, s, n, o, r, c, h, I, C, d) {
    if (Math.abs(h) < 1e-12) return void (Math.abs(I) >= 1e-12 && this.#t(t, e, i, s, n, o, r, c, -C / I, d));
    const u = I ** 2 - 4 * C * h;
    if (u < 0) return;
    const E = Math.sqrt(u), p = 2 * h;
    this.#t(t, e, i, s, n, o, r, c, (-I + E) / p, d), this.#t(t, e, i, s, n, o, r, c, (-I - E) / p, d);
  }
  static bezierBoundingBox(t, e, i, s, n, o, r, c, h) {
    return h ? (h[0] = Math.min(h[0], t, r), h[1] = Math.min(h[1], e, c), h[2] = Math.max(h[2], t, r), h[3] = Math.max(h[3], e, c)) : h = [Math.min(t, r), Math.min(e, c), Math.max(t, r), Math.max(e, c)], this.#A(t, i, n, r, e, s, o, c, 3 * (3 * (i - n) - t + r), 6 * (t - 2 * i + n), 3 * (i - t), h), this.#A(t, i, n, r, e, s, o, c, 3 * (3 * (s - o) - e + c), 6 * (e - 2 * s + o), 3 * (s - e), h), h;
  }
}
const Ym = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
function cA(A) {
  if (A[0] >= "ï") {
    let e;
    if (A[0] === "þ" && A[1] === "ÿ" ? (e = "utf-16be", A.length % 2 == 1 && (A = A.slice(0, -1))) : A[0] === "ÿ" && A[1] === "þ" ? (e = "utf-16le", A.length % 2 == 1 && (A = A.slice(0, -1))) : A[0] === "ï" && A[1] === "»" && A[2] === "¿" && (e = "utf-8"), e) try {
      const i = new TextDecoder(e, { fatal: !0 }), s = re(A), n = i.decode(s);
      return n.includes("\x1B") ? n.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "") : n;
    } catch (i) {
      O(`stringToPDFString: "${i}".`);
    }
  }
  const t = [];
  for (let e = 0, i = A.length; e < i; e++) {
    const s = A.charCodeAt(e);
    if (s === 27) {
      for (; ++e < i && A.charCodeAt(e) !== 27; ) ;
      continue;
    }
    const n = Ym[s];
    t.push(n ? String.fromCharCode(n) : A.charAt(e));
  }
  return t.join("");
}
function ar(A) {
  return decodeURIComponent(escape(A));
}
function xh(A) {
  return unescape(encodeURIComponent(A));
}
function ja(A, t) {
  if (A.length !== t.length) return !1;
  for (let e = 0, i = A.length; e < i; e++) if (A[e] !== t[e]) return !1;
  return !0;
}
function Gs(A = /* @__PURE__ */ new Date()) {
  return [A.getUTCFullYear().toString(), (A.getUTCMonth() + 1).toString().padStart(2, "0"), A.getUTCDate().toString().padStart(2, "0"), A.getUTCHours().toString().padStart(2, "0"), A.getUTCMinutes().toString().padStart(2, "0"), A.getUTCSeconds().toString().padStart(2, "0")].join("");
}
let Kc = null, mC = null;
const Tm = 0, OQ = 1, WQ = 2, Km = 3, pl = 4, ml = 5, qm = 6, jQ = 7, Pm = 8, _m = Symbol("CIRCULAR_REF"), Ae = Symbol("EOF");
let ZQ = /* @__PURE__ */ Object.create(null), VQ = /* @__PURE__ */ Object.create(null), fo = /* @__PURE__ */ Object.create(null);
class at {
  constructor(t) {
    this.name = t;
  }
  static get(t) {
    return VQ[t] ||= new at(t);
  }
}
class KA {
  constructor(t) {
    this.cmd = t;
  }
  static get(t) {
    return ZQ[t] ||= new KA(t);
  }
}
const XQ = function() {
  return XQ;
};
class z {
  constructor(t = null) {
    this._map = /* @__PURE__ */ Object.create(null), this.xref = t, this.objId = null, this.suppressEncryption = !1, this.__nonSerializable__ = XQ;
  }
  assignXref(t) {
    this.xref = t;
  }
  get size() {
    return Object.keys(this._map).length;
  }
  get(t, e, i) {
    let s = this._map[t];
    return s === void 0 && e !== void 0 && (s = this._map[e], s === void 0 && i !== void 0 && (s = this._map[i])), s instanceof St && this.xref ? this.xref.fetch(s, this.suppressEncryption) : s;
  }
  async getAsync(t, e, i) {
    let s = this._map[t];
    return s === void 0 && e !== void 0 && (s = this._map[e], s === void 0 && i !== void 0 && (s = this._map[i])), s instanceof St && this.xref ? this.xref.fetchAsync(s, this.suppressEncryption) : s;
  }
  getArray(t, e, i) {
    let s = this._map[t];
    if (s === void 0 && e !== void 0 && (s = this._map[e], s === void 0 && i !== void 0 && (s = this._map[i])), s instanceof St && this.xref && (s = this.xref.fetch(s, this.suppressEncryption)), Array.isArray(s)) {
      s = s.slice();
      for (let n = 0, o = s.length; n < o; n++) s[n] instanceof St && this.xref && (s[n] = this.xref.fetch(s[n], this.suppressEncryption));
    }
    return s;
  }
  getRaw(t) {
    return this._map[t];
  }
  getKeys() {
    return Object.keys(this._map);
  }
  getRawValues() {
    return Object.values(this._map);
  }
  set(t, e) {
    this._map[t] = e;
  }
  has(t) {
    return this._map[t] !== void 0;
  }
  forEach(t) {
    for (const e in this._map) t(e, this.get(e));
  }
  static get empty() {
    const t = new z(null);
    return t.set = (e, i) => {
      oA("Should not call `set` on the empty dictionary.");
    }, bt(this, "empty", t);
  }
  static merge({ xref: t, dictArray: e, mergeSubDicts: i = !1 }) {
    const s = new z(t), n = /* @__PURE__ */ new Map();
    for (const o of e) if (o instanceof z) for (const [r, c] of Object.entries(o._map)) {
      let h = n.get(r);
      if (h === void 0) h = [], n.set(r, h);
      else if (!(i && c instanceof z)) continue;
      h.push(c);
    }
    for (const [o, r] of n) {
      if (r.length === 1 || !(r[0] instanceof z)) {
        s._map[o] = r[0];
        continue;
      }
      const c = new z(t);
      for (const h of r) for (const [I, C] of Object.entries(h._map)) c._map[I] === void 0 && (c._map[I] = C);
      c.size > 0 && (s._map[o] = c);
    }
    return n.clear(), s.size > 0 ? s : z.empty;
  }
  clone() {
    const t = new z(this.xref);
    for (const e of this.getKeys()) t.set(e, this.getRaw(e));
    return t;
  }
  delete(t) {
    delete this._map[t];
  }
}
class St {
  constructor(t, e) {
    this.num = t, this.gen = e;
  }
  toString() {
    return this.gen === 0 ? `${this.num}R` : `${this.num}R${this.gen}`;
  }
  static fromString(t) {
    const e = fo[t];
    if (e) return e;
    const i = /^(\d+)R(\d*)$/.exec(t);
    return i && i[1] !== "0" ? fo[t] = new St(parseInt(i[1]), i[2] ? parseInt(i[2]) : 0) : null;
  }
  static get(t, e) {
    const i = e === 0 ? `${t}R` : `${t}R${e}`;
    return fo[i] ||= new St(t, e);
  }
}
class XA {
  constructor(t = null) {
    this._set = new Set(t?._set);
  }
  has(t) {
    return this._set.has(t.toString());
  }
  put(t) {
    this._set.add(t.toString());
  }
  remove(t) {
    this._set.delete(t.toString());
  }
  [Symbol.iterator]() {
    return this._set.values();
  }
  clear() {
    this._set.clear();
  }
}
class Ii {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._map.size;
  }
  get(t) {
    return this._map.get(t.toString());
  }
  has(t) {
    return this._map.has(t.toString());
  }
  put(t, e) {
    this._map.set(t.toString(), e);
  }
  putAlias(t, e) {
    this._map.set(t.toString(), this.get(e));
  }
  [Symbol.iterator]() {
    return this._map.values();
  }
  clear() {
    this._map.clear();
  }
  *items() {
    for (const [t, e] of this._map) yield [St.fromString(t), e];
  }
}
function qA(A, t) {
  return A instanceof at && (t === void 0 || A.name === t);
}
function zA(A, t) {
  return A instanceof KA && (t === void 0 || A.cmd === t);
}
function zQ(A, t) {
  return A instanceof z && (t === void 0 || qA(A.get("Type"), t));
}
function Po(A, t) {
  return A.num === t.num && A.gen === t.gen;
}
class AA {
  get length() {
    oA("Abstract getter `length` accessed");
  }
  get isEmpty() {
    oA("Abstract getter `isEmpty` accessed");
  }
  get isDataLoaded() {
    return bt(this, "isDataLoaded", !0);
  }
  getByte() {
    oA("Abstract method `getByte` called");
  }
  getBytes(t) {
    oA("Abstract method `getBytes` called");
  }
  async getImageData(t, e) {
    return this.getBytes(t, e);
  }
  async asyncGetBytes() {
    oA("Abstract method `asyncGetBytes` called");
  }
  get isAsync() {
    return !1;
  }
  get canAsyncDecodeImageFromBuffer() {
    return !1;
  }
  peekByte() {
    const t = this.getByte();
    return t !== -1 && this.pos--, t;
  }
  peekBytes(t) {
    const e = this.getBytes(t);
    return this.pos -= e.length, e;
  }
  getUint16() {
    const t = this.getByte(), e = this.getByte();
    return t === -1 || e === -1 ? -1 : (t << 8) + e;
  }
  getInt32() {
    return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte();
  }
  getByteRange(t, e) {
    oA("Abstract method `getByteRange` called");
  }
  getString(t) {
    return Re(this.getBytes(t));
  }
  skip(t) {
    this.pos += t || 1;
  }
  reset() {
    oA("Abstract method `reset` called");
  }
  moveStart() {
    oA("Abstract method `moveStart` called");
  }
  makeSubStream(t, e, i = null) {
    oA("Abstract method `makeSubStream` called");
  }
  getBaseStreams() {
    return null;
  }
}
const $Q = /^[1-9]\.\d$/;
function DA(A) {
  let t;
  return function() {
    return A && (t = /* @__PURE__ */ Object.create(null), A(t), A = null), t;
  };
}
class yA extends de {
  constructor(t, e) {
    super(`Missing data [${t}, ${e})`, "MissingDataException"), this.begin = t, this.end = e;
  }
}
class Nh extends de {
  constructor(t) {
    super(t, "ParserEOFException");
  }
}
class Ds extends de {
  constructor(t) {
    super(t, "XRefEntryException");
  }
}
class qa extends de {
  constructor(t) {
    super(t, "XRefParseException");
  }
}
function tE(A) {
  const t = A.length;
  if (t === 0) return new Uint8Array(0);
  if (t === 1) return new Uint8Array(A[0]);
  let e = 0;
  for (let n = 0; n < t; n++) e += A[n].byteLength;
  const i = new Uint8Array(e);
  let s = 0;
  for (let n = 0; n < t; n++) {
    const o = new Uint8Array(A[n]);
    i.set(o, s), s += o.byteLength;
  }
  return i;
}
function ei({ dict: A, key: t, getArray: e = !1, stopWhenFound: i = !0 }) {
  let s;
  const n = new XA();
  for (; A instanceof z && (!A.objId || !n.has(A.objId)); ) {
    A.objId && n.put(A.objId);
    const o = e ? A.getArray(t) : A.get(t);
    if (o !== void 0) {
      if (i) return o;
      (s ||= []).push(o);
    }
    A = A.get("Parent");
  }
  return s;
}
const qc = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
function Om(A, t = !1) {
  pe(Number.isInteger(A) && A > 0, "The number should be a positive integer.");
  const e = [];
  let i;
  for (; A >= 1e3; ) A -= 1e3, e.push("M");
  i = A / 100 | 0, A %= 100, e.push(qc[i]), i = A / 10 | 0, A %= 10, e.push(qc[10 + i]), e.push(qc[20 + A]);
  const s = e.join("");
  return t ? s.toLowerCase() : s;
}
function Pc(A) {
  return A <= 0 ? 0 : Math.ceil(Math.log2(A));
}
function hs(A, t) {
  return A[t] << 24 >> 24;
}
function TA(A, t) {
  return A[t] << 8 | A[t + 1];
}
function bA(A, t) {
  return (A[t] << 24 | A[t + 1] << 16 | A[t + 2] << 8 | A[t + 3]) >>> 0;
}
function qe(A) {
  return A === 32 || A === 9 || A === 13 || A === 10;
}
function Pe(A, t) {
  return Array.isArray(A) ? (t === null || A.length === t) && A.every(((e) => typeof e == "number")) : ArrayBuffer.isView(A) && (A.length === 0 || typeof A[0] == "number") && (t === null || A.length === t);
}
function ks(A, t) {
  return Pe(A, 6) ? A : t;
}
function Gh(A, t) {
  return Pe(A, 4) ? A : t;
}
function Zi(A, t) {
  return Pe(A, 4) ? PA.normalizeRect(A) : t;
}
function AE(A) {
  const t = /(.+)\[(\d+)\]$/;
  return A.split(".").map(((e) => {
    const i = e.match(t);
    return i ? { name: i[1], pos: parseInt(i[2], 10) } : { name: e, pos: 0 };
  }));
}
function yl(A) {
  const t = [];
  let e = 0;
  for (let i = 0, s = A.length; i < s; i++) {
    const n = A.charCodeAt(i);
    (n < 33 || n > 126 || n === 35 || n === 40 || n === 41 || n === 60 || n === 62 || n === 91 || n === 93 || n === 123 || n === 125 || n === 47 || n === 37) && (e < i && t.push(A.substring(e, i)), t.push(`#${n.toString(16)}`), e = i + 1);
  }
  return t.length === 0 ? A : (e < A.length && t.push(A.substring(e, A.length)), t.join(""));
}
function Za(A) {
  return A.replaceAll(/([()\\\n\r])/g, ((t) => t === `
` ? "\\n" : t === "\r" ? "\\r" : `\\${t}`));
}
function _o(A, t, e, i) {
  if (!A) return;
  let s = null;
  if (A instanceof St) {
    if (i.has(A)) return;
    s = A, i.put(s), A = t.fetch(A);
  }
  if (Array.isArray(A)) for (const n of A) _o(n, t, e, i);
  else if (A instanceof z) {
    if (qA(A.get("S"), "JavaScript")) {
      const n = A.get("JS");
      let o;
      n instanceof AA ? o = n.getString() : typeof n == "string" && (o = n), o &&= cA(o).replaceAll("\0", ""), o && e.push(o);
    }
    _o(A.getRaw("Next"), t, e, i);
  }
  s && i.remove(s);
}
function Bg(A, t, e) {
  const i = /* @__PURE__ */ Object.create(null), s = ei({ dict: t, key: "AA", stopWhenFound: !1 });
  if (s) for (let n = s.length - 1; n >= 0; n--) {
    const o = s[n];
    if (o instanceof z) for (const r of o.getKeys()) {
      const c = e[r];
      if (!c) continue;
      const h = [];
      _o(o.getRaw(r), A, h, new XA()), h.length > 0 && (i[c] = h);
    }
  }
  if (t.has("A")) {
    const n = [];
    _o(t.get("A"), A, n, new XA()), n.length > 0 && (i.Action = n);
  }
  return _Q(i) > 0 ? i : null;
}
const Wm = { 60: "&lt;", 62: "&gt;", 38: "&amp;", 34: "&quot;", 39: "&apos;" };
function* jm(A) {
  for (let t = 0, e = A.length; t < e; t++) {
    const i = A.codePointAt(t);
    i > 55295 && (i < 57344 || i > 65533) && t++, yield i;
  }
}
function Pa(A) {
  const t = [];
  let e = 0;
  for (let i = 0, s = A.length; i < s; i++) {
    const n = A.codePointAt(i);
    if (32 <= n && n <= 126) {
      const o = Wm[n];
      o && (e < i && t.push(A.substring(e, i)), t.push(o), e = i + 1);
    } else e < i && t.push(A.substring(e, i)), t.push(`&#x${n.toString(16).toUpperCase()};`), n > 55295 && (n < 57344 || n > 65533) && i++, e = i + 1;
  }
  return t.length === 0 ? A : (e < A.length && t.push(A.substring(e, A.length)), t.join(""));
}
function vh(A, t = !1) {
  const e = /^("|').*("|')$/.exec(A);
  if (e && e[1] === e[2]) {
    if (new RegExp(`[^\\\\]${e[1]}`).test(A.slice(1, -1))) return t && O(`FontFamily contains unescaped ${e[1]}: ${A}.`), !1;
  } else for (const i of A.split(/[ \t]+/)) if (/^(\d|(-(\d|-)))/.test(i) || !/^[\w-\\]+$/.test(i)) return t && O(`FontFamily contains invalid <custom-ident>: ${A}.`), !1;
  return !0;
}
function Zm(A) {
  const t = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), { fontFamily: e, fontWeight: i, italicAngle: s } = A;
  if (!vh(e, !0)) return !1;
  const n = i ? i.toString() : "";
  A.fontWeight = t.has(n) ? n : "400";
  const o = parseFloat(s);
  return A.italicAngle = isNaN(o) || o < -90 || o > 90 ? "14" : s.toString(), !0;
}
function eE(A) {
  const t = new RegExp("^\\s*(" + ["app.launchURL", "window.open", "xfa.host.gotoURL"].join("|").replaceAll(".", "\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(A);
  if (t?.[2]) {
    const e = t[2];
    let i = !1;
    return t[3] === "true" && t[1] === "app.launchURL" && (i = !0), { url: e, newWindow: i };
  }
  return null;
}
function BA(A) {
  if (Number.isInteger(A)) return A.toString();
  const t = Math.round(100 * A);
  return t % 100 == 0 ? (t / 100).toString() : t % 10 == 0 ? A.toFixed(1) : A.toFixed(2);
}
function iE(A) {
  if (!A) return null;
  const t = /* @__PURE__ */ new Map();
  for (const [e, i] of A) {
    if (!e.startsWith(dQ)) continue;
    let s = t.get(i.pageIndex);
    s || (s = [], t.set(i.pageIndex, s)), s.push(i);
  }
  return t.size > 0 ? t : null;
}
function xi(A) {
  return (function(t) {
    return /^[\x00-\x7F]*$/.test(t);
  })(A) ? A : sE(A, !0);
}
function Vm(A) {
  const t = [];
  for (let e = 0, i = A.length; e < i; e++) {
    const s = A.charCodeAt(e);
    t.push((s >> 8 & 255).toString(16).padStart(2, "0"), (255 & s).toString(16).padStart(2, "0"));
  }
  return t.join("");
}
function sE(A, t = !1) {
  const e = [];
  t && e.push("þÿ");
  for (let i = 0, s = A.length; i < s; i++) {
    const n = A.charCodeAt(i);
    e.push(String.fromCharCode(n >> 8 & 255), String.fromCharCode(255 & n));
  }
  return e.join("");
}
function Oo(A, t, e) {
  switch (A) {
    case 90:
      return [0, 1, -1, 0, t, 0];
    case 180:
      return [-1, 0, 0, -1, t, e];
    case 270:
      return [0, -1, 1, 0, 0, e];
    default:
      throw new Error("Invalid rotation");
  }
}
function yC(A) {
  return Math.ceil(Math.ceil(Math.log2(1 + A)) / 8);
}
class RA extends AA {
  constructor(t, e, i, s) {
    super(), this.bytes = t instanceof Uint8Array ? t : new Uint8Array(t), this.start = e || 0, this.pos = this.start, this.end = e + i || this.bytes.length, this.dict = s;
  }
  get length() {
    return this.end - this.start;
  }
  get isEmpty() {
    return this.length === 0;
  }
  getByte() {
    return this.pos >= this.end ? -1 : this.bytes[this.pos++];
  }
  getBytes(t) {
    const e = this.bytes, i = this.pos, s = this.end;
    if (!t) return e.subarray(i, s);
    let n = i + t;
    return n > s && (n = s), this.pos = n, e.subarray(i, n);
  }
  getByteRange(t, e) {
    return t < 0 && (t = 0), e > this.end && (e = this.end), this.bytes.subarray(t, e);
  }
  reset() {
    this.pos = this.start;
  }
  moveStart() {
    this.start = this.pos;
  }
  makeSubStream(t, e, i = null) {
    return new RA(this.bytes.buffer, t, e, i);
  }
}
class _e extends RA {
  constructor(t) {
    super(re(t));
  }
}
class Wo extends RA {
  constructor() {
    super(new Uint8Array(0));
  }
}
class Xm extends RA {
  constructor(t, e, i) {
    super(new Uint8Array(t), 0, t, null), this.chunkSize = e, this._loadedChunks = /* @__PURE__ */ new Set(), this.numChunks = Math.ceil(t / e), this.manager = i, this.progressiveDataLength = 0, this.lastSuccessfulEnsureByteChunk = -1;
  }
  getMissingChunks() {
    const t = [];
    for (let e = 0, i = this.numChunks; e < i; ++e) this._loadedChunks.has(e) || t.push(e);
    return t;
  }
  get numChunksLoaded() {
    return this._loadedChunks.size;
  }
  get isDataLoaded() {
    return this.numChunksLoaded === this.numChunks;
  }
  onReceiveData(t, e) {
    const i = this.chunkSize;
    if (t % i != 0) throw new Error(`Bad begin offset: ${t}`);
    const s = t + e.byteLength;
    if (s % i != 0 && s !== this.bytes.length) throw new Error(`Bad end offset: ${s}`);
    this.bytes.set(new Uint8Array(e), t);
    const n = Math.floor(t / i), o = Math.floor((s - 1) / i) + 1;
    for (let r = n; r < o; ++r) this._loadedChunks.add(r);
  }
  onReceiveProgressiveData(t) {
    let e = this.progressiveDataLength;
    const i = Math.floor(e / this.chunkSize);
    this.bytes.set(new Uint8Array(t), e), e += t.byteLength, this.progressiveDataLength = e;
    const s = e >= this.end ? this.numChunks : Math.floor(e / this.chunkSize);
    for (let n = i; n < s; ++n) this._loadedChunks.add(n);
  }
  ensureByte(t) {
    if (t < this.progressiveDataLength) return;
    const e = Math.floor(t / this.chunkSize);
    if (!(e > this.numChunks) && e !== this.lastSuccessfulEnsureByteChunk) {
      if (!this._loadedChunks.has(e)) throw new yA(t, t + 1);
      this.lastSuccessfulEnsureByteChunk = e;
    }
  }
  ensureRange(t, e) {
    if (t >= e || e <= this.progressiveDataLength) return;
    const i = Math.floor(t / this.chunkSize);
    if (i > this.numChunks) return;
    const s = Math.min(Math.floor((e - 1) / this.chunkSize) + 1, this.numChunks);
    for (let n = i; n < s; ++n) if (!this._loadedChunks.has(n)) throw new yA(t, e);
  }
  nextEmptyChunk(t) {
    const e = this.numChunks;
    for (let i = 0; i < e; ++i) {
      const s = (t + i) % e;
      if (!this._loadedChunks.has(s)) return s;
    }
    return null;
  }
  hasChunk(t) {
    return this._loadedChunks.has(t);
  }
  getByte() {
    const t = this.pos;
    return t >= this.end ? -1 : (t >= this.progressiveDataLength && this.ensureByte(t), this.bytes[this.pos++]);
  }
  getBytes(t) {
    const e = this.bytes, i = this.pos, s = this.end;
    if (!t) return s > this.progressiveDataLength && this.ensureRange(i, s), e.subarray(i, s);
    let n = i + t;
    return n > s && (n = s), n > this.progressiveDataLength && this.ensureRange(i, n), this.pos = n, e.subarray(i, n);
  }
  getByteRange(t, e) {
    return t < 0 && (t = 0), e > this.end && (e = this.end), e > this.progressiveDataLength && this.ensureRange(t, e), this.bytes.subarray(t, e);
  }
  makeSubStream(t, e, i = null) {
    function s() {
    }
    e ? t + e > this.progressiveDataLength && this.ensureRange(t, t + e) : t >= this.progressiveDataLength && this.ensureByte(t), s.prototype = Object.create(this), s.prototype.getMissingChunks = function() {
      const o = this.chunkSize, r = Math.floor(this.start / o), c = Math.floor((this.end - 1) / o) + 1, h = [];
      for (let I = r; I < c; ++I) this._loadedChunks.has(I) || h.push(I);
      return h;
    }, Object.defineProperty(s.prototype, "isDataLoaded", { get() {
      return this.numChunksLoaded === this.numChunks || this.getMissingChunks().length === 0;
    }, configurable: !0 });
    const n = new s();
    return n.pos = n.start = t, n.end = t + e || this.end, n.dict = i, n;
  }
  getBaseStreams() {
    return [this];
  }
}
class zm {
  constructor(t, e) {
    this.length = e.length, this.chunkSize = e.rangeChunkSize, this.stream = new Xm(this.length, this.chunkSize, this), this.pdfNetworkStream = t, this.disableAutoFetch = e.disableAutoFetch, this.msgHandler = e.msgHandler, this.currRequestId = 0, this._chunksNeededByRequest = /* @__PURE__ */ new Map(), this._requestsByChunk = /* @__PURE__ */ new Map(), this._promisesByRequest = /* @__PURE__ */ new Map(), this.progressiveDataLength = 0, this.aborted = !1, this._loadedStreamCapability = Promise.withResolvers();
  }
  sendRequest(t, e) {
    const i = this.pdfNetworkStream.getRangeReader(t, e);
    i.isStreamingSupported || (i.onProgress = this.onProgress.bind(this));
    let s = [], n = 0;
    return new Promise(((o, r) => {
      const c = ({ value: h, done: I }) => {
        try {
          if (I) {
            const C = tE(s);
            return s = null, void o(C);
          }
          n += h.byteLength, i.isStreamingSupported && this.onProgress({ loaded: n }), s.push(h), i.read().then(c, r);
        } catch (C) {
          r(C);
        }
      };
      i.read().then(c, r);
    })).then(((o) => {
      this.aborted || this.onReceiveData({ chunk: o, begin: t });
    }));
  }
  requestAllChunks(t = !1) {
    if (!t) {
      const e = this.stream.getMissingChunks();
      this._requestChunks(e);
    }
    return this._loadedStreamCapability.promise;
  }
  _requestChunks(t) {
    const e = this.currRequestId++, i = /* @__PURE__ */ new Set();
    this._chunksNeededByRequest.set(e, i);
    for (const o of t) this.stream.hasChunk(o) || i.add(o);
    if (i.size === 0) return Promise.resolve();
    const s = Promise.withResolvers();
    this._promisesByRequest.set(e, s);
    const n = [];
    for (const o of i) {
      let r = this._requestsByChunk.get(o);
      r || (r = [], this._requestsByChunk.set(o, r), n.push(o)), r.push(e);
    }
    if (n.length > 0) {
      const o = this.groupChunks(n);
      for (const r of o) {
        const c = r.beginChunk * this.chunkSize, h = Math.min(r.endChunk * this.chunkSize, this.length);
        this.sendRequest(c, h).catch(s.reject);
      }
    }
    return s.promise.catch(((o) => {
      if (!this.aborted) throw o;
    }));
  }
  getStream() {
    return this.stream;
  }
  requestRange(t, e) {
    e = Math.min(e, this.length);
    const i = this.getBeginChunk(t), s = this.getEndChunk(e), n = [];
    for (let o = i; o < s; ++o) n.push(o);
    return this._requestChunks(n);
  }
  requestRanges(t = []) {
    const e = [];
    for (const i of t) {
      const s = this.getBeginChunk(i.begin), n = this.getEndChunk(i.end);
      for (let o = s; o < n; ++o) e.includes(o) || e.push(o);
    }
    return e.sort((function(i, s) {
      return i - s;
    })), this._requestChunks(e);
  }
  groupChunks(t) {
    const e = [];
    let i = -1, s = -1;
    for (let n = 0, o = t.length; n < o; ++n) {
      const r = t[n];
      i < 0 && (i = r), s >= 0 && s + 1 !== r && (e.push({ beginChunk: i, endChunk: s + 1 }), i = r), n + 1 === t.length && e.push({ beginChunk: i, endChunk: r + 1 }), s = r;
    }
    return e;
  }
  onProgress(t) {
    this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize + t.loaded, total: this.length });
  }
  onReceiveData(t) {
    const e = t.chunk, i = t.begin === void 0, s = i ? this.progressiveDataLength : t.begin, n = s + e.byteLength, o = Math.floor(s / this.chunkSize), r = n < this.length ? Math.floor(n / this.chunkSize) : Math.ceil(n / this.chunkSize);
    i ? (this.stream.onReceiveProgressiveData(e), this.progressiveDataLength = n) : this.stream.onReceiveData(s, e), this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
    const c = [];
    for (let h = o; h < r; ++h) {
      const I = this._requestsByChunk.get(h);
      if (I) {
        this._requestsByChunk.delete(h);
        for (const C of I) {
          const d = this._chunksNeededByRequest.get(C);
          d.has(h) && d.delete(h), d.size > 0 || c.push(C);
        }
      }
    }
    if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
      let h;
      if (this.stream.numChunksLoaded === 1) {
        const I = this.stream.numChunks - 1;
        this.stream.hasChunk(I) || (h = I);
      } else h = this.stream.nextEmptyChunk(r);
      Number.isInteger(h) && this._requestChunks([h]);
    }
    for (const h of c) {
      const I = this._promisesByRequest.get(h);
      this._promisesByRequest.delete(h), I.resolve();
    }
    this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize, total: this.length });
  }
  onError(t) {
    this._loadedStreamCapability.reject(t);
  }
  getBeginChunk(t) {
    return Math.floor(t / this.chunkSize);
  }
  getEndChunk(t) {
    return Math.floor((t - 1) / this.chunkSize) + 1;
  }
  abort(t) {
    this.aborted = !0, this.pdfNetworkStream?.cancelAllRequests(t);
    for (const e of this._promisesByRequest.values()) e.reject(t);
  }
}
class Vt {
  constructor(t, e) {
    this.name = t, this.numComps = e;
  }
  getRgb(t, e) {
    const i = new Uint8ClampedArray(3);
    return this.getRgbItem(t, e, i, 0), i;
  }
  getRgbItem(t, e, i, s) {
    oA("Should not call ColorSpace.getRgbItem");
  }
  getRgbBuffer(t, e, i, s, n, o, r) {
    oA("Should not call ColorSpace.getRgbBuffer");
  }
  getOutputLength(t, e) {
    oA("Should not call ColorSpace.getOutputLength");
  }
  isPassthrough(t) {
    return !1;
  }
  isDefaultDecode(t, e) {
    return Vt.isDefaultDecode(t, this.numComps);
  }
  fillRgb(t, e, i, s, n, o, r, c, h) {
    const I = e * i;
    let C = null;
    const d = 1 << r, u = i !== n || e !== s;
    if (this.isPassthrough(r)) C = c;
    else if (this.numComps === 1 && I > d && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
      const E = r <= 8 ? new Uint8Array(d) : new Uint16Array(d);
      for (let y = 0; y < d; y++) E[y] = y;
      const p = new Uint8ClampedArray(3 * d);
      if (this.getRgbBuffer(E, 0, d, p, 0, r, 0), u) {
        C = new Uint8Array(3 * I);
        let y = 0;
        for (let b = 0; b < I; ++b) {
          const D = 3 * c[b];
          C[y++] = p[D], C[y++] = p[D + 1], C[y++] = p[D + 2];
        }
      } else {
        let y = 0;
        for (let b = 0; b < I; ++b) {
          const D = 3 * c[b];
          t[y++] = p[D], t[y++] = p[D + 1], t[y++] = p[D + 2], y += h;
        }
      }
    } else u ? (C = new Uint8ClampedArray(3 * I), this.getRgbBuffer(c, 0, I, C, 0, r, 0)) : this.getRgbBuffer(c, 0, s * o, t, 0, r, h);
    if (C) if (u) (function(E, p, y, b, D, S, R) {
      R = R !== 1 ? 0 : R;
      const x = y / D, N = b / S;
      let U, T = 0;
      const q = new Uint16Array(D), _ = 3 * y;
      for (let Y = 0; Y < D; Y++) q[Y] = 3 * Math.floor(Y * x);
      for (let Y = 0; Y < S; Y++) {
        const ht = Math.floor(Y * N) * _;
        for (let ut = 0; ut < D; ut++) U = ht + q[ut], p[T++] = E[U++], p[T++] = E[U++], p[T++] = E[U++], T += R;
      }
    })(C, t, e, i, s, n, h);
    else {
      let E = 0, p = 0;
      for (let y = 0, b = s * o; y < b; y++) t[E++] = C[p++], t[E++] = C[p++], t[E++] = C[p++], E += h;
    }
  }
  get usesZeroToOneRange() {
    return bt(this, "usesZeroToOneRange", !0);
  }
  static _cache(t, e, i, s) {
    if (!i) throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
    if (!s) throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
    let n, o;
    t instanceof St && (o = t, t = e.fetch(t)), t instanceof at && (n = t.name), (n || o) && i.set(n, o, s);
  }
  static getCached(t, e, i) {
    if (!i) throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
    if (t instanceof St) {
      const s = i.getByRef(t);
      if (s) return s;
      try {
        t = e.fetch(t);
      } catch (n) {
        if (n instanceof yA) throw n;
      }
    }
    if (t instanceof at) {
      const s = i.getByName(t.name);
      if (s) return s;
    }
    return null;
  }
  static async parseAsync({ cs: t, xref: e, resources: i = null, pdfFunctionFactory: s, localColorSpaceCache: n }) {
    const o = this._parse(t, e, i, s);
    return this._cache(t, e, n, o), o;
  }
  static parse({ cs: t, xref: e, resources: i = null, pdfFunctionFactory: s, localColorSpaceCache: n }) {
    const o = this.getCached(t, e, n);
    if (o) return o;
    const r = this._parse(t, e, i, s);
    return this._cache(t, e, n, r), r;
  }
  static _parse(t, e, i = null, s) {
    if ((t = e.fetchIfRef(t)) instanceof at) switch (t.name) {
      case "G":
      case "DeviceGray":
        return this.singletons.gray;
      case "RGB":
      case "DeviceRGB":
        return this.singletons.rgb;
      case "DeviceRGBA":
        return this.singletons.rgba;
      case "CMYK":
      case "DeviceCMYK":
        return this.singletons.cmyk;
      case "Pattern":
        return new wC(null);
      default:
        if (i instanceof z) {
          const n = i.get("ColorSpace");
          if (n instanceof z) {
            const o = n.get(t.name);
            if (o) {
              if (o instanceof at) return this._parse(o, e, i, s);
              t = o;
              break;
            }
          }
        }
        return O(`Unrecognized ColorSpace: ${t.name}`), this.singletons.gray;
    }
    if (Array.isArray(t)) {
      const n = e.fetchIfRef(t[0]).name;
      let o, r, c, h, I, C;
      switch (n) {
        case "G":
        case "DeviceGray":
          return this.singletons.gray;
        case "RGB":
        case "DeviceRGB":
          return this.singletons.rgb;
        case "CMYK":
        case "DeviceCMYK":
          return this.singletons.cmyk;
        case "CalGray":
          return o = e.fetchIfRef(t[1]), h = o.getArray("WhitePoint"), I = o.getArray("BlackPoint"), C = o.get("Gamma"), new a3(h, I, C);
        case "CalRGB":
          o = e.fetchIfRef(t[1]), h = o.getArray("WhitePoint"), I = o.getArray("BlackPoint"), C = o.getArray("Gamma");
          const d = o.getArray("Matrix");
          return new le(h, I, C, d);
        case "ICCBased":
          const u = e.fetchIfRef(t[1]).dict;
          r = u.get("N");
          const E = u.get("Alternate");
          if (E) {
            const R = this._parse(E, e, i, s);
            if (R.numComps === r) return R;
            O("ICCBased color space: Ignoring incorrect /Alternate entry.");
          }
          if (r === 1) return this.singletons.gray;
          if (r === 3) return this.singletons.rgb;
          if (r === 4) return this.singletons.cmyk;
          break;
        case "Pattern":
          return c = t[1] || null, c && (c = this._parse(c, e, i, s)), new wC(c);
        case "I":
        case "Indexed":
          c = this._parse(t[1], e, i, s);
          const p = e.fetchIfRef(t[2]) + 1, y = e.fetchIfRef(t[3]);
          return new t3(c, p, y);
        case "Separation":
        case "DeviceN":
          const b = e.fetchIfRef(t[1]);
          r = Array.isArray(b) ? b.length : 1, c = this._parse(t[2], e, i, s);
          const D = s.create(t[3]);
          return new $m(r, c, D);
        case "Lab":
          o = e.fetchIfRef(t[1]), h = o.getArray("WhitePoint"), I = o.getArray("BlackPoint");
          const S = o.getArray("Range");
          return new n3(h, I, S);
        default:
          return O(`Unimplemented ColorSpace object: ${n}`), this.singletons.gray;
      }
    }
    return O(`Unrecognized ColorSpace object: ${t}`), this.singletons.gray;
  }
  static isDefaultDecode(t, e) {
    if (!Array.isArray(t)) return !0;
    if (2 * e !== t.length) return O("The decode map is not the correct length"), !0;
    for (let i = 0, s = t.length; i < s; i += 2) if (t[i] !== 0 || t[i + 1] !== 1) return !1;
    return !0;
  }
  static get singletons() {
    return bt(this, "singletons", { get gray() {
      return bt(this, "gray", new A3());
    }, get rgb() {
      return bt(this, "rgb", new e3());
    }, get rgba() {
      return bt(this, "rgba", new i3());
    }, get cmyk() {
      return bt(this, "cmyk", new s3());
    } });
  }
}
class $m extends Vt {
  constructor(t, e, i) {
    super("Alternate", t), this.base = e, this.tintFn = i, this.tmpBuf = new Float32Array(e.numComps);
  }
  getRgbItem(t, e, i, s) {
    const n = this.tmpBuf;
    this.tintFn(t, e, n, 0), this.base.getRgbItem(n, 0, i, s);
  }
  getRgbBuffer(t, e, i, s, n, o, r) {
    const c = this.tintFn, h = this.base, I = 1 / ((1 << o) - 1), C = h.numComps, d = h.usesZeroToOneRange, u = (h.isPassthrough(8) || !d) && r === 0;
    let E = u ? n : 0;
    const p = u ? s : new Uint8ClampedArray(C * i), y = this.numComps, b = new Float32Array(y), D = new Float32Array(C);
    let S, R;
    for (S = 0; S < i; S++) {
      for (R = 0; R < y; R++) b[R] = t[e++] * I;
      if (c(b, 0, D, 0), d) for (R = 0; R < C; R++) p[E++] = 255 * D[R];
      else h.getRgbItem(D, 0, p, E), E += C;
    }
    u || h.getRgbBuffer(p, 0, i, s, n, 8, r);
  }
  getOutputLength(t, e) {
    return this.base.getOutputLength(t * this.base.numComps / this.numComps, e);
  }
}
class wC extends Vt {
  constructor(t) {
    super("Pattern", null), this.base = t;
  }
  isDefaultDecode(t, e) {
    oA("Should not call PatternCS.isDefaultDecode");
  }
}
class t3 extends Vt {
  constructor(t, e, i) {
    super("Indexed", 1), this.base = t, this.highVal = e;
    const s = t.numComps * e;
    if (this.lookup = new Uint8Array(s), i instanceof AA) {
      const n = i.getBytes(s);
      this.lookup.set(n);
    } else {
      if (typeof i != "string") throw new Ct(`IndexedCS - unrecognized lookup table: ${i}`);
      for (let n = 0; n < s; ++n) this.lookup[n] = 255 & i.charCodeAt(n);
    }
  }
  getRgbItem(t, e, i, s) {
    const n = this.base.numComps, o = t[e] * n;
    this.base.getRgbBuffer(this.lookup, o, 1, i, s, 8, 0);
  }
  getRgbBuffer(t, e, i, s, n, o, r) {
    const c = this.base, h = c.numComps, I = c.getOutputLength(h, r), C = this.lookup;
    for (let d = 0; d < i; ++d) {
      const u = t[e++] * h;
      c.getRgbBuffer(C, u, 1, s, n, 8, r), n += I;
    }
  }
  getOutputLength(t, e) {
    return this.base.getOutputLength(t * this.base.numComps, e);
  }
  isDefaultDecode(t, e) {
    return !Array.isArray(t) || (t.length !== 2 ? (O("Decode map length is not correct"), !0) : !Number.isInteger(e) || e < 1 ? (O("Bits per component is not correct"), !0) : t[0] === 0 && t[1] === (1 << e) - 1);
  }
}
class A3 extends Vt {
  constructor() {
    super("DeviceGray", 1);
  }
  getRgbItem(t, e, i, s) {
    const n = 255 * t[e];
    i[s] = i[s + 1] = i[s + 2] = n;
  }
  getRgbBuffer(t, e, i, s, n, o, r) {
    const c = 255 / ((1 << o) - 1);
    let h = e, I = n;
    for (let C = 0; C < i; ++C) {
      const d = c * t[h++];
      s[I++] = d, s[I++] = d, s[I++] = d, I += r;
    }
  }
  getOutputLength(t, e) {
    return t * (3 + e);
  }
}
class e3 extends Vt {
  constructor() {
    super("DeviceRGB", 3);
  }
  getRgbItem(t, e, i, s) {
    i[s] = 255 * t[e], i[s + 1] = 255 * t[e + 1], i[s + 2] = 255 * t[e + 2];
  }
  getRgbBuffer(t, e, i, s, n, o, r) {
    if (o === 8 && r === 0) return void s.set(t.subarray(e, e + 3 * i), n);
    const c = 255 / ((1 << o) - 1);
    let h = e, I = n;
    for (let C = 0; C < i; ++C) s[I++] = c * t[h++], s[I++] = c * t[h++], s[I++] = c * t[h++], I += r;
  }
  getOutputLength(t, e) {
    return t * (3 + e) / 3 | 0;
  }
  isPassthrough(t) {
    return t === 8;
  }
}
class i3 extends Vt {
  constructor() {
    super("DeviceRGBA", 4);
  }
  getOutputLength(t, e) {
    return 4 * t;
  }
  isPassthrough(t) {
    return t === 8;
  }
}
class s3 extends Vt {
  constructor() {
    super("DeviceCMYK", 4);
  }
  #t(t, e, i, s, n) {
    const o = t[e] * i, r = t[e + 1] * i, c = t[e + 2] * i, h = t[e + 3] * i;
    s[n] = 255 + o * (-4.387332384609988 * o + 54.48615194189176 * r + 18.82290502165302 * c + 212.25662451639585 * h - 285.2331026137004) + r * (1.7149763477362134 * r - 5.6096736904047315 * c + -17.873870861415444 * h - 5.497006427196366) + c * (-2.5217340131683033 * c - 21.248923337353073 * h + 17.5119270841813) + h * (-21.86122147463605 * h - 189.48180835922747), s[n + 1] = 255 + o * (8.841041422036149 * o + 60.118027045597366 * r + 6.871425592049007 * c + 31.159100130055922 * h - 79.2970844816548) + r * (-15.310361306967817 * r + 17.575251261109482 * c + 131.35250912493976 * h - 190.9453302588951) + c * (4.444339102852739 * c + 9.8632861493405 * h - 24.86741582555878) + h * (-20.737325471181034 * h - 187.80453709719578), s[n + 2] = 255 + o * (0.8842522430003296 * o + 8.078677503112928 * r + 30.89978309703729 * c - 0.23883238689178934 * h - 14.183576799673286) + r * (10.49593273432072 * r + 63.02378494754052 * c + 50.606957656360734 * h - 112.23884253719248) + c * (0.03296041114873217 * c + 115.60384449646641 * h - 193.58209356861505) + h * (-22.33816807309886 * h - 180.12613974708367);
  }
  getRgbItem(t, e, i, s) {
    this.#t(t, e, 1, i, s);
  }
  getRgbBuffer(t, e, i, s, n, o, r) {
    const c = 1 / ((1 << o) - 1);
    for (let h = 0; h < i; h++) this.#t(t, e, c, s, n), e += 4, n += 3 + r;
  }
  getOutputLength(t, e) {
    return t / 4 * (3 + e) | 0;
  }
}
class a3 extends Vt {
  constructor(t, e, i) {
    if (super("CalGray", 1), !t) throw new Ct("WhitePoint missing - required for color space CalGray");
    if ([this.XW, this.YW, this.ZW] = t, [this.XB, this.YB, this.ZB] = e || [0, 0, 0], this.G = i || 1, this.XW < 0 || this.ZW < 0 || this.YW !== 1) throw new Ct(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (tA(`Invalid BlackPoint for ${this.name}, falling back to default.`), this.XB = this.YB = this.ZB = 0), this.XB === 0 && this.YB === 0 && this.ZB === 0 || O(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`), this.G < 1 && (tA(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`), this.G = 1);
  }
  #t(t, e, i, s, n) {
    const o = (t[e] * n) ** this.G, r = this.YW * o, c = Math.max(295.8 * r ** 0.3333333333333333 - 40.8, 0);
    i[s] = c, i[s + 1] = c, i[s + 2] = c;
  }
  getRgbItem(t, e, i, s) {
    this.#t(t, e, i, s, 1);
  }
  getRgbBuffer(t, e, i, s, n, o, r) {
    const c = 1 / ((1 << o) - 1);
    for (let h = 0; h < i; ++h) this.#t(t, e, s, n, c), e += 1, n += 3 + r;
  }
  getOutputLength(t, e) {
    return t * (3 + e);
  }
}
class le extends Vt {
  static #t = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
  static #A = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]);
  static #e = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]);
  static #s = new Float32Array([1, 1, 1]);
  static #a = new Float32Array(3);
  static #i = new Float32Array(3);
  static #r = new Float32Array(3);
  static #o = (24 / 116) ** 3 / 8;
  constructor(t, e, i, s) {
    if (super("CalRGB", 3), !t) throw new Ct("WhitePoint missing - required for color space CalRGB");
    const [n, o, r] = this.whitePoint = t, [c, h, I] = this.blackPoint = e || new Float32Array(3);
    if ([this.GR, this.GG, this.GB] = i || new Float32Array([1, 1, 1]), [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = s || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), n < 0 || r < 0 || o !== 1) throw new Ct(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    (c < 0 || h < 0 || I < 0) && (tA(`Invalid BlackPoint for ${this.name} [${c}, ${h}, ${I}], falling back to default.`), this.blackPoint = new Float32Array(3)), (this.GR < 0 || this.GG < 0 || this.GB < 0) && (tA(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`), this.GR = this.GG = this.GB = 1);
  }
  #h(t, e, i) {
    i[0] = t[0] * e[0] + t[1] * e[1] + t[2] * e[2], i[1] = t[3] * e[0] + t[4] * e[1] + t[5] * e[2], i[2] = t[6] * e[0] + t[7] * e[1] + t[8] * e[2];
  }
  #g(t, e, i) {
    i[0] = 1 * e[0] / t[0], i[1] = 1 * e[1] / t[1], i[2] = 1 * e[2] / t[2];
  }
  #c(t, e, i) {
    i[0] = 0.95047 * e[0] / t[0], i[1] = 1 * e[1] / t[1], i[2] = 1.08883 * e[2] / t[2];
  }
  #n(t) {
    return t <= 31308e-7 ? this.#l(0, 1, 12.92 * t) : t >= 0.99554525 ? 1 : this.#l(0, 1, 1.055 * t ** (1 / 2.4) - 0.055);
  }
  #l(t, e, i) {
    return Math.max(t, Math.min(e, i));
  }
  #C(t) {
    return t < 0 ? -this.#C(-t) : t > 8 ? ((t + 16) / 116) ** 3 : t * le.#o;
  }
  #I(t, e, i) {
    if (t[0] === 0 && t[1] === 0 && t[2] === 0) return i[0] = e[0], i[1] = e[1], void (i[2] = e[2]);
    const s = this.#C(0), n = (1 - s) / (1 - this.#C(t[0])), o = 1 - n, r = (1 - s) / (1 - this.#C(t[1])), c = 1 - r, h = (1 - s) / (1 - this.#C(t[2])), I = 1 - h;
    i[0] = e[0] * n + o, i[1] = e[1] * r + c, i[2] = e[2] * h + I;
  }
  #B(t, e, i) {
    if (t[0] === 1 && t[2] === 1) return i[0] = e[0], i[1] = e[1], void (i[2] = e[2]);
    const s = i;
    this.#h(le.#t, e, s);
    const n = le.#a;
    this.#g(t, s, n), this.#h(le.#A, n, i);
  }
  #d(t, e, i) {
    const s = i;
    this.#h(le.#t, e, s);
    const n = le.#a;
    this.#c(t, s, n), this.#h(le.#A, n, i);
  }
  #u(t, e, i, s, n) {
    const o = this.#l(0, 1, t[e] * n), r = this.#l(0, 1, t[e + 1] * n), c = this.#l(0, 1, t[e + 2] * n), h = o === 1 ? 1 : o ** this.GR, I = r === 1 ? 1 : r ** this.GG, C = c === 1 ? 1 : c ** this.GB, d = this.MXA * h + this.MXB * I + this.MXC * C, u = this.MYA * h + this.MYB * I + this.MYC * C, E = this.MZA * h + this.MZB * I + this.MZC * C, p = le.#i;
    p[0] = d, p[1] = u, p[2] = E;
    const y = le.#r;
    this.#B(this.whitePoint, p, y);
    const b = le.#i;
    this.#I(this.blackPoint, y, b);
    const D = le.#r;
    this.#d(le.#s, b, D);
    const S = le.#i;
    this.#h(le.#e, D, S), i[s] = 255 * this.#n(S[0]), i[s + 1] = 255 * this.#n(S[1]), i[s + 2] = 255 * this.#n(S[2]);
  }
  getRgbItem(t, e, i, s) {
    this.#u(t, e, i, s, 1);
  }
  getRgbBuffer(t, e, i, s, n, o, r) {
    const c = 1 / ((1 << o) - 1);
    for (let h = 0; h < i; ++h) this.#u(t, e, s, n, c), e += 3, n += 3 + r;
  }
  getOutputLength(t, e) {
    return t * (3 + e) / 3 | 0;
  }
}
class n3 extends Vt {
  constructor(t, e, i) {
    if (super("Lab", 3), !t) throw new Ct("WhitePoint missing - required for color space Lab");
    if ([this.XW, this.YW, this.ZW] = t, [this.amin, this.amax, this.bmin, this.bmax] = i || [-100, 100, -100, 100], [this.XB, this.YB, this.ZB] = e || [0, 0, 0], this.XW < 0 || this.ZW < 0 || this.YW !== 1) throw new Ct("Invalid WhitePoint components, no fallback available");
    (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (tA("Invalid BlackPoint, falling back to default"), this.XB = this.YB = this.ZB = 0), (this.amin > this.amax || this.bmin > this.bmax) && (tA("Invalid Range, falling back to defaults"), this.amin = -100, this.amax = 100, this.bmin = -100, this.bmax = 100);
  }
  #t(t) {
    return t >= 6 / 29 ? t ** 3 : 108 / 841 * (t - 4 / 29);
  }
  #A(t, e, i, s) {
    return i + t * (s - i) / e;
  }
  #e(t, e, i, s, n) {
    let o = t[e], r = t[e + 1], c = t[e + 2];
    i !== !1 && (o = this.#A(o, i, 0, 100), r = this.#A(r, i, this.amin, this.amax), c = this.#A(c, i, this.bmin, this.bmax)), r > this.amax ? r = this.amax : r < this.amin && (r = this.amin), c > this.bmax ? c = this.bmax : c < this.bmin && (c = this.bmin);
    const h = (o + 16) / 116, I = h + r / 500, C = h - c / 200, d = this.XW * this.#t(I), u = this.YW * this.#t(h), E = this.ZW * this.#t(C);
    let p, y, b;
    this.ZW < 1 ? (p = 3.1339 * d + -1.617 * u + -0.4906 * E, y = -0.9785 * d + 1.916 * u + 0.0333 * E, b = 0.072 * d + -0.229 * u + 1.4057 * E) : (p = 3.2406 * d + -1.5372 * u + -0.4986 * E, y = -0.9689 * d + 1.8758 * u + 0.0415 * E, b = 0.0557 * d + -0.204 * u + 1.057 * E), s[n] = 255 * Math.sqrt(p), s[n + 1] = 255 * Math.sqrt(y), s[n + 2] = 255 * Math.sqrt(b);
  }
  getRgbItem(t, e, i, s) {
    this.#e(t, e, !1, i, s);
  }
  getRgbBuffer(t, e, i, s, n, o, r) {
    const c = (1 << o) - 1;
    for (let h = 0; h < i; h++) this.#e(t, e, c, s, n), e += 3, n += 3 + r;
  }
  getOutputLength(t, e) {
    return t * (3 + e) / 3 | 0;
  }
  isDefaultDecode(t, e) {
    return !0;
  }
  get usesZeroToOneRange() {
    return bt(this, "usesZeroToOneRange", !1);
  }
}
function ce(A, t) {
  let e = 0;
  for (let i = 0; i <= t; i++) e = e << 8 | A[i];
  return e >>> 0;
}
function Wr(A, t) {
  return t === 1 ? String.fromCharCode(A[0], A[1]) : t === 3 ? String.fromCharCode(A[0], A[1], A[2], A[3]) : String.fromCharCode(...A.subarray(0, t + 1));
}
function Ee(A, t, e) {
  let i = 0;
  for (let s = e; s >= 0; s--) i += A[s] + t[s], A[s] = 255 & i, i >>= 8;
}
function Ps(A, t) {
  let e = 1;
  for (let i = t; i >= 0 && e > 0; i--) e += A[i], A[i] = 255 & e, e >>= 8;
}
const ba = 16;
class r3 {
  constructor(t) {
    this.buffer = t, this.pos = 0, this.end = t.length, this.tmpBuf = new Uint8Array(19);
  }
  readByte() {
    return this.pos >= this.end ? -1 : this.buffer[this.pos++];
  }
  readNumber() {
    let t, e = 0;
    do {
      const i = this.readByte();
      if (i < 0) throw new Ct("unexpected EOF in bcmap");
      t = !(128 & i), e = e << 7 | 127 & i;
    } while (!t);
    return e;
  }
  readSigned() {
    const t = this.readNumber();
    return 1 & t ? ~(t >>> 1) : t >>> 1;
  }
  readHex(t, e) {
    t.set(this.buffer.subarray(this.pos, this.pos + e + 1)), this.pos += e + 1;
  }
  readHexNumber(t, e) {
    let i;
    const s = this.tmpBuf;
    let n = 0;
    do {
      const h = this.readByte();
      if (h < 0) throw new Ct("unexpected EOF in bcmap");
      i = !(128 & h), s[n++] = 127 & h;
    } while (!i);
    let o = e, r = 0, c = 0;
    for (; o >= 0; ) {
      for (; c < 8 && s.length > 0; ) r |= s[--n] << c, c += 7;
      t[o] = 255 & r, o--, r >>= 8, c -= 8;
    }
  }
  readHexSigned(t, e) {
    this.readHexNumber(t, e);
    const i = 1 & t[e] ? 255 : 0;
    let s = 0;
    for (let n = 0; n <= e; n++) s = (1 & s) << 8 | t[n], t[n] = s >> 1 ^ i;
  }
  readString() {
    const t = this.readNumber(), e = new Array(t);
    for (let i = 0; i < t; i++) e[i] = this.readNumber();
    return String.fromCharCode(...e);
  }
}
class o3 {
  async process(t, e, i) {
    const s = new r3(t), n = s.readByte();
    e.vertical = !!(1 & n);
    let o = null;
    const r = new Uint8Array(ba), c = new Uint8Array(ba), h = new Uint8Array(ba), I = new Uint8Array(ba), C = new Uint8Array(ba);
    let d, u;
    for (; (u = s.readByte()) >= 0; ) {
      const E = u >> 5;
      if (E === 7) {
        switch (31 & u) {
          case 0:
            s.readString();
            break;
          case 1:
            o = s.readString();
        }
        continue;
      }
      const p = !!(16 & u), y = 15 & u;
      if (y + 1 > ba) throw new Error("BinaryCMapReader.process: Invalid dataSize.");
      const b = 1, D = s.readNumber();
      switch (E) {
        case 0:
          s.readHex(r, y), s.readHexNumber(c, y), Ee(c, r, y), e.addCodespaceRange(y + 1, ce(r, y), ce(c, y));
          for (let S = 1; S < D; S++) Ps(c, y), s.readHexNumber(r, y), Ee(r, c, y), s.readHexNumber(c, y), Ee(c, r, y), e.addCodespaceRange(y + 1, ce(r, y), ce(c, y));
          break;
        case 1:
          s.readHex(r, y), s.readHexNumber(c, y), Ee(c, r, y), s.readNumber();
          for (let S = 1; S < D; S++) Ps(c, y), s.readHexNumber(r, y), Ee(r, c, y), s.readHexNumber(c, y), Ee(c, r, y), s.readNumber();
          break;
        case 2:
          s.readHex(h, y), d = s.readNumber(), e.mapOne(ce(h, y), d);
          for (let S = 1; S < D; S++) Ps(h, y), p || (s.readHexNumber(C, y), Ee(h, C, y)), d = s.readSigned() + (d + 1), e.mapOne(ce(h, y), d);
          break;
        case 3:
          s.readHex(r, y), s.readHexNumber(c, y), Ee(c, r, y), d = s.readNumber(), e.mapCidRange(ce(r, y), ce(c, y), d);
          for (let S = 1; S < D; S++) Ps(c, y), p ? r.set(c) : (s.readHexNumber(r, y), Ee(r, c, y)), s.readHexNumber(c, y), Ee(c, r, y), d = s.readNumber(), e.mapCidRange(ce(r, y), ce(c, y), d);
          break;
        case 4:
          s.readHex(h, b), s.readHex(I, y), e.mapOne(ce(h, b), Wr(I, y));
          for (let S = 1; S < D; S++) Ps(h, b), p || (s.readHexNumber(C, b), Ee(h, C, b)), Ps(I, y), s.readHexSigned(C, y), Ee(I, C, y), e.mapOne(ce(h, b), Wr(I, y));
          break;
        case 5:
          s.readHex(r, b), s.readHexNumber(c, b), Ee(c, r, b), s.readHex(I, y), e.mapBfRange(ce(r, b), ce(c, b), Wr(I, y));
          for (let S = 1; S < D; S++) Ps(c, b), p ? r.set(c) : (s.readHexNumber(r, b), Ee(r, c, b)), s.readHexNumber(c, b), Ee(c, r, b), s.readHex(I, y), e.mapBfRange(ce(r, b), ce(c, b), Wr(I, y));
          break;
        default:
          throw new Error(`BinaryCMapReader.process - unknown type: ${E}`);
      }
    }
    return o ? i(o) : e;
  }
}
const g3 = new Uint8Array(0);
class Be extends AA {
  constructor(t) {
    if (super(), this._rawMinBufferLength = t || 0, this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = g3, this.minBufferLength = 512, t) for (; this.minBufferLength < t; ) this.minBufferLength *= 2;
  }
  get isEmpty() {
    for (; !this.eof && this.bufferLength === 0; ) this.readBlock();
    return this.bufferLength === 0;
  }
  ensureBuffer(t) {
    const e = this.buffer;
    if (t <= e.byteLength) return e;
    let i = this.minBufferLength;
    for (; i < t; ) i *= 2;
    const s = new Uint8Array(i);
    return s.set(e), this.buffer = s;
  }
  getByte() {
    const t = this.pos;
    for (; this.bufferLength <= t; ) {
      if (this.eof) return -1;
      this.readBlock();
    }
    return this.buffer[this.pos++];
  }
  getBytes(t, e = null) {
    const i = this.pos;
    let s;
    if (t) {
      for (this.ensureBuffer(i + t), s = i + t; !this.eof && this.bufferLength < s; ) this.readBlock(e);
      const n = this.bufferLength;
      s > n && (s = n);
    } else {
      for (; !this.eof; ) this.readBlock(e);
      s = this.bufferLength;
    }
    return this.pos = s, this.buffer.subarray(i, s);
  }
  async getImageData(t, e = null) {
    if (!this.canAsyncDecodeImageFromBuffer) return this.getBytes(t, e);
    const i = await this.stream.asyncGetBytes();
    return this.decodeImage(i, e);
  }
  reset() {
    this.pos = 0;
  }
  makeSubStream(t, e, i = null) {
    if (e === void 0) for (; !this.eof; ) this.readBlock();
    else {
      const s = t + e;
      for (; this.bufferLength <= s && !this.eof; ) this.readBlock();
    }
    return new RA(this.buffer, t, e, i);
  }
  getBaseStreams() {
    return this.str ? this.str.getBaseStreams() : null;
  }
}
class c3 extends Be {
  constructor(t, e = null) {
    let i = 0;
    for (const s of t) i += s instanceof Be ? s._rawMinBufferLength : s.length;
    super(i), this.streams = t, this._onError = e;
  }
  readBlock() {
    const t = this.streams;
    if (t.length === 0) return void (this.eof = !0);
    const e = t.shift();
    let i;
    try {
      i = e.getBytes();
    } catch (o) {
      if (this._onError) return void this._onError(o, e.dict?.objId);
      throw o;
    }
    const s = this.bufferLength, n = s + i.length;
    this.ensureBuffer(n).set(i, s), this.bufferLength = n;
  }
  getBaseStreams() {
    const t = [];
    for (const e of this.streams) {
      const i = e.getBaseStreams();
      i && t.push(...i);
    }
    return t.length > 0 ? t : null;
  }
}
class h3 extends Be {
  constructor(t, e) {
    e && (e *= 0.8), super(e), this.str = t, this.dict = t.dict, this.input = new Uint8Array(5);
  }
  readBlock() {
    const t = this.str;
    let e = t.getByte();
    for (; qe(e); ) e = t.getByte();
    if (e === -1 || e === 126) return void (this.eof = !0);
    const i = this.bufferLength;
    let s, n;
    if (e === 122) {
      for (s = this.ensureBuffer(i + 4), n = 0; n < 4; ++n) s[i + n] = 0;
      this.bufferLength += 4;
    } else {
      const o = this.input;
      for (o[0] = e, n = 1; n < 5; ++n) {
        for (e = t.getByte(); qe(e); ) e = t.getByte();
        if (o[n] = e, e === -1 || e === 126) break;
      }
      if (s = this.ensureBuffer(i + n - 1), this.bufferLength += n - 1, n < 5) {
        for (; n < 5; ++n) o[n] = 117;
        this.eof = !0;
      }
      let r = 0;
      for (n = 0; n < 5; ++n) r = 85 * r + (o[n] - 33);
      for (n = 3; n >= 0; --n) s[i + n] = 255 & r, r >>= 8;
    }
  }
}
class l3 extends Be {
  constructor(t, e) {
    e && (e *= 0.5), super(e), this.str = t, this.dict = t.dict, this.firstDigit = -1;
  }
  readBlock() {
    const t = this.str.getBytes(8e3);
    if (!t.length) return void (this.eof = !0);
    const e = t.length + 1 >> 1, i = this.ensureBuffer(this.bufferLength + e);
    let s = this.bufferLength, n = this.firstDigit;
    for (const o of t) {
      let r;
      if (o >= 48 && o <= 57) r = 15 & o;
      else {
        if (!(o >= 65 && o <= 70 || o >= 97 && o <= 102)) {
          if (o === 62) {
            this.eof = !0;
            break;
          }
          continue;
        }
        r = 9 + (15 & o);
      }
      n < 0 ? n = r : (i[s++] = n << 4 | r, n = -1);
    }
    n >= 0 && this.eof && (i[s++] = n << 4, n = -1), this.firstDigit = n, this.bufferLength = s;
  }
}
const Yi = -1, bC = [[-1, -1], [-1, -1], [7, 8], [7, 7], [6, 6], [6, 6], [6, 5], [6, 5], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]], DC = [[-1, -1], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]], kC = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]], SC = [[-1, -1], [-1, -1], [12, -2], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]], FC = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]], RC = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
class aE {
  constructor(t, e = {}) {
    if (!t || typeof t.next != "function") throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
    let i;
    for (this.source = t, this.eof = !1, this.encoding = e.K || 0, this.eoline = e.EndOfLine || !1, this.byteAlign = e.EncodedByteAlign || !1, this.columns = e.Columns || 1728, this.rows = e.Rows || 0, this.eoblock = e.EndOfBlock ?? !0, this.black = e.BlackIs1 || !1, this.codingLine = new Uint32Array(this.columns + 1), this.refLine = new Uint32Array(this.columns + 2), this.codingLine[0] = this.columns, this.codingPos = 0, this.row = 0, this.nextLine2D = this.encoding < 0, this.inputBits = 0, this.inputBuf = 0, this.outputBits = 0, this.rowsDone = !1; (i = this._lookBits(12)) === 0; ) this._eatBits(1);
    i === 1 && this._eatBits(12), this.encoding > 0 && (this.nextLine2D = !this._lookBits(1), this._eatBits(1));
  }
  readNextChar() {
    if (this.eof) return -1;
    const t = this.refLine, e = this.codingLine, i = this.columns;
    let s, n, o, r, c;
    if (this.outputBits === 0) {
      if (this.rowsDone && (this.eof = !0), this.eof) return -1;
      let h, I, C;
      if (this.err = !1, this.nextLine2D) {
        for (r = 0; e[r] < i; ++r) t[r] = e[r];
        for (t[r++] = i, t[r] = i, e[0] = 0, this.codingPos = 0, s = 0, n = 0; e[this.codingPos] < i; ) switch (h = this._getTwoDimCode(), h) {
          case 0:
            this._addPixels(t[s + 1], n), t[s + 1] < i && (s += 2);
            break;
          case 1:
            if (h = I = 0, n) {
              do
                h += C = this._getBlackCode();
              while (C >= 64);
              do
                I += C = this._getWhiteCode();
              while (C >= 64);
            } else {
              do
                h += C = this._getWhiteCode();
              while (C >= 64);
              do
                I += C = this._getBlackCode();
              while (C >= 64);
            }
            for (this._addPixels(e[this.codingPos] + h, n), e[this.codingPos] < i && this._addPixels(e[this.codingPos] + I, 1 ^ n); t[s] <= e[this.codingPos] && t[s] < i; ) s += 2;
            break;
          case 7:
            if (this._addPixels(t[s] + 3, n), n ^= 1, e[this.codingPos] < i) for (++s; t[s] <= e[this.codingPos] && t[s] < i; ) s += 2;
            break;
          case 5:
            if (this._addPixels(t[s] + 2, n), n ^= 1, e[this.codingPos] < i) for (++s; t[s] <= e[this.codingPos] && t[s] < i; ) s += 2;
            break;
          case 3:
            if (this._addPixels(t[s] + 1, n), n ^= 1, e[this.codingPos] < i) for (++s; t[s] <= e[this.codingPos] && t[s] < i; ) s += 2;
            break;
          case 2:
            if (this._addPixels(t[s], n), n ^= 1, e[this.codingPos] < i) for (++s; t[s] <= e[this.codingPos] && t[s] < i; ) s += 2;
            break;
          case 8:
            if (this._addPixelsNeg(t[s] - 3, n), n ^= 1, e[this.codingPos] < i) for (s > 0 ? --s : ++s; t[s] <= e[this.codingPos] && t[s] < i; ) s += 2;
            break;
          case 6:
            if (this._addPixelsNeg(t[s] - 2, n), n ^= 1, e[this.codingPos] < i) for (s > 0 ? --s : ++s; t[s] <= e[this.codingPos] && t[s] < i; ) s += 2;
            break;
          case 4:
            if (this._addPixelsNeg(t[s] - 1, n), n ^= 1, e[this.codingPos] < i) for (s > 0 ? --s : ++s; t[s] <= e[this.codingPos] && t[s] < i; ) s += 2;
            break;
          case Yi:
            this._addPixels(i, 0), this.eof = !0;
            break;
          default:
            tA("bad 2d code"), this._addPixels(i, 0), this.err = !0;
        }
      } else for (e[0] = 0, this.codingPos = 0, n = 0; e[this.codingPos] < i; ) {
        if (h = 0, n) do
          h += C = this._getBlackCode();
        while (C >= 64);
        else do
          h += C = this._getWhiteCode();
        while (C >= 64);
        this._addPixels(e[this.codingPos] + h, n), n ^= 1;
      }
      let d = !1;
      if (this.byteAlign && (this.inputBits &= -8), this.eoblock || this.row !== this.rows - 1) {
        if (h = this._lookBits(12), this.eoline) for (; h !== Yi && h !== 1; ) this._eatBits(1), h = this._lookBits(12);
        else for (; h === 0; ) this._eatBits(1), h = this._lookBits(12);
        h === 1 ? (this._eatBits(12), d = !0) : h === Yi && (this.eof = !0);
      } else this.rowsDone = !0;
      if (!this.eof && this.encoding > 0 && !this.rowsDone && (this.nextLine2D = !this._lookBits(1), this._eatBits(1)), this.eoblock && d && this.byteAlign) {
        if (h = this._lookBits(12), h === 1) {
          if (this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1)), this.encoding >= 0) for (r = 0; r < 4; ++r) h = this._lookBits(12), h !== 1 && tA("bad rtc code: " + h), this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1));
          this.eof = !0;
        }
      } else if (this.err && this.eoline) {
        for (; ; ) {
          if (h = this._lookBits(13), h === Yi) return this.eof = !0, -1;
          if (h >> 1 == 1) break;
          this._eatBits(1);
        }
        this._eatBits(12), this.encoding > 0 && (this._eatBits(1), this.nextLine2D = !(1 & h));
      }
      this.outputBits = e[0] > 0 ? e[this.codingPos = 0] : e[this.codingPos = 1], this.row++;
    }
    if (this.outputBits >= 8) c = 1 & this.codingPos ? 0 : 255, this.outputBits -= 8, this.outputBits === 0 && e[this.codingPos] < i && (this.codingPos++, this.outputBits = e[this.codingPos] - e[this.codingPos - 1]);
    else {
      o = 8, c = 0;
      do {
        if (typeof this.outputBits != "number") throw new Ct('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
        this.outputBits > o ? (c <<= o, 1 & this.codingPos || (c |= 255 >> 8 - o), this.outputBits -= o, o = 0) : (c <<= this.outputBits, 1 & this.codingPos || (c |= 255 >> 8 - this.outputBits), o -= this.outputBits, this.outputBits = 0, e[this.codingPos] < i ? (this.codingPos++, this.outputBits = e[this.codingPos] - e[this.codingPos - 1]) : o > 0 && (c <<= o, o = 0));
      } while (o);
    }
    return this.black && (c ^= 255), c;
  }
  _addPixels(t, e) {
    const i = this.codingLine;
    let s = this.codingPos;
    t > i[s] && (t > this.columns && (tA("row is wrong length"), this.err = !0, t = this.columns), 1 & s ^ e && ++s, i[s] = t), this.codingPos = s;
  }
  _addPixelsNeg(t, e) {
    const i = this.codingLine;
    let s = this.codingPos;
    if (t > i[s]) t > this.columns && (tA("row is wrong length"), this.err = !0, t = this.columns), 1 & s ^ e && ++s, i[s] = t;
    else if (t < i[s]) {
      for (t < 0 && (tA("invalid code"), this.err = !0, t = 0); s > 0 && t < i[s - 1]; ) --s;
      i[s] = t;
    }
    this.codingPos = s;
  }
  _findTableCode(t, e, i, s) {
    const n = s || 0;
    for (let o = t; o <= e; ++o) {
      let r = this._lookBits(o);
      if (r === Yi) return [!0, 1, !1];
      if (o < e && (r <<= e - o), !n || r >= n) {
        const c = i[r - n];
        if (c[0] === o) return this._eatBits(o), [!0, c[1], !0];
      }
    }
    return [!1, 0, !1];
  }
  _getTwoDimCode() {
    let t, e = 0;
    if (this.eoblock) {
      if (e = this._lookBits(7), t = bC[e], t?.[0] > 0) return this._eatBits(t[0]), t[1];
    } else {
      const i = this._findTableCode(1, 7, bC);
      if (i[0] && i[2]) return i[1];
    }
    return tA("Bad two dim code"), Yi;
  }
  _getWhiteCode() {
    let t, e = 0;
    if (this.eoblock) {
      if (e = this._lookBits(12), e === Yi) return 1;
      if (t = e >> 5 ? kC[e >> 3] : DC[e], t[0] > 0) return this._eatBits(t[0]), t[1];
    } else {
      let i = this._findTableCode(1, 9, kC);
      if (i[0] || (i = this._findTableCode(11, 12, DC), i[0])) return i[1];
    }
    return tA("bad white code"), this._eatBits(1), 1;
  }
  _getBlackCode() {
    let t, e;
    if (this.eoblock) {
      if (t = this._lookBits(13), t === Yi) return 1;
      if (e = t >> 7 ? !(t >> 9) && t >> 7 ? FC[(t >> 1) - 64] : RC[t >> 7] : SC[t], e[0] > 0) return this._eatBits(e[0]), e[1];
    } else {
      let i = this._findTableCode(2, 6, RC);
      if (i[0] || (i = this._findTableCode(7, 12, FC, 64), i[0]) || (i = this._findTableCode(10, 13, SC), i[0])) return i[1];
    }
    return tA("bad black code"), this._eatBits(1), 1;
  }
  _lookBits(t) {
    let e;
    for (; this.inputBits < t; ) {
      if ((e = this.source.next()) === -1) return this.inputBits === 0 ? Yi : this.inputBuf << t - this.inputBits & 65535 >> 16 - t;
      this.inputBuf = this.inputBuf << 8 | e, this.inputBits += 8;
    }
    return this.inputBuf >> this.inputBits - t & 65535 >> 16 - t;
  }
  _eatBits(t) {
    (this.inputBits -= t) < 0 && (this.inputBits = 0);
  }
}
class I3 extends Be {
  constructor(t, e, i) {
    super(e), this.str = t, this.dict = t.dict, i instanceof z || (i = z.empty);
    const s = { next: () => t.getByte() };
    this.ccittFaxDecoder = new aE(s, { K: i.get("K"), EndOfLine: i.get("EndOfLine"), EncodedByteAlign: i.get("EncodedByteAlign"), Columns: i.get("Columns"), Rows: i.get("Rows"), EndOfBlock: i.get("EndOfBlock"), BlackIs1: i.get("BlackIs1") });
  }
  readBlock() {
    for (; !this.eof; ) {
      const t = this.ccittFaxDecoder.readNextChar();
      if (t === -1) return void (this.eof = !0);
      this.ensureBuffer(this.bufferLength + 1), this.buffer[this.bufferLength++] = t;
    }
  }
}
const xC = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), C3 = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), u3 = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), B3 = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], d3 = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
class NC extends Be {
  constructor(t, e) {
    super(e), this.str = t, this.dict = t.dict;
    const i = t.getByte(), s = t.getByte();
    if (i === -1 || s === -1) throw new Ct(`Invalid header in flate stream: ${i}, ${s}`);
    if ((15 & i) != 8) throw new Ct(`Unknown compression method in flate stream: ${i}, ${s}`);
    if (((i << 8) + s) % 31 != 0) throw new Ct(`Bad FCHECK in flate stream: ${i}, ${s}`);
    if (32 & s) throw new Ct(`FDICT bit set in flate stream: ${i}, ${s}`);
    this.codeSize = 0, this.codeBuf = 0;
  }
  async getImageData(t, e) {
    return (await this.asyncGetBytes())?.subarray(0, t) || this.getBytes(t);
  }
  async asyncGetBytes() {
    this.str.reset();
    const t = this.str.getBytes();
    try {
      const { readable: e, writable: i } = new DecompressionStream("deflate"), s = i.getWriter();
      s.write(t), s.close();
      const n = [];
      let o = 0;
      for await (const h of e) n.push(h), o += h.byteLength;
      const r = new Uint8Array(o);
      let c = 0;
      for (const h of n) r.set(h, c), c += h.byteLength;
      return r;
    } catch {
      return this.str = new RA(t, 2, t.length, this.str.dict), this.reset(), null;
    }
  }
  get isAsync() {
    return !0;
  }
  getBits(t) {
    const e = this.str;
    let i, s = this.codeSize, n = this.codeBuf;
    for (; s < t; ) {
      if ((i = e.getByte()) === -1) throw new Ct("Bad encoding in flate stream");
      n |= i << s, s += 8;
    }
    return i = n & (1 << t) - 1, this.codeBuf = n >> t, this.codeSize = s -= t, i;
  }
  getCode(t) {
    const e = this.str, i = t[0], s = t[1];
    let n, o = this.codeSize, r = this.codeBuf;
    for (; o < s && (n = e.getByte()) !== -1; ) r |= n << o, o += 8;
    const c = i[r & (1 << s) - 1], h = c >> 16, I = 65535 & c;
    if (h < 1 || o < h) throw new Ct("Bad encoding in flate stream");
    return this.codeBuf = r >> h, this.codeSize = o - h, I;
  }
  generateHuffmanTable(t) {
    const e = t.length;
    let i, s = 0;
    for (i = 0; i < e; ++i) t[i] > s && (s = t[i]);
    const n = 1 << s, o = new Int32Array(n);
    for (let r = 1, c = 0, h = 2; r <= s; ++r, c <<= 1, h <<= 1) for (let I = 0; I < e; ++I) if (t[I] === r) {
      let C = 0, d = c;
      for (i = 0; i < r; ++i) C = C << 1 | 1 & d, d >>= 1;
      for (i = C; i < n; i += h) o[i] = r << 16 | I;
      ++c;
    }
    return [o, s];
  }
  #t(t) {
    tA(t), this.eof = !0;
  }
  readBlock() {
    let t, e, i;
    const s = this.str;
    try {
      e = this.getBits(3);
    } catch (h) {
      return void this.#t(h.message);
    }
    if (1 & e && (this.eof = !0), e >>= 1, e === 0) {
      let h;
      if ((h = s.getByte()) === -1) return void this.#t("Bad block header in flate stream");
      let I = h;
      if ((h = s.getByte()) === -1) return void this.#t("Bad block header in flate stream");
      if (I |= h << 8, (h = s.getByte()) === -1) return void this.#t("Bad block header in flate stream");
      let C = h;
      if ((h = s.getByte()) === -1) return void this.#t("Bad block header in flate stream");
      if (C |= h << 8, C !== (65535 & ~I) && (I !== 0 || C !== 0)) throw new Ct("Bad uncompressed block length in flate stream");
      this.codeBuf = 0, this.codeSize = 0;
      const d = this.bufferLength, u = d + I;
      if (t = this.ensureBuffer(u), this.bufferLength = u, I === 0) s.peekByte() === -1 && (this.eof = !0);
      else {
        const E = s.getBytes(I);
        t.set(E, d), E.length < I && (this.eof = !0);
      }
      return;
    }
    let n, o;
    if (e === 1) n = B3, o = d3;
    else {
      if (e !== 2) throw new Ct("Unknown block type in flate stream");
      {
        const h = this.getBits(5) + 257, I = this.getBits(5) + 1, C = this.getBits(4) + 4, d = new Uint8Array(xC.length);
        let u;
        for (u = 0; u < C; ++u) d[xC[u]] = this.getBits(3);
        const E = this.generateHuffmanTable(d);
        i = 0, u = 0;
        const p = h + I, y = new Uint8Array(p);
        let b, D, S;
        for (; u < p; ) {
          const R = this.getCode(E);
          if (R === 16) b = 2, D = 3, S = i;
          else if (R === 17) b = 3, D = 3, S = i = 0;
          else {
            if (R !== 18) {
              y[u++] = i = R;
              continue;
            }
            b = 7, D = 11, S = i = 0;
          }
          let x = this.getBits(b) + D;
          for (; x-- > 0; ) y[u++] = S;
        }
        n = this.generateHuffmanTable(y.subarray(0, h)), o = this.generateHuffmanTable(y.subarray(h, p));
      }
    }
    t = this.buffer;
    let r = t ? t.length : 0, c = this.bufferLength;
    for (; ; ) {
      let h = this.getCode(n);
      if (h < 256) {
        c + 1 >= r && (t = this.ensureBuffer(c + 1), r = t.length), t[c++] = h;
        continue;
      }
      if (h === 256) return void (this.bufferLength = c);
      h -= 257, h = C3[h];
      let I = h >> 16;
      I > 0 && (I = this.getBits(I)), i = (65535 & h) + I, h = this.getCode(o), h = u3[h], I = h >> 16, I > 0 && (I = this.getBits(I));
      const C = (65535 & h) + I;
      c + i >= r && (t = this.ensureBuffer(c + i), r = t.length);
      for (let d = 0; d < i; ++d, ++c) t[c] = t[c - C];
    }
  }
}
const Q3 = [{ qe: 22017, nmps: 1, nlps: 1, switchFlag: 1 }, { qe: 13313, nmps: 2, nlps: 6, switchFlag: 0 }, { qe: 6145, nmps: 3, nlps: 9, switchFlag: 0 }, { qe: 2753, nmps: 4, nlps: 12, switchFlag: 0 }, { qe: 1313, nmps: 5, nlps: 29, switchFlag: 0 }, { qe: 545, nmps: 38, nlps: 33, switchFlag: 0 }, { qe: 22017, nmps: 7, nlps: 6, switchFlag: 1 }, { qe: 21505, nmps: 8, nlps: 14, switchFlag: 0 }, { qe: 18433, nmps: 9, nlps: 14, switchFlag: 0 }, { qe: 14337, nmps: 10, nlps: 14, switchFlag: 0 }, { qe: 12289, nmps: 11, nlps: 17, switchFlag: 0 }, { qe: 9217, nmps: 12, nlps: 18, switchFlag: 0 }, { qe: 7169, nmps: 13, nlps: 20, switchFlag: 0 }, { qe: 5633, nmps: 29, nlps: 21, switchFlag: 0 }, { qe: 22017, nmps: 15, nlps: 14, switchFlag: 1 }, { qe: 21505, nmps: 16, nlps: 14, switchFlag: 0 }, { qe: 20737, nmps: 17, nlps: 15, switchFlag: 0 }, { qe: 18433, nmps: 18, nlps: 16, switchFlag: 0 }, { qe: 14337, nmps: 19, nlps: 17, switchFlag: 0 }, { qe: 13313, nmps: 20, nlps: 18, switchFlag: 0 }, { qe: 12289, nmps: 21, nlps: 19, switchFlag: 0 }, { qe: 10241, nmps: 22, nlps: 19, switchFlag: 0 }, { qe: 9217, nmps: 23, nlps: 20, switchFlag: 0 }, { qe: 8705, nmps: 24, nlps: 21, switchFlag: 0 }, { qe: 7169, nmps: 25, nlps: 22, switchFlag: 0 }, { qe: 6145, nmps: 26, nlps: 23, switchFlag: 0 }, { qe: 5633, nmps: 27, nlps: 24, switchFlag: 0 }, { qe: 5121, nmps: 28, nlps: 25, switchFlag: 0 }, { qe: 4609, nmps: 29, nlps: 26, switchFlag: 0 }, { qe: 4353, nmps: 30, nlps: 27, switchFlag: 0 }, { qe: 2753, nmps: 31, nlps: 28, switchFlag: 0 }, { qe: 2497, nmps: 32, nlps: 29, switchFlag: 0 }, { qe: 2209, nmps: 33, nlps: 30, switchFlag: 0 }, { qe: 1313, nmps: 34, nlps: 31, switchFlag: 0 }, { qe: 1089, nmps: 35, nlps: 32, switchFlag: 0 }, { qe: 673, nmps: 36, nlps: 33, switchFlag: 0 }, { qe: 545, nmps: 37, nlps: 34, switchFlag: 0 }, { qe: 321, nmps: 38, nlps: 35, switchFlag: 0 }, { qe: 273, nmps: 39, nlps: 36, switchFlag: 0 }, { qe: 133, nmps: 40, nlps: 37, switchFlag: 0 }, { qe: 73, nmps: 41, nlps: 38, switchFlag: 0 }, { qe: 37, nmps: 42, nlps: 39, switchFlag: 0 }, { qe: 21, nmps: 43, nlps: 40, switchFlag: 0 }, { qe: 9, nmps: 44, nlps: 41, switchFlag: 0 }, { qe: 5, nmps: 45, nlps: 42, switchFlag: 0 }, { qe: 1, nmps: 45, nlps: 43, switchFlag: 0 }, { qe: 22017, nmps: 46, nlps: 46, switchFlag: 0 }];
class E3 {
  constructor(t, e, i) {
    this.data = t, this.bp = e, this.dataEnd = i, this.chigh = t[e], this.clow = 0, this.byteIn(), this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127, this.clow = this.clow << 7 & 65535, this.ct -= 7, this.a = 32768;
  }
  byteIn() {
    const t = this.data;
    let e = this.bp;
    t[e] === 255 ? t[e + 1] > 143 ? (this.clow += 65280, this.ct = 8) : (e++, this.clow += t[e] << 9, this.ct = 7, this.bp = e) : (e++, this.clow += e < this.dataEnd ? t[e] << 8 : 65280, this.ct = 8, this.bp = e), this.clow > 65535 && (this.chigh += this.clow >> 16, this.clow &= 65535);
  }
  readBit(t, e) {
    let i = t[e] >> 1, s = 1 & t[e];
    const n = Q3[i], o = n.qe;
    let r, c = this.a - o;
    if (this.chigh < o) c < o ? (c = o, r = s, i = n.nmps) : (c = o, r = 1 ^ s, n.switchFlag === 1 && (s = r), i = n.nlps);
    else {
      if (this.chigh -= o, 32768 & c) return this.a = c, s;
      c < o ? (r = 1 ^ s, n.switchFlag === 1 && (s = r), i = n.nlps) : (r = s, i = n.nmps);
    }
    do
      this.ct === 0 && this.byteIn(), c <<= 1, this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1, this.clow = this.clow << 1 & 65535, this.ct--;
    while (!(32768 & c));
    return this.a = c, t[e] = i << 1 | s, r;
  }
}
class SA extends de {
  constructor(t) {
    super(t, "Jbig2Error");
  }
}
class f3 {
  getContexts(t) {
    return t in this ? this[t] : this[t] = new Int8Array(65536);
  }
}
class bn {
  constructor(t, e, i) {
    this.data = t, this.start = e, this.end = i;
  }
  get decoder() {
    return bt(this, "decoder", new E3(this.data, this.start, this.end));
  }
  get contextCache() {
    return bt(this, "contextCache", new f3());
  }
}
function Ie(A, t, e) {
  const i = A.getContexts(t);
  let s = 1;
  function n(h) {
    let I = 0;
    for (let C = 0; C < h; C++) {
      const d = e.readBit(i, s);
      s = s < 256 ? s << 1 | d : 511 & (s << 1 | d) | 256, I = I << 1 | d;
    }
    return I >>> 0;
  }
  const o = n(1), r = n(1) ? n(1) ? n(1) ? n(1) ? n(1) ? n(32) + 4436 : n(12) + 340 : n(8) + 84 : n(6) + 20 : n(4) + 4 : n(2);
  let c;
  return o === 0 ? c = r : r > 0 && (c = -r), c >= -2147483648 && c <= 2147483647 ? c : null;
}
function nE(A, t, e) {
  const i = A.getContexts("IAID");
  let s = 1;
  for (let n = 0; n < e; n++)
    s = s << 1 | t.readBit(i, s);
  return e < 31 ? s & (1 << e) - 1 : 2147483647 & s;
}
const GC = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"], p3 = [[{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: 2, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -3, y: -1 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }]], vC = [{ coding: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }, { coding: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }], m3 = [39717, 1941, 229, 405];
function jr(A, t, e, i, s, n, o, r) {
  if (A)
    return Mh(new Jn(r.data, r.start, r.end), t, e, !1);
  if (i === 0 && !s && o.length === 4 && o[0].x === 3 && o[0].y === -1 && o[1].x === -3 && o[1].y === -1 && o[2].x === 2 && o[2].y === -2 && o[3].x === -2 && o[3].y === -2) return (function(H, W, lt) {
    const $ = lt.decoder, ot = lt.contextCache.getContexts("GB"), V = [];
    let rt, Bt, Rt, Ft, ft, Kt, yt;
    for (Bt = 0; Bt < W; Bt++) for (ft = V[Bt] = new Uint8Array(H), Kt = Bt < 1 ? ft : V[Bt - 1], yt = Bt < 2 ? ft : V[Bt - 2], rt = yt[0] << 13 | yt[1] << 12 | yt[2] << 11 | Kt[0] << 7 | Kt[1] << 6 | Kt[2] << 5 | Kt[3] << 4, Rt = 0; Rt < H; Rt++) ft[Rt] = Ft = $.readBit(ot, rt), rt = (31735 & rt) << 1 | (Rt + 3 < H ? yt[Rt + 3] << 11 : 0) | (Rt + 4 < H ? Kt[Rt + 4] << 4 : 0) | Ft;
    return V;
  })(t, e, r);
  const c = p3[i].concat(o);
  c.sort((function(H, W) {
    return H.y - W.y || H.x - W.x;
  }));
  const h = c.length, I = new Int8Array(h), C = new Int8Array(h), d = [];
  let u, E, p = 0, y = 0, b = 0, D = 0;
  for (E = 0; E < h; E++) I[E] = c[E].x, C[E] = c[E].y, y = Math.min(y, c[E].x), b = Math.max(b, c[E].x), D = Math.min(D, c[E].y), E < h - 1 && c[E].y === c[E + 1].y && c[E].x === c[E + 1].x - 1 ? p |= 1 << h - 1 - E : d.push(E);
  const S = d.length, R = new Int8Array(S), x = new Int8Array(S), N = new Uint16Array(S);
  for (u = 0; u < S; u++) E = d[u], R[u] = c[E].x, x[u] = c[E].y, N[u] = 1 << h - 1 - E;
  const U = -y, T = -D, q = t - b, _ = m3[i];
  let Y = new Uint8Array(t);
  const ht = [], ut = r.decoder, j = r.contextCache.getContexts("GB");
  let it, tt, Z, st, dt, ct = 0, M = 0;
  for (let H = 0; H < e; H++) {
    if (s && (ct ^= ut.readBit(j, _), ct)) {
      ht.push(Y);
      continue;
    }
    for (Y = new Uint8Array(Y), ht.push(Y), it = 0; it < t; it++) {
      if (it >= U && it < q && H >= T) for (M = M << 1 & p, E = 0; E < S; E++) tt = H + x[E], Z = it + R[E], st = ht[tt][Z], st && (st = N[E], M |= st);
      else for (M = 0, dt = h - 1, E = 0; E < h; E++, dt--) Z = it + I[E], Z >= 0 && Z < t && (tt = H + C[E], tt >= 0 && (st = ht[tt][Z], st && (M |= st << dt)));
      const W = ut.readBit(j, M);
      Y[it] = W;
    }
  }
  return ht;
}
function rE(A, t, e, i, s, n, o, r, c) {
  let h = vC[e].coding;
  e === 0 && (h = h.concat([r[0]]));
  const I = h.length, C = new Int32Array(I), d = new Int32Array(I);
  let u;
  for (u = 0; u < I; u++) C[u] = h[u].x, d[u] = h[u].y;
  let E = vC[e].reference;
  e === 0 && (E = E.concat([r[1]]));
  const p = E.length, y = new Int32Array(p), b = new Int32Array(p);
  for (u = 0; u < p; u++) y[u] = E[u].x, b[u] = E[u].y;
  const D = i[0].length, S = i.length, R = [], x = c.decoder, N = c.contextCache.getContexts("GR");
  for (let U = 0; U < t; U++) {
    const T = new Uint8Array(A);
    R.push(T);
    for (let q = 0; q < A; q++) {
      let _, Y, ht = 0;
      for (u = 0; u < I; u++) _ = U + d[u], Y = q + C[u], _ < 0 || Y < 0 || Y >= A ? ht <<= 1 : ht = ht << 1 | R[_][Y];
      for (u = 0; u < p; u++) _ = U + b[u] - n, Y = q + y[u] - s, _ < 0 || _ >= S || Y < 0 || Y >= D ? ht <<= 1 : ht = ht << 1 | i[_][Y];
      const ut = x.readBit(N, ht);
      T[q] = ut;
    }
  }
  return R;
}
function MC(A, t, e, i, s, n, o, r, c, h, I, C, d, u, E, p, y, b, D) {
  if (A && t) throw new SA("refinement with Huffman is not supported");
  const S = [];
  let R, x;
  for (R = 0; R < i; R++) {
    if (x = new Uint8Array(e), s) for (let _ = 0; _ < e; _++) x[_] = s;
    S.push(x);
  }
  const N = y.decoder, U = y.contextCache;
  let T = A ? -u.tableDeltaT.decode(D) : -Ie(U, "IADT", N), q = 0;
  for (R = 0; R < n; ) {
    T += A ? u.tableDeltaT.decode(D) : Ie(U, "IADT", N), q += A ? u.tableFirstS.decode(D) : Ie(U, "IAFS", N);
    let _ = q;
    for (; ; ) {
      let Y = 0;
      o > 1 && (Y = A ? D.readBits(b) : Ie(U, "IAIT", N));
      const ht = o * T + Y, ut = A ? u.symbolIDTable.decode(D) : nE(U, N, c), j = t && (A ? D.readBit() : Ie(U, "IARI", N));
      let it = r[ut], tt = it[0].length, Z = it.length;
      if (j) {
        const $ = Ie(U, "IARDW", N), ot = Ie(U, "IARDH", N);
        tt += $, Z += ot, it = rE(tt, Z, E, it, ($ >> 1) + Ie(U, "IARDX", N), (ot >> 1) + Ie(U, "IARDY", N), 0, p, y);
      }
      let st = 0;
      h ? 1 & C ? st = Z - 1 : _ += Z - 1 : C > 1 ? _ += tt - 1 : st = tt - 1;
      const dt = ht - (1 & C ? 0 : Z - 1), ct = _ - (2 & C ? tt - 1 : 0);
      let M, H, W;
      if (h) for (M = 0; M < Z; M++) {
        if (x = S[ct + M], !x) continue;
        W = it[M];
        const $ = Math.min(e - dt, tt);
        switch (d) {
          case 0:
            for (H = 0; H < $; H++) x[dt + H] |= W[H];
            break;
          case 2:
            for (H = 0; H < $; H++) x[dt + H] ^= W[H];
            break;
          default:
            throw new SA(`operator ${d} is not supported`);
        }
      }
      else for (H = 0; H < Z; H++) if (x = S[dt + H], x) switch (W = it[H], d) {
        case 0:
          for (M = 0; M < tt; M++) x[ct + M] |= W[M];
          break;
        case 2:
          for (M = 0; M < tt; M++) x[ct + M] ^= W[M];
          break;
        default:
          throw new SA(`operator ${d} is not supported`);
      }
      R++;
      const lt = A ? u.tableDeltaS.decode(D) : Ie(U, "IADS", N);
      if (lt === null) break;
      _ += st + lt + I;
    }
  }
  return S;
}
function y3(A, t) {
  const e = {};
  e.number = bA(A, t);
  const i = A[t + 4], s = 63 & i;
  if (!GC[s]) throw new SA("invalid segment type: " + s);
  e.type = s, e.typeName = GC[s], e.deferredNonRetain = !!(128 & i);
  const n = !!(64 & i), o = A[t + 5];
  let r = o >> 5 & 7;
  const c = [31 & o];
  let h = t + 6;
  if (o === 7) {
    r = 536870911 & bA(A, h - 1), h += 3;
    let E = r + 7 >> 3;
    for (c[0] = A[h++]; --E > 0; ) c.push(A[h++]);
  } else if (o === 5 || o === 6) throw new SA("invalid referred-to flags");
  e.retainBits = c;
  let I = 4;
  e.number <= 256 ? I = 1 : e.number <= 65536 && (I = 2);
  const C = [];
  let d, u;
  for (d = 0; d < r; d++) {
    let E;
    E = I === 1 ? A[h] : I === 2 ? TA(A, h) : bA(A, h), C.push(E), h += I;
  }
  if (e.referredTo = C, n ? (e.pageAssociation = bA(A, h), h += 4) : e.pageAssociation = A[h++], e.length = bA(A, h), h += 4, e.length === 4294967295) {
    if (s !== 38) throw new SA("invalid unknown segment length");
    {
      const E = po(A, h), p = !!(1 & A[h + mo]), y = 6, b = new Uint8Array(y);
      for (p || (b[0] = 255, b[1] = 172), b[2] = E.height >>> 24 & 255, b[3] = E.height >> 16 & 255, b[4] = E.height >> 8 & 255, b[5] = 255 & E.height, d = h, u = A.length; d < u; d++) {
        let D = 0;
        for (; D < y && b[D] === A[d + D]; ) D++;
        if (D === y) {
          e.length = d + y;
          break;
        }
      }
      if (e.length === 4294967295) throw new SA("segment end was not found");
    }
  }
  return e.headerEnd = h, e;
}
function w3(A, t, e, i) {
  const s = [];
  let n = e;
  for (; n < i; ) {
    const o = y3(t, n);
    n = o.headerEnd;
    const r = { header: o, data: t };
    if (A.randomAccess || (r.start = n, n += o.length, r.end = n), s.push(r), o.type === 51) break;
  }
  if (A.randomAccess) for (let o = 0, r = s.length; o < r; o++) s[o].start = n, n += s[o].header.length, s[o].end = n;
  return s;
}
function po(A, t) {
  return { width: bA(A, t), height: bA(A, t + 4), x: bA(A, t + 8), y: bA(A, t + 12), combinationOperator: 7 & A[t + 16] };
}
const mo = 17;
function b3(A, t) {
  const e = A.header, i = A.data, s = A.end;
  let n, o, r, c, h = A.start;
  switch (e.type) {
    case 0:
      const C = {}, d = TA(i, h);
      if (C.huffman = !!(1 & d), C.refinement = !!(2 & d), C.huffmanDHSelector = d >> 2 & 3, C.huffmanDWSelector = d >> 4 & 3, C.bitmapSizeSelector = d >> 6 & 1, C.aggregationInstancesSelector = d >> 7 & 1, C.bitmapCodingContextUsed = !!(256 & d), C.bitmapCodingContextRetained = !!(512 & d), C.template = d >> 10 & 3, C.refinementTemplate = d >> 12 & 1, h += 2, !C.huffman) {
        for (c = C.template === 0 ? 4 : 1, o = [], r = 0; r < c; r++) o.push({ x: hs(i, h), y: hs(i, h + 1) }), h += 2;
        C.at = o;
      }
      if (C.refinement && !C.refinementTemplate) {
        for (o = [], r = 0; r < 2; r++) o.push({ x: hs(i, h), y: hs(i, h + 1) }), h += 2;
        C.refinementAt = o;
      }
      C.numberOfExportedSymbols = bA(i, h), h += 4, C.numberOfNewSymbols = bA(i, h), h += 4, n = [C, e.number, e.referredTo, i, h, s];
      break;
    case 6:
    case 7:
      const u = {};
      u.info = po(i, h), h += mo;
      const E = TA(i, h);
      if (h += 2, u.huffman = !!(1 & E), u.refinement = !!(2 & E), u.logStripSize = E >> 2 & 3, u.stripSize = 1 << u.logStripSize, u.referenceCorner = E >> 4 & 3, u.transposed = !!(64 & E), u.combinationOperator = E >> 7 & 3, u.defaultPixelValue = E >> 9 & 1, u.dsOffset = E << 17 >> 27, u.refinementTemplate = E >> 15 & 1, u.huffman) {
        const U = TA(i, h);
        h += 2, u.huffmanFS = 3 & U, u.huffmanDS = U >> 2 & 3, u.huffmanDT = U >> 4 & 3, u.huffmanRefinementDW = U >> 6 & 3, u.huffmanRefinementDH = U >> 8 & 3, u.huffmanRefinementDX = U >> 10 & 3, u.huffmanRefinementDY = U >> 12 & 3, u.huffmanRefinementSizeSelector = !!(16384 & U);
      }
      if (u.refinement && !u.refinementTemplate) {
        for (o = [], r = 0; r < 2; r++) o.push({ x: hs(i, h), y: hs(i, h + 1) }), h += 2;
        u.refinementAt = o;
      }
      u.numberOfSymbolInstances = bA(i, h), h += 4, n = [u, e.referredTo, i, h, s];
      break;
    case 16:
      const p = {}, y = i[h++];
      p.mmr = !!(1 & y), p.template = y >> 1 & 3, p.patternWidth = i[h++], p.patternHeight = i[h++], p.maxPatternIndex = bA(i, h), h += 4, n = [p, e.number, i, h, s];
      break;
    case 22:
    case 23:
      const b = {};
      b.info = po(i, h), h += mo;
      const D = i[h++];
      b.mmr = !!(1 & D), b.template = D >> 1 & 3, b.enableSkip = !!(8 & D), b.combinationOperator = D >> 4 & 7, b.defaultPixelValue = D >> 7 & 1, b.gridWidth = bA(i, h), h += 4, b.gridHeight = bA(i, h), h += 4, b.gridOffsetX = 4294967295 & bA(i, h), h += 4, b.gridOffsetY = 4294967295 & bA(i, h), h += 4, b.gridVectorX = TA(i, h), h += 2, b.gridVectorY = TA(i, h), h += 2, n = [b, e.referredTo, i, h, s];
      break;
    case 38:
    case 39:
      const S = {};
      S.info = po(i, h), h += mo;
      const R = i[h++];
      if (S.mmr = !!(1 & R), S.template = R >> 1 & 3, S.prediction = !!(8 & R), !S.mmr) {
        for (c = S.template === 0 ? 4 : 1, o = [], r = 0; r < c; r++) o.push({ x: hs(i, h), y: hs(i, h + 1) }), h += 2;
        S.at = o;
      }
      n = [S, i, h, s];
      break;
    case 48:
      const x = { width: bA(i, h), height: bA(i, h + 4), resolutionX: bA(i, h + 8), resolutionY: bA(i, h + 12) };
      x.height === 4294967295 && delete x.height;
      const N = i[h + 16];
      TA(i, h + 17), x.lossless = !!(1 & N), x.refinement = !!(2 & N), x.defaultPixelValue = N >> 2 & 1, x.combinationOperator = N >> 3 & 3, x.requiresBuffer = !!(32 & N), x.combinationOperatorOverride = !!(64 & N), n = [x];
      break;
    case 49:
    case 50:
    case 51:
    case 62:
      break;
    case 53:
      n = [e.number, i, h, s];
      break;
    default:
      throw new SA(`segment type ${e.typeName}(${e.type}) is not implemented`);
  }
  const I = "on" + e.typeName;
  I in t && t[I].apply(t, n);
}
function D3(A, t) {
  for (let e = 0, i = A.length; e < i; e++) b3(A[e], t);
}
class k3 {
  onPageInformation(t) {
    this.currentPageInfo = t;
    const e = t.width + 7 >> 3, i = new Uint8ClampedArray(e * t.height);
    t.defaultPixelValue && i.fill(255), this.buffer = i;
  }
  drawBitmap(t, e) {
    const i = this.currentPageInfo, s = t.width, n = t.height, o = i.width + 7 >> 3, r = i.combinationOperatorOverride ? t.combinationOperator : i.combinationOperator, c = this.buffer, h = 128 >> (7 & t.x);
    let I, C, d, u, E = t.y * o + (t.x >> 3);
    switch (r) {
      case 0:
        for (I = 0; I < n; I++) {
          for (d = h, u = E, C = 0; C < s; C++) e[I][C] && (c[u] |= d), d >>= 1, d || (d = 128, u++);
          E += o;
        }
        break;
      case 2:
        for (I = 0; I < n; I++) {
          for (d = h, u = E, C = 0; C < s; C++) e[I][C] && (c[u] ^= d), d >>= 1, d || (d = 128, u++);
          E += o;
        }
        break;
      default:
        throw new SA(`operator ${r} is not supported`);
    }
  }
  onImmediateGenericRegion(t, e, i, s) {
    const n = t.info, o = new bn(e, i, s), r = jr(t.mmr, n.width, n.height, t.template, t.prediction, null, t.at, o);
    this.drawBitmap(n, r);
  }
  onImmediateLosslessGenericRegion() {
    this.onImmediateGenericRegion(...arguments);
  }
  onSymbolDictionary(t, e, i, s, n, o) {
    let r, c;
    t.huffman && (r = (function(d, u, E) {
      let p, y, b, D, S = 0;
      switch (d.huffmanDHSelector) {
        case 0:
        case 1:
          p = ls(d.huffmanDHSelector + 4);
          break;
        case 3:
          p = _s(S, u, E), S++;
          break;
        default:
          throw new SA("invalid Huffman DH selector");
      }
      switch (d.huffmanDWSelector) {
        case 0:
        case 1:
          y = ls(d.huffmanDWSelector + 2);
          break;
        case 3:
          y = _s(S, u, E), S++;
          break;
        default:
          throw new SA("invalid Huffman DW selector");
      }
      return d.bitmapSizeSelector ? (b = _s(S, u, E), S++) : b = ls(1), D = d.aggregationInstancesSelector ? _s(S, u, E) : ls(1), { tableDeltaHeight: p, tableDeltaWidth: y, tableBitmapSize: b, tableAggregateInstances: D };
    })(t, i, this.customTables), c = new Jn(s, n, o));
    let h = this.symbols;
    h || (this.symbols = h = {});
    const I = [];
    for (const d of i) {
      const u = h[d];
      u && I.push(...u);
    }
    const C = new bn(s, n, o);
    h[e] = (function(d, u, E, p, y, b, D, S, R, x, N, U) {
      if (d && u) throw new SA("symbol refinement with Huffman is not supported");
      const T = [];
      let q = 0, _ = Pc(E.length + p);
      const Y = N.decoder, ht = N.contextCache;
      let ut, j;
      for (d && (ut = ls(1), j = [], _ = Math.max(_, 1)); T.length < p; ) {
        q += d ? b.tableDeltaHeight.decode(U) : Ie(ht, "IADH", Y);
        let M = 0, H = 0;
        const W = d ? j.length : 0;
        for (; ; ) {
          const lt = d ? b.tableDeltaWidth.decode(U) : Ie(ht, "IADW", Y);
          if (lt === null) break;
          let $;
          if (M += lt, H += M, u) {
            const ot = Ie(ht, "IAAI", Y);
            if (ot > 1) $ = MC(d, u, M, q, 0, ot, 1, E.concat(T), _, 0, 0, 1, 0, b, R, x, N, 0, U);
            else {
              const V = nE(ht, Y, _), rt = Ie(ht, "IARDX", Y), Bt = Ie(ht, "IARDY", Y);
              $ = rE(M, q, R, V < E.length ? E[V] : T[V - E.length], rt, Bt, 0, x, N);
            }
            T.push($);
          } else d ? j.push(M) : ($ = jr(!1, M, q, D, !1, null, S, N), T.push($));
        }
        if (d && !u) {
          const lt = b.tableBitmapSize.decode(U);
          let $;
          if (U.byteAlign(), lt === 0) $ = S3(U, H, q);
          else {
            const V = U.end, rt = U.position + lt;
            U.end = rt, $ = Mh(U, H, q, !1), U.end = V, U.position = rt;
          }
          const ot = j.length;
          if (W === ot - 1) T.push($);
          else {
            let V, rt, Bt, Rt, Ft, ft = 0;
            for (V = W; V < ot; V++) {
              for (Rt = j[V], Bt = ft + Rt, Ft = [], rt = 0; rt < q; rt++) Ft.push($[rt].subarray(ft, Bt));
              T.push(Ft), ft = Bt;
            }
          }
        }
      }
      const it = [], tt = [];
      let Z, st, dt = !1;
      const ct = E.length + p;
      for (; tt.length < ct; ) {
        let M = d ? ut.decode(U) : Ie(ht, "IAEX", Y);
        for (; M--; ) tt.push(dt);
        dt = !dt;
      }
      for (Z = 0, st = E.length; Z < st; Z++) tt[Z] && it.push(E[Z]);
      for (let M = 0; M < p; Z++, M++) tt[Z] && it.push(T[M]);
      return it;
    })(t.huffman, t.refinement, I, t.numberOfNewSymbols, t.numberOfExportedSymbols, r, t.template, t.at, t.refinementTemplate, t.refinementAt, C, c);
  }
  onImmediateTextRegion(t, e, i, s, n) {
    const o = t.info;
    let r, c;
    const h = this.symbols, I = [];
    for (const E of e) {
      const p = h[E];
      p && I.push(...p);
    }
    const C = Pc(I.length);
    t.huffman && (c = new Jn(i, s, n), r = (function(E, p, y, b, D) {
      const S = [];
      for (let _ = 0; _ <= 34; _++) {
        const Y = D.readBits(4);
        S.push(new Bs([_, Y, 0, 0]));
      }
      const R = new yo(S, !1);
      S.length = 0;
      for (let _ = 0; _ < b; ) {
        const Y = R.decode(D);
        if (Y >= 32) {
          let ht, ut, j;
          switch (Y) {
            case 32:
              if (_ === 0) throw new SA("no previous value in symbol ID table");
              ut = D.readBits(2) + 3, ht = S[_ - 1].prefixLength;
              break;
            case 33:
              ut = D.readBits(3) + 3, ht = 0;
              break;
            case 34:
              ut = D.readBits(7) + 11, ht = 0;
              break;
            default:
              throw new SA("invalid code length in symbol ID table");
          }
          for (j = 0; j < ut; j++) S.push(new Bs([_, ht, 0, 0])), _++;
        } else S.push(new Bs([_, Y, 0, 0])), _++;
      }
      D.byteAlign();
      const x = new yo(S, !1);
      let N, U, T, q = 0;
      switch (E.huffmanFS) {
        case 0:
        case 1:
          N = ls(E.huffmanFS + 6);
          break;
        case 3:
          N = _s(q, p, y), q++;
          break;
        default:
          throw new SA("invalid Huffman FS selector");
      }
      switch (E.huffmanDS) {
        case 0:
        case 1:
        case 2:
          U = ls(E.huffmanDS + 8);
          break;
        case 3:
          U = _s(q, p, y), q++;
          break;
        default:
          throw new SA("invalid Huffman DS selector");
      }
      switch (E.huffmanDT) {
        case 0:
        case 1:
        case 2:
          T = ls(E.huffmanDT + 11);
          break;
        case 3:
          T = _s(q, p, y), q++;
          break;
        default:
          throw new SA("invalid Huffman DT selector");
      }
      if (E.refinement) throw new SA("refinement with Huffman is not supported");
      return { symbolIDTable: x, tableFirstS: N, tableDeltaS: U, tableDeltaT: T };
    })(t, e, this.customTables, I.length, c));
    const d = new bn(i, s, n), u = MC(t.huffman, t.refinement, o.width, o.height, t.defaultPixelValue, t.numberOfSymbolInstances, t.stripSize, I, C, t.transposed, t.dsOffset, t.referenceCorner, t.combinationOperator, r, t.refinementTemplate, t.refinementAt, d, t.logStripSize, c);
    this.drawBitmap(o, u);
  }
  onImmediateLosslessTextRegion() {
    this.onImmediateTextRegion(...arguments);
  }
  onPatternDictionary(t, e, i, s, n) {
    let o = this.patterns;
    o || (this.patterns = o = {});
    const r = new bn(i, s, n);
    o[e] = (function(c, h, I, C, d, u) {
      const E = [];
      c || (E.push({ x: -h, y: 0 }), d === 0 && E.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 }));
      const p = jr(c, (C + 1) * h, I, d, !1, null, E, u), y = [];
      for (let b = 0; b <= C; b++) {
        const D = [], S = h * b, R = S + h;
        for (let x = 0; x < I; x++) D.push(p[x].subarray(S, R));
        y.push(D);
      }
      return y;
    })(t.mmr, t.patternWidth, t.patternHeight, t.maxPatternIndex, t.template, r);
  }
  onImmediateHalftoneRegion(t, e, i, s, n) {
    const o = this.patterns[e[0]], r = t.info, c = new bn(i, s, n), h = (function(I, C, d, u, E, p, y, b, D, S, R, x, N, U, T) {
      if (y) throw new SA("skip is not supported");
      if (b !== 0) throw new SA(`operator "${b}" is not supported in halftone region`);
      const q = [];
      let _, Y, ht;
      for (_ = 0; _ < E; _++) {
        if (ht = new Uint8Array(u), p) for (Y = 0; Y < u; Y++) ht[Y] = p;
        q.push(ht);
      }
      const ut = C.length, j = C[0], it = j[0].length, tt = j.length, Z = Pc(ut), st = [];
      I || (st.push({ x: d <= 1 ? 3 : 2, y: -1 }), d === 0 && st.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 }));
      const dt = [];
      let ct, M, H, W, lt, $, ot, V, rt, Bt, Rt;
      for (I && (ct = new Jn(T.data, T.start, T.end)), _ = Z - 1; _ >= 0; _--) M = I ? Mh(ct, D, S, !0) : jr(!1, D, S, d, !1, null, st, T), dt[_] = M;
      for (H = 0; H < S; H++) for (W = 0; W < D; W++) {
        for (lt = 0, $ = 0, Y = Z - 1; Y >= 0; Y--) lt ^= dt[Y][H][W], $ |= lt << Y;
        if (ot = C[$], V = R + H * U + W * N >> 8, rt = x + H * N - W * U >> 8, V >= 0 && V + it <= u && rt >= 0 && rt + tt <= E) for (_ = 0; _ < tt; _++) for (Rt = q[rt + _], Bt = ot[_], Y = 0; Y < it; Y++) Rt[V + Y] |= Bt[Y];
        else {
          let Ft, ft;
          for (_ = 0; _ < tt; _++) if (ft = rt + _, !(ft < 0 || ft >= E)) for (Rt = q[ft], Bt = ot[_], Y = 0; Y < it; Y++) Ft = V + Y, Ft >= 0 && Ft < u && (Rt[Ft] |= Bt[Y]);
        }
      }
      return q;
    })(t.mmr, o, t.template, r.width, r.height, t.defaultPixelValue, t.enableSkip, t.combinationOperator, t.gridWidth, t.gridHeight, t.gridOffsetX, t.gridOffsetY, t.gridVectorX, t.gridVectorY, c);
    this.drawBitmap(r, h);
  }
  onImmediateLosslessHalftoneRegion() {
    this.onImmediateHalftoneRegion(...arguments);
  }
  onTables(t, e, i, s) {
    let n = this.customTables;
    n || (this.customTables = n = {}), n[t] = (function(o, r, c) {
      const h = o[r], I = 4294967295 & bA(o, r + 1), C = 4294967295 & bA(o, r + 5), d = new Jn(o, r + 9, c), u = 1 + (h >> 1 & 7), E = 1 + (h >> 4 & 7), p = [];
      let y, b, D = I;
      do
        y = d.readBits(u), b = d.readBits(E), p.push(new Bs([D, y, b, 0])), D += 1 << b;
      while (D < C);
      return y = d.readBits(u), p.push(new Bs([I - 1, y, 32, 0, "lower"])), y = d.readBits(u), p.push(new Bs([C, y, 32, 0])), 1 & h && (y = d.readBits(u), p.push(new Bs([y, 0]))), new yo(p, !1);
    })(e, i, s);
  }
}
class Bs {
  constructor(t) {
    t.length === 2 ? (this.isOOB = !0, this.rangeLow = 0, this.prefixLength = t[0], this.rangeLength = 0, this.prefixCode = t[1], this.isLowerRange = !1) : (this.isOOB = !1, this.rangeLow = t[0], this.prefixLength = t[1], this.rangeLength = t[2], this.prefixCode = t[3], this.isLowerRange = t[4] === "lower");
  }
}
class jo {
  constructor(t) {
    this.children = [], t ? (this.isLeaf = !0, this.rangeLength = t.rangeLength, this.rangeLow = t.rangeLow, this.isLowerRange = t.isLowerRange, this.isOOB = t.isOOB) : this.isLeaf = !1;
  }
  buildTree(t, e) {
    const i = t.prefixCode >> e & 1;
    if (e <= 0) this.children[i] = new jo(t);
    else {
      let s = this.children[i];
      s || (this.children[i] = s = new jo(null)), s.buildTree(t, e - 1);
    }
  }
  decodeNode(t) {
    if (this.isLeaf) {
      if (this.isOOB) return null;
      const i = t.readBits(this.rangeLength);
      return this.rangeLow + (this.isLowerRange ? -i : i);
    }
    const e = this.children[t.readBit()];
    if (!e) throw new SA("invalid Huffman data");
    return e.decodeNode(t);
  }
}
class yo {
  constructor(t, e) {
    e || this.assignPrefixCodes(t), this.rootNode = new jo(null);
    for (let i = 0, s = t.length; i < s; i++) {
      const n = t[i];
      n.prefixLength > 0 && this.rootNode.buildTree(n, n.prefixLength - 1);
    }
  }
  decode(t) {
    return this.rootNode.decodeNode(t);
  }
  assignPrefixCodes(t) {
    const e = t.length;
    let i = 0;
    for (let I = 0; I < e; I++) i = Math.max(i, t[I].prefixLength);
    const s = new Uint32Array(i + 1);
    for (let I = 0; I < e; I++) s[t[I].prefixLength]++;
    let n, o, r, c = 1, h = 0;
    for (s[0] = 0; c <= i; ) {
      for (h = h + s[c - 1] << 1, n = h, o = 0; o < e; ) r = t[o], r.prefixLength === c && (r.prefixCode = n, n++), o++;
      c++;
    }
  }
}
const LC = {};
function ls(A) {
  let t, e = LC[A];
  if (e) return e;
  switch (A) {
    case 1:
      t = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
      break;
    case 2:
      t = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
      break;
    case 3:
      t = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
      break;
    case 4:
      t = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
      break;
    case 5:
      t = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
      break;
    case 6:
      t = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
      break;
    case 7:
      t = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
      break;
    case 8:
      t = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
      break;
    case 9:
      t = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
      break;
    case 10:
      t = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
      break;
    case 11:
      t = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 12:
      t = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
      break;
    case 13:
      t = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 14:
      t = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
      break;
    case 15:
      t = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
      break;
    default:
      throw new SA(`standard table B.${A} does not exist`);
  }
  for (let i = 0, s = t.length; i < s; i++) t[i] = new Bs(t[i]);
  return e = new yo(t, !0), LC[A] = e, e;
}
class Jn {
  constructor(t, e, i) {
    this.data = t, this.start = e, this.end = i, this.position = e, this.shift = -1, this.currentByte = 0;
  }
  readBit() {
    if (this.shift < 0) {
      if (this.position >= this.end) throw new SA("end of data while reading bit");
      this.currentByte = this.data[this.position++], this.shift = 7;
    }
    const t = this.currentByte >> this.shift & 1;
    return this.shift--, t;
  }
  readBits(t) {
    let e, i = 0;
    for (e = t - 1; e >= 0; e--) i |= this.readBit() << e;
    return i;
  }
  byteAlign() {
    this.shift = -1;
  }
  next() {
    return this.position >= this.end ? -1 : this.data[this.position++];
  }
}
function _s(A, t, e) {
  let i = 0;
  for (let s = 0, n = t.length; s < n; s++) {
    const o = e[t[s]];
    if (o) {
      if (A === i) return o;
      i++;
    }
  }
  throw new SA("can't find custom Huffman table");
}
function S3(A, t, e) {
  const i = [];
  for (let s = 0; s < e; s++) {
    const n = new Uint8Array(t);
    i.push(n);
    for (let o = 0; o < t; o++) n[o] = A.readBit();
    A.byteAlign();
  }
  return i;
}
function Mh(A, t, e, i) {
  const s = new aE(A, { K: -1, Columns: t, Rows: e, BlackIs1: !0, EndOfBlock: i }), n = [];
  let o, r = !1;
  for (let c = 0; c < e; c++) {
    const h = new Uint8Array(t);
    n.push(h);
    let I = -1;
    for (let C = 0; C < t; C++) I < 0 && (o = s.readNextChar(), o === -1 && (o = 0, r = !0), I = 7), h[C] = o >> I & 1, I--;
  }
  if (i && !r)
    for (let h = 0; h < 5 && s.readNextChar() !== -1; h++) ;
  return n;
}
class F3 {
  parseChunks(t) {
    return (function(e) {
      const i = new k3();
      for (let s = 0, n = e.length; s < n; s++) {
        const o = e[s];
        D3(w3({}, o.data, o.start, o.end), i);
      }
      return i.buffer;
    })(t);
  }
  parse(t) {
    throw new Error("Not implemented: Jbig2Image.parse");
  }
}
class R3 extends Be {
  constructor(t, e, i) {
    super(e), this.stream = t, this.dict = t.dict, this.maybeLength = e, this.params = i;
  }
  get bytes() {
    return bt(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(t) {
  }
  readBlock() {
    this.decodeImage();
  }
  decodeImage(t) {
    if (this.eof) return this.buffer;
    t ||= this.bytes;
    const e = new F3(), i = [];
    if (this.params instanceof z) {
      const o = this.params.get("JBIG2Globals");
      if (o instanceof AA) {
        const r = o.getBytes();
        i.push({ data: r, start: 0, end: r.length });
      }
    }
    i.push({ data: t, start: 0, end: t.length });
    const s = e.parseChunks(i), n = s.length;
    for (let o = 0; o < n; o++) s[o] ^= 255;
    return this.buffer = s, this.bufferLength = n, this.eof = !0, this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
}
function x3(A) {
  switch (A.kind) {
    case xo:
      return Lh(A);
    case _n:
      return (function({ src: t, srcPos: e = 0, dest: i, destPos: s = 0, width: n, height: o }) {
        let r = 0;
        const c = t.length >> 2, h = new Uint32Array(t.buffer, e, c);
        if (es.isLittleEndian) {
          for (; r < c - 2; r += 3, s += 4) {
            const I = h[r], C = h[r + 1], d = h[r + 2];
            i[s] = 4278190080 | I, i[s + 1] = I >>> 24 | C << 8 | 4278190080, i[s + 2] = C >>> 16 | d << 16 | 4278190080, i[s + 3] = d >>> 8 | 4278190080;
          }
          for (let I = 4 * r, C = t.length; I < C; I += 3) i[s++] = t[I] | t[I + 1] << 8 | t[I + 2] << 16 | 4278190080;
        } else {
          for (; r < c - 2; r += 3, s += 4) {
            const I = h[r], C = h[r + 1], d = h[r + 2];
            i[s] = 255 | I, i[s + 1] = I << 24 | C >>> 8 | 255, i[s + 2] = C << 16 | d >>> 16 | 255, i[s + 3] = d << 8 | 255;
          }
          for (let I = 4 * r, C = t.length; I < C; I += 3) i[s++] = t[I] << 24 | t[I + 1] << 16 | t[I + 2] << 8 | 255;
        }
        return { srcPos: e, destPos: s };
      })(A);
  }
  return null;
}
function Lh({ src: A, srcPos: t = 0, dest: e, width: i, height: s, nonBlackColor: n = 4294967295, inverseDecode: o = !1 }) {
  const r = es.isLittleEndian ? 4278190080 : 255, [c, h] = o ? [n, r] : [r, n], I = i >> 3, C = 7 & i, d = A.length;
  e = new Uint32Array(e.buffer);
  let u = 0;
  for (let E = 0; E < s; E++) {
    for (const y = t + I; t < y; t++) {
      const b = t < d ? A[t] : 255;
      e[u++] = 128 & b ? h : c, e[u++] = 64 & b ? h : c, e[u++] = 32 & b ? h : c, e[u++] = 16 & b ? h : c, e[u++] = 8 & b ? h : c, e[u++] = 4 & b ? h : c, e[u++] = 2 & b ? h : c, e[u++] = 1 & b ? h : c;
    }
    if (C === 0) continue;
    const p = t < d ? A[t++] : 255;
    for (let y = 0; y < C; y++) e[u++] = p & 1 << 7 - y ? h : c;
  }
  return { srcPos: t, destPos: u };
}
class bi extends de {
  constructor(t) {
    super(t, "JpegError");
  }
}
class Uh extends de {
  constructor(t, e) {
    super(t, "DNLMarkerError"), this.scanLines = e;
  }
}
class oE extends de {
  constructor(t) {
    super(t, "EOIMarkerError");
  }
}
const Wn = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), Zr = 4017, Vr = 799, Xr = 3406, zr = 2276, $r = 1567, to = 3784, Da = 5793, Ao = 2896;
function N3(A, t) {
  let e, i, s = 0, n = 16;
  for (; n > 0 && !A[n - 1]; ) n--;
  const o = [{ children: [], index: 0 }];
  let r, c = o[0];
  for (e = 0; e < n; e++) {
    for (i = 0; i < A[e]; i++) {
      for (c = o.pop(), c.children[c.index] = t[s]; c.index > 0; ) c = o.pop();
      for (c.index++, o.push(c); o.length <= e; ) o.push(r = { children: [], index: 0 }), c.children[c.index] = r.children, c = r;
      s++;
    }
    e + 1 < n && (o.push(r = { children: [], index: 0 }), c.children[c.index] = r.children, c = r);
  }
  return o[0].children;
}
function Hh(A, t, e) {
  return 64 * ((A.blocksPerLine + 1) * t + e);
}
function G3(A, t, e, i, s, n, o, r, c, h = !1) {
  const I = e.mcusPerLine, C = e.progressive, d = t;
  let u = 0, E = 0;
  function p() {
    if (E > 0) return E--, u >> E & 1;
    if (u = A[t++], u === 255) {
      const M = A[t++];
      if (M) {
        if (M === 220 && h) {
          const H = TA(A, t += 2);
          if (t += 2, H > 0 && H !== e.scanLines) throw new Uh("Found DNL marker (0xFFDC) while parsing scan data", H);
        } else if (M === 217) {
          if (h) {
            const H = N * (e.precision === 8 ? 8 : 0);
            if (H > 0 && Math.round(e.scanLines / H) >= 5) throw new Uh("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", H);
          }
          throw new oE("Found EOI marker (0xFFD9) while parsing scan data");
        }
        throw new bi(`unexpected marker ${(u << 8 | M).toString(16)}`);
      }
    }
    return E = 7, u >>> 7;
  }
  function y(M) {
    let H = M;
    for (; ; ) {
      switch (H = H[p()], typeof H) {
        case "number":
          return H;
        case "object":
          continue;
      }
      throw new bi("invalid huffman sequence");
    }
  }
  function b(M) {
    let H = 0;
    for (; M > 0; ) H = H << 1 | p(), M--;
    return H;
  }
  function D(M) {
    if (M === 1) return p() === 1 ? 1 : -1;
    const H = b(M);
    return H >= 1 << M - 1 ? H : H + (-1 << M) + 1;
  }
  let S = 0, R, x = 0, N = 0;
  function U(M, H, W, lt, $) {
    const ot = W % I;
    N = (W / I | 0) * M.v + lt;
    const V = ot * M.h + $;
    H(M, Hh(M, N, V));
  }
  function T(M, H, W) {
    N = W / M.blocksPerLine | 0;
    const lt = W % M.blocksPerLine;
    H(M, Hh(M, N, lt));
  }
  const q = i.length;
  let _, Y, ht, ut, j, it;
  it = C ? n === 0 ? r === 0 ? function(M, H) {
    const W = y(M.huffmanTableDC), lt = W === 0 ? 0 : D(W) << c;
    M.blockData[H] = M.pred += lt;
  } : function(M, H) {
    M.blockData[H] |= p() << c;
  } : r === 0 ? function(M, H) {
    if (S > 0) return void S--;
    let W = n;
    const lt = o;
    for (; W <= lt; ) {
      const $ = y(M.huffmanTableAC), ot = 15 & $, V = $ >> 4;
      if (ot === 0) {
        if (V < 15) {
          S = b(V) + (1 << V) - 1;
          break;
        }
        W += 16;
        continue;
      }
      W += V;
      const rt = Wn[W];
      M.blockData[H + rt] = D(ot) * (1 << c), W++;
    }
  } : function(M, H) {
    let W = n;
    const lt = o;
    let $, ot, V = 0;
    for (; W <= lt; ) {
      const rt = H + Wn[W], Bt = M.blockData[rt] < 0 ? -1 : 1;
      switch (x) {
        case 0:
          if (ot = y(M.huffmanTableAC), $ = 15 & ot, V = ot >> 4, $ === 0) V < 15 ? (S = b(V) + (1 << V), x = 4) : (V = 16, x = 1);
          else {
            if ($ !== 1) throw new bi("invalid ACn encoding");
            R = D($), x = V ? 2 : 3;
          }
          continue;
        case 1:
        case 2:
          M.blockData[rt] ? M.blockData[rt] += Bt * (p() << c) : (V--, V === 0 && (x = x === 2 ? 3 : 0));
          break;
        case 3:
          M.blockData[rt] ? M.blockData[rt] += Bt * (p() << c) : (M.blockData[rt] = R << c, x = 0);
          break;
        case 4:
          M.blockData[rt] && (M.blockData[rt] += Bt * (p() << c));
      }
      W++;
    }
    x === 4 && (S--, S === 0 && (x = 0));
  } : function(M, H) {
    const W = y(M.huffmanTableDC), lt = W === 0 ? 0 : D(W);
    M.blockData[H] = M.pred += lt;
    let $ = 1;
    for (; $ < 64; ) {
      const ot = y(M.huffmanTableAC), V = 15 & ot, rt = ot >> 4;
      if (V === 0) {
        if (rt < 15) break;
        $ += 16;
        continue;
      }
      $ += rt;
      const Bt = Wn[$];
      M.blockData[H + Bt] = D(V), $++;
    }
  };
  let tt, Z = 0;
  const st = q === 1 ? i[0].blocksPerLine * i[0].blocksPerColumn : I * e.mcusPerColumn;
  let dt, ct;
  for (; Z <= st; ) {
    const M = s ? Math.min(st - Z, s) : st;
    if (M > 0) {
      for (Y = 0; Y < q; Y++) i[Y].pred = 0;
      if (S = 0, q === 1) for (_ = i[0], j = 0; j < M; j++) T(_, it, Z), Z++;
      else for (j = 0; j < M; j++) {
        for (Y = 0; Y < q; Y++) for (_ = i[Y], dt = _.h, ct = _.v, ht = 0; ht < ct; ht++) for (ut = 0; ut < dt; ut++) U(_, it, Z, ht, ut);
        Z++;
      }
    }
    if (E = 0, tt = Jh(A, t), !tt || (tt.invalid && (O(`decodeScan - ${M > 0 ? "unexpected" : "excessive"} MCU data, current marker is: ${tt.invalid}`), t = tt.offset), !(tt.marker >= 65488 && tt.marker <= 65495))) break;
    t += 2;
  }
  return t - d;
}
function v3(A, t, e) {
  const i = A.quantizationTable, s = A.blockData;
  let n, o, r, c, h, I, C, d, u, E, p, y, b, D, S, R, x;
  if (!i) throw new bi("missing required Quantization Table.");
  for (let N = 0; N < 64; N += 8) u = s[t + N], E = s[t + N + 1], p = s[t + N + 2], y = s[t + N + 3], b = s[t + N + 4], D = s[t + N + 5], S = s[t + N + 6], R = s[t + N + 7], u *= i[N], E | p | y | b | D | S | R ? (E *= i[N + 1], p *= i[N + 2], y *= i[N + 3], b *= i[N + 4], D *= i[N + 5], S *= i[N + 6], R *= i[N + 7], n = Da * u + 128 >> 8, o = Da * b + 128 >> 8, r = p, c = S, h = Ao * (E - R) + 128 >> 8, d = Ao * (E + R) + 128 >> 8, I = y << 4, C = D << 4, n = n + o + 1 >> 1, o = n - o, x = r * to + c * $r + 128 >> 8, r = r * $r - c * to + 128 >> 8, c = x, h = h + C + 1 >> 1, C = h - C, d = d + I + 1 >> 1, I = d - I, n = n + c + 1 >> 1, c = n - c, o = o + r + 1 >> 1, r = o - r, x = h * zr + d * Xr + 2048 >> 12, h = h * Xr - d * zr + 2048 >> 12, d = x, x = I * Vr + C * Zr + 2048 >> 12, I = I * Zr - C * Vr + 2048 >> 12, C = x, e[N] = n + d, e[N + 7] = n - d, e[N + 1] = o + C, e[N + 6] = o - C, e[N + 2] = r + I, e[N + 5] = r - I, e[N + 3] = c + h, e[N + 4] = c - h) : (x = Da * u + 512 >> 10, e[N] = x, e[N + 1] = x, e[N + 2] = x, e[N + 3] = x, e[N + 4] = x, e[N + 5] = x, e[N + 6] = x, e[N + 7] = x);
  for (let N = 0; N < 8; ++N) u = e[N], E = e[N + 8], p = e[N + 16], y = e[N + 24], b = e[N + 32], D = e[N + 40], S = e[N + 48], R = e[N + 56], E | p | y | b | D | S | R ? (n = Da * u + 2048 >> 12, o = Da * b + 2048 >> 12, r = p, c = S, h = Ao * (E - R) + 2048 >> 12, d = Ao * (E + R) + 2048 >> 12, I = y, C = D, n = 4112 + (n + o + 1 >> 1), o = n - o, x = r * to + c * $r + 2048 >> 12, r = r * $r - c * to + 2048 >> 12, c = x, h = h + C + 1 >> 1, C = h - C, d = d + I + 1 >> 1, I = d - I, n = n + c + 1 >> 1, c = n - c, o = o + r + 1 >> 1, r = o - r, x = h * zr + d * Xr + 2048 >> 12, h = h * Xr - d * zr + 2048 >> 12, d = x, x = I * Vr + C * Zr + 2048 >> 12, I = I * Zr - C * Vr + 2048 >> 12, C = x, u = n + d, R = n - d, E = o + C, S = o - C, p = r + I, D = r - I, y = c + h, b = c - h, u < 16 ? u = 0 : u >= 4080 ? u = 255 : u >>= 4, E < 16 ? E = 0 : E >= 4080 ? E = 255 : E >>= 4, p < 16 ? p = 0 : p >= 4080 ? p = 255 : p >>= 4, y < 16 ? y = 0 : y >= 4080 ? y = 255 : y >>= 4, b < 16 ? b = 0 : b >= 4080 ? b = 255 : b >>= 4, D < 16 ? D = 0 : D >= 4080 ? D = 255 : D >>= 4, S < 16 ? S = 0 : S >= 4080 ? S = 255 : S >>= 4, R < 16 ? R = 0 : R >= 4080 ? R = 255 : R >>= 4, s[t + N] = u, s[t + N + 8] = E, s[t + N + 16] = p, s[t + N + 24] = y, s[t + N + 32] = b, s[t + N + 40] = D, s[t + N + 48] = S, s[t + N + 56] = R) : (x = Da * u + 8192 >> 14, x = x < -2040 ? 0 : x >= 2024 ? 255 : x + 2056 >> 4, s[t + N] = x, s[t + N + 8] = x, s[t + N + 16] = x, s[t + N + 24] = x, s[t + N + 32] = x, s[t + N + 40] = x, s[t + N + 48] = x, s[t + N + 56] = x);
}
function M3(A, t) {
  const e = t.blocksPerLine, i = t.blocksPerColumn, s = new Int16Array(64);
  for (let n = 0; n < i; n++) for (let o = 0; o < e; o++)
    v3(t, Hh(t, n, o), s);
  return t.blockData;
}
function Jh(A, t, e = t) {
  const i = A.length - 1;
  let s = e < t ? e : t;
  if (t >= i) return null;
  const n = TA(A, t);
  if (n >= 65472 && n <= 65534) return { invalid: null, marker: n, offset: t };
  let o = TA(A, s);
  for (; !(o >= 65472 && o <= 65534); ) {
    if (++s >= i) return null;
    o = TA(A, s);
  }
  return { invalid: n.toString(16), marker: o, offset: s };
}
class L3 {
  constructor({ decodeTransform: t = null, colorTransform: e = -1 } = {}) {
    this._decodeTransform = t, this._colorTransform = e;
  }
  parse(t, { dnlScanLines: e = null } = {}) {
    function i() {
      const p = TA(t, r);
      r += 2;
      let y = r + p - 2;
      const b = Jh(t, y, r);
      b?.invalid && (O("readDataBlock - incorrect length, current marker is: " + b.invalid), y = b.offset);
      const D = t.subarray(r, y);
      return r += D.length, D;
    }
    function s(p) {
      const y = Math.ceil(p.samplesPerLine / 8 / p.maxH), b = Math.ceil(p.scanLines / 8 / p.maxV);
      for (const D of p.components) {
        const S = Math.ceil(Math.ceil(p.samplesPerLine / 8) * D.h / p.maxH), R = Math.ceil(Math.ceil(p.scanLines / 8) * D.v / p.maxV), x = y * D.h, N = 64 * (b * D.v) * (x + 1);
        D.blockData = new Int16Array(N), D.blocksPerLine = S, D.blocksPerColumn = R;
      }
      p.mcusPerLine = y, p.mcusPerColumn = b;
    }
    let n, o, r = 0, c = null, h = null, I = 0;
    const C = [], d = [], u = [];
    let E = TA(t, r);
    if (r += 2, E !== 65496) throw new bi("SOI not found");
    E = TA(t, r), r += 2;
    t: for (; E !== 65497; ) {
      let p, y, b;
      switch (E) {
        case 65504:
        case 65505:
        case 65506:
        case 65507:
        case 65508:
        case 65509:
        case 65510:
        case 65511:
        case 65512:
        case 65513:
        case 65514:
        case 65515:
        case 65516:
        case 65517:
        case 65518:
        case 65519:
        case 65534:
          const D = i();
          E === 65504 && D[0] === 74 && D[1] === 70 && D[2] === 73 && D[3] === 70 && D[4] === 0 && (c = { version: { major: D[5], minor: D[6] }, densityUnits: D[7], xDensity: D[8] << 8 | D[9], yDensity: D[10] << 8 | D[11], thumbWidth: D[12], thumbHeight: D[13], thumbData: D.subarray(14, 14 + 3 * D[12] * D[13]) }), E === 65518 && D[0] === 65 && D[1] === 100 && D[2] === 111 && D[3] === 98 && D[4] === 101 && (h = { version: D[5] << 8 | D[6], flags0: D[7] << 8 | D[8], flags1: D[9] << 8 | D[10], transformCode: D[11] });
          break;
        case 65499:
          const S = TA(t, r);
          r += 2;
          const R = S + r - 2;
          let x;
          for (; r < R; ) {
            const st = t[r++], dt = new Uint16Array(64);
            if (st >> 4) {
              if (st >> 4 != 1) throw new bi("DQT - invalid table spec");
              for (y = 0; y < 64; y++) x = Wn[y], dt[x] = TA(t, r), r += 2;
            } else for (y = 0; y < 64; y++) x = Wn[y], dt[x] = t[r++];
            C[15 & st] = dt;
          }
          break;
        case 65472:
        case 65473:
        case 65474:
          if (n) throw new bi("Only single frame JPEGs supported");
          r += 2, n = {}, n.extended = E === 65473, n.progressive = E === 65474, n.precision = t[r++];
          const N = TA(t, r);
          r += 2, n.scanLines = e || N, n.samplesPerLine = TA(t, r), r += 2, n.components = [], n.componentIds = {};
          const U = t[r++];
          let T = 0, q = 0;
          for (p = 0; p < U; p++) {
            const st = t[r], dt = t[r + 1] >> 4, ct = 15 & t[r + 1];
            T < dt && (T = dt), q < ct && (q = ct);
            const M = t[r + 2];
            b = n.components.push({ h: dt, v: ct, quantizationId: M, quantizationTable: null }), n.componentIds[st] = b - 1, r += 3;
          }
          n.maxH = T, n.maxV = q, s(n);
          break;
        case 65476:
          const _ = TA(t, r);
          for (r += 2, p = 2; p < _; ) {
            const st = t[r++], dt = new Uint8Array(16);
            let ct = 0;
            for (y = 0; y < 16; y++, r++) ct += dt[y] = t[r];
            const M = new Uint8Array(ct);
            for (y = 0; y < ct; y++, r++) M[y] = t[r];
            p += 17 + ct, (st >> 4 ? d : u)[15 & st] = N3(dt, M);
          }
          break;
        case 65501:
          r += 2, o = TA(t, r), r += 2;
          break;
        case 65498:
          const Y = ++I == 1 && !e;
          r += 2;
          const ht = t[r++], ut = [];
          for (p = 0; p < ht; p++) {
            const st = t[r++], dt = n.componentIds[st], ct = n.components[dt];
            ct.index = st;
            const M = t[r++];
            ct.huffmanTableDC = u[M >> 4], ct.huffmanTableAC = d[15 & M], ut.push(ct);
          }
          const j = t[r++], it = t[r++], tt = t[r++];
          try {
            const st = G3(t, r, n, ut, o, j, it, tt >> 4, 15 & tt, Y);
            r += st;
          } catch (st) {
            if (st instanceof Uh) return O(`${st.message} -- attempting to re-parse the JPEG image.`), this.parse(t, { dnlScanLines: st.scanLines });
            if (st instanceof oE) {
              O(`${st.message} -- ignoring the rest of the image data.`);
              break t;
            }
            throw st;
          }
          break;
        case 65500:
          r += 4;
          break;
        case 65535:
          t[r] !== 255 && r--;
          break;
        default:
          const Z = Jh(t, r - 2, r - 3);
          if (Z?.invalid) {
            O("JpegImage.parse - unexpected data, current marker is: " + Z.invalid), r = Z.offset;
            break;
          }
          if (!Z || r >= t.length - 1) {
            O("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
            break t;
          }
          throw new bi("JpegImage.parse - unknown marker: " + E.toString(16));
      }
      E = TA(t, r), r += 2;
    }
    if (!n) throw new bi("JpegImage.parse - no frame data found.");
    this.width = n.samplesPerLine, this.height = n.scanLines, this.jfif = c, this.adobe = h, this.components = [];
    for (const p of n.components) {
      const y = C[p.quantizationId];
      y && (p.quantizationTable = y), this.components.push({ index: p.index, output: M3(0, p), scaleX: p.h / n.maxH, scaleY: p.v / n.maxV, blocksPerLine: p.blocksPerLine, blocksPerColumn: p.blocksPerColumn });
    }
    this.numComponents = this.components.length;
  }
  _getLinearizedBlockData(t, e, i = !1) {
    const s = this.width / t, n = this.height / e;
    let o, r, c, h, I, C, d, u, E, p, y, b = 0;
    const D = this.components.length, S = t * e * D, R = new Uint8ClampedArray(S), x = new Uint32Array(t), N = 4294967288;
    let U;
    for (d = 0; d < D; d++) {
      if (o = this.components[d], r = o.scaleX * s, c = o.scaleY * n, b = d, y = o.output, h = o.blocksPerLine + 1 << 3, r !== U) {
        for (I = 0; I < t; I++) u = 0 | I * r, x[I] = (u & N) << 3 | 7 & u;
        U = r;
      }
      for (C = 0; C < e; C++) for (u = 0 | C * c, p = h * (u & N) | (7 & u) << 3, I = 0; I < t; I++) R[b] = y[p + x[I]], b += D;
    }
    let T = this._decodeTransform;
    if (i || D !== 4 || T || (T = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), T) for (d = 0; d < S; ) for (u = 0, E = 0; u < D; u++, d++, E += 2) R[d] = (R[d] * T[E] >> 8) + T[E + 1];
    return R;
  }
  get _isColorConversionNeeded() {
    return this.adobe ? !!this.adobe.transformCode : this.numComponents === 3 ? this._colorTransform !== 0 && (this.components[0].index !== 82 || this.components[1].index !== 71 || this.components[2].index !== 66) : this._colorTransform === 1;
  }
  _convertYccToRgb(t) {
    let e, i, s;
    for (let n = 0, o = t.length; n < o; n += 3) e = t[n], i = t[n + 1], s = t[n + 2], t[n] = e - 179.456 + 1.402 * s, t[n + 1] = e + 135.459 - 0.344 * i - 0.714 * s, t[n + 2] = e - 226.816 + 1.772 * i;
    return t;
  }
  _convertYccToRgba(t, e) {
    for (let i = 0, s = 0, n = t.length; i < n; i += 3, s += 4) {
      const o = t[i], r = t[i + 1], c = t[i + 2];
      e[s] = o - 179.456 + 1.402 * c, e[s + 1] = o + 135.459 - 0.344 * r - 0.714 * c, e[s + 2] = o - 226.816 + 1.772 * r, e[s + 3] = 255;
    }
    return e;
  }
  _convertYcckToRgb(t) {
    let e, i, s, n, o = 0;
    for (let r = 0, c = t.length; r < c; r += 4) e = t[r], i = t[r + 1], s = t[r + 2], n = t[r + 3], t[o++] = i * (-660635669420364e-19 * i + 437130475926232e-18 * s - 54080610064599e-18 * e + 48449797120281e-17 * n - 0.154362151871126) - 122.67195406894 + s * (-957964378445773e-18 * s + 817076911346625e-18 * e - 0.00477271405408747 * n + 1.53380253221734) + e * (961250184130688e-18 * e - 0.00266257332283933 * n + 0.48357088451265) + n * (-336197177618394e-18 * n + 0.484791561490776), t[o++] = 107.268039397724 + i * (219927104525741e-19 * i - 640992018297945e-18 * s + 659397001245577e-18 * e + 426105652938837e-18 * n - 0.176491792462875) + s * (-778269941513683e-18 * s + 0.00130872261408275 * e + 770482631801132e-18 * n - 0.151051492775562) + e * (0.00126935368114843 * e - 0.00265090189010898 * n + 0.25802910206845) + n * (-318913117588328e-18 * n - 0.213742400323665), t[o++] = i * (-570115196973677e-18 * i - 263409051004589e-19 * s + 0.0020741088115012 * e - 0.00288260236853442 * n + 0.814272968359295) - 20.810012546947 + s * (-153496057440975e-19 * s - 132689043961446e-18 * e + 560833691242812e-18 * n - 0.195152027534049) + e * (0.00174418132927582 * e - 0.00255243321439347 * n + 0.116935020465145) + n * (-343531996510555e-18 * n + 0.24165260232407);
    return t.subarray(0, o);
  }
  _convertYcckToRgba(t) {
    for (let e = 0, i = t.length; e < i; e += 4) {
      const s = t[e], n = t[e + 1], o = t[e + 2], r = t[e + 3];
      t[e] = n * (-660635669420364e-19 * n + 437130475926232e-18 * o - 54080610064599e-18 * s + 48449797120281e-17 * r - 0.154362151871126) - 122.67195406894 + o * (-957964378445773e-18 * o + 817076911346625e-18 * s - 0.00477271405408747 * r + 1.53380253221734) + s * (961250184130688e-18 * s - 0.00266257332283933 * r + 0.48357088451265) + r * (-336197177618394e-18 * r + 0.484791561490776), t[e + 1] = 107.268039397724 + n * (219927104525741e-19 * n - 640992018297945e-18 * o + 659397001245577e-18 * s + 426105652938837e-18 * r - 0.176491792462875) + o * (-778269941513683e-18 * o + 0.00130872261408275 * s + 770482631801132e-18 * r - 0.151051492775562) + s * (0.00126935368114843 * s - 0.00265090189010898 * r + 0.25802910206845) + r * (-318913117588328e-18 * r - 0.213742400323665), t[e + 2] = n * (-570115196973677e-18 * n - 263409051004589e-19 * o + 0.0020741088115012 * s - 0.00288260236853442 * r + 0.814272968359295) - 20.810012546947 + o * (-153496057440975e-19 * o - 132689043961446e-18 * s + 560833691242812e-18 * r - 0.195152027534049) + s * (0.00174418132927582 * s - 0.00255243321439347 * r + 0.116935020465145) + r * (-343531996510555e-18 * r + 0.24165260232407), t[e + 3] = 255;
    }
    return t;
  }
  _convertYcckToCmyk(t) {
    let e, i, s;
    for (let n = 0, o = t.length; n < o; n += 4) e = t[n], i = t[n + 1], s = t[n + 2], t[n] = 434.456 - e - 1.402 * s, t[n + 1] = 119.541 - e + 0.344 * i + 0.714 * s, t[n + 2] = 481.816 - e - 1.772 * i;
    return t;
  }
  _convertCmykToRgb(t) {
    let e, i, s, n, o = 0;
    for (let r = 0, c = t.length; r < c; r += 4) e = t[r], i = t[r + 1], s = t[r + 2], n = t[r + 3], t[o++] = 255 + e * (-6747147073602441e-20 * e + 8379262121013727e-19 * i + 2894718188643294e-19 * s + 0.003264231057537806 * n - 1.1185611867203937) + i * (26374107616089405e-21 * i - 8626949158638572e-20 * s - 2748769067499491e-19 * n - 0.02155688794978967) + s * (-3878099212869363e-20 * s - 3267808279485286e-19 * n + 0.0686742238595345) - n * (3361971776183937e-19 * n + 0.7430659151342254), t[o++] = 255 + e * (13596372813588848e-20 * e + 924537132573585e-18 * i + 10567359618683593e-20 * s + 4791864687436512e-19 * n - 0.3109689587515875) + i * (-23545346108370344e-20 * i + 2702845253534714e-19 * s + 0.0020200308977307156 * n - 0.7488052167015494) + s * (6834815998235662e-20 * s + 15168452363460973e-20 * n - 0.09751927774728933) - n * (3189131175883281e-19 * n + 0.7364883807733168), t[o++] = 255 + e * (13598650411385307e-21 * e + 12423956175490851e-20 * i + 4751985097583589e-19 * s - 36729317476630422e-22 * n - 0.05562186980264034) + i * (16141380598724676e-20 * i + 9692239130725186e-19 * s + 7782692450036253e-19 * n - 0.44015232367526463) + s * (5068882914068769e-22 * s + 0.0017778369011375071 * n - 0.7591454649749609) - n * (3435319965105553e-19 * n + 0.7063770186160144);
    return t.subarray(0, o);
  }
  _convertCmykToRgba(t) {
    for (let e = 0, i = t.length; e < i; e += 4) {
      const s = t[e], n = t[e + 1], o = t[e + 2], r = t[e + 3];
      t[e] = 255 + s * (-6747147073602441e-20 * s + 8379262121013727e-19 * n + 2894718188643294e-19 * o + 0.003264231057537806 * r - 1.1185611867203937) + n * (26374107616089405e-21 * n - 8626949158638572e-20 * o - 2748769067499491e-19 * r - 0.02155688794978967) + o * (-3878099212869363e-20 * o - 3267808279485286e-19 * r + 0.0686742238595345) - r * (3361971776183937e-19 * r + 0.7430659151342254), t[e + 1] = 255 + s * (13596372813588848e-20 * s + 924537132573585e-18 * n + 10567359618683593e-20 * o + 4791864687436512e-19 * r - 0.3109689587515875) + n * (-23545346108370344e-20 * n + 2702845253534714e-19 * o + 0.0020200308977307156 * r - 0.7488052167015494) + o * (6834815998235662e-20 * o + 15168452363460973e-20 * r - 0.09751927774728933) - r * (3189131175883281e-19 * r + 0.7364883807733168), t[e + 2] = 255 + s * (13598650411385307e-21 * s + 12423956175490851e-20 * n + 4751985097583589e-19 * o - 36729317476630422e-22 * r - 0.05562186980264034) + n * (16141380598724676e-20 * n + 9692239130725186e-19 * o + 7782692450036253e-19 * r - 0.44015232367526463) + o * (5068882914068769e-22 * o + 0.0017778369011375071 * r - 0.7591454649749609) - r * (3435319965105553e-19 * r + 0.7063770186160144), t[e + 3] = 255;
    }
    return t;
  }
  getData({ width: t, height: e, forceRGBA: i = !1, forceRGB: s = !1, isSourcePDF: n = !1 }) {
    if (this.numComponents > 4) throw new bi("Unsupported color mode");
    const o = this._getLinearizedBlockData(t, e, n);
    if (this.numComponents === 1 && (i || s)) {
      const r = o.length * (i ? 4 : 3), c = new Uint8ClampedArray(r);
      let h = 0;
      if (i) (function(I, C) {
        if (es.isLittleEndian) for (let d = 0, u = I.length; d < u; d++) C[d] = 65793 * I[d] | 4278190080;
        else for (let d = 0, u = I.length; d < u; d++) C[d] = 16843008 * I[d] | 255;
      })(o, new Uint32Array(c.buffer));
      else for (const I of o) c[h++] = I, c[h++] = I, c[h++] = I;
      return c;
    }
    if (this.numComponents === 3 && this._isColorConversionNeeded) {
      if (i) {
        const r = new Uint8ClampedArray(o.length / 3 * 4);
        return this._convertYccToRgba(o, r);
      }
      return this._convertYccToRgb(o);
    }
    if (this.numComponents === 4) {
      if (this._isColorConversionNeeded) return i ? this._convertYcckToRgba(o) : s ? this._convertYcckToRgb(o) : this._convertYcckToCmyk(o);
      if (i) return this._convertCmykToRgba(o);
      if (s) return this._convertCmykToRgb(o);
    }
    return o;
  }
}
class wl extends Be {
  constructor(t, e, i) {
    super(e), this.stream = t, this.dict = t.dict, this.maybeLength = e, this.params = i;
  }
  get bytes() {
    return bt(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(t) {
  }
  readBlock() {
    this.decodeImage();
  }
  decodeImage(t) {
    if (this.eof) return this.buffer;
    t ||= this.bytes;
    for (let o = 0, r = t.length - 1; o < r; o++) if (t[o] === 255 && t[o + 1] === 216) {
      o > 0 && (t = t.subarray(o));
      break;
    }
    const e = { decodeTransform: void 0, colorTransform: void 0 }, i = this.dict.getArray("D", "Decode");
    if ((this.forceRGBA || this.forceRGB) && Array.isArray(i)) {
      const o = this.dict.get("BPC", "BitsPerComponent") || 8, r = i.length, c = new Int32Array(r);
      let h = !1;
      const I = (1 << o) - 1;
      for (let C = 0; C < r; C += 2) c[C] = 256 * (i[C + 1] - i[C]) | 0, c[C + 1] = i[C] * I | 0, c[C] === 256 && c[C + 1] === 0 || (h = !0);
      h && (e.decodeTransform = c);
    }
    if (this.params instanceof z) {
      const o = this.params.get("ColorTransform");
      Number.isInteger(o) && (e.colorTransform = o);
    }
    const s = new L3(e);
    s.parse(t);
    const n = s.getData({ width: this.drawWidth, height: this.drawHeight, forceRGBA: this.forceRGBA, forceRGB: this.forceRGB, isSourcePDF: !0 });
    return this.buffer = n, this.bufferLength = n.length, this.eof = !0, this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
}
var _c, U3 = (_c = typeof document < "u" ? document.currentScript?.src : void 0, function(A = {}) {
  var t, e, i = A;
  new Promise(((M, H) => {
    t = M, e = H;
  })), i.decode = function(M, { numComponents: H = 4, isIndexedColormap: W = !1, smaskInData: lt = !1 }) {
    const $ = M.length, ot = i._malloc($);
    i.HEAPU8.set(M, ot);
    const V = i._jp2_decode(ot, $, H > 0 ? H : 0, !!W, !!lt);
    if (i._free(ot), V) {
      const { errorMessages: Bt } = i;
      return Bt ? (delete i.errorMessages, Bt) : "Unknown error";
    }
    const { imageData: rt } = i;
    return i.imageData = null, rt;
  };
  var s = Object.assign({}, i), n = "./this.program", o = "";
  typeof document < "u" && document.currentScript && (o = document.currentScript.src), _c && (o = _c), o = o.startsWith("blob:") ? "" : o.substr(0, o.replace(/[?#].*/, "").lastIndexOf("/") + 1);
  var r, c, h, I, C, d = i.print || console.log.bind(console), u = i.printErr || console.error.bind(console);
  function E(M) {
    if (U(M)) return (function(H) {
      for (var W = atob(H), lt = new Uint8Array(W.length), $ = 0; $ < W.length; ++$) lt[$] = W.charCodeAt($);
      return lt;
    })(M.slice(N.length));
  }
  function p() {
    var M = c.buffer;
    i.HEAP8 = h = new Int8Array(M), i.HEAP16 = new Int16Array(M), i.HEAPU8 = I = new Uint8Array(M), i.HEAPU16 = new Uint16Array(M), i.HEAP32 = new Int32Array(M), i.HEAPU32 = C = new Uint32Array(M), i.HEAPF32 = new Float32Array(M), i.HEAPF64 = new Float64Array(M);
  }
  Object.assign(i, s), s = null, i.arguments && i.arguments, i.thisProgram && (n = i.thisProgram), i.quit && i.quit, i.wasmBinary && (r = i.wasmBinary);
  var y, b = [], D = [], S = [], R = 0, x = null, N = "data:application/octet-stream;base64,", U = (M) => M.startsWith(N);
  function T(M, H) {
    var W, lt = (function($) {
      if ($ == y && r) return new Uint8Array(r);
      var ot = E($);
      if (ot) return ot;
      throw 'sync fetching of the wasm failed: you can preload it to Module["wasmBinary"] manually, or emcc.py will do that for you when generating HTML (but not JS)';
    })(M);
    return W = new WebAssembly.Module(lt), [new WebAssembly.Instance(W, H), W];
  }
  var q = (M) => {
    for (; M.length > 0; ) M.shift()(i);
  };
  i.noExitRuntime;
  var _, Y = (M) => {
    var H = (M - c.buffer.byteLength + 65535) / 65536;
    try {
      return c.grow(H), p(), 1;
    } catch {
    }
  }, ht = {}, ut = () => {
    if (!ut.strings) {
      var M = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: n || "./this.program" };
      for (var H in ht) ht[H] === void 0 ? delete M[H] : M[H] = ht[H];
      var W = [];
      for (var H in M) W.push(`${H}=${M[H]}`);
      ut.strings = W;
    }
    return ut.strings;
  }, j = [null, [], []], it = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0, tt = (M, H, W) => {
    for (var lt = H + W, $ = H; M[$] && !($ >= lt); ) ++$;
    if ($ - H > 16 && M.buffer && it) return it.decode(M.subarray(H, $));
    for (var ot = ""; H < $; ) {
      var V = M[H++];
      if (128 & V) {
        var rt = 63 & M[H++];
        if ((224 & V) != 192) {
          var Bt = 63 & M[H++];
          if ((V = (240 & V) == 224 ? (15 & V) << 12 | rt << 6 | Bt : (7 & V) << 18 | rt << 12 | Bt << 6 | 63 & M[H++]) < 65536) ot += String.fromCharCode(V);
          else {
            var Rt = V - 65536;
            ot += String.fromCharCode(55296 | Rt >> 10, 56320 | 1023 & Rt);
          }
        } else ot += String.fromCharCode((31 & V) << 6 | rt);
      } else ot += String.fromCharCode(V);
    }
    return ot;
  }, Z = (M, H) => M ? tt(I, M, H) : "", st = { c: (M, H, W) => I.copyWithin(M, H, H + W), g: function(M, H) {
    M >>= 2;
    const W = i.imageData = new Uint8ClampedArray(H), lt = i.HEAP32.subarray(M, M + H);
    W.set(lt);
  }, f: function(M, H, W, lt) {
    M >>= 2, H >>= 2, W >>= 2;
    const $ = i.imageData = new Uint8ClampedArray(3 * lt), ot = i.HEAP32.subarray(M, M + lt), V = i.HEAP32.subarray(H, H + lt), rt = i.HEAP32.subarray(W, W + lt);
    for (let Bt = 0; Bt < lt; Bt++) $[3 * Bt] = ot[Bt], $[3 * Bt + 1] = V[Bt], $[3 * Bt + 2] = rt[Bt];
  }, e: function(M, H, W, lt, $) {
    M >>= 2, H >>= 2, W >>= 2, lt >>= 2;
    const ot = i.imageData = new Uint8ClampedArray(4 * $), V = i.HEAP32.subarray(M, M + $), rt = i.HEAP32.subarray(H, H + $), Bt = i.HEAP32.subarray(W, W + $), Rt = i.HEAP32.subarray(lt, lt + $);
    for (let Ft = 0; Ft < $; Ft++) ot[4 * Ft] = V[Ft], ot[4 * Ft + 1] = rt[Ft], ot[4 * Ft + 2] = Bt[Ft], ot[4 * Ft + 3] = Rt[Ft];
  }, k: (M) => {
    var H = I.length, W = 2147483648;
    if ((M >>>= 0) > W) return !1;
    for (var lt, $, ot = 1; ot <= 4; ot *= 2) {
      var V = H * (1 + 0.2 / ot);
      V = Math.min(V, M + 100663296);
      var rt = Math.min(W, (lt = Math.max(M, V)) + (($ = 65536) - lt % $) % $);
      if (Y(rt)) return !0;
    }
    return !1;
  }, l: (M, H) => {
    var W = 0;
    return ut().forEach(((lt, $) => {
      var ot = H + W;
      C[M + 4 * $ >> 2] = ot, ((V, rt) => {
        for (var Bt = 0; Bt < V.length; ++Bt) h[rt++] = V.charCodeAt(Bt);
        h[rt] = 0;
      })(lt, ot), W += lt.length + 1;
    })), 0;
  }, m: (M, H) => {
    var W = ut();
    C[M >> 2] = W.length;
    var lt = 0;
    return W.forEach((($) => lt += $.length + 1)), C[H >> 2] = lt, 0;
  }, n: (M) => 52, j: function(M, H, W, lt, $) {
    return 70;
  }, b: (M, H, W, lt) => {
    for (var $, ot, V, rt = 0, Bt = 0; Bt < W; Bt++) {
      var Rt = C[H >> 2], Ft = C[H + 4 >> 2];
      H += 8;
      for (var ft = 0; ft < Ft; ft++) $ = M, ot = I[Rt + ft], V = void 0, V = j[$], ot === 0 || ot === 10 ? (($ === 1 ? d : u)(tt(V, 0)), V.length = 0) : V.push(ot);
      rt += Ft;
    }
    return C[lt >> 2] = rt, 0;
  }, o: function(M, H) {
    M >>= 2;
    const W = i.imageData = new Uint8ClampedArray(4 * H), lt = i.HEAP32.subarray(M, M + H);
    for (let $ = 0; $ < H; $++) W[4 * $] = W[4 * $ + 1] = W[4 * $ + 2] = lt[$], W[4 * $ + 3] = 255;
  }, i: function(M, H, W) {
    M >>= 2, H >>= 2;
    const lt = i.imageData = new Uint8ClampedArray(4 * W), $ = i.HEAP32.subarray(M, M + W), ot = i.HEAP32.subarray(H, H + W);
    for (let V = 0; V < W; V++) lt[4 * V] = lt[4 * V + 1] = lt[4 * V + 2] = $[V], lt[4 * V + 3] = ot[V];
  }, d: function(M) {
    const H = Z(M);
    (i.warn || console.warn)(`OpenJPEG: ${H}`);
  }, h: function(M, H, W, lt) {
    M >>= 2, H >>= 2, W >>= 2;
    const $ = i.imageData = new Uint8ClampedArray(4 * lt), ot = i.HEAP32.subarray(M, M + lt), V = i.HEAP32.subarray(H, H + lt), rt = i.HEAP32.subarray(W, W + lt);
    for (let Bt = 0; Bt < lt; Bt++) $[4 * Bt] = ot[Bt], $[4 * Bt + 1] = V[Bt], $[4 * Bt + 2] = rt[Bt], $[4 * Bt + 3] = 255;
  }, a: function(M) {
    const H = Z(M);
    i.errorMessages ? i.errorMessages += `
` + H : i.errorMessages = H;
  } }, dt = (function() {
    var M = { a: st };
    function H(W, lt) {
      var $;
      return dt = W.exports, c = dt.p, p(), $ = dt.q, D.unshift($), (function() {
        if (R--, i.monitorRunDependencies?.(R), R == 0 && x) {
          var ot = x;
          x = null, ot();
        }
      })(), dt;
    }
    if (R++, i.monitorRunDependencies?.(R), i.instantiateWasm) try {
      return i.instantiateWasm(M, H);
    } catch (W) {
      u(`Module.instantiateWasm callback failed with error: ${W}`), e(W);
    }
    return y || (y = "data:application/octet-stream;base64,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A0kNAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgACADQQRrIgRLBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAswAQF/AkAgAEUNACABRQ0AQQggACABbCIBECUiAARAIABBACABEBUaCyAAIQILIAILEQAgAEUEQEEADwtBCCAAECUL8gICAn8BfgJAIAJFDQAgACABOgAAIAAgAmoiA0EBayABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBA2sgAToAACADQQJrIAE6AAAgAkEHSQ0AIAAgAToAAyADQQRrIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBBGsgATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQQhrIAE2AgAgAkEMayABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkEQayABNgIAIAJBFGsgATYCACACQRhrIAE2AgAgAkEcayABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa1CgYCAgBB+IQUgAyAEaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQSBrIgJBH0sNAAsLIAALJwEBfyMAQRBrIgMkACADIAI2AgwgACABIAJBAEEAEGsgA0EQaiQAC+gFAQl/IAFFBEBBAA8LAn8gAEUE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ACAEIE5BCmpBAiAFEBpBAkcEQCAFQQFBAiAAKAK4ARtBlhJBABAPIAAoArgBRSFnDAELIE5BCmogTkEMakECEBEgTigCDCIBQZD/A0YNACABQdn/A0YEQCAAQYACNgIIIABBADYCzAEMAQsgBCkDCCKGAVAEfkIABSCGASAEKQM4fQtQBEAgAEHAADYCCCAFQQJBrD9BABAPDAELQQAhZyAFQQFB7D5BABAPCyBOQRBqJAAgZwsLACAABEAgABAQCwu0AQEBfyAAKAIMRQRAIAIgACgCJCABEQMADwsCQEEIEBQiA0UNACADIAI2AgQgAyABNgIAQQgQFCIBRQRAIAMQEA8LIAEgAzYCACAAIAAoAgRB5ABsIgI2AigDQCAAKAIYIAJKDQALIAEgACgCFDYCBCAAIAE2AhQgACAAKAIYQQFqNgIYIAAoAhwiAUUNACABKAIAQQA2AgggACABKAIENgIcIAAgACgCIEEBazYCICABEBALC/oCAQR/AkAgAEUNACAAKAKsKCIBBEAgACgCqCgiAgRAQQAhAQNAIAAoAqwoIAFBA3RqKAIAIgMEQCADEBAgACgCqCghAgsgAUEBaiIBIAJJDQALIAAoAqwoIQELIABBADYCqCggARAQIABBADYCrCgLIAAoArQoIgEEQCABEBAgAEEANgK0KAsgACgC0CsiAQRAIAEQECAAQQA2AtArCyAAKALsKyIBBEAgARAQIABBADYC7CsLIAAoAugrIgEEQCABEBAgAEEANgLoKwsgACgC/CsiAQRAIAEQECAAQQA2AoQsIABCADcC/CsLIAAoAvArIgEEQCAAKAL0KyIDBH9BACECA0AgASgCDCIEBEAgBBAQIAFBADYCDCAAKAL0KyEDCyABQRRqIQEgAkEBaiICIANJDQALIAAoAvArBSABCxAQIABBADYC8CsLIAAoAuQrIgEEQCABEBAgAEEANgLkKwsgACgC3CsiAUUNACABEBAgAEIANwLcKwsLyAcCEX8BfiAAKAIQIghBIE8EQCAAKQMIpw8LAkAgACgCFCIDQQROBEAgACgCACICQQNrKAIAIQEgACADQQRrIgM2AhQgACACQQRrNgIADAELIANBAEwEQAwBCyADQQFxIQ0gACgCACECAkAgA0EBRgRAQRghBAwBCyADQf7///8HcSEJQRghBANAIAAgAkEB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IABBADYCiAEgACgCZBAQIABBADYCZCAALQC8AUECcUUEQCAAKAKoARAQCyAAQdAAakEAQfAAEBUaIAAoAsABEDIgAEEANgLAASAAKALEARAyIABBADYCwAEgACgCyAEiAQRAIAEoAhwiAgRAIAIQECABQQA2AhwLIAEoAigiAgRAIAEoAiQEQANAIAIgBUEobCIDaigCJCIEBEAgBBAQIAEoAigiAiADakEANgIkCyACIANqKAIQIgQEQCAEEBAgASgCKCICIANqQQA2AhALIAIgA2ooAhgiBARAIAQQECABKAIoIgIgA2pBADYCGAsgBUEBaiIFIAEoAiRJDQALCyACEBAgAUEANgIoCyABEBALIABBADYCyAEgACgCSBAhIABBADYCSCAAKAJMECEgAEEANgJMIAAoAtQBIgMEQAJAIAMoAghFDQAgAygCDARAIANBADYCKANAIAMoAhhBAEoNAAsLIANBATYCECADKAIAEBAgAygCHCICRQ0AA0AgAigCBCEBIAIQECADIAE2AhwgASICDQALCyADKAIkIgIEQCACKAIEIgVBAEoEQEEAIQEDQCACKAIAIAFBDGxqIgQoAggiBgRAIAQoAgQgBhECACACKAIEIQULIAFBAWoiASAFSA0ACwsgAigCABAQIAIQEAsgAxAQCyAAQQA2AtQBIAAQEAsL5gMCCH8EfiAAKAIUKAIAKAIUIAFBzABsaiIJKAIMIgggACgCGCgCGCABQTRsaiIKNQIEIhBCAX0iEiAANQI8fCAQgKciCyAIIAtJGyEMIAkoAggiCCAKNQIAIhFCAX0iEyAANQI4fCARgKciCiAIIApJGyEKIAkoAgQiCCASIAA1AjR8IBCApyILIAggC0sbIQsgCSgCACIIIBMgADUCMHwgEYCnIg0gCCANSxshDUEAIQggACgCICgC0CsgAUG4CGxqKAIUIQ4CQCAJKAIUQQAgAmtBfyACG2oiAkUEQCAKIQAgDSEIIAshAQwBCyADQQFxIAJBAWsiD3QiCSANSQRAIA0gCWutQn8gAq0iEIZCf4V8IBCIpyEIC0EAIQBBACEBIANBAXYgD3QiAyALSQRAIAsgA2utQn8gAq0iEIZCf4V8IBCIpyEBCyAJIApJBEAgCiAJa61CfyACrSIQhkJ/hXwgEIinIQALIAMgDE8EQEEAIQwMAQsgDCADa61CfyACrSIQhkJ/hXwgEIinIQwLQX8gAEECQQMgDkEBRhsiAmoiAyAAIANLGyAES0F/IAIgDGoiACAAIAxJGyAFS3EgCCACayIAQQAgACAITRsgBklxIAEgAmsiAEEAIAAgAU0bIAdJcQuiAQEGfyAABEAgACgCBCICBEAgAhAQIABBADYCBAsgAQRAIAAhAgNAIAIoAsgBIgMEQEEAIQUgAigCxAEiBAR/A0AgAygCDCIGBEAgBhAQIANBADYCDCACKALEASEECyADQRBqIQMgBUEBaiIFIARJDQALIAIoAsgBBSADCxAQIAJBADYCyAELIAJB8AFqIQIgB0EBaiIHIAFHDQALCyAAEBALC9UZAhN/A3sgACgCACIKIAAoAgwiDUEFdCIFaiEGIAogBWshFiAAKAIQIQUgACgCHCELIAAoAhQhCSAAKAIIIQ4CQAJAAkACQCADQQhJDQAgAUEPcQ0AIAZBD3FFDQELIAUgCU8NAgJAAkAgA0EBaw4CAAEDCwJAIAkgBWsiCEEYSQ0AIAEgBUECdGohByANQQV0IgQgCiAFQQZ0amogASAJQQJ0akkEQCAHIAogCUEGdGogBGpBPGtJDQELIAX9Ef0MAAAAAAEAAAACAAAAAwAAAP2uASEYIAUgCEF8cSIPaiEFQQAhBANAIAYgGEEE/asBIhf9GwBBAnRqIAcgBEECdGr9AAIAIhn9HwA4AgAgBiAX/RsBQQJ0aiAZ/R8BOAIAIAYgF/0bAkECdGogGf0fAjgCACAGIBf9GwNBAnRqIBn9HwM4AgAgGP0MBAAAAAQAAAAEAAAABAAAAP2uASEYIARBBGoiBCAPRw0ACyAIIA9GDQQLIAUhBCAJIAVrQQNxIgcEQEEAIQgDQCAGIARBBnRqIAEgBEECdGoqAgA4AgAgBEEBaiEEIAhBAWoiCCAHRw0ACwsgBSAJa0F8Sw0DA0AgBiAEQQZ0aiABIARBAnRqKgIAOAIAIAYgBEEBaiIFQQZ0aiABIAVBAnRqKgIAOAIAIAYgBEECaiIFQQZ0aiABIAVBAnRqKgIAOAIAIAYgBEEDaiIFQQZ0aiABIAVBAnRqKgIAOAIAIARBBGoiBCAJRw0ACwwDCyABIAJBAnRqIQgCQCAJIAVrIg9BPEkEQCAFIQQMAQsgCiAFQQZ0IA1BBXRqaiIEIAkgBUF/c2oiB0EGdCIQaiAESQRAIAUhBAwBCyAEQQRqIgQgEGogBEkEQCAFIQQMAQsgB0H///8fSwRAIAUhBAwBCyANQQV0IgQgCiAFQQZ0amoiByABIAIgCWpBAnRqSSAKIAlBBnRqIARqQThrIgQgASACIAVqQQJ0aktxBEAgBSEEDAELIAcgASAJQQJ0akkgASAFQQJ0aiAESXEEQCAFIQQMAQsgBf0R/QwAAAAAAQAAAAIAAAADAAAA/a4BIRggBSAPQXxxIhBqIQRBACEHA0AgBiAYQQT9qwEiF/0bAEECdGoiESABIAUgB2pBAnQiDGr9AAIAIhn9HwA4AgAgBiAX/RsBQQJ0aiITIBn9HwE4AgAgBiAX/RsCQQJ0aiIUIBn9HwI4AgAgBiAX/RsDQQJ0aiIVIBn9HwM4AgAgESAIIAxq/QACACIX/R8AOAIEIBMgF/0fATgCBCAUIBf9HwI4AgQgFSAX/R8DOAIEIBj9DAQAAAAEAAAABAAAAAQAAAD9rgEhGCAHQQRqIgcgEEcNAAsgDyAQRg0DCyAEQQFqIQUgCSAEa0EBcQRAIAYgBEEGdGoiByABIARBAnQiBGoqAgA4AgAgByAEIAhqKgIAOAIEIAUhBAsgBSAJRg0CA0AgBiAEQQZ0aiIFIAEgBEECdCIHaioCADgCACAFIAcgCGoqAgA4AgQgBiAEQQFqIgVBBnRqIgcgASAFQQJ0IgVqKgIAOAIAIAcgBSAIaioCADgCBCAEQQJqIgQgCUcNAAsMAgsgBSAJTw0BIAEgAkECdGohCANAIAYgBUEGdGoiBCABIAVBAnRqKgIAOAIAIAQgASACIAVqIgdBAnRqKgIAOAIEIAQgASACIAdqIgdBAnRqKgIAOAIIIAQgASACIAdqIgdBAnRqKgIAOAIMIAQgASACIAdqIgdBAnRqKgIAOAIQIAQgASACIAdqIgdBAnRqKgIAOAIUIAQgASACIAdqQQJ0IgdqKgIAOAIYIAQgByAIaioCADgCHCAFQQFqIgUgCUcNAAsMAQsgASACQQJ0aiEIIANBA0YhByADQQRGIQ8gA0EFRiEQIANBB0YhEQNAIAYgBUEGdGoiBCABIAVBAnRqKgIAOAIAIAQgASACIAVqIgxBAnRqKgIAOAIEIAQgASACIAxqIgxBAnRqKgIAOAIIAkAgBw0AIAQgASACIAxqIgxBAnRqKgIAOAIMIA8NACAEIAEgAiAMaiIMQQJ0aioCADgCECAQDQAgBCABIAIgDGoiDEECdGoqAgA4AhQgA0EGRg0AIAQgASACIAxqQQJ0IgxqKgIAOAIYIBENACAEIAggDGoqAgA4AhwLIAVBAWoiBSAJRw0ACwsgFkEgaiEGIAEgDkECdGohBCAAKAIYIQUCQAJAAkAgA0EISQ0AIARBD3ENACAGQQ9xRQ0BCyAFIAtPDQECQAJAAkAgA0EBaw4CAAECCwJAIAsgBWsiAEEcSQ0AIAogBUEGdEEgciANQQV0IgJraiABIAsgDmpBAnRqSQRAIAEgBSAOakECdGogC0EGdCACayAKakEca0kNAQsgBCAFQQJ0aiEDIAX9Ef0MAAAAAAEAAAACAAAAAwAAAP2uASEYIAUgAEF8cSIBaiEFQQAhAgNAIAYgGEEE/asBIhf9GwBBAnRqIAMgAkECdGr9AAIAIhn9HwA4AgAgBiAX/RsBQQJ0aiAZ/R8BOAIAIAYgF/0bAkECdGogGf0fAjgCACAGIBf9GwNBAnRqIBn9HwM4AgAgGP0MBAAAAAQAAAAEAAAABAAAAP2uASEYIAJBBGoiAiABRw0ACyAAIAFGDQQLIAUhAiALIAVrQQNxIgAEQEEAIQEDQCAGIAJBBnRqIAQgAkECdGoqAgA4AgAgAkEBaiECIAFBAWoiASAARw0ACwsgBSALa0F8Sw0DA0AgBiACQQZ0aiAEIAJBAnRqKgIAOAIAIAYgAkEBaiIAQQZ0aiAEIABBAnRqKgIAOAIAIAYgAkECaiIAQQZ0aiAEIABBAnRqKgIAOAIAIAYgAkEDaiIAQQZ0aiAEIABBAnRqKgIAOAIAIAJBBGoiAiALRw0ACwwDCyAEIAJBAnRqIQMCQCALIAVrIgBBxABJBEAgBSECDAELIAogBUEGdCIJQSByIA1BBXQiCGtqIgcgCyAFQX9zaiIPQQZ0IhBqIAdJBEAgBSECDAELIAogCUEkciAIa2oiCSAQaiAJSQRAIAUhAgwBCyAPQf///x9LBEAgBSECDAELIAogBUEGdEEgciANQQV0IglraiINIAEgCyAOaiIIIAJqQQJ0akkgC0EGdCAJayAKakEYayIJIAEgDkECdGogBUECdGoiCiACQQJ0aktxBEAgBSECDAELIA0gASAIQQJ0akkgCSAKS3EEQCAFIQIMAQsgBf0R/QwAAAAAAQAAAAIAAAADAAAA/a4BIRggBSAAQXxxIglqIQJBACEBA0AgBiAYQQT9qwEiF/0bAEECdGoiCiAEIAEgBWpBAnQiDWr9AAIAIhn9HwA4AgAgBiAX/RsBQQJ0aiIOIBn9HwE4AgAgBiAX/RsCQQJ0aiIIIBn9HwI4AgAgBiAX/RsDQQJ0aiIHIBn9HwM4AgAgCiADIA1q/QACACIX/R8AOAIEIA4gF/0fATgCBCAIIBf9HwI4AgQgByAX/R8DOAIEIBj9DAQAAAAEAAAABAAAAAQAAAD9rgEhGCABQQRqIgEgCUcNAAsgACAJRg0DCyACQQFqIQAgCyACa0EBcQRAIAYgAkEGdGoiASAEIAJBAnQiAmoqAgA4AgAgASACIANqKgIAOAIEIAAhAgsgACALRg0CA0AgBiACQQZ0aiIAIAQgAkECdCIBaioCADgCACAAIAEgA2oqAgA4AgQgBiACQQFqIgBBBnRqIgEgBCAAQQJ0IgBqKgIAOAIAIAEgACADaioCADgCBCACQQJqIgIgC0cNAAsMAgsgBCACQQJ0aiEBIANBA0YhCSADQQRGIQogA0EFRiENIANBB0YhDgNAIAYgBUEGdGoiACAEIAVBAnRqKgIAOAIAIAAgBCACIAVqIghBAnRqKgIAOAIEIAAgBCACIAhqIghBAnRqKgIAOAIIAkAgCQ0AIAAgBCACIAhqIghBAnRqKgIAOAIMIAoNACAAIAQgAiAIaiIIQQJ0aioCADgCECANDQAgACAEIAIgCGoiCEECdGoqAgA4AhQgA0EGRg0AIAAgBCACIAhqQQJ0IghqKgIAOAIYIA4NACAAIAEgCGoqAgA4AhwLIAVBAWoiBSALRw0ACwwBCyAFIAtPDQAgBCACQQJ0aiEBA0AgBiAFQQZ0aiIAIAQgBUECdGoqAgA4AgAgACAEIAIgBWoiA0ECdGoqAgA4AgQgACAEIAIgA2oiA0ECdGoqAgA4AgggACAEIAIgA2oiA0ECdGoqAgA4AgwgACAEIAIgA2oiA0ECdGoqAgA4AhAgACAEIAIgA2oiA0ECdGoqAgA4AhQgACAEIAIgA2pBAnQiA2oqAgA4AhggACABIANqKgIAOAIcIAVBAWoiBSALRw0ACwsLmwMBBH8gASAAQQRqIgRqQQFrQQAgAWtxIgUgAmogACAAKAIAIgFqQQRrTQR/IAAoAgQiAyAAKAIIIgY2AgggBiADNgIEIAQgBUcEQCAAIABBBGsoAgBBfnFrIgMgBSAEayIEIAMoAgBqIgU2AgAgAyAFQXxxakEEayAFNgIAIAAgBGoiACABIARrIgE2AgALAn8gASACQRhqTwRAIAAgAmpBCGoiAyABIAJrQQhrIgE2AgAgAyABQXxxakEEayABQQFyNgIAIAMCfyADKAIAQQhrIgFB/wBNBEAgAUEDdkEBawwBCyABZyEEIAFBHSAEa3ZBBHMgBEECdGtB7gBqIAFB/x9NDQAaQT8gAUEeIARrdkECcyAEQQF0a0HHAGoiASABQT9PGwsiAUEEdCIEQaDHAWo2AgQgAyAEQajHAWoiBCgCADYCCCAEIAM2AgAgAygCCCADNgIEQajPAUGozwEpAwBCASABrYaENwMAIAAgAkEIaiIBNgIAIAAgAUF8cWoMAQsgACABagtBBGsgATYCACAAQQRqBUEACwvCAQEDfwJAIAEgAigCECIDBH8gAwUgAhA+DQEgAigCEAsgAigCFCIEa0sEQCACIAAgASACKAIkEQAADwsCQAJAIAIoAlBBAEgNACABRQ0AIAEhAwNAIAAgA2oiBUEBay0AAEEKRwRAIANBAWsiAw0BDAILCyACIAAgAyACKAIkEQAAIgQgA0kNAiABIANrIQEgAigCFCEEDAELIAAhBUEAIQMLIAQgBSABEBIaIAIgAigCFCABajYCFCABIANqIQQLIAQLWQEBfyAAIAAoAkgiAUEBayABcjYCSCAAKAIAIgFBCHEEQCAAIAFBIHI2AgBBfw8LIABCADcCBCAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQQQALzAIBBH8gASAA/QACAP0LAgAgASgCGCICBEAgASgCECIDBH9BACECA0AgASgCGCACQTRsaigCLCIEBEAgBBAQIAEoAhAhAwsgAkEBaiICIANJDQALIAEoAhgFIAILEBAgAUEANgIYCyABIAAoAhAiAjYCECABIAJBNGwQFCICNgIYIAIEQCABKAIQBEBBACEDA0AgAiADQTRsIgVqIgIgACgCGCAFaiIE/QACAP0LAgAgAiAEKAIwNgIwIAIgBP0AAiD9CwIgIAIgBP0AAhD9CwIQIAEoAhgiAiAFakEANgIsIANBAWoiAyABKAIQSQ0ACwsgASAAKAIUNgIUIAEgACgCICICNgIgIAIEQCABIAIQFCICNgIcIAJFBEAgAUIANwIcDwsgAiAAKAIcIAAoAiAQEhoPCyABQQA2AhwPCyABQQA2AhAgAUEANgIYCwQAQQELxgEBA38DQCAAQQR0IgFBpMcBaiABQaDHAWoiAjYCACABQajHAWogAjYCACAAQQFqIgBBwABHDQALQTAQbRojAEEQayIAJAACQCAAQQxqIABBCGoQDA0AQbDPAUEIIAAoAgxBAnRBBGoQJSIBNgIAIAFFDQBBCCAAKAIIECUiAQRAQbDPASgCACICIAAoAgxBAnRqQQA2AgAgAiABEAtFDQELQbDPAUEANgIACyAAQRBqJABBzM8BQSo2AgBBlNABQdjQATYCAAuQBgIFfwN7IwBBEGsiBiQAAn8gACgCCEEQRgRAIAAoApwBIAAoAswBQYwsbGoMAQsgACgCDAshAAJAIAMoAgAiBUUEQEEAIQIgBEEBQcATQQAQDwwBCyAAKALQKyEJIAMgBUEBazYCACACIAZBDGpBARARIAkgAUG4CGxqIgcgBigCDCIAQQV2NgKkBiAHIABBH3EiATYCGCACQQFqIQAgAwJ/An8CQAJ/AkACQCABDgIAAwELIAMoAgAMAQsgAygCAEEBdgsiBUHiAE8EfyAGQuGAgICQDDcCBCAGIAU2AgAgBEECQcX4ACAGEA8gBygCGAUgAQsEQCAFIgENAUEADAILIAUEQCAHQRxqIQFBACECA0AgACAGQQxqQQEQESACQeAATQRAIAYoAgwhBCABIAJBA3RqIghBADYCBCAIIARBA3Y2AgALIABBAWohACACQQFqIgIgBUcNAAsLQQAhAiADKAIAIgAgBUkNAyAAIAVrDAILIAdBHGohBEEAIQIDQCAAIAZBDGpBAhARIAJB4ABNBEAgBCACQQN0aiIFIAYoAgwiCEH/D3E2AgQgBSAIQQt2NgIACyAAQQJqIQAgAkEBaiICIAFHDQALIAFBAXQLIQBBACECIAMoAgAiASAASQ0BIAEgAGsLNgIAQQEhAiAHKAIYQQFHDQAgB0EcaiEEIAf9CQIcIQwgBygCICED/QwBAAAAAgAAAAMAAAAEAAAAIQtBACEBA0AgBCABQQN0aiIAQRhqIAwgC/0M//////////////////////2uASIK/RsAQQNu/REgCv0bAUEDbv0cASAK/RsCQQNu/RwCIAr9GwNBA279HAP9sQH9DAAAAAAAAAAAAAAAAAAAAAD9uAEiCv1aAgACIABBEGogCv1aAgABIABBCGogCv1aAgAAIAQgAUEEaiIBQQN0aiIFIAr9WgIAAyAAIAM2AhwgACADNgIUIAAgAzYCDCAFIAM2AgQgC/0MBAAAAAQAAAAEAAAABAAAAP2uASELIAFB4ABHDQALCyAGQRBqJAAgAgufBgEGfyMAQSBrIgYkAAJ/IAAoAghBEEYEQCAAKAKcASAAKALMAUGMLGxqDAELIAAoAgwLIQUCQCADKAIAQQRNBEBBACEAIARBAUGdE0EAEA8MAQsgAiAFKALQKyABQbgIbGoiBSIJQQRqQQEQESAFIAUoAgRBAWoiBzYCBCAHQSJPBEAgBkEhNgIEIAYgBzYCACAEQQFB+TkgBhAPQQAhAAwBCyAHIAAoAqABIghNBEAgBiAHNgIYIAYgCDYCFCAGIAE2AhAgBEEBQbT7ACAGQRBqEA8gACAAKAIIQYCAAnI2AghBACEADAELIAJBAWogBUEIakEBEBEgBSAFKAIIQQJqNgIIIAJBAmogBUEMakEBEBEgBSAFKAIMQQJqIgA2AgwCQAJAIAUoAggiAUEKSw0AIABBCksNACAAIAFqQQ1JDQELQQAhACAEQQFBwylBABAPDAELIAJBA2ogBUEQakEBEBEgBS0AEEGAAXEEQEEAIQAgBEEBQYsyQQAQDwwBCyACQQRqIAVBFGpBARARIAUoAhRBAk8EQEEAIQAgBEEBQcoxQQAQDwwBCyADIAMoAgBBBWsiBzYCAEEBIQAgBSgCBCEBIAUtAABBAXFFBEAgAUUNASAFQbAHaiEBIAVBrAZqIQJBACEFA0AgAiAFQQJ0IgBqQQ82AgAgACABakEPNgIAQQEhACAFQQFqIgUgCSgCBEkNAAsMAQsgASAHTQRAAkAgAUUEQEEAIQEMAQsgAkEFaiAGQRxqQQEQESAFIAYoAhwiAEEEdjYCsAcgBSAAQQ9xNgKsBiAFKAIEIgFBAk8EQCAFQbAHaiEHIAVBrAZqIQggAkEGaiEAQQEhBQNAIAAgBkEcakEBEBECQCAGKAIcIgFBEE8EQCABQQ9xIgINAQtBACEAIARBAUHwLUEAEA8MBQsgCCAFQQJ0IgpqIAI2AgAgByAKaiABQQR2NgIAIABBAWohACAFQQFqIgUgCSgCBCIBSQ0ACwsgAygCACEHCyADIAcgAWs2AgBBASEADAELQQAhACAEQQFBnRNBABAPCyAGQSBqJAAgAAtSACABIAAtAAA6AAcgASAALQABOgAGIAEgAC0AAjoABSABIAAtAAM6AAQgASAALQAEOgADIAEgAC0ABToAAiABIAAtAAY6AAEgASAALQAHOgAAC5IBAQR/IAAgATYCoAECQCAAKAJIIgNFDQAgAygCGCIGRQ0AIAAoAgwiBEUNACAEKALQK0UNACADKAIQIgRFBEBBAQ8LQQAhAwNAIAEgACgCDCgC0CsgA0G4CGxqKAIETwRAIAJBAUGixQBBABAPQQAPCyAGIANBNGxqIAE2AihBASEFIANBAWoiAyAERw0ACwsgBQusBwIJfwh+IwBBEGsiCiQAAkAgAkUEQCADQQFB+tUAQQAQDwwBCyACKAIQIgsgACgCSCIGKAIQSQRAIANBAUG1zgBBABAPDAELIAQgACgCaCIFIAAoAmxsIgdPBEAgCiAENgIAIAogB0EBazYCBCADQQFB9/oAIAoQD0EAIQUMAQsgAiAAKAJUIAQgBSAEIAVuIgdsayIIIAAoAlxsaiIFNgIAIAIgBSAGKAIAIgYgBSAGSxsiBjYCACACIAAoAlQgACgCXCAIQQFqbGoiBTYCCCACIAUgACgCSCgCCCIIIAUgCEkbIgg2AgggAiAAKAJYIAAoAmAgB2xqIgU2AgQgAiAFIAAoAkgoAgQiCSAFIAlLGyIJNgIEIAIgACgCWCAAKAJgIAdBAWpsaiIFNgIMIAIgBSAAKAJIKAIMIgcgBSAHSRsiBTYCDCAAKAJIIgwoAhAiBwRAIAWsQgF9IREgCKxCAX0hEiAJrUIBfSETIAatQgF9IRQgDCgCGCEIIAIoAhghBUEAIQYDQCAFIAggBkE0bGooAigiCTYCKCAFIBQgBSgCACIMrSIOfCAOgCIVPgIQIAUgEyAFKAIEIg2tIg58IA6AIhA+AhQgBUJ/IAmtIg6GIg8gEMR9IA6HpyAPIBEgDawiEHwgEH/EfSAOh6drNgIMIAUgDyAVxH0gDoenIA8gEiAMrCIPfCAPf8R9IA6Hp2s2AgggBUE0aiEFIAZBAWoiBiAHRw0ACwsgByALSQRAIAIoAhghBQNAIAUgB0E0bCIGaigCLBAQIAIoAhgiBSAGakEANgIsIAdBAWoiByACKAIQSQ0ACyACIAAoAkgoAhA2AhALIAAoAkwiBQRAIAUQIQsgAEEBQSQQEyIHNgJMQQAhBSAHRQ0AIAIgBxA/IAAgBDYCLCAAKALAAUEXIAMQJEUNACAAKALAASIEKAIAIQYgBCgCCCEHAkAgBgRAQQEhBSAGQQFxIQsgBkEBRgR/QQAFIAZBfnEhCEEAIQYDQAJ/QQAgBUUNABpBACAAIAEgAyAHKAIAEQAARQ0AGiAAIAEgAyAHKAIEEQAAQQBHCyEFIAdBCGohByAGQQJqIgYgCEcNAAsgBUEBcwshBgJAAkAgCwRAIAYNASAAIAEgAyAHKAIAEQAAQQBHIQULIARBADYCACAFQQFxRQ0BDAMLIARBADYCAAsgACgCSBAhQQAhBSAAQQA2AkgMAgsgBEEANgIACyAAIAIQRyEFCyAKQRBqJAAgBQvyAwEFfwJAAkAgACgCPCICRQRAIAEoAhANAUEBDwsgAkE0bBAUIgVFDQEgASgCEARAIAEoAhghAgNAIAIgA0E0bCIEaigCLBAQIAEoAhgiAiAEakEANgIsIANBAWoiAyABKAIQIgRJDQALCyABIAAoAjwEfyAAKAJMKAIYIQNBACECA0AgBSACQTRsaiIEIAMgACgCQCACQQJ0aigCAEE0bCIGaiID/QACAP0LAgAgBCADKAIwNgIwIAQgA/0AAiD9CwIgIAQgA/0AAhD9CwIQIAQgACgCTCgCGCIDIAZqIgYoAiQ2AiQgBCAGKAIsNgIsIAZBADYCLCACQQFqIgIgACgCPCIGSQ0ACyABKAIQBSAECwR/IAAoAkwoAhghAkEAIQMDQCACIANBNGwiBGooAiwQECAAKAJMKAIYIgIgBGpBADYCLCADQQFqIgMgASgCEEkNAAsgACgCPAUgBgs2AhAgASgCGBAQIAEgBTYCGEEBDwsgASgCGCEEIAAoAkwoAhghA0EAIQIDQCAEIAJBNGwiBWoiBCADIAVqKAIkNgIkIAQoAiwQECABKAIYIgQgBWogACgCTCgCGCIDIAVqIgUoAiw2AiwgBUEANgIsIAJBAWoiAiABKAIQSQ0AC0EBDwsgACgCSBAhIABBADYCSEEAC84EAQh/AkAgAkUNAAJAIAAoAqABIgVFDQAgACgCSCIERQ0AIAQoAhBFDQAgBCgCGCgCKCAFRw0AIAIoAhAiCEUNACACKAIYIgYoAigNACAGKAIsDQBBACEEIAhBCE8EQCAIQXhxIQkDQCAGIARBNGxqIAU2AiggBiAEQQFyQTRsaiAFNgIoIAYgBEECckE0bGogBTYCKCAGIARBA3JBNGxqIAU2AiggBiAEQQRyQTRsaiAFNgIoIAYgBEEFckE0bGogBTYCKCAGIARBBnJBNGxqIAU2AiggBiAEQQdyQTRsaiAFNgIoIARBCGohBCAKQQhqIgogCUcNAAsLIAhBB3EiCARAA0AgBiAEQTRsaiAFNgIoIARBAWohBCALQQFqIgsgCEcNAAsLIAIgAxA3DQBBAA8LIAAoAkwiBUUEQCAAQQFBJBATIgU2AkwgBUUNAQsgAiAFED8gACgCwAFBFiADECRFDQAgACgCwAEiBigCACEEIAYoAgghBQJAIAQEQEEBIQcgBEEBcSEIIARBAUYEf0EABSAEQX5xIQlBACEEA0ACf0EAIAdFDQAaQQAgACABIAMgBSgCABEAAEUNABogACABIAMgBSgCBBEAAEEARwshByAFQQhqIQUgBEECaiIEIAlHDQALIAdBAXMLIQQCQAJAIAgEQCAEDQEgACABIAMgBSgCABEAAEEARyEHCyAGQQA2AgAgB0EBcUUNAQwDCyAGQQA2AgALIAAoAkgQISAAQQA2AkhBAA8LIAZBADYCAAsgACACEEchBwsgBwv4BAEGfwJAQQFBMBATIgIEfyACIAAoAsgBIgH9AAMA/QsDACACIAEpAxA3AxAgAiABKAIYIgE2AhggAiABQRhsEBQiATYCHCABRQRAIAIQEEEADwsCQCAAKALIASgCHCIDBEAgASADIAIoAhhBGGwQEhoMAQsgARAQIAJBADYCHAsgAiAAKALIASgCJCIBNgIkIAIgAUEoEBMiATYCKCABRQRAIAIoAhwQECACEBBBAA8LAkAgACgCyAEoAigEQCACKAIkRQ0BA0AgASAFQShsIgNqIAAoAsgBKAIoIANqKAIUIgE2AhQgAUEYbBAUIQEgAigCKCIEIANqIgYgATYCGCABRQRAIAUEf0EAIQEDQCACKAIoIAFBKGxqKAIYEBAgAUEBaiIBIAVHDQALIAIoAigFIAQLEBAMBQsCQCAAKALIASgCKCADaigCGCIEBEAgASAEIAYoAhRBGGwQEhogAigCKCEBDAELIAEQECACKAIoIgEgA2pBADYCGAsgASADaiAAKALIASgCKCADaigCBCIBNgIEIAFBGGwQFCEBIAIoAigiBCADaiIGIAE2AhAgAUUEQCAFBH9BACEBA0AgAUEobCIAIAIoAihqKAIYEBAgAigCKCAAaigCEBAQIAFBAWoiASAFRw0ACyACKAIoBSAECxAQDAULAkAgACgCyAEoAiggA2ooAhAiBARAIAEgBCAGKAIEQRhsEBIaIAIoAighAQwBCyABEBAgAigCKCIBIANqQQA2AhALIAEgA2pCADcCICAFQQFqIgUgAigCJEkNAAsMAQsgARAQIAJBADYCKAsgAgVBAAsPCyACKAIcEBAgAhAQQQALoAYCDn8BeyMAQRBrIggkACAAKAJIKAIQIQ0gCEEBQTgQEyIBNgIMAkAgAUUNACABIAAoAkgoAhAiCTYCGCABIAD9AAJU/QsCACABIAAoAmg2AhAgACgCbCECIAFBADYCNCABIAI2AhQgASAAKAIMIgwoAgA2AiAgASAMKAIENgIkIAEgDCgCCDYCKCABIAwoAhA2AiwgASAJQbgIEBMiADYCMCAABEAgDQRAA0AgDkG4CGwiACABKAIwaiIFIAwoAtArIABqIgT9AAIAIg/9CwIEIAUgBCgCEDYCFCAFIAQoAhQ2AhggD/0bASIAQSBNBEAgBUG0B2ogBEGwB2ogABASGiAFQbAGaiAEQawGaiAEKAIEEBIaCyAFIAQoAhgiADYCHCAFIAQoAqQGNgKoBkEBIQYCQCAAQQFHBEAgBCgCBEEDbCIAQQNrQd8ASw0BIABBAmshBgsgBUGkA2ohCSAFQSBqIQogBEEcaiELQQAhAAJAIAZBCEkNACAEIAZBA3RqQRxqIApLBEAgCyAFIAZBAnRqQaQDakkNAQsgBkF8cSEAQQAhAgNAIAogAkECdCIDaiALIAJBA3RqIgdBHGogB0EUaiAHQQxqIAf9CQIE/VYCAAH9VgIAAv1WAgAD/QsCACADIAlqIAdBGGogB0EQaiAHQQhqIAf9CQIA/VYCAAH9VgIAAv1WAgAD/QsCACACQQRqIgIgAEcNAAsgACAGRg0BCyAAQQFyIQMgBkEBcQRAIAogAEECdCICaiALIABBA3RqIgAoAgQ2AgAgAiAJaiAAKAIANgIAIAMhAAsgAyAGRg0AA0AgCiAAQQJ0IgJqIAsgAEEDdGoiAygCBDYCACACIAlqIAMoAgA2AgAgCiAAQQFqIgNBAnQiAmogCyADQQN0aiIDKAIENgIAIAIgCWogAygCADYCACAAQQJqIgAgBkcNAAsLIAUgBCgCqAY2AqwGIA5BAWoiDiANRw0ACwsgASEDDAELIAhBDGoEQCAIKAIMIgEoAjAiAAR/IAAQECAIKAIMBSABCxAQIAhBADYCDAsLIAhBEGokACADC/kEAQh/IwBBgAJrIgMkACAABEBB/AxBESACEB0gAyAAKAIANgLwASACQZoRIANB8AFqEBYgAyAAKAIENgLgASACQacRIANB4AFqEBYgAyAAKAIINgLQASACQYI3IANB0AFqEBYgAyAAKAIQNgLAASACQf0QIANBwAFqEBYgAUEASgRAA0AgACgC0CshBCADIAc2ArABIAJBog0gA0GwAWoQFiADIAQgB0G4CGxqIgQoAgA2AqABIAJBmREgA0GgAWoQFiADIAQoAgQ2ApABIAJB9DcgA0GQAWoQFiADIAQoAgg2AoABIAJBoDYgA0GAAWoQFiADIAQoAgw2AnAgAkGwNiADQfAAahAWIAMgBCgCEDYCYCACQYgRIANB4ABqEBYgAyAEKAIUNgJQIAJBtjggA0HQAGoQFkHVC0EXIAIQHSAEKAIEBEAgBEGwB2ohBiAEQawGaiEIQQAhBQNAIAggBUECdCIJaigCACEKIAMgBiAJaigCADYCRCADIAo2AkAgAkGLDCADQUBrEBYgBUEBaiIFIAQoAgRJDQALCyACEG4gAyAEKAIYNgIwIAJBwDYgA0EwahAWIAMgBCgCpAY2AiAgAkHxNiADQSBqEBZBASEGQe0LQRQgAhAdAkAgBCgCGEEBRwRAIAQoAgQiBUEATA0BIAVBA2xBAmshBgsgBEEcaiEIQQAhBQNAIAMgCCAFQQN0aikCAEIgiTcDECACQYsMIANBEGoQFiAFQQFqIgUgBkcNAAsLIAIQbiADIAQoAqgGNgIAIAJB4DYgAxAWQZkMQQUgAhAdIAdBAWoiByABRw0ACwtBmgxBBCACEB0LIANBgAJqJAAL5goDCX8BewF+IwBBsAFrIgUkAAJAIAFBgANxBEBBni1BCyACEB0MAQsCQCABQQFxRQ0AIAAoAkgiBkUNACMAQdAAayIDJABB7gxBDSACEB0gA0EAOgBPIANBCToATiADIAYpAgA3AkQgAyADQc4AaiIENgJAIAJBhjkgA0FAaxAWIAMgBikCCDcCNCADIAQ2AjAgAkH1OCADQTBqEBYgAyAGKAIQNgIkIAMgBDYCICACQZM3IANBIGoQFgJAIAYoAhhFDQAgBigCEEUNAANAIAMgA0HOAGoiCjYCECADIAc2AhQgAkGODSADQRBqEBYgBigCGCAHQTRsaiEIIwBBMGsiBCQAIARBCTsALiAEQQk6AC0gBCAIKQIANwIkIAQgBEEtaiIJNgIgIAJBzzYgBEEgahAWIAQgCCgCGDYCFCAEIAk2AhAgAkHFOCAEQRBqEBYgBCAIKAIgNgIEIAQgCTYCACACQao4IAQQFiAEQTBqJAAgAyAKNgIAIAJBlAwgAxAWIAdBAWoiByAGKAIQSQ0ACwtBnAxBAiACEB0gA0HQAGokAAsCQCABQQJxRQ0AIAAoAkhFDQBB+Q1BJCACEB0gBSAAKQJUNwOgASACQecRIAVBoAFqEBYgBSAAKQJcNwOQASACQcURIAVBkAFqEBYgBSAAKQNoNwOAASACQdcRIAVBgAFqEBYgACgCDCAAKAJIKAIQIAIQS0GcDEECIAIQHQsCQCABQQhxRQ0AIAAoAkhFDQAgACgCaCAAKAJsbCIERQ0AIAAoApwBIQMDQCADIAAoAkgoAhAgAhBLIANBjCxqIQMgC0EBaiILIARHDQALCyABQRBxRQ0AIAAoAsgBIQFB0w1BJSACEB0gBSAB/QADAP0LBHAgAkHJKyAFQfAAahAWQcENQREgAhAdAkAgASgCHEUNACABKAIYRQ0AQQAhAwNAIAEoAhwgA0EYbGoiAC8BACEEIAApAwghDSAFIAAoAhA2AmAgBSANNwNYIAUgBDYCUCACQYs4IAVB0ABqEBYgA0EBaiIDIAEoAhhJDQALC0GaDEEEIAIQHQJAIAEoAigiBEUNACABKAIkIgdFDQBBACEDQQAhAAJAIAdBBE8EQCAHQXxxIQADQCAEIANBA3JBKGxqQQRqIAQgA0ECckEobGpBBGogBCADQQFyQShsakEEaiAEIANBKGxq/QkCBP1WAgAB/VYCAAL9VgIAAyAM/a4BIQwgA0EEaiIDIABHDQALIAwgDCAM/Q0ICQoLDA0ODwABAgMAAQID/a4BIgwgDCAM/Q0EBQYHAAECAwABAgMAAQID/a4B/RsAIQMgACAHRg0BCwNAIAQgAEEobGooAgQgA2ohAyAAQQFqIgAgB0cNAAsLIANFDQBBsA1BECACEB0gASgCJARAIAEoAighAEEAIQcDQCAFIAAgB0EobCIEaigCBCIGNgJEIAUgBzYCQCACQdE4IAVBQGsQFiABKAIoIQACQCAGRQ0AQQAhAyAAIARqKAIQRQ0AA0AgASgCKCAEaigCECADQRhsaiIA/QADACEMIAUgACkDEDcDOCAFIAz9CwMoIAUgAzYCICACQaXRACAFQSBqEBYgA0EBaiIDIAZHDQALIAEoAighAAsCQCAAIARqIgYoAhhFDQBBACEDIAYoAhRFDQADQCAAIARqKAIYIANBGGxqIgAvAQAhBiAAKQMIIQ0gBSAAKAIQNgIQIAUgDTcDCCAFIAY2AgAgAkGLOCAFEBYgA0EBaiIDIAEoAigiACAEaigCFEkNAAsLIAdBAWoiByABKAIkSQ0ACwtBmgxBBCACEB0LQZwMQQIgAhAdCyAFQbABaiQAC48CAQN/AkBBAUHoARATIgEEfyABQQE2AgAgAUEBNgK4ASABIAEtALwBQQZyOgC8ASABQQFBjCwQEyIANgIMIABFDQEgAUEBQegHEBMiADYCECAARQ0BIAFCADcDMCABQX82AiwgAUHoBzYCFAJAQQFBMBATIgAEQCAAQQA2AhggAEHkADYCICAAQeQAQRgQEyICNgIcIAINASAAEBALIAFBADYCyAEMAgsgAEEANgIoIAEgADYCyAEgARAzIgA2AsQBIABFDQEgARAzIgA2AsABIABFDQECQBCRAUUNAAsgAUEAEGYiADYC1AEgAEUEQCABQQAQZiIANgLUASAARQ0CCyABBUEACw8LIAEQOEEAC40JAgl/AX4jAEHQAWsiByQAIAAoAkghCQJAAkACQCAAKAJoQQFHDQAgACgCbEEBRw0AIAAoApwBKALcKw0BCyAAKAIIQQhGDQAgBkEBQeHOAEEAEA8MAQsCQCABKAIQIgxFDQAgACgCoAEhCiABKAIYIQsgDEEITwRAIAxBeHEhDwNAIAsgCEE0bGogCjYCKCALIAhBAXJBNGxqIAo2AiggCyAIQQJyQTRsaiAKNgIoIAsgCEEDckE0bGogCjYCKCALIAhBBHJBNGxqIAo2AiggCyAIQQVyQTRsaiAKNgIoIAsgCEEGckE0bGogCjYCKCALIAhBB3JBNGxqIAo2AiggCEEIaiEIIA5BCGoiDiAPRw0ACwsgDEEHcSIMRQ0AA0AgCyAIQTRsaiAKNgIoIAhBAWohCCANQQFqIg0gDEcNAAsLIAIgA3IgBHIgBXJFBEAgBkEEQa8wQQAQDyAAQgA3AhwgACAAKQJoNwIkIAEgCf0AAgD9CwIAIAEgBhA3IQgMAQsgAkEASARAIAcgAjYCACAGQQFBx90AIAcQD0EAIQgMAQsgAiAJKAIIIghLBEAgByAINgIUIAcgAjYCECAGQQFBm+EAIAdBEGoQD0EAIQgMAQsCQCACIAkoAgAiCEkEQCAHIAg2AsQBIAcgAjYCwAEgBkECQfvjACAHQcABahAPIABBADYCHCAJKAIAIQIMAQsgACACIAAoAlRrIAAoAlxuNgIcCyABIAI2AgAgA0EASARAIAcgAzYCICAGQQFBh90AIAdBIGoQD0EAIQgMAQsgAyAJKAIMIgJLBEAgByACNgI0IAcgAzYCMCAGQQFB7t8AIAdBMGoQD0EAIQgMAQsCQCADIAkoAgQiAkkEQCAHIAI2ArQBIAcgAzYCsAEgBkECQcziACAHQbABahAPIABBADYCICAJKAIEIQMMAQsgACADIAAoAlhrIAAoAmBuNgIgCyABIAM2AgRBACEIIARBAEwEQCAHIAQ2AkAgBkEBQcXcACAHQUBrEA8MAQsgBCAJKAIAIgJJBEAgByACNgJUIAcgBDYCUCAGQQFBouMAIAdB0ABqEA8MAQsCQCAEIAkoAggiAksEQCAHIAI2AqQBIAcgBDYCoAEgBkECQcPgACAHQaABahAPIAAgACgCaDYCJCAJKAIIIQQMAQsgACAANQJcIhAgBCAAKAJUa618QgF9IBCAPgIkCyABIAQ2AgggBUEATARAIAcgBTYCYCAGQQFBgtwAIAdB4ABqEA8MAQsgBSAJKAIEIgJJBEAgByACNgJ0IAcgBTYCcCAGQQFB8uEAIAdB8ABqEA8MAQsCQCAFIAkoAgwiAksEQCAHIAI2ApQBIAcgBTYCkAEgBkECQZXfACAHQZABahAPIAAgACgCbDYCKCAJKAIMIQUMAQsgACAANQJgIhAgBSAAKAJYa618QgF9IBCAPgIoCyABIAU2AgwgACAALQBEQQJyOgBEIAEgBhA3IghFBEBBACEIDAELIAcgAf0AAgD9CwSAASAGQQRBtDkgB0GAAWoQDwsgB0HQAWokACAIC5UCAQd/IwBBIGsiBSQAAn8gACgCSCIERQRAIANBAUHF5gBBABAPQQAMAQtBAEEEIAQoAhAQEyIERQ0AGiABBEAgACgCSCEIA0ACQAJAIAIgBkECdGooAgAiByAIKAIQTwRAIAUgBzYCECADQQFB+REgBUEQahAPDAELIAQgB0ECdGoiCSgCAEUNASAFIAc2AgAgA0EBQY0aIAUQDwsgBBAQQQAMAwsgCUEBNgIAIAZBAWoiBiABRw0ACwsgBBAQIAAoAkAQEAJAIAEEQCAAIAFBAnQiBBAUIgM2AkAgA0UEQCAAQQA2AjxBAAwDCyADIAIgBBASGgwBCyAAQQA2AkALIAAgATYCPEEBCyEKIAVBIGokACAKC7wFAQd/IAFBAUEkEBMiBDYCSAJAAkAgBEUNAAJAIAEoAsQBQRIgAxAkBEAgASgCxAFBEyADECQNAQsMAgsgASgCxAEiBygCACEGIAcoAgghBAJAIAYEQEEBIQUgBkEBRwRAIAZBfnEhCQNAAn9BACAFRQ0AGkEAIAEgACADIAQoAgARAABFDQAaIAEgACADIAQoAgQRAABBAEcLIQUgBEEIaiEEIAhBAmoiCCAJRw0ACwsCQAJAIAZBAXEEQCAFRQ0BIAEgACADIAQoAgARAABBAEchBQsgB0EANgIAIAVFDQEMAwsgB0EANgIACwwDCyAHQQA2AgALAkAgASgCwAFBFCADECQEQCABKALAAUEVIAMQJA0BCwwCCyABKALAASIHKAIAIQYgBygCCCEEAkAgBgRAQQEhBSAGQQFxIQkgBkEBRgR/QQAFIAZBfnEhBkEAIQgDQAJ/QQAgBUUNABpBACABIAAgAyAEKAIAEQAARQ0AGiABIAAgAyAEKAIEEQAAQQBHCyEFIARBCGohBCAIQQJqIgggBkcNAAsgBUULIQYCQAJAIAkEQCAGDQEgASAAIAMgBCgCABEAAEEARyEFCyAHQQA2AgAgBUUNAQwDCyAHQQA2AgALDAMLIAdBADYCAAsgAkEBQSQQEyIANgIAIABFDQAgASgCSCAAED8gASgCyAEgASgCbCABKAJobCIANgIkIABBKBATIQMgASgCyAEiACADNgIoAkAgA0UNACAAKAIkRQRAQQEPC0EAIQQDQCADIARBKGwiBWoiAEEANgIUIABB5AA2AhxB5ABBGBATIQAgBSABKALIASIHKAIoIgNqIAA2AhggAEUNAUEBIQogBEEBaiIEIAcoAiRJDQALDAELIAIoAgAQIUEAIQogAkEANgIACyAKDwsgASgCSBAhIAFBADYCSEEACwIACwQAQQELNAACQCAARQ0AIAFFDQAgACABKAIENgKkASAAIAEoAgA2AqABIAAgASgCuEBBAnE2AuABCwu0BQEIfyAAKAIYIgQoAhAiCUUEQEEADwsgBCgCGCEFIAAoAhQoAgAoAhQhBAJAAkAgAUUEQEEAIQEDQCAFKAIYIQIgBCgCHCAEKAIYQZgBbGoiAEGMAWsoAgAiByAAQZQBaygCACIIayEDIABBkAFrKAIAIABBmAFrKAIAayEAAkAgByAIRg0AIACtIAOtfkIgiFANAAwECyAAIANsIQMCQEEEIAJBA3YgAkEHcUEAR2oiACAAQQNGGyICRQ0AIAKtIAOtfkIgiFANAAwEC0F/IQAgAiADbCICIAFBf3NLDQIgBEHMAGohBCAFQTRqIQUgASACaiIBIQAgBkEBaiIGIAlHDQALDAELQQAhASAAKAJARQRAA0AgBSgCGCECIAQoAhwgBCgCGEGYAWxqIgBBBGsoAgAiByAAQQxrKAIAIghrIQMgAEEIaygCACAAQRBrKAIAayEAAkAgByAIRg0AIACtIAOtfkIgiFANAAwECyAAIANsIQMCQEEEIAJBA3YgAkEHcUEAR2oiACAAQQNGGyICRQ0AIAKtIAOtfkIgiFANAAwEC0F/IQAgAiADbCICIAFBf3NLDQIgBEHMAGohBCAFQTRqIQUgASACaiIBIQAgBkEBaiIGIAlHDQALDAELA0AgBSgCGCECIAQoAhwgBCgCGEGYAWxqIgBBjAFrKAIAIgcgAEGUAWsoAgAiCGshAyAAQZABaygCACAAQZgBaygCAGshAAJAIAcgCEYNACAArSADrX5CIIhQDQAMAwsgACADbCEDAkBBBCACQQN2IAJBB3FBAEdqIgAgAEEDRhsiAkUNACACrSADrX5CIIhQDQAMAwtBfyEAIAIgA2wiAiABQX9zSw0BIARBzABqIQQgBUE0aiEFIAEgAmoiASEAIAZBAWoiBiAJRw0ACwsgAA8LQX8L2gQBC38gAARAIAAoAhQiAQRAIAEoAgAiBQRAIAUoAhQhAyAFKAIQBH9BEEERIAAtAChBAXEbIQgDQCADKAIcIgIEQCADKAIgIgFBmAFuIQpBACEJIAFBmAFPBH8DQCACKAIwIgEEQCACKAI0IgZBKG4hB0EAIQQgBkEoTwR/A0AgASgCIBApIAFBADYCICABKAIkECkgAUEANgIkIAEgCBECACABQShqIQEgBEEBaiIEIAdHDQALIAIoAjAFIAELEBAgAkEANgIwCyACKAJUIgEEQCACKAJYIgZBKG4hB0EAIQQgBkEoTwR/A0AgASgCIBApIAFBADYCICABKAIkECkgAUEANgIkIAEgCBECACABQShqIQEgBEEBaiIEIAdHDQALIAIoAlQFIAELEBAgAkEANgJUCyACKAJ4IgEEQCACKAJ8IgZBKG4hB0EAIQQgBkEoTwR/A0AgASgCIBApIAFBADYCICABKAIkECkgAUEANgIkIAEgCBECACABQShqIQEgBEEBaiIEIAdHDQALIAIoAngFIAELEBAgAkEANgJ4CyACQZgBaiECIAlBAWoiCSAKRw0ACyADKAIcBSACCxAQIANBADYCHAsCQCADKAIoRQ0AIAMoAiQiAUUNACABEBAgA/0MAAAAAAAAAAAAAAAAAAAAAP0LAiQLIAMoAjQQECADQcwAaiEDIAtBAWoiCyAFKAIQSQ0ACyAFKAIUBSADCxAQIAVBADYCFCAAKAIUKAIAEBAgACgCFCIBQQA2AgALIAEQECAAQQA2AhQLIAAoAkQQECAAEBALC8sTARV/IwBBIGsiDyQAIA8gBTYCGCABIAMoAhxBzABsaigCHCADKAIgQZgBbGohEQJAAkAgAygCKA0AIBEoAhhFDQAgEUEcaiEJA0ACQCAJKAIIIAkoAgBHBH8gCSgCDCAJKAIERgVBAQsNACADKAIkIgEgCSgCGEEobk8EQCAIQQFBghVBABAPDAQLIAkoAhQgAUEobGoiASgCIBBiIAEoAiQQYiABKAIUIAEoAhBsIg1FDQAgASgCGCEBIA1BCE8EQCANQXhxIQtBACEKA0AgAUIANwLoAyABQgA3AqgDIAFCADcC6AIgAUIANwKoAiABQgA3AugBIAFCADcCqAEgAUIANwJoIAFCADcCKCABQYAEaiEBIApBCGoiCiALRw0ACwtBACEKIA1BB3EiDUUNAANAIAFCADcCKCABQUBrIQEgCkEBaiIKIA1HDQALCyAJQSRqIQkgDEEBaiIMIBEoAhhJDQALCyAFIQ0CQCACLQAAQQJxRQ0AIAdBBU0EQCAIQQJBsR9BABAPDAELAkAgBS0AAEH/AUYEQCAFLQABQZEBRg0BCyAIQQJB2x9BABAPDAELIA8gBUEGaiINNgIYC0EUEBQiC0UNAAJ/IAAtAGxBAXEEQCAAQShqIQcgACgCKCENIABBLGoMAQsgAi0AiCxBAnEEQCACQbAoaiEHIAIoArAoIQ0gAkG8KGoMAQsgDyAFIAdqIA1rNgIcIA9BGGohByAPQRxqCyISKAIAIQAgC0IANwIMIAsgDTYCCCALIA02AgAgCyAAIA1qNgIEIAtBARAfRQRAIAsQZBogCygCCCALKAIAayEaIAsQLCAaIA1qIQECQCACLQAAQQRxRQ0AIAcoAgAgEigCACABa2pBAU0EQCAIQQJBmCFBABAPDAELAkAgAS0AAEH/AUYEQCABLQABQZIBRg0BCyAIQQJBwiFBABAPDAELIAFBAmohAQsgEiASKAIAIAcoAgAgAWtqNgIAIAcgATYCACAEQQA2AgAgBiAPKAIYIAVrNgIAQQEhFwwBCyARKAIYBEAgEUEcaiEQA0AgAygCJCEAIBAoAhQhAQJAIBAoAgggECgCAEcEfyAQKAIMIBAoAgRGBUEBCw0AIAEgAEEobGoiFCgCFCAUKAIQbCIYRQ0AIBQoAhghCUEAIRUDQAJAAn8gCSgCKEUEQCALIBQoAiAgFSADKAIoQQFqEGAMAQsgC0EBEB8LRQRAIAlBADYCJAwBCyAJKAIoRQRAQQAhAQNAIAEiAEEBaiEBIAsgFCgCJCAVIAAQYEUNAAsgECgCHCEBIAlBAzYCICAJIAE2AhggCSABIABrQQFqNgIcCyAJAn9BASALQQEQH0UNABpBAiALQQEQH0UNABogC0ECEB8iAEEDRwRAIABBA2oMAQsgC0EFEB8iAEEfRwRAIABBBmoMAQsgC0EHEB9BJWoLNgIkQQAhAQNAIAEiAEEBaiEBIAtBARAfDQALIAkgCSgCICAAajYCIAJAAkACfyAJKAIoIgBFBEAgAigC0CsgAygCHEG4CGxqKAIQIQAgCSgCMEUEQCAJKAIAQfABEBciAUUNBCAJIAE2AgAgASAJKAIwQRhsakEAQfABEBUaIAlBCjYCMAsgCSgCACIB/QwAAAAAAAAAAAAAAAAAAAAA/QsCACABQgA3AhBBAUEKQe0AIABBAXEbIABBBHEbIQpBAAwBCyAJKAIAIgEgAEEBayIMQRhsaiIKKAIEIAooAgxHDQEgAigC0CsgAygCHEG4CGxqKAIQIQogCSgCMCIMIABBAWpJBH8gASAMQQpqIgxBGGwQFyIBRQ0DIAkgATYCACABIAkoAjBBGGxqQQBB8AEQFRogCSAMNgIwIAkoAgAFIAELIABBGGxqIgH9DAAAAAAAAAAAAAAAAAAAAAD9CwIAIAFCADcCEAJ/QQEgCkEEcQ0AGkHtACAKQQFxRQ0AGkECQQJBASABQQxrKAIAIgpBCkYbIApBAUYbCyEKIAALIQwgASAKNgIMCyAJKAIkIQAgAigC0CsgAygCHEG4CGxqLQAQQcAAcQRAA0AgDEEYbCIOIAkoAgBqIABBASAMGyITNgIQIAkoAiAhFkEAIQogACEBIBNBAk8EQANAIApBAWohCiABQQNLIRsgAUEBdiEBIBsNAAsLIAogFmoiAUEhTwRAIA8gATYCECAIQQFBvPQAIA9BEGoQDwwDCyALIAEQHyEKIAkoAgAiASAOaiIOIAo2AhQgACAOKAIQayIAQQBMDQMgAigC0CsgAygCHEG4CGxqKAIQIQogCSgCMCIOIAxBAmpJBEAgASAOQQpqIg5BGGwQFyIBRQ0DIAkgATYCACABIAkoAjBBGGxqQQBB8AEQFRogCSAONgIwIAkoAgAhAQsgASAMQQFqIgxBGGxqIgH9DAAAAAAAAAAAAAAAAAAAAAD9CwIAIAFCADcCECABAn9BASAKQQRxDQAaQe0AIApBAXFFDQAaQQJBAkEBIAFBDGsoAgAiAUEKRhsgAUEBRhsLNgIMDAALAAsDQCAMQRhsIg4gCSgCAGoiASABKAIMIAEoAgRrIgEgACAAIAFKGyIBNgIQIAkoAiAhE0EAIQogAUECTwRAA0AgCkEBaiEKIAFBA0shHCABQQF2IQEgHA0ACwsgCiATaiIBQSFPBEAgDyABNgIAIAhBAUG89AAgDxAPDAILIAsgARAfIQogCSgCACIBIA5qIg4gCjYCFCAAIA4oAhBrIgBBAEwNAiACKALQKyADKAIcQbgIbGooAhAhCiAJKAIwIg4gDEECakkEQCABIA5BCmoiDkEYbBAXIgFFDQIgCSABNgIAIAEgCSgCMEEYbGpBAEHwARAVGiAJIA42AjAgCSgCACEBCyABIAxBAWoiDEEYbGoiAf0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAUIANwIQIAECf0EBIApBBHENABpB7QAgCkEBcUUNABpBAkECQQEgAUEMaygCACIBQQpGGyABQQFGGws2AgwMAAsACyALECwMBQsgCUFAayEJIBVBAWoiFSAYRw0ACwsgEEEkaiEQIBlBAWoiGSARKAIYSQ0ACwsgCxBkRQRAIAsQLAwBCyALKAIIIAsoAgBrIR0gCxAsIB0gDWohAQJAIAItAABBBHFFDQAgBygCACASKAIAIAFrakEBTQRAIAhBAkGYIUEAEA8MAQsCQCABLQAAQf8BRgRAIAEtAAFBkgFGDQELIAhBAkHCIUEAEA8MAQsgAUECaiEBCyASIBIoAgAgBygCACABa2o2AgAgByABNgIAQQEhFyAEQQE2AgAgBiAPKAIYIAVrNgIACyAPQSBqJAAgFwuWJAIUfw5+AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAJUDgUAAQIDBAoLAkAgACgCNCIGIAAoAsQBIgFJBEAgACgCQCIHIAFBAWpJDQELIAAoAuwBQQFB9D9BABAPDAwLIAAoAixFBEAgACgCJCECQQAhAQwFCyAAQQA2AiwgACgCRCEDQQEhAQwECwJAIAAoAjQiBiAAKALEASIBSQRAIAAoAkAiByABQQFqSQ0BCyAAKALsAUEBQaHAAEEAEA8MCwsgACgCLEUEQCAAKAIkIQRBACEBDAgLIABBADYCLCAAKAIwIQNBASEBDAcLAkAgACgCNCIEIAAoAsQBIgpJBEAgACgCQCIOIApBAWpJDQELIAAoAuwBQQFBqMEAQQAQDwwKCyAAKAIsRQRAIAAoAighCwwGCyAAQgA3AuQBIABBADYCLCAAKALIASEMA0AgDCAHQQR0aiIFKAIIIg8EQCAFKAIMIRJBACEBA0ACQCAPIAFBf3NqIhAgEiABQQR0aiIRKAIAaiIJQR9LDQAgBSgCACITQX8gCXZLDQAgACACIBMgCXQiCSACIAlJGyAJIAIbIgI2AuQBCwJAIBEoAgQgEGoiCUEfSw0AIAUoAgQiEEF/IAl2Sw0AIAAgAyAQIAl0IgkgAyAJSRsgCSADGyIDNgLoAQsgAUEBaiIBIA9HDQALCyAHQQFqIgcgCkcNAAsgAkUNByADRQ0HIAAtAABFBEAgACAAKALQATYCbCAAIAAoAswBNgJkIAAgACgC2AE2AnAgACAAKALUATYCaAsgACgCMCEFQQEhAQwFCwJAIAAoAjQiBSAAKALEASIJSQRAIAAoAkAiEiAJQQFqSQ0BCyAAKALsAUEBQfvAAEEAEA8MCQsgACgCLEUEQCAAKALIASINIAAoAhwiBEEEdGohCyAAKAIoIQgMBAsgAEIANwLkASAAQQA2AiwgACgCyAEhDQNAIA0gBkEEdGoiCigCCCIOBEAgCigCDCEQQQAhAQNAAkAgDiABQX9zaiIRIBAgAUEEdGoiEygCAGoiDEEfSw0AIAooAgAiFEF/IAx2Sw0AIAAgAiAUIAx0IgwgAiAMSRsgDCACGyICNgLkAQsCQCATKAIEIBFqIgxBH0sNACAKKAIEIhFBfyAMdksNACAAIAMgESAMdCIMIAMgDEkbIAwgAxsiAzYC6AELIAFBAWoiASAORw0ACwsgBkEBaiIGIAlHDQALIAJFDQYgA0UNBgJAIAAtAAAEQCAAKAJsIQYMAQsgACAAKALQASIGNgJsIAAgACgCzAE2AmQgACAAKALYATYCcCAAIAAoAtQBNgJoC0EBIQEMAwsCQCAAKAI0IgYgACgCxAEiAUkEQCAAKAJAIg8gAUEBakkNAQsgACgC7AFBAUHOwABBABAPDAYLIAAoAixFBEAgACgCyAEgACgCHCIGQQR0aiEFIAAoAighB0EAIQEMAgsgACAGNgIcIABBADYCLEEBIQEMAQsDQAJ/AkAgAUUEQCACQQFqIQIMAQsgACADNgIoIAAoAjggA00NCSAAKAIwIQRBAAwBC0EBCyEBA0ACQAJAAkACQCABRQRAIAAgBDYCICAEIAAoAjxPDQEgACAGNgIcIAYhAUEAIQUMBAsgACACNgIkIAAoAkwgAk0EQCAAKAIcIQFBASEFDAQLIAAoAhAgACgCIGwgACgCDCAAKAIobGogACgCFCAAKAIcbGogACgCGCACbGoiASAAKAIITwRADAwLIAAoAgQgAUEBdGoiAS8BAA0BDA0LIAAoAihBAWohAwwBC0EAIQEMAwtBASEBDAILA0ACQAJAAkAgBUUEQCABIAdPDQEgACgCICIFIAAoAsgBIAFBBHRqIg0oAghPDQMgAC0AAEUEQCAAIA0oAgwgBUEEdGoiASgCDCABKAIIbDYCTAsgACgCSCECQQEhAQwFCyAAIAFBAWoiATYCHAwBCyAAKAIgQQFqIQRBACEBDAMLQQAhBQwBC0EBIQUMAAsACwALAAsDQAJ/AkAgAUUEQCAAIAdBAWoiBzYCKAwBCyAGIA9PDQggAEIANwLkASAAKALIASAGQQR0aiIFKAIIIgtFDQggBSgCDCEKQQAhAkEAIQRBACEBA0ACQCALIAFBf3NqIgkgCiABQQR0aiIOKAIAaiIIQR9LDQAgBSgCACIMQX8gCHZLDQAgACAEIAwgCHQiCCAEIAhJGyAIIAQbIgQ2AuQBCwJAIA4oAgQgCWoiCEEfSw0AIAUoAgQiCUF/IAh2Sw0AIAAgAiAJIAh0IgggAiAISRsgCCACGyICNgLoAQsgAUEBaiIBIAtHDQALIARFDQYgAkUNBgJAIAAtAAAEQCAAKAJsIQIMAQsgACAAKALQASICNgJsIAAgACgCzAE2AmQgACAAKALYATYCcCAAIAAoAtQBNgJoC0EADAELQQELIQEDQAJAAkACQAJAIAFFBEAgACACNgLgASACIAAoAnBPDQEgACgCZCENQQAhAQwECyAAKAI4IAdNBEAgACgCICEDQQEhAQwECyAAKAIQIAAoAiBsIAAoAgwgB2xqIAAoAhQgBmxqIAAoAhggACgCJGxqIgEgACgCCE8EQAwLCyAAKAIEIAFBAXRqIgEvAQANAQwMCyAAIAZBAWoiBjYCHAwBC0EAIQEMAwtBASEBDAILA0ACQAJAAkAgAAJ/IAFFBEAgACANNgLcASANIAAoAmhPDQIgACgCMAwBCyADQQFqCyIDNgIgIAAoAjwiASAFKAIIIgQgASAESRsgA0sEQCAFKAIAIgEgAa0iHiAEIANBf3NqIgitIhaGIhcgFoinRw0DIAUoAgQiBEJ/IBaIp3EgBEcNAyAErSIVIBaGIhhCAX0iGSAANQLYAXwgGIAhHyAZIAAoAtABIgmtfCAYgCEaIBdCAX0iGyAANQLUAXwgF4AhICAbIAAoAswBIg6tfCAXgCEcIAFCfyAFKAIMIANBBHRqIgsoAgAiCiAIaq0iHYincSABRw0DIAQgFSALKAIEIgEgCGqtIhWGIiEgFYinRw0DIAAoAuABIgStIiIgIYJCAFIEQCAEIAlHDQRCfyAVhkJ/hSAaQv////8PgyAWhoNQDQQLIAAoAtwBIgStIhUgHiAdhoJCAFIEQCAEIA5HDQRCfyAdhkJ/hSAcQv////8PgyAWhoNQDQQLIAsoAggiBEUNAyALKAIMRQ0DIBynIgsgIKdGDQMgGqciCCAfp0YNAyAAIAAoAkQiBzYCKCAAIBUgG3wgF4CnIAp2IAsgCnZrIBkgInwgGICnIAF2IAggAXZrIARsajYCJEEBIQEMBQsgACgC3AEiASAAKALkASIEaiABIARwayENDAELIAAoAuABIgEgACgC6AEiBGogASAEcGshAkEAIQEMAwtBACEBDAELQQEhAQwACwALAAsACwNAAn8CQCABRQRAIAAgCEEBaiIINgIoDAELIAAgBjYC4AEgACgCcCAGTQ0HIAAoAmQhD0EADAELQQELIQEDQAJAAkACQAJAIAFFBEAgACAPNgLcASAPIAAoAmhPDQEgACAFNgIcIAUhBEEAIQEMBAsgACgCOCAITQRAIAAoAiAhB0EBIQEMBAsgACgCECAAKAIgbCAAKAIMIAhsaiAAKAIUIARsaiAAKAIYIAAoAiRsaiIBIAAoAghPBEAMCgsgACgCBCABQQF0aiIBLwEADQEMCwsgACgC4AEiASAAKALoASIGaiABIAZwayEGDAELQQAhAQwDC0EBIQEMAgsDQAJAAkACQAJAIAFFBEAgBCASTw0CIAAgACgCMCIHNgIgIA0gBEEEdGohCwwBCyAAIAdBAWoiBzYCIAsgACgCPCIBIAsoAggiAiABIAJJGyAHSwRAIAsoAgAiASABrSIeIAIgB0F/c2oiCq0iFoYiFyAWiKdHDQMgCygCBCICQn8gFoincSACRw0DIAKtIhUgFoYiGEIBfSIZIAA1AtgBfCAYgCEfIBkgACgC0AEiDq18IBiAIRogF0IBfSIbIAA1AtQBfCAXgCEgIBsgACgCzAEiDK18IBeAIRwgAUJ/IAsoAgwgB0EEdGoiAygCACIJIApqrSIdiKdxIAFHDQMgAiAVIAMoAgQiASAKaq0iFYYiISAViKdHDQMgACgC4AEiAq0iIiAhgkIAUgRAIAIgDkcNBEJ/IBWGQn+FIBpC/////w+DIBaGg1ANBAsgACgC3AEiAq0iFSAeIB2GgkIAUgRAIAIgDEcNBEJ/IB2GQn+FIBxC/////w+DIBaGg1ANBAsgAygCCCICRQ0DIAMoAgxFDQMgHKciAyAgp0YNAyAapyIKIB+nRg0DIAAgACgCRCIINgIoIAAgFSAbfCAXgKcgCXYgAyAJdmsgGSAifCAYgKcgAXYgCiABdmsgAmxqNgIkQQEhAQwFCyAAIARBAWoiBDYCHAwBCyAAKALcASIBIAAoAuQBIgJqIAEgAnBrIQ9BACEBDAMLQQAhAQwBC0EBIQEMAAsACwALAAsDQAJ/AkAgAUUEQCAAIAtBAWoiCzYCKAwBCyAAIAU2AiAgACgCPCAFTQ0GIAAoAmwhCEEADAELQQELIQEDQAJAAkACQAJAIAFFBEAgACAINgLgASAIIAAoAnBPDQEgACgCZCENQQAhAQwECyAAKAI4IAtNBEAgACgCHCEGQQEhAQwECyAAKAIQIAAoAiBsIAAoAgwgC2xqIAAoAhQgACgCHGxqIAAoAhggACgCJGxqIgEgACgCCE8EQAwJCyAAKAIEIAFBAXRqIgEvAQANAQwKCyAAKAIgQQFqIQUMAQtBACEBDAMLQQEhAQwCCwNAAkACQAJAAkAgAUUEQCAAIA02AtwBIA0gACgCaE8NAiAAIAQ2AhwgBCEGDAELIAAgBkEBaiIGNgIcCyAGIA5JBEAgACgCICIHIAAoAsgBIAZBBHRqIgEoAggiA08NAyABKAIAIgIgAq0iHiADIAdBf3NqIgqtIhaGIhcgFoinRw0DIAEoAgQiA0J/IBaIp3EgA0cNAyADrSIVIBaGIhhCAX0iGSAANQLYAXwgGIAhHyAZIAAoAtABIg+tfCAYgCEaIBdCAX0iGyAANQLUAXwgF4AhICAbIAAoAswBIgmtfCAXgCEcIAJCfyABKAIMIAdBBHRqIgEoAgAiByAKaq0iHYincSACRw0DIAMgFSABKAIEIgIgCmqtIhWGIiEgFYinRw0DIAAoAuABIgOtIiIgIYJCAFIEQCADIA9HDQRCfyAVhkJ/hSAaQv////8PgyAWhoNQDQQLIAAoAtwBIgOtIhUgHiAdhoJCAFIEQCADIAlHDQRCfyAdhkJ/hSAcQv////8PgyAWhoNQDQQLIAEoAggiA0UNAyABKAIMRQ0DIBynIgEgIKdGDQMgGqciCiAfp0YNAyAAIAAoAkQiCzYCKCAAIBUgG3wgF4CnIAd2IAEgB3ZrIBkgInwgGICnIAJ2IAogAnZrIANsajYCJEEBIQEMBQsgACgC3AEiASAAKALkASICaiABIAJwayENDAELIAAoAuABIgEgACgC6AEiAmogASACcGshCEEAIQEMAwtBACEBDAELQQEhAQwACwALAAsACwNAAn8CQCABRQRAIARBAWohBAwBCyAAIAM2AiAgACgCPCADTQ0FIAAoAkQhAkEADAELQQELIQEDQAJAAkACQAJAIAFFBEAgACACNgIoIAIgACgCOE8NASAAIAY2AhwgBiEBQQAhBQwECyAAIAQ2AiQgACgCTCAETQRAIAAoAhwhAUEBIQUMBAsgACgCECAAKAIgbCAAKAIMIAAoAihsaiAAKAIUIAAoAhxsaiAAKAIYIARsaiIBIAAoAghPBEAMCAsgACgCBCABQQF0aiIBLwEADQEMCQsgACgCIEEBaiEDDAELQQAhAQwDC0EBIQEMAgsDQAJAAkACQCAFRQRAIAEgB08NASAAKAIgIgUgACgCyAEgAUEEdGoiDSgCCE8NAyAALQAARQRAIAAgDSgCDCAFQQR0aiIBKAIMIAEoAghsNgJMCyAAKAJIIQRBASEBDAULIAAgAUEBaiIBNgIcDAELIAAoAihBAWohAkEAIQEMAwtBACEFDAELQQEhBQwACwALAAsAC0EADwsgACgC7AFBAUGaCkEAEA8LQQAPCyABQQE7AQBBAQuRCwEKfwJAIAEoAgAgBEEDbCIMdiIGQZCAgAFxDQAgACAAQRxqIg4gACgCbCAGQe8DcWotAABBAnRqIgo2AmggACAAKAIEIAooAgAiCSgCACIIayIGNgIEAkAgCCAAKAIAIgdBEHZLBEAgCSgCBCELIAAgCDYCBCAKIAlBCEEMIAYgCEkiBhtqKAIANgIAIAsgC0UgBhshCSAAKAIIIQYDQAJAIAYNACAAKAIQIgZBAWohCyAGLQABIQogBi0AAEH/AUYEQCAKQZABTwRAIAAgACgCDEEBajYCDCAHQYD+A2ohB0EIIQYMAgsgACALNgIQIAcgCkEJdGohB0EHIQYMAQsgACALNgIQQQghBiAHIApBCHRqIQcLIAAgBkEBayIGNgIIIAAgB0EBdCIHNgIAIAAgCEEBdCIINgIEIAhBgIACSQ0ACyAIIQYMAQsgACAHIAhBEHRrIgc2AgAgBkGAgAJxRQRAIAkoAgQhCyAKIAlBDEEIIAYgCEkiCBtqKAIANgIAIAtFIAsgCBshCSAAKAIIIQgDQAJAIAgNACAAKAIQIghBAWohCyAILQABIQogCC0AAEH/AUYEQCAKQZABTwRAIAAgACgCDEEBajYCDCAHQYD+A2ohB0EIIQgMAgsgACALNgIQIAcgCkEJdGohB0EHIQgMAQsgACALNgIQQQghCCAHIApBCHRqIQcLIAAgCEEBayIINgIIIAAgB0EBdCIHNgIAIAAgBkEBdCIGNgIEIAZBgIACSQ0ACwwBCyAJKAIEIQkLIAlFDQAgACAOIAEoAgQgDEERanZBBHEgAUEEayINKAIAIAxBE2p2QQFxIAEoAgAiCCAMQRBqdkHAAHEgCCAMdkGqAXFyIAggDEEMakEOIAQbdkEQcXJyciIPQdC5AWotAABBAnRqIgs2AmggACAGIAsoAgAiCigCACIIayIGNgIEAkAgCCAHQRB2SwRAIAooAgQhCSAAIAg2AgQgCyAKQQhBDCAGIAhJIgYbaigCADYCACAJIAlFIAYbIQogACgCCCEGA0ACQCAGDQAgACgCECIGQQFqIQsgBi0AASEJIAYtAABB/wFGBEAgCUGQAU8EQCAAIAAoAgxBAWo2AgwgB0GA/gNqIQdBCCEGDAILIAAgCzYCECAHIAlBCXRqIQdBByEGDAELIAAgCzYCEEEIIQYgByAJQQh0aiEHCyAAIAZBAWsiBjYCCCAAIAdBAXQiBzYCACAAIAhBAXQiCDYCBCAIQYCAAkkNAAsMAQsgACAHIAhBEHRrIgk2AgAgBkGAgAJxRQRAIAooAgQhByALIApBDEEIIAYgCEkiCBtqKAIANgIAIAdFIAcgCBshCiAAKAIIIQcDQAJAIAcNACAAKAIQIgdBAWohCyAHLQABIQggBy0AAEH/AUYEQCAIQZABTwRAIAAgACgCDEEBajYCDCAJQYD+A2ohCUEIIQcMAgsgACALNgIQIAkgCEEJdGohCUEHIQcMAQsgACALNgIQQQghByAJIAhBCHRqIQkLIAAgB0EBayIHNgIIIAAgCUEBdCIJNgIAIAAgBkEBdCIGNgIEIAZBgIACSQ0ACwwBCyAKKAIEIQoLIAJBACADayADIAogD0HQuwFqLQAAcyIDGzYCACANIA0oAgBBICAMdHI2AgAgASABKAIAIANBE3RBEHIgDHRyNgIAIAEgASgCBEEIIAx0cjYCBCAEIAVyRQRAIAFBfiAAKAJ8a0ECdGoiAiACKAIEQYCAAnI2AgQgAiACKAIAIANBH3RyQYCABHI2AgAgAkEEayICIAIoAgBBgIAIcjYCAAsgBEEDRw0AIAEgACgCfEECdGoiAEEEaiAAKAIEQQRyNgIAIAAgACgCDEEBcjYCDCAAIAAoAgggA0ESdHJBAnI2AggLC6sLAQl/AkAgASgCACAEQQNsIg12IgdBkICAAXENACAHQe8DcSIHRQ0AIAAgAEEcaiIOIAAoAmwgB2otAABBAnRqIgs2AmggACAAKAIEIAsoAgAiCigCACIJayIHNgIEAkAgCSAAKAIAIghBEHZLBEAgCigCBCEMIAAgCTYCBCALIApBCEEMIAcgCUkiBxtqKAIANgIAIAwgDEUgBxshCiAAKAIIIQcDQAJAIAcNACAAKAIQIgdBAWohDCAHLQABIQsgBy0AAEH/AUYEQCALQZABTwRAIAAgACgCDEEBajYCDCAIQYD+A2ohCEEIIQcMAgsgACAMNgIQIAggC0EJdGohCEEHIQcMAQsgACAMNgIQQQghByAIIAtBCHRqIQgLIAAgB0EBayIHNgIIIAAgCEEBdCIINgIAIAAgCUEBdCIJNgIEIAlBgIACSQ0ACyAJIQcMAQsgACAIIAlBEHRrIgg2AgAgB0GAgAJxRQRAIAooAgQhDCALIApBDEEIIAcgCUkiCRtqKAIANgIAIAxFIAwgCRshCiAAKAIIIQkDQAJAIAkNACAAKAIQIglBAWohDCAJLQABIQsgCS0AAEH/AUYEQCALQZABTwRAIAAgACgCDEEBajYCDCAIQYD+A2ohCEEIIQkMAgsgACAMNgIQIAggC0EJdGohCEEHIQkMAQsgACAMNgIQQQghCSAIIAtBCHRqIQgLIAAgCUEBayIJNgIIIAAgCEEBdCIINgIAIAAgB0EBdCIHNgIEIAdBgIACSQ0ACwwBCyAKKAIEIQoLAkAgCkUNACAAIA4gASgCBCANQRFqdkEEcSABQQRrIg8oAgAgDUETanZBAXEgASgCACIJIA1BEGp2QcAAcSAJIA12QaoBcXIgCSANQQxqQQ4gBBt2QRBxcnJyIgpB0LkBai0AAEECdGoiDDYCaCAAIAcgDCgCACILKAIAIglrIgc2AgQgCkHQuwFqLQAAIQ4CQCAJIAhBEHZLBEAgCygCBCEKIAAgCTYCBCAMIAtBCEEMIAcgCUkiBxtqKAIANgIAIAogCkUgBxshCyAAKAIIIQcDQAJAIAcNACAAKAIQIgdBAWohDCAHLQABIQogBy0AAEH/AUYEQCAKQZABTwRAIAAgACgCDEEBajYCDCAIQYD+A2ohCEEIIQcMAgsgACAMNgIQIAggCkEJdGohCEEHIQcMAQsgACAMNgIQQQghByAIIApBCHRqIQgLIAAgB0EBayIHNgIIIAAgCEEBdCIINgIAIAAgCUEBdCIJNgIEIAlBgIACSQ0ACwwBCyAAIAggCUEQdGsiCjYCACAHQYCAAnFFBEAgCygCBCEIIAwgC0EMQQggByAJSSIJG2ooAgA2AgAgCEUgCCAJGyELIAAoAgghCANAAkAgCA0AIAAoAhAiCEEBaiEMIAgtAAEhCSAILQAAQf8BRgRAIAlBkAFPBEAgACAAKAIMQQFqNgIMIApBgP4DaiEKQQghCAwCCyAAIAw2AhAgCiAJQQl0aiEKQQchCAwBCyAAIAw2AhBBCCEIIAogCUEIdGohCgsgACAIQQFrIgg2AgggACAKQQF0Igo2AgAgACAHQQF0Igc2AgQgB0GAgAJJDQALDAELIAsoAgQhCwsgAkEAIANrIAMgCyAOcyICGzYCACAPIA8oAgBBICANdHI2AgAgASABKAIAIAJBE3RBEHIgDXRyNgIAIAEgASgCBEEIIA10cjYCBCAEIAZyRQRAIAEgBUECdGsiACAAKAIEQYCAAnI2AgQgACAAKAIAIAJBH3RyQYCABHI2AgAgAEEEayIAIAAoAgBBgIAIcjYCAAsgBEEDRw0AIAEgBUECdGoiACAAKAIEQQFyNgIEIAAgACgCACACQRJ0ckECcjYCACAAQQRrIgAgACgCAEEEcjYCAAsgASABKAIAQYCAgAEgDXRyNgIACwutAQAgAEHwnQE2AmQgAEHwnQE2AmAgAEHwnQE2AlwgAEHwnQE2AlggAEHwnQE2AlQgAEHwnQE2AlAgAEHwnQE2AkwgAEHwnQE2AkggAEHwnQE2AkQgAEHwnQE2AkAgAEHwnQE2AjwgAEHwnQE2AjggAEHwnQE2AjQgAEHwnQE2AjAgAEHwnQE2AiwgAEHwnQE2AiggAEHwnQE2AiQgAEHwnQE2AiAgAEHwnQE2AhwLkgYCCX8EfiAAIAE2AgAgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAwggACADNgIcIAAgAkEBayIFNgIYIAFBA3EhCgJ/IAJBAEwEQCABIQQgAwwBCyAAIAFBAWoiBDYCACABLQAACyEBQQghByAAQQg2AhAgACABrSINNwMIIAAgDUL/AYMiDkL/AVEiCTYCFAJAIApBA0YNACAAIAJBAmsiCDYCGAJ/IAJBAkgEQCAEIQEgAwwBCyAAIARBAWoiATYCACAELQAACyEEIABBD0EQIA5C/wFRGyIHNgIQIAAgBK0iDkL/AYMiD0L/AVEiCTYCFCAAIA5CCIYgDYQiDTcDCCAKQQJGBEAgASEEIAUhAiAIIQUMAQsgACACQQNrIgs2AhggAAJ/IAJBA0gEQCABIQYgAwwBCyAAIAFBAWoiBjYCACABLQAAC60iDkL/AYMiEEL/AVEiCTYCFCAAQQdBCCAPQv8BURsgB2oiATYCECAAIA4gB62GIA2EIg03AwggCkEBRgRAIAYhBCABIQcgCCECIAshBQwBCyAAIAJBBGsiBTYCGCAAAn8gAkEESARAIAYhBCADDAELIAAgBkEBaiIENgIAIAYtAAALrSIOQv8Bg0L/AVEiCTYCFCAAQQdBCCAQQv8BURsgAWoiBzYCECAAIA4gAa2GIA2EIg03AwggCyECCwJAIAJBBU4EQCAEKAIAIQMgACACQQVrNgIYIAAgBEEEajYCAAwBC0EAIQFBf0EAIAMbIQMgAkECSA0AA0AgACAEQQFqIgI2AgAgBC0AACEEIAAgBUEBayIGNgIYIANB/wEgAXRBf3NxIAQgAXRyIQMgAUEIaiEBIAVBAUshDCACIQQgBiEFIAwNAAsLIAAgA0EYdiIBQf8BRjYCFCAAQQdBCCAJGyICQQdBCCADQf8BcSIEQf8BRhtqIgVBB0EIIANBCHZB/wFxIgZB/wFGG2oiCEEHQQggA0EQdkH/AXEiA0H/AUYbIAdqajYCECAAIAYgAnQgAyAFdHIgASAIdHIgBHKtIAethiANhDcDCAu2BQISfwJ+An8gACgCHCABQZgBbGoiAkGQAWsoAgAgAkGYAWsoAgBrIgMhBSACQYwBaygCACACQZQBaygCAGsiAiEGQcAAIAMgA0HAAE8bIQNBwAAgAiACQcAATxshBAJAIAVFDQAgBkUNACADRQ0AIARFDQBBfyAEbkECdiADSQ0AQQFBHBATIgIgBDYCDCACIAM2AgggAiAGNgIEIAIgBTYCACACIAStIhQgBq18QgF9IBSAIhSnIgQ2AhQgAiADrSIVIAWtfEIBfSAVgCIVpyIDNgIQAkAgFEL/////D4MgFUL/////D4N+QiCIpw0AIAJBBCADIARsEBMiAzYCGCADRQ0AIAIMAgsgAhAQC0EACyIJRQRAQQAPCwJAIAEEQANAIA5BmAFsIg8gACgCHGoiBSgCGCICBEAgBUEcaiEQIAUoAhQhAyAFKAIQIQRBACEKA0AgAyAEbARAIBAgCkEkbGohBkEAIQsDQCAGKAIUIAtBKGxqIggoAhQiAiAIKAIQIgdsBEBBACEEA0AgCCgCGCAEQQZ0aiIDKAI8IhEEQCADKAIMIQcgAygCFCESIAMoAhAhDCADKAIIIhMgBigCAGshAyAGKAIQIg1BAXEEQCAAKAIcIA9qIgJBkAFrKAIAIANqIAJBmAFrKAIAayEDCyAHIAYoAgRrIQIgDUECcQRAIAIgACgCHCAPaiINQYwBaygCAGogDUGUAWsoAgBrIQILIAkgAyACIAMgDCATayIMaiASIAdrIAJqIBFBASAMQQAQJkUNCSAIKAIQIQcgCCgCFCECCyAEQQFqIgQgAiAHbEkNAAsgBSgCECEEIAUoAhQhAwsgC0EBaiILIAMgBGxJDQALIAUoAhghAgsgCkEBaiIKIAJJDQALCyAOQQFqIg4gAUcNAAsLIAkPCyAJECNBAAvQDAIQfwZ7IAAoAggiCyAAKAIEaiEHAkAgACgCDEUEQCAHQQJIDQEgASgCACABIAtBAnRqIg0oAgAiBEEBakEBdWshAyAAKAIAIQYCQCAHQQRJBEAgBCECDAELIAdBBGsiAEEBdiIJQQFqIQwCQCAAQRZJBEBBASEADAELIAYgASALQQJ0aiIFIAlBAnQiAmpBCGpJIAYgCUEDdGpBCGoiACAFQQRqS3EEQEEBIQAMAQsgBiABIAJqQQhqSSABQQRqIABJcQRAQQEhAAwBCyAMQfz///8HcSIFQQFyIQAgBUEBdCEIIAT9ESESIAP9ESET/QwAAAAAAgAAAAQAAAAGAAAAIRZBACECA0AgASACQQJ0QQRyIgNq/QACACEVIAMgDWr9AAIAIRQgBiACQQN0aiIDIBP9WgIAAyADQQhqIBUgFCASIBT9DQwNDg8QERITFBUWFxgZGhsiFf2uAf0MAgAAAAIAAAACAAAAAgAAAP2uAUEC/awB/bEBIhL9WgIAACADQRBqIBL9WgIAASADQRhqIBL9WgIAAiAGIBb9DAEAAAABAAAAAQAAAAEAAAD9UCIX/RsAQQJ0aiASIBMgEv0NDA0ODxAREhMUFRYXGBkaG/2uAUEB/awBIBX9rgEiE/1aAgAAIAYgF/0bAUECdGogE/1aAgABIAYgF/0bAkECdGogE/1aAgACIAYgF/0bA0ECdGogE/1aAgADIBb9DAgAAAAIAAAACAAAAAgAAAD9rgEhFiASIRMgFCESIAJBBGoiAiAFRw0ACyAS/RsDIQIgE/0bAyEDIAUgDEYNASACIQQLA0AgASAAQQJ0IgJqKAIAIQkgAiANaigCACECIAYgCEECdGoiBSADNgIAIAUgAyAJIAIgBGpBAmpBAnVrIgNqQQF1IARqNgIEIAhBAmohCCAAIAxHIRAgAiEEIABBAWohACAQDQALCyAGIAhBAnRqIAM2AgBBfCEAIAdBAXEEfyAGIAdBAWsiAEECdGogASAAQQF0aigCACACQQFqQQF1ayIANgIAIAAgA2pBAXUhA0F4BUF8CyAGIAdBAnQiAGpqIAIgA2o2AgAgASAGIAAQEhoPCwJAAkACQCAHQQFrDgIAAQILIAEgASgCAEECbTYCAA8LIAAoAgAiBCABKAIAIAEgC0ECdGoiAygCAEEBakEBdWsiADYCBCAEIAAgAygCAGo2AgAgASAEKQIANwIADwsgB0EDSA0AIAAoAgAiCiABKAIAIAEgC0ECdGoiDigCBCIEIA4oAgAiAGpBAmpBAnVrIgMgAGo2AgBBASEIAkAgB0ECayIGIAdBAXEiDEUiAGtBAkkEQCAEIQIMAQsgByAAa0EEayIAQQF2IgJBAWohDwJAAkAgAEEWSQ0AIApBBGoiBSABIAJBAnQiAGpBCGpJIAogAkEDdGpBDGoiAiABQQRqS3ENACAFIAAgASALQQJ0aiIAakEMakkgAEEIaiACSXENACAPQXxxIgVBAXIhACAFQQF0QQFyIQggBP0RIRMgA/0RIRJBACECA0AgCiACQQN0aiIEIAEgAkECdCIDav0AAgQgEyADIA5q/QACCCIT/Q0MDQ4PEBESExQVFhcYGRobIhUgE/2uAf0MAgAAAAIAAAACAAAAAgAAAP2uAUEC/awB/bEBIhQgFCASIBT9DQwNDg8QERITFBUWFxgZGhv9rgFBAf2sASAV/a4BIhX9DQQFBgcYGRobCAkKCxwdHh/9CwIUIAQgEiAV/Q0MDQ4PEBESEwABAgMUFRYXIBT9DQABAgMEBQYHEBESEwwNDg/9CwIEIBQhEiACQQRqIgIgBUcNAAsgE/0bAyECIBL9GwMhAyAFIA9GDQIgAiEEDAELQQEhAAsDQCABIABBAnRqKAIAIQ0gDiAAQQFqIgVBAnRqKAIAIQIgCiAIQQJ0aiIJIAM2AgAgCSADIA0gAiAEakECakECdWsiA2pBAXUgBGo2AgQgCEECaiEIIAAgD0chESACIQQgBSEAIBENAAsLIAogCEECdGogAzYCAAJAIAxFBEAgCiAGQQJ0aiABIAdBAXRqQQRrKAIAIAJBAWpBAXVrIgAgA2pBAXUgAmo2AgAMAQsgAiADaiEACyAKIAdBAnQiA2pBBGsgADYCACABIAogAxASGgsLoAcDA30DewJ/IANBCE8EQCADQQN2IQsDQCAB/QAEACEHIAAgAP0ABAAiCCAC/QAEACIJ/Qy8dLM/vHSzP7x0sz+8dLM//eYB/eQB/QsEACABIAggB/0MzzGwPs8xsD7PMbA+zzGwPv3mAf3lASAJ/Qzh0TY/4dE2P+HRNj/h0TY//eYB/eUB/QsEACACIAggB/0M5dDiP+XQ4j/l0OI/5dDiP/3mAf3kAf0LBAAgAf0ABBAhByAAIAD9AAQQIgggAv0ABBAiCf0MvHSzP7x0sz+8dLM/vHSzP/3mAf3kAf0LBBAgASAIIAf9DM8xsD7PMbA+zzGwPs8xsD795gH95QEgCf0M4dE2P+HRNj/h0TY/4dE2P/3mAf3lAf0LBBAgAiAIIAf9DOXQ4j/l0OI/5dDiP+XQ4j/95gH95AH9CwQQIAJBIGohAiABQSBqIQEgAEEgaiEAIApBAWoiCiALRw0ACwsCQCADQQdxIgNFDQAgASoCACEEIAAgAioCACIGQ7x0sz+UIAAqAgAiBZI4AgAgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIAIAIgBSAEQ+XQ4j+UkjgCACADQQFGDQAgASoCBCEEIAAgAioCBCIGQ7x0sz+UIAAqAgQiBZI4AgQgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIEIAIgBSAEQ+XQ4j+UkjgCBCADQQJGDQAgASoCCCEEIAAgAioCCCIGQ7x0sz+UIAAqAggiBZI4AgggASAFIARDzzGwvpSSIAZD4dE2v5SSOAIIIAIgBSAEQ+XQ4j+UkjgCCCADQQNGDQAgASoCDCEEIAAgAioCDCIGQ7x0sz+UIAAqAgwiBZI4AgwgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIMIAIgBSAEQ+XQ4j+UkjgCDCADQQRGDQAgASoCECEEIAAgAioCECIGQ7x0sz+UIAAqAhAiBZI4AhAgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIQIAIgBSAEQ+XQ4j+UkjgCECADQQVGDQAgASoCFCEEIAAgAioCFCIGQ7x0sz+UIAAqAhQiBZI4AhQgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIUIAIgBSAEQ+XQ4j+UkjgCFCADQQZGDQAgASoCGCEEIAAgAioCGCIGQ7x0sz+UIAAqAhgiBZI4AhggASAFIARDzzGwvpSSIAZD4dE2v5SSOAIYIAIgBSAEQ+XQ4j+UkjgCGAsL4AECBn8DewJAIANFDQAgA0EETwRAIANBfHEhBgNAIAAgBEECdCIFaiIHIAf9AAIAIAIgBWoiB/0AAgAiCyABIAVqIgX9AAIAIgz9rgFBAv2sAf2xASIKIAv9rgH9CwIAIAUgCv0LAgAgByAKIAz9rgH9CwIAIARBBGoiBCAGRw0ACyADIAZGDQELA0AgACAGQQJ0IgRqIgUgBSgCACACIARqIgUoAgAiByABIARqIggoAgAiCWpBAnVrIgQgB2o2AgAgCCAENgIAIAUgBCAJajYCACAGQQFqIgYgA0cNAAsLC90BAQR/IwBBgAFrIgYkACAGIQUCQCABKAIMIAJBBHRqIgIoAgAiBEUEQCACIQEMAQsDQCAFIAI2AgAgBUEEaiEFIAQiASICKAIAIgQNAAsLQQAhBANAIAEoAggiAiAESARAIAEgBDYCCCAEIQILAkAgAiADTg0AA0AgAiABKAIETg0BAkAgAEEBEB8EQCABIAI2AgQMAQsgAkEBaiECCyACIANIDQALCyABIAI2AgggBSAGRwRAIAVBBGsiBSgCACEBIAIhBAwBCwsgASgCBCEHIAZBgAFqJAAgByADSAv9BgELfyMAQYACayIKJAACQCAARQRAQQAhAAwBCwJAIAEgACgCAEYEQCAAKAIEIAJGDQELIAAgAjYCBCAAIAE2AgAgCiACNgIAIAogATYCgAEgAiEEIAEhBQNAIAogByIMQQFqIgdBAnQiCGogBEEBakECbSIJNgIAIApBgAFqIAhqIAVBAWpBAm0iCDYCACAGIAQgBWwiC2ohBiAJIQQgCCEFIAtBAUsNAAsgACAGNgIIAkACQAJAAkAgBkUEQCAAKAIMIgRFDQIgAEEMaiEFDAELIAZBBHQiBCAAKAIQTQ0DIAAoAgwgBBAXIgENAiADQQFBmjFBABAPIABBDGoiBSgCACIERQ0BCyAEEBAgBUEANgIACyAAEBBBACEADAMLIAAgATYCDCABIAAoAhAiAmpBACAEIAJrEBUaIAAgBDYCECAAKAIEIQIgACgCACEBCyAAKAIMIQUgDARAQQAhAyAFIAEgAmxBBHRqIgQhBgNAAkAgCiADQQJ0IgFqKAIAIghBAEwNACAIQQFrIQtBACEJAkACQCAKQYABaiABaigCACICQQBMBEAgCEEBcSENQQAhByAIQQFHDQEgBiEBDAILA0AgBiEBIAIhBgNAAkAgBSAENgIAIAZBAUYEQCAFQRBqIQUgBEEQaiEEDAELIAUgBDYCECAEQRBqIQQgBUEgaiEFIAZBAkohDiAGQQJrIQYgDg0BCwsgBCABIAJBBHRqIAkgCSALRnJBAXEiBxshBiAEIAEgBxshBCAJQQFqIgkgCEcNAAsMAgsgCEH+////B3EhCANAIAcgC0YhASAHQQJqIQcgBCAGIAEbIgQhBiAEIQEgCUECaiIJIAhHDQALCyANRQRAIAQhBgwBCyAEIAEgAkEEdGogByAHIAtGckEBcSICGyEGIAQgASACGyEECyADQQFqIgMgDEcNAAsLIAVBADYCAAsgACgCCCIBRQ0AIAAoAgwhBCABQQRPBEAgAUF8cSECQQAhBQNAIARBADYCPCAEQucHNwI0IARBADYCLCAEQucHNwIkIARBADYCHCAEQucHNwIUIARBADYCDCAEQucHNwIEIARBQGshBCAFQQRqIgUgAkcNAAsLIAFBA3EiAUUNAEEAIQUDQCAEQQA2AgwgBELnBzcCBCAEQRBqIQQgBUEBaiIFIAFHDQALCyAKQYACaiQAIAALsQEBA38CQCAARQ0AIAAoAggiAUUNACAAKAIMIQAgAUEETwRAIAFBfHEhAwNAIABBADYCPCAAQucHNwI0IABBADYCLCAAQucHNwIkIABBADYCHCAAQucHNwIUIABBADYCDCAAQucHNwIEIABBQGshACACQQRqIgIgA0cNAAsLIAFBA3EiAUUNAEEAIQIDQCAAQQA2AgwgAELnBzcCBCAAQRBqIQAgAkEBaiICIAFHDQALCwv7BQEQfyMAQYACayIIJAACf0EBQRQQEyIGRQRAIAJBAUH0MEEAEA9BAAwBCyAGIAE2AgQgBiAANgIAIAggATYCACAIIAA2AoABA0AgCCAFIg1BAWoiBUECdCIHaiABQQFqQQJtIgM2AgAgCEGAAWogB2ogAEEBakECbSIHNgIAIAQgACABbCIJaiEEIAMhASAHIQAgCUEBSw0ACyAGIAQ2AgggBEUEQCAGEBBBAAwBCyAGIARBEBATIgM2AgwgA0UEQCACQQFB2hpBABAPIAYQEEEADAELIAYgBigCCCILQQR0NgIQIAMhACANBEAgAyAGKAIEIAYoAgBsQQR0aiIEIQEDQAJAIAggDkECdCICaigCACIJQQBMDQAgCUEBayEMQQAhBwJAIAhBgAFqIAJqKAIAIgJBAEwEQEEAIQUgCUEBRwRAIAlB/v///wdxIQoDQCAFIAxGIQ8gBUECaiEFIAEgBCAPGyIEIQEgB0ECaiIHIApHDQALCyAJQQFxDQEgBCEBDAILA0AgBCEFIAIhBANAAkAgACABNgIAIARBAUYEQCAAQRBqIQAgAUEQaiEBDAELIAAgATYCECABQRBqIQEgAEEgaiEAIARBAkohECAEQQJrIQQgEA0BCwsgASAFIAJBBHRqIAcgByAMRnJBAXEiChshBCABIAUgChshASAHQQFqIgcgCUcNAAsMAQsgASAEIAJBBHRqIAUgBSAMRnJBAXEiBRshESABIAQgBRshASARIQQLIA5BAWoiDiANRw0ACwsgAEEANgIAAkAgC0UNACALQQRPBEAgC0F8cSEAQQAhAQNAIANBADYCPCADQucHNwI0IANBADYCLCADQucHNwIkIANBADYCHCADQucHNwIUIANBADYCDCADQucHNwIEIANBQGshAyABQQRqIgEgAEcNAAsLIAtBA3EiAEUNAEEAIQEDQCADQQA2AgwgA0LnBzcCBCADQRBqIQMgAUEBaiIBIABHDQALCyAGCyESIAhBgAJqJAAgEgtTAQF/An8gAC0ADEH/AUYEQCAAQoD+g4DwADcCDEEAIAAoAggiASAAKAIETw0BGiAAIAFBAWo2AgggACABLQAAQYD+A3I2AgwLIABBADYCEEEBCwt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARBlIQAgASgCAEFAags2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLSQEBfwJAQQFBLBATIgEEQCABQQA2AhACQCAAQQBMBEAgAUEBQQgQEyIANgIkIABFDQEMAwsgAUEANgIMCyABEBALQQAhAQsgAQuRAgAgAEUEQEEADwsCfwJAIAFB/wBNDQACQEGU0AEoAgAoAgBFBEAgAUGAf3FBgL8DRg0CDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMAwsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMMAwsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQMAwsLQZTHAUEZNgIAQX8MAQsgACABOgAAQQELC7wCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAwALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC3MBBn8gACgCACIDLAAAQTBrIgFBCUsE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AyAAQRh2NgIUIAMgBDYCECADIABBCHZB/wFxNgIcIAMgAEEQdkH/AXE2AhggAkEBQc31ACADQRBqEA8MBwsgBSAITQRAIAYhBAwECyAFIQggBiAFEBciBA0DIAYQECACQQFB/w9BABAPQQAMBwsgBEECcUUEQCACQQFBwg9BABAPIAYQEEEADAcLIAAgBEH/////B3I2AmQgASAHIAVrrSINIAIgASgCKBEIACANUQ0DIAAtAGRBCHFFDQEgAkECQZIcQQAQDwsgBhAQQQEMBQsgAkEBQZIcQQAQDyAGEBBBAAwECyABIAQgBSACEBogBUcEQCACQQFBxBxBABAPIAQQEEEADAQLIAAgBCIGIAUgAiAKKAIEEQEADQALIAQQEEEADAILIAJBAUGiJUEAEA9BAAwBCyAGEBBBAAshDCADQfAAaiQAIAwL5gEBBn8gACgCCEE1IAIQJARAAkAgACgCCCIGKAIAIQMgBigCCCEFAkACQAJ/AkAgAwRAQQEhBCADQQFxIQcgA0EBRw0BQQAMAgsgBkEANgIADAILIANBfnEhAwNAAn9BACAERQ0AGkEAIAAgASACIAUoAgARAABFDQAaIAAgASACIAUoAgQRAABBAEcLIQQgBUEIaiEFIAhBAmoiCCADRw0ACyAERQshAyAHBEAgAw0CIAAgASACIAUoAgARAABBAEchBAsgBkEANgIAIARFDQILIAAoAgAaQQEPCyAGQQA2AgALC0EACwoAIAAoAgAaQQALFAAgACgCACIABEAgACABNgK4AQsLIQAgACgCACABEFMgAEEAOgB8IAAgASgCuEBBAXE2AoABCzIAIAJFBEBBAA8LIAAoAgAgASACIAMQSEUEQCADQQFBqS9BABAPQQAPCyAAIAIgAxBxC2kCAn8BfCMAQRBrIgMkACACBEADQCAAIANBCGoQRCABAn8gAysDCCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAs2AgAgAUEEaiEBIABBCGohACAEQQFqIgQgAkcNAAsLIANBEGokAAuEAQICfwF9IwBBEGsiAyQAIAIEQANAIAMgAC0AADoADyADIAAtAAE6AA4gAyAALQACOgANIAMgAC0AAzoADCABAn8gAyoCDCIFi0MAAABPXQRAIAWoDAELQYCAgIB4CzYCACABQQRqIQEgAEEEaiEAIARBAWoiBCACRw0ACwsgA0EQaiQAC0sBAn8jAEEQayIDJAAgAgRAA0AgACADQQxqQQQQESABIAMoAgw2AgAgAUEEaiEBIABBBGohACAEQQFqIgQgAkcNAAsLIANBEGokAAtLAQJ/IwBBEGsiAyQAIAIEQANAIAAgA0EMakECEBEgASADKAIMNgIAIAFBBGohASAAQQJqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALSgECfyMAQRBrIgMkACACBEADQCAAIANBCGoQRCABIAMrAwi2OAIAIAFBBGohASAAQQhqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALaAECfyMAQRBrIgMkACACBEADQCADIAAtAAA6AA8gAyAALQABOgAOIAMgAC0AAjoADSADIAAtAAM6AAwgASADKgIMOAIAIAFBBGohASAAQQRqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALTAECfyMAQRBrIgMkACACBEADQCAAIANBDGpBBBARIAEgAygCDLM4AgAgAUEEaiEBIABBBGohACAEQQFqIgQgAkcNAAsLIANBEGokAAtMAQJ/IwBBEGsiAyQAIAIEQANAIAAgA0EMakECEBEgASADKAIMszgCACABQQRqIQEgAEECaiEAIARBAWoiBCACRw0ACwsgA0EQaiQAC6oIAg1/AXsjAEEQayIIJAACfyAAKAIIQRBGBEAgACgCnAEgACgCzAFBjCxsagwBCyAAKAIMCyEJAkAgAkUEQCADQQFB8B9BABAPDAELIAAoAkghBkEBIQQgASAIQQhqQQEQESAIKAIIIgVBAk8EQCADQQJBxsgAQQAQDwwBCyACIAVBAWpHBEBBACEEIANBAkHwH0EAEA8MAQsCQCAGKAIQIgNFDQAgCSgC0CshBCADQQhPBEAgA0F4cSEGQQAhAgNAIARBADYCvEMgBEEANgKEOyAEQQA2AswyIARBADYClCogBEEANgLcISAEQQA2AqQZIARBADYC7BAgBEEANgK0CCAEQcDDAGohBCACQQhqIgIgBkcNAAsLIANBB3EiA0UNAEEAIQIDQCAEQQA2ArQIIARBuAhqIQQgAkEBaiICIANHDQALCyAJKALoKyICBH8gAhAQIAlBADYC6CsgCCgCCAUgBQtFBEBBASEEDAELA0AgAUEBaiIBIAhBDGpBARARAkAgCSgCgCxFDQAgCSgC/CsiAygCACAIKAIMRw0AIAMoAgQiBSAAKAJIIgYoAhBHDQAgAygCCCICBEBBACEEIAIoAhAgBSAFbCIFIAIoAgBBAnRB0L0BaigCAGxHDQMgCSAFQQJ0EBQiBzYC6CsgB0UNAyACKAIMIAcgBSACKAIAQQJ0QYDAAWooAgARBQALIAMoAgwiAkUNAEEAIQQgAigCECAGKAIQIgMgAigCAEECdEHQvQFqKAIAbEcNAiADQQJ0EBQiBUUNAiACKAIMIAUgAyACKAIAQQJ0QZDAAWooAgARBQACQCAGKAIQIgdFDQAgCSgC0CshBEEAIQsCQAJAIAdBBEkNACAEQbQIaiIMIAUgB0ECdGpJBEAgBSAEIAdBuAhsakkNAQsgBEHcIWohDSAEQaQZaiEOIARB7BBqIQ8gBSAHQXxxIgZBAnRqIQIgBCAGQbgIbGohBEEAIQMDQCAMIANBuAhsIgpqIAUgA0ECdGr9AAIAIhH9WgIAACAKIA9qIBH9WgIAASAKIA5qIBH9WgIAAiAKIA1qIBH9WgIAAyADQQRqIgMgBkcNAAsgBiAHRg0CDAELIAUhAkEAIQYLIAcgBiIDa0EHcSIKBEADQCAEIAIoAgA2ArQIIANBAWohAyAEQbgIaiEEIAJBBGohAiALQQFqIgsgCkcNAAsLIAYgB2tBeEsNAANAIAQgAigCADYCtAggBCACKAIENgLsECAEIAIoAgg2AqQZIAQgAigCDDYC3CEgBCACKAIQNgKUKiAEIAIoAhQ2AswyIAQgAigCGDYChDsgBCACKAIcNgK8QyAEQcDDAGohBCACQSBqIQIgA0EIaiIDIAdHDQALCyAFEBALQQEhBCAQQQFqIhAgCCgCCEkNAAsLIAhBEGokACAECwQAQn8LvwkBC38jAEEQayIFJAACfyAAKAIIQRBGBEAgACgCnAEgACgCzAFBjCxsagwBCyAAKAIMCyEHAn8gAkEBTQRAIANBAUHYI0EAEA9BAAwBCyABIAVBDGpBAhARIAUoAgwEQCADQQJB8CxBABAPQQEMAQsgAkEGTQRAIANBAUHYI0EAEA9BAAwBCyABQQJqIAVBCGpBARARIAcoAvwrIgkhAAJAAkACQCAHKAKALCIGRQ0AIAUoAgghCANAIAAoAgAgCEYNASAAQRRqIQAgBEEBaiIEIAZHDQALDAELIAQgBkcNAQsgBygChCwgBkYEfyAHIAZBCmoiADYChCwgCSAAQRRsEBciAEUEQCAHKAL8KxAQIAdBADYChCwgB0IANwL8KyADQQFB8iNBABAPQQAMAwsgByAANgL8KyAAIAcoAoAsIgRBFGxqQQAgBygChCwgBGtBFGwQFRogBygC/CshCSAHKAKALAUgBgtBFGwgCWohAEEBIQsLIAAgBSgCCDYCACABQQNqIAVBDGpBAhARIAUoAgwEQCADQQJB8CxBABAPQQEMAQsgAUEFaiAFQQRqQQIQESAFKAIEIgRBAk8EQCADQQJBqBdBABAPQQEMAQsgAkEHayEGIAQEQCABQQdqIQJBACEJA0AgBkECTQRAIANBAUHYI0EAEA9BAAwDCyACIAVBDGpBARARIAUoAgxBAUcEQCADQQJBsipBABAPQQEMAwsgAkEBaiAFQQIQESAAIAUoAgAiBEH//wFxIgE2AgQgBkEDayIIIARBD3ZBAWoiBiABbEECaiIKSQRAIANBAUHYI0EAEA9BAAwDCyACQQNqIQJBACEEIAEEQANAIAIgBUEMaiAGEBEgBCAFKAIMRwRAIANBAkHaL0EAEA9BAQwFCyACIAZqIQIgBEEBaiIEIAAoAgRJDQALCyACIAVBAhARIAUgBSgCACIEQf//AXEiATYCACAAKAIEIAFHBEAgA0ECQdgYQQAQD0EBDAMLIAggCmsiCiAEQQ92QQFqIgYgAWxBA2oiDEkEQCADQQFB2CNBABAPQQAMAwsgAkECaiECQQAhBCABBEADQCACIAVBDGogBhARIAQgBSgCDEcEQCADQQJB2i9BABAPQQEMBQsgAiAGaiECIARBAWoiBCAAKAIESQ0ACwsgAiAFQQxqQQMQESAFKAIMIQYgAEIANwIIIAAgBkGAgARxRSAALQAQQf4BcXI6ABAgBSAGQf8BcSIINgIIAkAgCEUNACAHKAL0KyINBEAgBygC8CshBEEAIQEDQCAIIAQoAghGBEAgACAENgIIDAMLIARBFGohBCABQQFqIgEgDUcNAAsLIANBAUHYI0EAEA9BAAwDCyAFIAZBCHZB/wFxIgY2AggCQCAGRQ0AIAcoAvQrIggEQCAHKALwKyEEQQAhAQNAIAYgBCgCCEYEQCAAIAQ2AgwMAwsgBEEUaiEEIAFBAWoiASAIRw0ACwsgA0EBQdgjQQAQD0EADAMLIAogDGshBiACQQNqIQIgCUEBaiIJIAUoAgRJDQALCyAGBEAgA0EBQdgjQQAQD0EADAELQQEgC0UNABogByAHKAKALEEBajYCgCxBAQshDiAFQRBqJAAgDgv1AQEFfyMAQRBrIgQkAAJAIAIgACgCSCgCECIGQQJqRwRAIANBAUHwIkEAEA8MAQsgASAEQQxqQQIQESAGIAQoAgxHBEAgA0EBQfAiQQAQDwwBCyAGRQRAQQEhBQwBCyABQQJqIQIgACgCSCgCGCEAQQAhAQNAIAIgBEEIakEBEBEgACAEKAIIIgVB/wBxIgdBAWoiCDYCGCAAIAVBB3ZBAXE2AiAgB0EfTwRAIAQgCDYCBCAEIAE2AgAgA0EBQbfzACAEEA9BACEFDAILIABBNGohAEEBIQUgAkEBaiECIAFBAWoiASAGRw0ACwsgBEEQaiQAIAULmAUBCn8jAEEQayIHJAACfyAAKAIIQRBGBEAgACgCnAEgACgCzAFBjCxsagwBCyAAKAIMCyEFAn8gAkEBTQRAIANBAUHxHkEAEA9BAAwBCyABIAdBDGpBAhARAkAgBygCDARAIANBAkGGG0EAEA8MAQsgAkEGTQRAIANBAUHxHkEAEA9BAAwCCyABQQJqIAdBDGpBAhARIAUoAvArIQQgBy0ADCEKAkACQAJAIAUoAvQrIgZFBEAgBCEADAELIAQhAANAIAAoAgggCkYNASAAQRRqIQAgCEEBaiIIIAZHDQALDAELIAYgCEcNAQsgBSgC+CsgBkYEQCAFIAZBCmoiADYC+CsgBCAAQRRsEBchACAFKALwKyEEIABFBEAgBBAQIAVBADYC+CsgBUIANwLwKyADQQFBix9BABAPQQAMBAsCQCAAIARGDQAgBSgCgCwiC0UNACAFKAL8KyEMQQAhCANAIAwgCEEUbGoiBigCCCIJBEAgBiAAIAkgBGtqNgIICyAGKAIMIgkEQCAGIAAgCSAEa2o2AgwLIAhBAWoiCCALRw0ACwsgBSAANgLwKyAAIAUoAvQrIgRBFGxqQQAgBSgC+CsgBGtBFGwQFRogBSgC9CshBiAFKALwKyEECyAFIAZBAWo2AvQrIAQgBkEUbGohAAsgACgCDCIEBEAgBBAQIABCADcCDAsgACAKNgIIIAAgBygCDCIEQQp2QQNxNgIAIAAgBEEIdkEDcTYCBCABQQRqIAdBDGpBAhARIAcoAgwEQCADQQJBvRZBABAPDAELIAAgAkEGayICEBQiBDYCDCAERQRAIANBAUHxHkEAEA9BAAwCCyAEIAFBBmogAhASGiAAIAI2AhALQQELIQ0gB0EQaiQAIA0LJwBBASEBIAIgACgCSCgCEEECdEcEfyADQQFB1yFBABAPQQAFQQELC6sDAQV/IwBBEGsiBiQAAn8gAkEBTQRAIANBAUH9HUEAEA9BAAwBCyAALQC8AUEBcQRAIANBAUGJ3gBBABAPQQAMAQsgACgCnAEgACgCzAFBjCxsaiIAIAAtAIgsQQJyOgCILCABIAZBDGpBARARAkAgACgCrCgiBEUEQCAAIAYoAgxBAWoiBUEIEBMiBDYCrCggBEUEQCADQQFBlx5BABAPQQAMAwsgACAFNgKoKAwBCyAGKAIMIgUgACgCqChJDQAgBCAFQQFqIgRBA3QQFyIFRQRAIANBAUGXHkEAEA9BAAwCCyAAIAU2AqwoIAUgACgCqCgiB0EDdGpBACAEIAdrQQN0EBUaIAAgBDYCqCggACgCrCghBAsgBCAGKAIMIgVBA3RqKAIABEAgBiAFNgIAIANBAUG9NSAGEA9BAAwBCyACQQFrIgIQFCEEIAAoAqwoIgAgBigCDCIFQQN0aiAENgIAIARFBEAgA0EBQZceQQAQD0EADAELIAAgBUEDdGogAjYCBCAAIAYoAgxBA3RqKAIAIAFBAWogAhASGkEBCyEIIAZBEGokACAIC/UCAQV/IwBBEGsiBiQAAn8gAkEBTQRAIANBAUGkIEEAEA9BAAwBCyAAIAAtALwBQQFyOgC8ASABIAZBDGpBARARAkAgACgCdCIERQRAIAAgBigCDEEBaiIFQQgQEyIENgJ0IARFBEAgA0EBQb4gQQAQD0EADAMLIAAgBTYCcAwBCyAGKAIMIgUgACgCcEkNACAEIAVBAWoiBEEDdBAXIgVFBEAgA0EBQb4gQQAQD0EADAILIAAgBTYCdCAFIAAoAnAiB0EDdGpBACAEIAdrQQN0EBUaIAAgBDYCcCAAKAJ0IQQLIAQgBigCDCIFQQN0aigCAARAIAYgBTYCACADQQFB0zUgBhAPQQAMAQsgAkEBayICEBQhBCAAKAJ0IgAgBigCDCIFQQN0aiAENgIAIARFBEAgA0EBQb4gQQAQD0EADAELIAAgBUEDdGogAjYCBCAAIAYoAgxBA3RqKAIAIAFBAWogAhASGkEBCyEIIAZBEGokACAIC6ABAQR/IwBBEGsiBCQAAn8gAkUEQCADQQFB1x5BABAPQQAMAQsgASAEQQxqQQEQEUEBIAJBAWsiBUUNABpBACEAQQAhAgNAIAFBAWoiASAEQQhqQQEQESAEKAIIIgZBGHRBH3UgBkH/AHEgAnJBB3RxIQIgAEEBaiIAIAVHDQALQQEgAkUNABogA0EBQdceQQAQD0EACyEHIARBEGokACAHCxsAQQEhACACBH9BAQUgA0EBQf4gQQAQD0EACwuAAQEBfyMAQRBrIgAkAEEBIQQCQCACQQFNBEBBACEEIANBAUHkIEEAEA8MAQsgASAAQQxqQQEQESABQQFqIABBCGpBARARIAJBAmsgACgCCCIBQQV2QQJxIAFBBHZBA3FqQQJqcEUNAEEAIQQgA0EBQeQgQQAQDwsgAEEQaiQAIAQLBABBAAsLorwBIQBBgAgLkXVjYW5ub3QgYWxsb2NhdGUgb3BqX3RjZF9zZWdfZGF0YV9jaHVua190KiBhcnJheQAtKyAgIDBYMHgALTBYKzBYIDBYLTB4KzB4IDB4AFVua25vd24gZm9ybWF0AEZhaWxlZCB0byBzZXR1cCB0aGUgZGVjb2RlcgBGYWlsZWQgdG8gcmVhZCB0aGUgaGVhZGVyAG5hbgAqbF90aWxlX2xlbiA+IFVJTlRfTUFYIC0gT1BKX0NPTU1PTl9DQkxLX0RBVEFfRVhUUkEgLSBwX2oyay0+bV9zcGVjaWZpY19wYXJhbS5tX2RlY29kZXIubV9zb3RfbGVuZ3RoAGluZgBGYWlsZWQgdG8gZGVjb2RlIHRoZSBpbWFnZQBJbnZhbGlkIGFjY2VzcyB0byBwaS0+aW5jbHVkZQAvdG1wL29wZW5qcGVnL3NyYy9iaW4vY29tbW9uL2NvbG9yLmMAQUxMX0NQVVMAT1BKX05VTV9USFJFQURTAE5BTgBJTkYAcF9qMmstPm1fc3BlY2lmaWNfcGFyYW0ubV9kZWNvZGVyLm1fc290X2xlbmd0aCA+IFVJTlRfTUFYIC0gT1BKX0NPTU1PTl9DQkxLX0RBVEFfRVhUUkEACQkJIHByZWNjaW50c2l6ZSAodyxoKT0ACQkJIHN0ZXBzaXplcyAobSxlKT0ALgAobnVsbCkAKCVkLCVkKSAAJXN9CgAJCSB9CgBbREVWXSBEdW1wIGFuIGltYWdlX2NvbXBfaGVhZGVyIHN0cnVjdCB7CgBbREVWXSBEdW1wIGFuIGltYWdlX2hlYWRlciBzdHJ1Y3QgewoASW1hZ2UgaW5mbyB7CgAJIGRlZmF1bHQgdGlsZSB7CgAlcwkgY29tcG9uZW50ICVkIHsKAAkJIGNvbXAgJWQgewoACSBUaWxlIGluZGV4OiB7CgAJIE1hcmtlciBsaXN0OiB7CgBDb2Rlc3RyZWFtIGluZGV4IGZyb20gbWFpbiBoZWFkZXI6IHsKAENvZGVzdHJlYW0gaW5mbyBmcm9tIG1haW4gaGVhZGVyOiB7CgBTdHJlYW0gZXJyb3Igd2hpbGUgcmVhZGluZyBKUDIgSGVhZGVyIGJveAoARm91bmQgYSBtaXNwbGFjZWQgJyVjJWMlYyVjJyBib3ggb3V0c2lkZSBqcDJoIGJveAoATWFsZm9ybWVkIEpQMiBmaWxlIGZvcm1hdDogZmlyc3QgYm94IG11c3QgYmUgSlBFRyAyMDAwIHNpZ25hdHVyZSBib3gKAE1hbGZvcm1lZCBKUDIgZmlsZSBmb3JtYXQ6IHNlY29uZCBib3ggbXVzdCBiZSBmaWxlIHR5cGUgYm94CgBOb3QgZW5vdWdoIG1lbW9yeSB0byBoYW5kbGUganBlZzIwMDAgYm94CgBOb3QgZW5vdWdoIG1lbW9yeSB3aXRoIEZUWVAgQm94CgBBIG1hcmtlciBJRCB3YXMgZXhwZWN0ZWQgKDB4ZmYtLSkgaW5zdGVhZCBvZiAlLjh4CgAJCSBtY3Q9JXgKAAkJCSBjYmxrc3R5PSUjeAoACQkJIGNzdHk9JSN4CgAJCSBwcmc9JSN4CgBJbnRlZ2VyIG92ZXJmbG93CgAJIHRkeD0ldSwgdGR5PSV1CgAJIHR3PSV1LCB0aD0ldQoACSB0eDA9JXUsIHR5MD0ldQoASW52YWxpZCBjb21wb25lbnQgaW5kZXg6ICV1CgBTdHJlYW0gdG9vIHNob3J0CgBNYXJrZXIgaGFuZGxlciBmdW5jdGlvbiBmYWlsZWQgdG8gcmVhZCB0aGUgbWFya2VyIHNlZ21lbnQKAE5vdCBlbm91Z2ggbWVtb3J5IGZvciBjdXJyZW50IHByZWNpbmN0IGNvZGVibG9jayBlbGVtZW50CgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQKAEVycm9yIHJlYWRpbmcgU1FjZCBvciBTUWNjIGVsZW1lbnQKAEEgQlBDQyBoZWFkZXIgYm94IGlzIGF2YWlsYWJsZSBhbHRob3VnaCBCUEMgZ2l2ZW4gYnkgdGhlIElIRFIgYm94ICglZCkgaW5kaWNhdGUgY29tcG9uZW50cyBiaXQgZGVwdGggaXMgY29uc3RhbnQKAEVycm9yIHdpdGggU0laIG1hcmtlcjogaWxsZWdhbCB0aWxlIG9mZnNldAoASW52YWxpZCBwcmVjaW5jdAoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGJhbmQgcHJlY2ludHMKAEZhaWxlZCB0byBkZWNvZGUgYWxsIHVzZWQgY29tcG9uZW50cwoAU2l6ZSBvZiBjb2RlIGJsb2NrIGRhdGEgZXhjZWVkcyBzeXN0ZW0gbGltaXRzCgBTaXplIG9mIHRpbGUgZGF0YSBleGNlZWRzIHN5c3RlbSBsaW1pdHMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtdWx0aXBsZSBNQ1QgbWFya2VycwoAQ29ycnVwdGVkIFBQTSBtYXJrZXJzCgBOb3QgZW5vdWdoIG1lbW9yeSBmb3IgdGlsZSByZXNvbHV0aW9ucwoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIGNvbGxlY3Rpb25zCgBJbnZhbGlkIFBDTFIgYm94LiBSZXBvcnRzIDAgcGFsZXR0ZSBjb2x1bW5zCgBXZSBkbyBub3Qgc3VwcG9ydCBST0kgaW4gZGVjb2RpbmcgSFQgY29kZWJsb2NrcwoAQ2Fubm90IGhhbmRsZSBib3ggb2YgdW5kZWZpbmVkIHNpemVzCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgY29sbGVjdGlvbnMgd2l0aG91dCBzYW1lIG51bWJlciBvZiBpbmRpeGVzCgBJbnZhbGlkIHRpbGVjLT53aW5feHh4IHZhbHVlcwoAQ2Fubm90IGhhbmRsZSBib3ggb2YgbGVzcyB0aGFuIDggYnl0ZXMKAENhbm5vdCBoYW5kbGUgWEwgYm94IG9mIGxlc3MgdGhhbiAxNiBieXRlcwoAQ29tcG9uZW50IGluZGV4ICV1IHVzZWQgc2V2ZXJhbCB0aW1lcwoASW52YWxpZCBQQ0xSIGJveC4gUmVwb3J0cyAlZCBlbnRyaWVzCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBjcmVhdGUgVGFnLXRyZWUgbm9kZXMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtY3QgZGF0YSB3aXRoaW4gbXVsdGlwbGUgTUNUIHJlY29yZHMKAENhbm5vdCBkZWNvZGUgdGlsZSwgbWVtb3J5IGVycm9yCgBvcGpfajJrX2FwcGx5X25iX3RpbGVfcGFydHNfY29ycmVjdGlvbiBlcnJvcgoAUHJvYmxlbSB3aXRoIHNraXBwaW5nIEpQRUcyMDAwIGJveCwgc3RyZWFtIGVycm9yCgBQcm9ibGVtIHdpdGggcmVhZGluZyBKUEVHMjAwMCBib3gsIHN0cmVhbSBlcnJvcgoAVW5rbm93biBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCB0bCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCBtaCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHRha2UgaW4gY2hhcmdlIFNJWiBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUFBUIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBQUFQgbWFya2VyCgBFcnJvciByZWFkaW5nIFNPVCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUExUIG1hcmtlcgoARXJyb3IgcmVhZGluZyBNQ1QgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIE1DVCBtYXJrZXIKAE5vdCBlbm91Z2ggc3BhY2UgZm9yIGV4cGVjdGVkIFNPUCBtYXJrZXIKAEV4cGVjdGVkIFNPUCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgTUNPIG1hcmtlcgoARXJyb3IgcmVhZGluZyBSR04gbWFya2VyCgBFcnJvciByZWFkaW5nIFBQTSBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgUFBNIG1hcmtlcgoARXJyb3IgcmVhZGluZyBUTE0gbWFya2VyCgBFcnJvciByZWFkaW5nIFBMTSBtYXJrZXIKAE5vdCBlbm91Z2ggc3BhY2UgZm9yIGV4cGVjdGVkIEVQSCBtYXJrZXIKAEV4cGVjdGVkIEVQSCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgQ1JHIG1hcmtlcgoAVW5rbm93biBwcm9ncmVzc2lvbiBvcmRlciBpbiBDT0QgbWFya2VyCgBVbmtub3duIFNjb2QgdmFsdWUgaW4gQ09EIG1hcmtlcgoARXJyb3IgcmVhZGluZyBDT0QgbWFya2VyCgBFcnJvciByZWFkaW5nIFFDRCBtYXJrZXIKAENycm9yIHJlYWRpbmcgQ0JEIG1hcmtlcgoARXJyb3IgcmVhZGluZyBQT0MgbWFya2VyCgBFcnJvciByZWFkaW5nIENPQyBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUUNDIG1hcmtlcgoARXJyb3IgcmVhZGluZyBNQ0MgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIE1DQyBtYXJrZXIKAHJlcXVpcmVkIFNJWiBtYXJrZXIgbm90IGZvdW5kIGluIG1haW4gaGVhZGVyCgByZXF1aXJlZCBDT0QgbWFya2VyIG5vdCBmb3VuZCBpbiBtYWluIGhlYWRlcgoAcmVxdWlyZWQgUUNEIG1hcmtlciBub3QgZm91bmQgaW4gbWFpbiBoZWFkZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGhhbmRsZSBqcGVnMjAwMCBmaWxlIGhlYWRlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBoZWFkZXIKAEVycm9yIHdpdGggSlAgU2lnbmF0dXJlIDogYmFkIG1hZ2ljIG51bWJlcgoASW4gU09UIG1hcmtlciwgVFBTb3QgKCVkKSBpcyBub3QgdmFsaWQgcmVnYXJkcyB0byB0aGUgY3VycmVudCBudW1iZXIgb2YgdGlsZS1wYXJ0ICglZCksIGdpdmluZyB1cAoASW4gU09UIG1hcmtlciwgVFBTb3QgKCVkKSBpcyBub3QgdmFsaWQgcmVnYXJkcyB0byB0aGUgcHJldmlvdXMgbnVtYmVyIG9mIHRpbGUtcGFydCAoJWQpLCBnaXZpbmcgdXAKAEluIFNPVCBtYXJrZXIsIFRQU290ICglZCkgaXMgbm90IHZhbGlkIHJlZ2FyZHMgdG8gdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHRpbGUtcGFydCAoaGVhZGVyKSAoJWQpLCBnaXZpbmcgdXAKAHRpbGVzIHJlcXVpcmUgYXQgbGVhc3Qgb25lIHJlc29sdXRpb24KAE1hcmtlciBpcyBub3QgY29tcGxpYW50IHdpdGggaXRzIHBvc2l0aW9uCgBQcm9ibGVtIHdpdGggc2VlayBmdW5jdGlvbgoARXJyb3IgcmVhZGluZyBTUENvZCBTUENvYyBlbGVtZW50LCBJbnZhbGlkIGNibGt3L2NibGtoIGNvbWJpbmF0aW9uCgBJbnZhbGlkIG11bHRpcGxlIGNvbXBvbmVudCB0cmFuc2Zvcm1hdGlvbgoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIGNvbGxlY3Rpb25zIG90aGVyIHRoYW4gYXJyYXkgZGVjb3JyZWxhdGlvbgoAVG9vIGxhcmdlIHZhbHVlIGZvciBOcHBtCgBOb3QgZW5vdWdoIGJ5dGVzIHRvIHJlYWQgTnBwbQoAYmFkIHBsYWNlZCBqcGVnIGNvZGVzdHJlYW0KAAkgTWFpbiBoZWFkZXIgc3RhcnQgcG9zaXRpb249JWxsaQoJIE1haW4gaGVhZGVyIGVuZCBwb3NpdGlvbj0lbGxpCgBNYXJrZXIgc2l6ZSBpbmNvbnNpc3RlbnQgd2l0aCBzdHJlYW0gbGVuZ3RoCgBUaWxlIHBhcnQgbGVuZ3RoIHNpemUgaW5jb25zaXN0ZW50IHdpdGggc3RyZWFtIGxlbmd0aAoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIGRhdGEgc3Bhbm5pbmcKAFdyb25nIGZsYWcKAEVycm9yIHdpdGggRlRZUCBzaWduYXR1cmUgQm94IHNpemUKAEVycm9yIHdpdGggSlAgc2lnbmF0dXJlIEJveCBzaXplCgBJbnZhbGlkIHByZWNpbmN0IHNpemUKAEluY29uc2lzdGVudCBtYXJrZXIgc2l6ZQoASW52YWxpZCBtYXJrZXIgc2l6ZQoARXJyb3Igd2l0aCBTSVogbWFya2VyIHNpemUKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCBhIG5ldyB2YWxpZGF0aW9uIHByb2NlZHVyZQoATm90IGVub3VnaCBtZW1vcnkgdG8gZGVjb2RlIHRpbGUKAEZhaWxlZCB0byBkZWNvZGUgdGhlIGNvZGVzdHJlYW0gaW4gdGhlIEpQMiBmaWxlCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgY29sbGVjdGlvbnMgd2l0aCBpbmRpeCBzaHVmZmxlCgBDYW5ub3QgYWxsb2NhdGUgVGllciAxIGhhbmRsZQoATm8gZGVjb2RlZCBhcmVhIHBhcmFtZXRlcnMsIHNldCB0aGUgZGVjb2RlZCBhcmVhIHRvIHRoZSB3aG9sZSBpbWFnZQoATm90IGVub3VnaCBtZW1vcnkgdG8gY3JlYXRlIFRhZy10cmVlCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWluaXRpYWxpemUgdGhlIHRhZyB0cmVlCgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQsIEludmFsaWQgdHJhbnNmb3JtYXRpb24gZm91bmQKAEVycm9yIHJlYWRpbmcgU1BDb2QgU1BDb2MgZWxlbWVudC4gVW5zdXBwb3J0ZWQgTWl4ZWQgSFQgY29kZS1ibG9jayBzdHlsZSBmb3VuZAoAVGlsZSBZIGNvb3JkaW5hdGVzIGFyZSBub3Qgc3VwcG9ydGVkCgBUaWxlIFggY29vcmRpbmF0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQKAEltYWdlIGNvb3JkaW5hdGVzIGFib3ZlIElOVF9NQVggYXJlIG5vdCBzdXBwb3J0ZWQKAEpQRUcyMDAwIEhlYWRlciBib3ggbm90IHJlYWQgeWV0LCAnJWMlYyVjJWMnIGJveCB3aWxsIGJlIGlnbm9yZWQKAG9wal9qMmtfbWVyZ2VfcHB0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgU09UIG1hcmtlci4gVGlsZSBpbmRleCBhbGxvY2F0aW9uIGZhaWxlZAoASWdub3JpbmcgaWhkciBib3guIEZpcnN0IGloZHIgYm94IGFscmVhZHkgcmVhZAoAWnBwdCAldSBhbHJlYWR5IHJlYWQKAFpwcG0gJXUgYWxyZWFkeSByZWFkCgBQVEVSTSBjaGVjayBmYWlsdXJlOiAlZCBzeW50aGV0aXplZCAweEZGIG1hcmtlcnMgcmVhZAoACQkJIGNibGt3PTJeJWQKAAkJCSBjYmxraD0yXiVkCgAJCQkgcW50c3R5PSVkCgAlcyBkeD0lZCwgZHk9JWQKAAkJCSByb2lzaGlmdD0lZAoACQkJIG51bWdiaXRzPSVkCgAJCSBudW1sYXllcnM9JWQKACVzIG51bWNvbXBzPSVkCgBvcGpfanAyX2FwcGx5X2NkZWY6IGFjbj0lZCwgbnVtY29tcHM9JWQKAG9wal9qcDJfYXBwbHlfY2RlZjogY249JWQsIG51bWNvbXBzPSVkCgAJCQkgbnVtcmVzb2x1dGlvbnM9JWQKAAkJIHR5cGU9JSN4LCBwb3M9JWxsaSwgbGVuPSVkCgAlcyBzZ25kPSVkCgAJCQkgcW1mYmlkPSVkCgAlcyBwcmVjPSVkCgAJCSBuYiBvZiB0aWxlLXBhcnQgaW4gdGlsZSBbJWRdPSVkCgAlcyB4MT0lZCwgeTE9JWQKACVzIHgwPSVkLCB5MD0lZAoARmFpbGVkIHRvIGRlY29kZSB0aWxlICVkLyVkCgBTZXR0aW5nIGRlY29kaW5nIGFyZWEgdG8gJWQsJWQsJWQsJWQKAEZhaWxlZCB0byBkZWNvZGUgY29tcG9uZW50ICVkCgBJbnZhbGlkIHZhbHVlIGZvciBudW1yZXNvbHV0aW9ucyA6ICVkLCBtYXggdmFsdWUgaXMgc2V0IGluIG9wZW5qcGVnLmggYXQgJWQKAEludmFsaWQgY29tcG9uZW50IG51bWJlcjogJWQsIHJlZ2FyZGluZyB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgJWQKAFRvbyBtYW55IFBPQ3MgJWQKAEludmFsaWQgdGlsZSBudW1iZXIgJWQKAEludmFsaWQgdGlsZSBwYXJ0IGluZGV4IGZvciB0aWxlIG51bWJlciAlZC4gR290ICVkLCBleHBlY3RlZCAlZAoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBudW1iZXIgb2YgY29tcG9uZW50IGlzIGlsbGVnYWwgLT4gJWQKAE5vdCBlbm91Z2ggbWVtb3J5IGZvciBjaWVsYWIKAENhbm5vdCBhbGxvY2F0ZSBjYmxrLT5kZWNvZGVkX2RhdGEKAEZhaWxlZCB0byBtZXJnZSBQUFQgZGF0YQoARmFpbGVkIHRvIG1lcmdlIFBQTSBkYXRhCgBJbnZhbGlkIG51bWJlciBvZiBsYXllcnMgaW4gQ09EIG1hcmtlciA6ICVkIG5vdCBpbiByYW5nZSBbMS02NTUzNV0KACVzOiVkOmNvbG9yX2NteWtfdG9fcmdiCglDQU4gTk9UIENPTlZFUlQKACVzOiVkOmNvbG9yX2VzeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgAlczolZDpjb2xvcl9zeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgBTdHJlYW0gdG9vIHNob3J0LCBleHBlY3RlZCBTT1QKAFVuYWJsZSB0byBzZXQgdDEgaGFuZGxlIGFzIFRMUwoAU3RyZWFtIGRvZXMgbm90IGVuZCB3aXRoIEVPQwoAQ2Fubm90IGhhbmRsZSBib3ggc2l6ZXMgaGlnaGVyIHRoYW4gMl4zMgoAb3BqX3BpX25leHRfbHJjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcmxjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfY3BybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcGNybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcnBjbCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3QxX2RlY29kZV9jYmxrKCk6IHVuc3VwcG9ydGVkIGJwbm9fcGx1c19vbmUgPSAlZCA+PSAzMQoARmFpbGVkIHRvIGRlY29kZSB0aWxlIDEvMQoASW5zdWZmaWNpZW50IGRhdGEgZm9yIENNQVAgYm94LgoATmVlZCB0byByZWFkIGEgUENMUiBib3ggYmVmb3JlIHRoZSBDTUFQIGJveC4KAEluc3VmZmljaWVudCBkYXRhIGZvciBDREVGIGJveC4KAE51bWJlciBvZiBjaGFubmVsIGRlc2NyaXB0aW9uIGlzIGVxdWFsIHRvIHplcm8gaW4gQ0RFRiBib3guCgBTdHJlYW0gZXJyb3Igd2hpbGUgcmVhZGluZyBKUDIgSGVhZGVyIGJveDogbm8gJ2loZHInIGJveC4KAE5vbiBjb25mb3JtYW50IGNvZGVzdHJlYW0gVFBzb3Q9PVROc290LgoAU3RyZWFtIGVycm9yIHdoaWxlIHJlYWRpbmcgSlAyIEhlYWRlciBib3g6IGJveCBsZW5ndGggaXMgaW5jb25zaXN0ZW50LgoAQm94IGxlbmd0aCBpcyBpbmNvbnNpc3RlbnQuCgBSZXNvbHV0aW9uIGZhY3RvciBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gcmVzb2x1dGlvbiBpbiB0aGUgY29tcG9uZW50LgoAQ29tcG9uZW50IG1hcHBpbmcgc2VlbXMgd3JvbmcuIFRyeWluZyB0byBjb3JyZWN0LgoASW5jb21wbGV0ZSBjaGFubmVsIGRlZmluaXRpb25zLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW52YWxpZCBjb2RlYmxvY2sgbGVuZ3RoIHZhbHVlcy4KAFdlIGRvIG5vdCBzdXBwb3J0IG1vcmUgdGhhbiAzIGNvZGluZyBwYXNzZXMgaW4gYW4gSFQgY29kZWJsb2NrOyBUaGlzIGNvZGVibG9ja3MgaGFzICVkIHBhc3Nlcy4KAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFRoZXJlIGFyZSAlZCB6ZXJvIGJpdHBsYW5lcyBpbiAlZCBiaXRwbGFuZXMuCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgdHJhbnNmb3JtYXRpb24gc3RhZ2VzLgoAVW5rbm93biBtYXJrZXIgaGFzIGJlZW4gZGV0ZWN0ZWQgYW5kIGdlbmVyYXRlZCBlcnJvci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfc2V0dXBfZGVjb2RlciBmdW5jdGlvbiBpcyBub3QgYSBkZWNvbXByZXNzb3IgaGFuZGxlci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfcmVhZF9oZWFkZXIgZnVuY3Rpb24gaXMgbm90IGEgZGVjb21wcmVzc29yIGhhbmRsZXIuCgBUaWxlcyBkb24ndCBhbGwgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb24uIFNraXAgdGhlIE1DVCBzdGVwLgoATnVtYmVyIG9mIGNvbXBvbmVudHMgKCVkKSBpcyBpbmNvbnNpc3RlbnQgd2l0aCBhIE1DVC4gU2tpcCB0aGUgTUNUIHN0ZXAuCgBKUDIgYm94IHdoaWNoIGFyZSBhZnRlciB0aGUgY29kZXN0cmVhbSB3aWxsIG5vdCBiZSByZWFkIGJ5IHRoaXMgZnVuY3Rpb24uCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBXaGVuIHRoZSBudW1iZXIgb2YgemVybyBwbGFuZXMgYml0cGxhbmVzIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgYml0cGxhbmVzLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3MgbWFrZXMgc2Vuc2UsIGJ1dCB3ZSBoYXZlICVkIHBhc3NlcyBpbiB0aGlzIGNvZGVibG9jay4gVGhlcmVmb3JlLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3Mgd2lsbCBiZSBkZWNvZGVkLiBUaGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgZGlzcGxheWVkIGFnYWluLgoASW1hZ2UgaGFzIGxlc3MgY29tcG9uZW50cyB0aGFuIGNvZGVzdHJlYW0uCgBOZWVkIHRvIGRlY29kZSB0aGUgbWFpbiBoZWFkZXIgYmVmb3JlIGJlZ2luIHRvIGRlY29kZSB0aGUgcmVtYWluaW5nIGNvZGVzdHJlYW0uCgBQc290IHZhbHVlIG9mIHRoZSBjdXJyZW50IHRpbGUtcGFydCBpcyBlcXVhbCB0byB6ZXJvLCB3ZSBhc3N1bWluZyBpdCBpcyB0aGUgbGFzdCB0aWxlLXBhcnQgb2YgdGhlIGNvZGVzdHJlYW0uCgBBIG1hbGZvcm1lZCBjb2RlYmxvY2sgdGhhdCBoYXMgbW9yZSB0aGFuIG9uZSBjb2RpbmcgcGFzcywgYnV0IHplcm8gbGVuZ3RoIGZvciAybmQgYW5kIHBvdGVudGlhbGx5IHRoZSAzcmQgcGFzcyBpbiBhbiBIVCBjb2RlYmxvY2suCgAJCQkgdGlsZS1wYXJ0WyVkXTogc3Rhcl9wb3M9JWxsaSwgZW5kX2hlYWRlcj0lbGxpLCBlbmRfcG9zPSVsbGkuCgBUaWxlICV1IGhhcyBUUHNvdCA9PSAwIGFuZCBUTnNvdCA9PSAwLCBidXQgbm8gb3RoZXIgdGlsZS1wYXJ0cyB3ZXJlIGZvdW5kLiBFT0MgaXMgYWxzbyBtaXNzaW5nLgoAQ29tcG9uZW50ICVkIGRvZXNuJ3QgaGF2ZSBhIG1hcHBpbmcuCgBBIGNvbmZvcm1pbmcgSlAyIHJlYWRlciBzaGFsbCBpZ25vcmUgYWxsIENvbG91ciBTcGVjaWZpY2F0aW9uIGJveGVzIGFmdGVyIHRoZSBmaXJzdCwgc28gd2UgaWdub3JlIHRoaXMgb25lLgoAVGhlIHNpZ25hdHVyZSBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlICBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlIGZ0eXAgYm94IG11c3QgYmUgdGhlIHNlY29uZCBib3ggaW4gdGhlIGZpbGUuCgBGYWlsZWQgdG8gZGVjb2RlLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW5jb3JyZWN0IE1FTCBzZWdtZW50IHNlcXVlbmNlLgoAQ29tcG9uZW50ICVkIGlzIG1hcHBlZCB0d2ljZS4KAE9ubHkgb25lIENNQVAgYm94IGlzIGFsbG93ZWQuCgBXZSBuZWVkIGFuIGltYWdlIHByZXZpb3VzbHkgY3JlYXRlZC4KAElIRFIgYm94X21pc3NpbmcuIFJlcXVpcmVkLgoASlAySCBib3ggbWlzc2luZy4gUmVxdWlyZWQuCgBOb3Qgc3VyZSBob3cgdGhhdCBoYXBwZW5lZC4KAE1haW4gaGVhZGVyIGhhcyBiZWVuIGNvcnJlY3RseSBkZWNvZGVkLgoAVGlsZSAlZC8lZCBoYXMgYmVlbiBkZWNvZGVkLgoASGVhZGVyIG9mIHRpbGUgJWQgLyAlZCBoYXMgYmVlbiByZWFkLgoARW1wdHkgU09UIG1hcmtlciBkZXRlY3RlZDogUHNvdD0lZC4KAERpcmVjdCB1c2UgYXQgIyVkIGhvd2V2ZXIgcGNvbD0lZC4KAEltcGxlbWVudGF0aW9uIGxpbWl0YXRpb246IGZvciBwYWxldHRlIG1hcHBpbmcsIHBjb2xbJWRdIHNob3VsZCBiZSBlcXVhbCB0byAlZCwgYnV0IGlzIGVxdWFsIHRvICVkLgoASW52YWxpZCBjb21wb25lbnQvcGFsZXR0ZSBpbmRleCBmb3IgZGlyZWN0IG1hcHBpbmcgJWQuCgBJbnZhbGlkIHZhbHVlIGZvciBjbWFwWyVkXS5tdHlwID0gJWQuCgBQc290IHZhbHVlIGlzIG5vdCBjb3JyZWN0IHJlZ2FyZHMgdG8gdGhlIEpQRUcyMDAwIG5vcm06ICVkLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gVkxDIGNvZGUgcHJvZHVjZXMgc2lnbmlmaWNhbnQgc2FtcGxlcyBvdXRzaWRlIHRoZSBjb2RlYmxvY2sgYXJlYS4KAFVuZXhwZWN0ZWQgT09NLgoAMzIgYml0cyBhcmUgbm90IGVub3VnaCB0byBkZWNvZGUgdGhpcyBjb2RlYmxvY2ssIHNpbmNlIHRoZSBudW1iZXIgb2YgYml0cGxhbmUsICVkLCBpcyBsYXJnZXIgdGhhbiAzMC4KAEJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTE9JWQpIHNob3VsZCBiZSA+IDAuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIHNob3VsZCBiZSA+IDAuCgBVcCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTA9JWQpIHNob3VsZCBiZSA+PSAwLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIHNob3VsZCBiZSA+PSAwLgoARXJyb3IgcmVhZGluZyBQUFQgbWFya2VyOiBwYWNrZXQgaGVhZGVyIGhhdmUgYmVlbiBwcmV2aW91c2x5IGZvdW5kIGluIHRoZSBtYWluIGhlYWRlciAoUFBNIG1hcmtlcikuCgBTdGFydCB0byByZWFkIGoyayBtYWluIGhlYWRlciAoJWxsZCkuCgBCb3R0b20gcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kxPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZc2l6PSVkKS4KAFVwIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MD0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWXNpej0lZCkuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhzaXo9JWQpLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhzaXo9JWQpLgoAQm90dG9tIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MT0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWU9zaXo9JWQpLgoAVXAgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZT3Npej0lZCkuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhPc2l6PSVkKS4KAExlZnQgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3gwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChYT3Npej0lZCkuCgBTaXplIHggb2YgdGhlIGRlY29kZWQgY29tcG9uZW50IGltYWdlIGlzIGluY29ycmVjdCAoY29tcFslZF0udz0lZCkuCgBTaXplIHkgb2YgdGhlIGRlY29kZWQgY29tcG9uZW50IGltYWdlIGlzIGluY29ycmVjdCAoY29tcFslZF0uaD0lZCkuCgBUaWxlIHJlYWQsIGRlY29kZWQgYW5kIHVwZGF0ZWQgaXMgbm90IHRoZSBkZXNpcmVkIG9uZSAoJWQgdnMgJWQpLgoASW52YWxpZCBjb21wb25lbnQgaW5kZXggJWQgKD49ICVkKS4KAG9wal9yZWFkX2hlYWRlcigpIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIG9wal9zZXRfZGVjb2RlZF9jb21wb25lbnRzKCkuCgBNZW1vcnkgYWxsb2NhdGlvbiBmYWlsdXJlIGluIG9wal9qcDJfYXBwbHlfcGNscigpLgoAaW1hZ2UtPmNvbXBzWyVkXS5kYXRhID09IE5VTEwgaW4gb3BqX2pwMl9hcHBseV9wY2xyKCkuCgBpbnZhbGlkIGJveCBzaXplICVkICgleCkKAEZhaWwgdG8gcmVhZCB0aGUgY3VycmVudCBtYXJrZXIgc2VnbWVudCAoJSN4KQoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBJSERSIHcoJXUpIGgoJXUpIHZzLiBTSVogdygldSkgaCgldSkKAEVycm9yIHJlYWRpbmcgQ09DIG1hcmtlciAoYmFkIG51bWJlciBvZiBjb21wb25lbnRzKQoASW52YWxpZCBudW1iZXIgb2YgdGlsZXMgOiAldSB4ICV1IChtYXhpbXVtIGZpeGVkIGJ5IGpwZWcyMDAwIG5vcm0gaXMgNjU1MzUgdGlsZXMpCgBJbnZhbGlkIG51bWJlciBvZiBjb21wb25lbnRzIChpaGRyKQoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGltYWdlIGhlYWRlciAoaWhkcikKAFdyb25nIHZhbHVlcyBmb3I6IHcoJWQpIGgoJWQpIG51bWNvbXBzKCVkKSAoaWhkcikKAEludmFsaWQgdmFsdWVzIGZvciBjb21wID0gJWQgOiBkeD0ldSBkeT0ldSAoc2hvdWxkIGJlIGJldHdlZW4gMSBhbmQgMjU1IGFjY29yZGluZyB0byB0aGUgSlBFRzIwMDAgbm9ybSkKAEJhZCBpbWFnZSBoZWFkZXIgYm94IChiYWQgc2l6ZSkKAEJhZCBDT0xSIGhlYWRlciBib3ggKGJhZCBzaXplKQoAQmFkIEJQQ0MgaGVhZGVyIGJveCAoYmFkIHNpemUpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IG5lZ2F0aXZlIG9yIHplcm8gaW1hZ2Ugc2l6ZSAoJWxsZCB4ICVsbGQpCgBza2lwOiBzZWdtZW50IHRvbyBsb25nICglZCkgd2l0aCBtYXggKCVkKSBmb3IgY29kZWJsb2NrICVkIChwPSVkLCBiPSVkLCByPSVkLCBjPSVkKQoAcmVhZDogc2VnbWVudCB0b28gbG9uZyAoJWQpIHdpdGggbWF4ICglZCkgZm9yIGNvZGVibG9jayAlZCAocD0lZCwgYj0lZCwgcj0lZCwgYz0lZCkKAERlc3BpdGUgSlAyIEJQQyE9MjU1LCBwcmVjaXNpb24gYW5kL29yIHNnbmQgdmFsdWVzIGZvciBjb21wWyVkXSBpcyBkaWZmZXJlbnQgdGhhbiBjb21wWzBdOgogICAgICAgIFswXSBwcmVjKCVkKSBzZ25kKCVkKSBbJWRdIHByZWMoJWQpIHNnbmQoJWQpCgBiYWQgY29tcG9uZW50IG51bWJlciBpbiBSR04gKCVkIHdoZW4gdGhlcmUgYXJlIG9ubHkgJWQpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IG51bWJlciBvZiBjb21wb25lbnQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgcmVtYWluaW5nIG51bWJlciBvZiBwYXJhbWV0ZXJzICggJWQgdnMgJWQpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IGludmFsaWQgdGlsZSBzaXplICh0ZHg6ICVkLCB0ZHk6ICVkKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoYmFkIHNpemU6ICVkKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoQ0lFTGFiLCBiYWQgc2l6ZTogJWQpCgBQVEVSTSBjaGVjayBmYWlsdXJlOiAlZCByZW1haW5pbmcgYnl0ZXMgaW4gY29kZSBibG9jayAoJWQgdXNlZCAvICVkKQoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gT25lIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQ6IDIgPD0gU2N1cCA8PSBtaW4oTGN1cCwgNDA3OSkKAEludmFsaWQgdmFsdWVzIGZvciBjb21wID0gJWQgOiBwcmVjPSV1IChzaG91bGQgYmUgYmV0d2VlbiAxIGFuZCAzOCBhY2NvcmRpbmcgdG8gdGhlIEpQRUcyMDAwIG5vcm0uIE9wZW5KcGVnIG9ubHkgc3VwcG9ydHMgdXAgdG8gMzEpCgBJbnZhbGlkIGJpdCBudW1iZXIgJWQgaW4gb3BqX3QyX3JlYWRfcGFja2V0X2hlYWRlcigpCgBTdHJlYW0gZXJyb3IhCgBFcnJvciBvbiB3cml0aW5nIHN0cmVhbSEKAFN0cmVhbSByZWFjaGVkIGl0cyBlbmQgIQoARXhwZWN0ZWQgYSBTT0MgbWFya2VyIAoASW52YWxpZCBib3ggc2l6ZSAlZCBmb3IgYm94ICclYyVjJWMlYycuIE5lZWQgJWQgYnl0ZXMsICVkIGJ5dGVzIHJlbWFpbmluZyAKAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFVfcSBpcyBsYXJnZXIgdGhhbiB6ZXJvIGJpdHBsYW5lcyArIDEgCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBEZWNvZGluZyB0aGlzIGNvZGVibG9jayBpcyBzdG9wcGVkLiBVX3EgaXNsYXJnZXIgdGhhbiBiaXRwbGFuZXMgKyAxIAoAQ09MUiBCT1ggbWV0aCB2YWx1ZSBpcyBub3QgYSByZWd1bGFyIHZhbHVlICglZCksIHNvIHdlIHdpbGwgaWdub3JlIHRoZSBlbnRpcmUgQ29sb3VyIFNwZWNpZmljYXRpb24gYm94LiAKAFdoaWxlIHJlYWRpbmcgQ0NQX1FOVFNUWSBlbGVtZW50IGluc2lkZSBRQ0Qgb3IgUUNDIG1hcmtlciBzZWdtZW50LCBudW1iZXIgb2Ygc3ViYmFuZHMgKCVkKSBpcyBncmVhdGVyIHRvIE9QSl9KMktfTUFYQkFORFMgKCVkKS4gU28gd2UgbGltaXQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzdG9yZWQgdG8gT1BKX0oyS19NQVhCQU5EUyAoJWQpIGFuZCBza2lwIHRoZSByZXN0LiAKAEpQMiBJSERSIGJveDogY29tcHJlc3Npb24gdHlwZSBpbmRpY2F0ZSB0aGF0IHRoZSBmaWxlIGlzIG5vdCBhIGNvbmZvcm1pbmcgSlAyIGZpbGUgKCVkKSAKAFRpbGUgaW5kZXggcHJvdmlkZWQgYnkgdGhlIHVzZXIgaXMgaW5jb3JyZWN0ICVkIChtYXggPSAlZCkgCgBFcnJvciBkZWNvZGluZyBjb21wb25lbnQgJWQuClRoZSBudW1iZXIgb2YgcmVzb2x1dGlvbnMgdG8gcmVtb3ZlICglZCkgaXMgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBudW1iZXIgb2YgcmVzb2x1dGlvbnMgb2YgdGhpcyBjb21wb25lbnQg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AAABVAAAAQAAAABQAADAUAAAAUgAAAAAAAAQUAAAsFAAAAFIAAABAAAAIFAAAMBQAAABOAAAAAAAADBQAACwUAAAATgAAAEAAABAUAAAwFAAAAEwAAAAAAAAUFAAABBRAAABMAAAAQAAAGBQAAAgUQAAASQAAAAAAABwUAAAMFEAAAEkAAABAAAAgFAAAEBRAAABHAAAAAAAAJBQAABwUQAAARwAAAEAAACgUAAAgFEAAAEWAAAAAAAAkFIAAJBRAAABFgAAAQAAAKBSAACgUQAAAVYAAAAAAADQUAAAwFAAAAFWAAABAAAA4FAAALBQAAABVAAAAAAAAPBQAACwUAAAAVQAAAEAAAAAUQAAwFAAAAFRAAAAAAAAEFEAANBQAAABUQAAAQAAACBRAADgUAAAAUgAAAAAAAAwUQAA8FAAAAFIAAABAAAAQFEAAABRAAABOAAAAAAAAFBRAAAQUQAAATgAAAEAAABgUQAAIFEAAAE0AAAAAAAAcFEAADBRAAABNAAAAQAAAIBRAABAUQAAATAAAAAAAACQUQAAUFEAAAEwAAABAAAAoFEAAGBRAAABKAAAAAAAALBRAABQUQAAASgAAAEAAADAUQAAYFEAAAEkAAAAAAAA0FEAAHBRAAABJAAAAQAAAOBRAACAUQAAASIAAAAAAADwUQAAkFEAAAEiAAABAAAAAFIAAKBRAAABHAAAAAAAABBSAACwUQAAARwAAAEAAAAgUgAAwFEAAAEYAAAAAAAAMFIAANBRAAABGAAAAQAAAEBSAADgUQAAARYAAAAAAABQUgAA8FEAAAEWAAABAAAAYFIAAABSAAABFAAAAAAAAHBSAAAQUgAAARQAAAEAAACAUgAAIFIAAAESAAAAAAAAkFIAADBSAAABEgAAAQAAAKBSAABAUgAAAREAAAAAAACwUgAAUFIAAAERAAABAAAAwFIAAGBSAADBCgAAAAAAANBSAABwUgAAwQoAAAEAAADgUgAAgFIAAMEJAAAAAAAA8FIAAJBSAADBCQAAAQAAAABTAACgUgAAoQgAAAAAAAAQUwAAsFIAAKEIAAABAAAAIFMAAMBSAAAhBQAAAAAAADBTAADQUgAAIQUAAAEAAABAUwAA4FIAAEEEAAAAAAAAUFMAAPBSAABBBAAAAQAAAGBTAAAAUwAAoQIAAAAAAABwUwAAEFMAAKECAAABAAAAgFMAACBTAAAhAgAAAAAAAJBTAAAwUwAAIQIAAAEAAACgUwAAQFMAAEEBAAAAAAAAsFMAAFBTAABBAQAAAQAAAMBTAABgUwAAEQEAAAAAAADQUwAAcFMAABEBAAABAAAA4FMAAIBTAACFAAAAAAAAAPBTAACQUwAAhQAAAAEAAAAAVAAAoFMAAEkAAAAAAAAAEFQAALBTAABJAAAAAQAAACBUAADAUwAAJQAAAAAAAAAwVAAA0FMAACUAAAABAAAAQFQAAOBTAAAVAAAAAAAAAFBUAADwUwAAFQAAAAEAAABgVAAAAFQAAAkAAAAAAAAAcFQAABBUAAAJAAAAAQAAAIBUAAAgVAAABQAAAAAAAACQVAAAMFQAAAUAAAABAAAAoFQAAEBUAAABAAAAAAAAAJBUAABQVAAAAQAAAAEAAACgVAAAYFQAAAFWAAAAAAAAsFQAALBUAAABVgAAAQAAAMBUAADAVAAAAAEDAwECAwMFBgcHBgYHBwABAwMBAgMDBQYHBwYGBwcFBgcHBgYHBwgICAgICAgIBQYHBwYGBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgCAgMDAgIDAwYGBwcGBgcHAgIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgAAQUGAQIGBgMDBwcDAwcHAAEFBgECBgYDAwcHAwMHBwMDBwcDAwcHBAQHBwQEBwcDAwcHAwMHBwQEBwcEBAcHAQIGBgICBgYDAwcHAwMHBwECBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwUGCAgGBggIBwcICAcHCAgFBggIBgYICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIAQIGBgICBgYDAwcHAwMHBwECBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwICBgYCAgYGAwMHBwMDBwcCAgYGAgIGBgMDBwcDAwcHAwMHBwMDBwcEBAcHBAQHBwMDBwcDAwcHBAQHBwQEBwcGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAYGCAgGBggIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAABAwMBAgMDBQYHBwYGBwcAAQMDAQIDAwUGBwcGBgcHBQYHBwYGBwcICAgICAgICAUGBwcGBgcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAgIDAwICAwMGBgcHBgYHBwICAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAAMBBAMGBAcBBAIFBAcFBwADAQQDBgQHAQQCBQQHBQcBBAIFBAcFBwIFAgUFBwUHAQQCBQQHBQcCBQIFBQcFBwMGBAcGCAcIBAcFBwcIBwgDBgQHBggHCAQHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgBBAIFBAcFBwIFAgUFBwUHAQQCBQQHBQcCBQIFBQcFBwIFAgUFBwUHAgUCBQUHBQcCBQIFBQcFBwIFAgUFBwUHBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAMGBAcGCAcIBAcFBwcIBwgDBgQHBggHCAQHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgGCAcICAgICAcIBwgICAgIBggHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgJCQoKCQkKCgwMDQsMDA0LCQkKCgkJCgoMDAsNDAwLDQwMDQ0MDAsLDAkNCgkMCgsMDAsLDAwNDQwJCwoJDAoNCQkKCgkJCgoMDA0LDAwNCwkJCgoJCQoKDAwLDQwMCw0MDA0NDAwLCwwJDQoJDAoLDAwLCwwMDQ0MCQsKCQwKDQoKCgoKCgoKDQsNCw0LDQsKCgkJCgoJCQ0LDAwNCwwMDQ0NDQsLCwsNCg0KCgsKCw0NDAwLCwwMDQoMCQoLCQwKCgkJCgoJCQsNDAwLDQwMCgoKCgoKCgoLDQsNCw0LDQsLDAwNDQwMCwoMCQoNCQwLCwsLDQ0NDQsKCwoKDQoNAEHZuwELNwEAAQABAAEAAAEBAAABAQABAAEAAQABAAAAAAEBAQEAAAAAAAEAAQAAAAABAQEBAAAAAQABAQEAQZm8AQs3AQABAAEAAQAAAQEAAAEBAAEAAQABAAEAAAAAAQEBAQAAAAAAAQABAAAAAAEBAQEAAAABAAEBAQBB2bwBCwcBAAEAAQABAEHpvAELlQIBAAEAAQABAAAAAAEBAQEAAAAAAAEAAQAAAAABAQEBAAAAAAABAAEBAQAAAQEAAAABAAEAAQABAQEBAQEBAQEAAQABAAEAAQAAAAABAQEBAAEAAAEBAAEAAAAAAQEBAQABAAEBAQEBAgAAAAQAAAAEAAAACAAAAJD/AAAMAAAAGAAAAFL/AAAUAAAAGQAAAFP/AAAUAAAAGgAAAF7/AAAUAAAAGwAAAFz/AAAUAAAAHAAAAF3/AAAUAAAAHQAAAF//AAAUAAAAHgAAAFH/AAACAAAAHwAAAFX/AAAEAAAAIAAAAFf/AAAEAAAAIQAAAFj/AAAQAAAAIgAAAGD/AAAEAAAAIwAAAGH/AAAQAAAAJAAAAJH/AEGIvwELZWP/AAAEAAAAJQAAAGT/AAAUAAAAJgAAAHT/AAAUAAAAJwAAAHj/AAAEAAAAKAAAAFD/AAAEAAAAKQAAAFn/AAAEAAAAKgAAAHX/AAAUAAAAKwAAAHf/AAAUAAAALAAAAAAAAAAUAEGAwAELNS0AAAAuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAAICBQajYAAABweXRmNwAAAGgycGo4AEHAwAELMnJkaGk5AAAAcmxvYzoAAABjY3BiOwAAAHJsY3A8AAAAcGFtYz0AAABmZWRjPgAAAPhiAEGAwQELQRkACwAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQAKChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEHRwQELIQ4AAAAAAAAAABkACw0ZGRkADQAAAgAJDgAAAAkADgAADgBBi8IBCwEMAEGXwgELFRMAAAAAEwAAAAAJDAAAAAAADAAADABBxcIBCwEQAEHRwgELFQ8AAAAEDwAAAAAJEAAAAAAAEAAAEABB/8IBCwESAEGLwwELHhEAAAAAEQAAAAAJEgAAAAAAEgAAEgAAGgAAABoaGgBBwsMBCw4aAAAAGhoaAAAAAAAACQBB88MBCwEUAEH/wwELFRcAAAAAFwAAAAAJFAAAAAAAFAAAFABBrcQBCwEWAEG5xAELJxUAAAAAFQAAAAAJFgAAAAAAFgAAFgAAMDEyMzQ1Njc4OUFCQ0RFRgBB4MQBCwmQbAEAAAAAAAUAQfTEAQsBaQBBjMUBCwpqAAAAawAAAHhoAEGkxQELAQIAQbTFAQsI//////////8AQfjFAQsBBQBBhMYBCwFsAEGcxgELDmoAAABtAAAAiGgAAAAEAEG0xgELAQEAQcTGAQsF/////wo="), H(T(y, M)[0]);
  })();
  function ct() {
    function M() {
      _ || (_ = !0, i.calledRun = !0, q(D), t(i), i.onRuntimeInitialized && i.onRuntimeInitialized(), (function() {
        if (i.postRun) for (typeof i.postRun == "function" && (i.postRun = [i.postRun]); i.postRun.length; ) H = i.postRun.shift(), S.unshift(H);
        var H;
        q(S);
      })());
    }
    R > 0 || ((function() {
      if (i.preRun) for (typeof i.preRun == "function" && (i.preRun = [i.preRun]); i.preRun.length; ) H = i.preRun.shift(), b.unshift(H);
      var H;
      q(b);
    })(), R > 0 || (i.setStatus ? (i.setStatus("Running..."), setTimeout((function() {
      setTimeout((function() {
        i.setStatus("");
      }), 1), M();
    }), 1)) : M()));
  }
  if (dt.q, i._malloc = dt.r, i._free = dt.s, i._jp2_decode = dt.u, x = function M() {
    _ || ct(), _ || (x = M);
  }, i.preInit) for (typeof i.preInit == "function" && (i.preInit = [i.preInit]); i.preInit.length > 0; ) i.preInit.pop()();
  return ct(), i;
});
const H3 = U3;
class UC extends de {
  constructor(t) {
    super(t, "JpxError");
  }
}
class bl {
  static #t = null;
  static decode(t, e) {
    e ||= {}, this.#t ||= H3({ warn: O });
    const i = this.#t.decode(t, e);
    if (typeof i == "string") throw new UC(i);
    return i;
  }
  static cleanup() {
    this.#t = null;
  }
  static parseImageProperties(t) {
    let e = t.getByte();
    for (; e >= 0; ) {
      const i = e;
      if (e = t.getByte(), (i << 8 | e) === 65361) {
        t.skip(4);
        const s = t.getInt32() >>> 0, n = t.getInt32() >>> 0, o = t.getInt32() >>> 0, r = t.getInt32() >>> 0;
        return t.skip(16), { width: s - o, height: n - r, bitsPerComponent: 8, componentsCount: t.getUint16() };
      }
    }
    throw new UC("No size marker found in JPX stream");
  }
}
class J3 extends Be {
  constructor(t, e, i) {
    super(e), this.stream = t, this.dict = t.dict, this.maybeLength = e, this.params = i;
  }
  get bytes() {
    return bt(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(t) {
  }
  readBlock(t) {
    this.decodeImage(null, t);
  }
  decodeImage(t, e) {
    return this.eof || (t ||= this.bytes, this.buffer = bl.decode(t, e), this.bufferLength = this.buffer.length, this.eof = !0), this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
}
class HC extends Be {
  constructor(t, e, i) {
    super(e), this.str = t, this.dict = t.dict, this.cachedData = 0, this.bitsCached = 0;
    const s = 4096, n = { earlyChange: i, codeLength: 9, nextCode: 258, dictionaryValues: new Uint8Array(s), dictionaryLengths: new Uint16Array(s), dictionaryPrevCodes: new Uint16Array(s), currentSequence: new Uint8Array(s), currentSequenceLength: 0 };
    for (let o = 0; o < 256; ++o) n.dictionaryValues[o] = o, n.dictionaryLengths[o] = 1;
    this.lzwState = n;
  }
  readBits(t) {
    let e = this.bitsCached, i = this.cachedData;
    for (; e < t; ) {
      const s = this.str.getByte();
      if (s === -1) return this.eof = !0, null;
      i = i << 8 | s, e += 8;
    }
    return this.bitsCached = e -= t, this.cachedData = i, this.lastCode = null, i >>> e & (1 << t) - 1;
  }
  readBlock() {
    let t, e, i, s = 1024;
    const n = this.lzwState;
    if (!n) return;
    const o = n.earlyChange;
    let r = n.nextCode;
    const c = n.dictionaryValues, h = n.dictionaryLengths, I = n.dictionaryPrevCodes;
    let C = n.codeLength, d = n.prevCode;
    const u = n.currentSequence;
    let E = n.currentSequenceLength, p = 0, y = this.bufferLength, b = this.ensureBuffer(this.bufferLength + s);
    for (t = 0; t < 512; t++) {
      const D = this.readBits(C), S = E > 0;
      if (D < 256) u[0] = D, E = 1;
      else {
        if (!(D >= 258)) {
          if (D === 256) {
            C = 9, r = 258, E = 0;
            continue;
          }
          this.eof = !0, delete this.lzwState;
          break;
        }
        if (D < r) for (E = h[D], e = E - 1, i = D; e >= 0; e--) u[e] = c[i], i = I[i];
        else u[E++] = u[0];
      }
      if (S && (I[r] = d, h[r] = h[d] + 1, c[r] = u[0], r++, C = r + o & r + o - 1 ? C : 0 | Math.min(Math.log(r + o) / 0.6931471805599453 + 1, 12)), d = D, p += E, s < p) {
        do
          s += 512;
        while (s < p);
        b = this.ensureBuffer(this.bufferLength + s);
      }
      for (e = 0; e < E; e++) b[y++] = u[e];
    }
    n.nextCode = r, n.codeLength = C, n.prevCode = d, n.currentSequenceLength = E, this.bufferLength = y;
  }
}
class JC extends Be {
  constructor(t, e, i) {
    if (super(e), !(i instanceof z)) return t;
    const s = this.predictor = i.get("Predictor") || 1;
    if (s <= 1) return t;
    if (s !== 2 && (s < 10 || s > 15)) throw new Ct(`Unsupported predictor: ${s}`);
    this.readBlock = s === 2 ? this.readBlockTiff : this.readBlockPng, this.str = t, this.dict = t.dict;
    const n = this.colors = i.get("Colors") || 1, o = this.bits = i.get("BPC", "BitsPerComponent") || 8, r = this.columns = i.get("Columns") || 1;
    return this.pixBytes = n * o + 7 >> 3, this.rowBytes = r * n * o + 7 >> 3, this;
  }
  readBlockTiff() {
    const t = this.rowBytes, e = this.bufferLength, i = this.ensureBuffer(e + t), s = this.bits, n = this.colors, o = this.str.getBytes(t);
    if (this.eof = !o.length, this.eof) return;
    let r, c = 0, h = 0, I = 0, C = 0, d = e;
    if (s === 1 && n === 1) for (r = 0; r < t; ++r) {
      let u = o[r] ^ c;
      u ^= u >> 1, u ^= u >> 2, u ^= u >> 4, c = (1 & u) << 7, i[d++] = u;
    }
    else if (s === 8) {
      for (r = 0; r < n; ++r) i[d++] = o[r];
      for (; r < t; ++r) i[d] = i[d - n] + o[r], d++;
    } else if (s === 16) {
      const u = 2 * n;
      for (r = 0; r < u; ++r) i[d++] = o[r];
      for (; r < t; r += 2) {
        const E = ((255 & o[r]) << 8) + (255 & o[r + 1]) + ((255 & i[d - u]) << 8) + (255 & i[d - u + 1]);
        i[d++] = E >> 8 & 255, i[d++] = 255 & E;
      }
    } else {
      const u = new Uint8Array(n + 1), E = (1 << s) - 1;
      let p = 0, y = e;
      const b = this.columns;
      for (r = 0; r < b; ++r) for (let D = 0; D < n; ++D) I < s && (c = c << 8 | 255 & o[p++], I += 8), u[D] = u[D] + (c >> I - s) & E, I -= s, h = h << s | u[D], C += s, C >= 8 && (i[y++] = h >> C - 8 & 255, C -= 8);
      C > 0 && (i[y++] = (h << 8 - C) + (c & (1 << 8 - C) - 1));
    }
    this.bufferLength += t;
  }
  readBlockPng() {
    const t = this.rowBytes, e = this.pixBytes, i = this.str.getByte(), s = this.str.getBytes(t);
    if (this.eof = !s.length, this.eof) return;
    const n = this.bufferLength, o = this.ensureBuffer(n + t);
    let r = o.subarray(n - t, n);
    r.length === 0 && (r = new Uint8Array(t));
    let c, h, I, C = n;
    switch (i) {
      case 0:
        for (c = 0; c < t; ++c) o[C++] = s[c];
        break;
      case 1:
        for (c = 0; c < e; ++c) o[C++] = s[c];
        for (; c < t; ++c) o[C] = o[C - e] + s[c] & 255, C++;
        break;
      case 2:
        for (c = 0; c < t; ++c) o[C++] = r[c] + s[c] & 255;
        break;
      case 3:
        for (c = 0; c < e; ++c) o[C++] = (r[c] >> 1) + s[c];
        for (; c < t; ++c) o[C] = (r[c] + o[C - e] >> 1) + s[c] & 255, C++;
        break;
      case 4:
        for (c = 0; c < e; ++c) h = r[c], I = s[c], o[C++] = h + I;
        for (; c < t; ++c) {
          h = r[c];
          const d = r[c - e], u = o[C - e], E = u + h - d;
          let p = E - u;
          p < 0 && (p = -p);
          let y = E - h;
          y < 0 && (y = -y);
          let b = E - d;
          b < 0 && (b = -b), I = s[c], o[C++] = p <= y && p <= b ? u + I : y <= b ? h + I : d + I;
        }
        break;
      default:
        throw new Ct(`Unsupported predictor: ${i}`);
    }
    this.bufferLength += t;
  }
}
class Y3 extends Be {
  constructor(t, e) {
    super(e), this.str = t, this.dict = t.dict;
  }
  readBlock() {
    const t = this.str.getBytes(2);
    if (!t || t.length < 2 || t[0] === 128) return void (this.eof = !0);
    let e, i = this.bufferLength, s = t[0];
    if (s < 128) {
      if (e = this.ensureBuffer(i + s + 1), e[i++] = t[1], s > 0) {
        const n = this.str.getBytes(s);
        e.set(n, i), i += s;
      }
    } else {
      s = 257 - s;
      const n = t[1];
      e = this.ensureBuffer(i + s + 1);
      for (let o = 0; o < s; o++) e[i++] = n;
    }
    this.bufferLength = i;
  }
}
class Es {
  constructor({ lexer: t, xref: e, allowStreams: i = !1, recoveryMode: s = !1 }) {
    this.lexer = t, this.xref = e, this.allowStreams = i, this.recoveryMode = s, this.imageCache = /* @__PURE__ */ Object.create(null), this._imageId = 0, this.refill();
  }
  refill() {
    this.buf1 = this.lexer.getObj(), this.buf2 = this.lexer.getObj();
  }
  shift() {
    this.buf2 instanceof KA && this.buf2.cmd === "ID" ? (this.buf1 = this.buf2, this.buf2 = null) : (this.buf1 = this.buf2, this.buf2 = this.lexer.getObj());
  }
  tryShift() {
    try {
      return this.shift(), !0;
    } catch (t) {
      if (t instanceof yA) throw t;
      return !1;
    }
  }
  getObj(t = null) {
    const e = this.buf1;
    if (this.shift(), e instanceof KA) switch (e.cmd) {
      case "BI":
        return this.makeInlineImage(t);
      case "[":
        const i = [];
        for (; !zA(this.buf1, "]") && this.buf1 !== Ae; ) i.push(this.getObj(t));
        if (this.buf1 === Ae) {
          if (this.recoveryMode) return i;
          throw new Nh("End of file inside array.");
        }
        return this.shift(), i;
      case "<<":
        const s = new z(this.xref);
        for (; !zA(this.buf1, ">>") && this.buf1 !== Ae; ) {
          if (!(this.buf1 instanceof at)) {
            tA("Malformed dictionary: key must be a name object"), this.shift();
            continue;
          }
          const n = this.buf1.name;
          if (this.shift(), this.buf1 === Ae) break;
          s.set(n, this.getObj(t));
        }
        if (this.buf1 === Ae) {
          if (this.recoveryMode) return s;
          throw new Nh("End of file inside dictionary.");
        }
        return zA(this.buf2, "stream") ? this.allowStreams ? this.makeStream(s, t) : s : (this.shift(), s);
      default:
        return e;
    }
    if (Number.isInteger(e)) {
      if (Number.isInteger(this.buf1) && zA(this.buf2, "R")) {
        const i = St.get(e, this.buf1);
        return this.shift(), this.shift(), i;
      }
      return e;
    }
    return typeof e == "string" && t ? t.decryptString(e) : e;
  }
  findDefaultInlineStreamEnd(t) {
    const { knownCommands: e } = this.lexer, i = t.pos;
    let s, n, o = 0;
    for (; (s = t.getByte()) !== -1; ) if (o === 0) o = s === 69 ? 1 : 0;
    else if (o === 1) o = s === 73 ? 2 : 0;
    else if (s === 32 || s === 10 || s === 13) {
      n = t.pos;
      const c = t.peekBytes(15), h = c.length;
      if (h === 0) break;
      for (let d = 0; d < h; d++) if (s = c[d], (s !== 0 || c[d + 1] === 0) && s !== 10 && s !== 13 && (s < 32 || s > 127)) {
        o = 0;
        break;
      }
      if (o !== 2) continue;
      if (!e) {
        O("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
        continue;
      }
      const I = new hi(new RA(c.slice()), e);
      I._hexStringWarn = () => {
      };
      let C = 0;
      for (; ; ) {
        const d = I.getObj();
        if (d === Ae) {
          o = 0;
          break;
        }
        if (d instanceof KA) {
          const u = e[d.cmd];
          if (!u) {
            o = 0;
            break;
          }
          if (u.variableArgs ? C <= u.numArgs : C === u.numArgs) break;
          C = 0;
        } else C++;
      }
      if (o === 2) break;
    } else o = 0;
    s === -1 && (O("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker"), n && (O('... trying to recover by using the last "EI" occurrence.'), t.skip(-(t.pos - n))));
    let r = 4;
    return t.skip(-r), s = t.peekByte(), t.skip(r), qe(s) || r--, t.pos - r - i;
  }
  findDCTDecodeInlineStreamEnd(t) {
    const e = t.pos;
    let i, s, n = !1;
    for (; (i = t.getByte()) !== -1; ) if (i === 255) {
      switch (t.getByte()) {
        case 0:
          break;
        case 255:
          t.skip(-1);
          break;
        case 217:
          n = !0;
          break;
        case 192:
        case 193:
        case 194:
        case 195:
        case 197:
        case 198:
        case 199:
        case 201:
        case 202:
        case 203:
        case 205:
        case 206:
        case 207:
        case 196:
        case 204:
        case 218:
        case 219:
        case 220:
        case 221:
        case 222:
        case 223:
        case 224:
        case 225:
        case 226:
        case 227:
        case 228:
        case 229:
        case 230:
        case 231:
        case 232:
        case 233:
        case 234:
        case 235:
        case 236:
        case 237:
        case 238:
        case 239:
        case 254:
          s = t.getUint16(), s > 2 ? t.skip(s - 2) : t.skip(-2);
      }
      if (n) break;
    }
    const o = t.pos - e;
    return i === -1 ? (O("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead."), t.skip(-o), this.findDefaultInlineStreamEnd(t)) : (this.inlineStreamSkipEI(t), o);
  }
  findASCII85DecodeInlineStreamEnd(t) {
    const e = t.pos;
    let i;
    for (; (i = t.getByte()) !== -1; ) if (i === 126) {
      const n = t.pos;
      for (i = t.peekByte(); qe(i); ) t.skip(), i = t.peekByte();
      if (i === 62) {
        t.skip();
        break;
      }
      if (t.pos > n) {
        const o = t.peekBytes(2);
        if (o[0] === 69 && o[1] === 73) break;
      }
    }
    const s = t.pos - e;
    return i === -1 ? (O("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead."), t.skip(-s), this.findDefaultInlineStreamEnd(t)) : (this.inlineStreamSkipEI(t), s);
  }
  findASCIIHexDecodeInlineStreamEnd(t) {
    const e = t.pos;
    let i;
    for (; (i = t.getByte()) !== -1 && i !== 62; ) ;
    const s = t.pos - e;
    return i === -1 ? (O("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead."), t.skip(-s), this.findDefaultInlineStreamEnd(t)) : (this.inlineStreamSkipEI(t), s);
  }
  inlineStreamSkipEI(t) {
    let e, i = 0;
    for (; (e = t.getByte()) !== -1; ) if (i === 0) i = e === 69 ? 1 : 0;
    else if (i === 1) i = e === 73 ? 2 : 0;
    else if (i === 2) break;
  }
  makeInlineImage(t) {
    const e = this.lexer, i = e.stream, s = /* @__PURE__ */ Object.create(null);
    let n;
    for (; !zA(this.buf1, "ID") && this.buf1 !== Ae; ) {
      if (!(this.buf1 instanceof at)) throw new Ct("Dictionary key must be a name object");
      const u = this.buf1.name;
      if (this.shift(), this.buf1 === Ae) break;
      s[u] = this.getObj(t);
    }
    e.beginInlineImagePos !== -1 && (n = i.pos - e.beginInlineImagePos);
    const o = this.xref.fetchIfRef(s.F || s.Filter);
    let r;
    if (o instanceof at) r = o.name;
    else if (Array.isArray(o)) {
      const u = this.xref.fetchIfRef(o[0]);
      u instanceof at && (r = u.name);
    }
    const c = i.pos;
    let h, I;
    switch (r) {
      case "DCT":
      case "DCTDecode":
        h = this.findDCTDecodeInlineStreamEnd(i);
        break;
      case "A85":
      case "ASCII85Decode":
        h = this.findASCII85DecodeInlineStreamEnd(i);
        break;
      case "AHx":
      case "ASCIIHexDecode":
        h = this.findASCIIHexDecodeInlineStreamEnd(i);
        break;
      default:
        h = this.findDefaultInlineStreamEnd(i);
    }
    if (h < 1e3 && n > 0) {
      const u = i.pos;
      i.pos = e.beginInlineImagePos, I = (function(p) {
        const y = [], b = p.length;
        let D = 0;
        for (; D < b - 1; ) y.push(p[D++] << 8 | p[D++]);
        return D < b && y.push(p[D]), b + "_" + String.fromCharCode.apply(null, y);
      })(i.getBytes(n + h)), i.pos = u;
      const E = this.imageCache[I];
      if (E !== void 0) return this.buf2 = KA.get("EI"), this.shift(), E.reset(), E;
    }
    const C = new z(this.xref);
    for (const u in s) C.set(u, s[u]);
    let d = i.makeSubStream(c, h, C);
    return t && (d = t.createStream(d, h)), d = this.filter(d, C, h), d.dict = C, I !== void 0 && (d.cacheKey = "inline_img_" + ++this._imageId, this.imageCache[I] = d), this.buf2 = KA.get("EI"), this.shift(), d;
  }
  #t(t) {
    const { stream: e } = this.lexer;
    e.pos = t;
    const i = new Uint8Array([101, 110, 100]), s = i.length, n = [new Uint8Array([115, 116, 114, 101, 97, 109]), new Uint8Array([115, 116, 101, 97, 109]), new Uint8Array([115, 116, 114, 101, 97])], o = 9 - s;
    for (; e.pos < e.end; ) {
      const r = e.peekBytes(2048), c = r.length - 9;
      if (c <= 0) break;
      let h = 0;
      for (; h < c; ) {
        let I = 0;
        for (; I < s && r[h + I] === i[I]; ) I++;
        if (I >= s) {
          let C = !1;
          for (const d of n) {
            const u = d.length;
            let E = 0;
            for (; E < u && r[h + I + E] === d[E]; ) E++;
            if (E >= o) {
              C = !0;
              break;
            }
            if (E >= u) {
              qe(r[h + I + E]) && (tA(`Found "${Re([...i, ...d])}" when searching for endstream command.`), C = !0);
              break;
            }
          }
          if (C) return e.pos += h, e.pos - t;
        }
        h++;
      }
      e.pos += c;
    }
    return -1;
  }
  makeStream(t, e) {
    const i = this.lexer;
    let s = i.stream;
    i.skipToNextLine();
    const n = s.pos - 1;
    let o = t.get("Length");
    if (Number.isInteger(o) || (tA(`Bad length "${o && o.toString()}" in stream.`), o = 0), s.pos = n + o, i.nextChar(), this.tryShift() && zA(this.buf2, "endstream")) this.shift();
    else {
      if (o = this.#t(n), o < 0) throw new Ct("Missing endstream command.");
      i.nextChar(), this.shift(), this.shift();
    }
    return this.shift(), s = s.makeSubStream(n, o, t), e && (s = e.createStream(s, o)), s = this.filter(s, t, o), s.dict = t, s;
  }
  filter(t, e, i) {
    let s = e.get("F", "Filter"), n = e.get("DP", "DecodeParms");
    if (s instanceof at) return Array.isArray(n) && O("/DecodeParms should not be an Array, when /Filter is a Name."), this.makeFilter(t, s.name, i, n);
    let o = i;
    if (Array.isArray(s)) {
      const r = s, c = n;
      for (let h = 0, I = r.length; h < I; ++h) {
        if (s = this.xref.fetchIfRef(r[h]), !(s instanceof at)) throw new Ct(`Bad filter name "${s}"`);
        n = null, Array.isArray(c) && h in c && (n = this.xref.fetchIfRef(c[h])), t = this.makeFilter(t, s.name, o, n), o = null;
      }
    }
    return t;
  }
  makeFilter(t, e, i, s) {
    if (i === 0) return O(`Empty "${e}" stream.`), new Wo();
    try {
      switch (e) {
        case "Fl":
        case "FlateDecode":
          return s ? new JC(new NC(t, i), i, s) : new NC(t, i);
        case "LZW":
        case "LZWDecode":
          let n = 1;
          return s ? (s.has("EarlyChange") && (n = s.get("EarlyChange")), new JC(new HC(t, i, n), i, s)) : new HC(t, i, n);
        case "DCT":
        case "DCTDecode":
          return new wl(t, i, s);
        case "JPX":
        case "JPXDecode":
          return new J3(t, i, s);
        case "A85":
        case "ASCII85Decode":
          return new h3(t, i);
        case "AHx":
        case "ASCIIHexDecode":
          return new l3(t, i);
        case "CCF":
        case "CCITTFaxDecode":
          return new I3(t, i, s);
        case "RL":
        case "RunLengthDecode":
          return new Y3(t, i);
        case "JBIG2Decode":
          return new R3(t, i, s);
      }
      return O(`Filter "${e}" is not supported.`), t;
    } catch (n) {
      if (n instanceof yA) throw n;
      return O(`Invalid stream: "${n}"`), new Wo();
    }
  }
}
const ka = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
function Oc(A) {
  return A >= 48 && A <= 57 ? 15 & A : A >= 65 && A <= 70 || A >= 97 && A <= 102 ? 9 + (15 & A) : -1;
}
class hi {
  constructor(t, e = null) {
    this.stream = t, this.nextChar(), this.strBuf = [], this.knownCommands = e, this._hexStringNumWarn = 0, this.beginInlineImagePos = -1;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  peekChar() {
    return this.stream.peekByte();
  }
  getNumber() {
    let t = this.currentChar, e = !1, i = 0, s = 1;
    if (t === 45 ? (s = -1, t = this.nextChar(), t === 45 && (t = this.nextChar())) : t === 43 && (t = this.nextChar()), t === 10 || t === 13) do
      t = this.nextChar();
    while (t === 10 || t === 13);
    if (t === 46 && (i = 10, t = this.nextChar()), t < 48 || t > 57) {
      const c = `Invalid number: ${String.fromCharCode(t)} (charCode ${t})`;
      if (qe(t) || t === -1) return tA(`Lexer.getNumber - "${c}".`), 0;
      throw new Ct(c);
    }
    let n = t - 48, o = 0, r = 1;
    for (; (t = this.nextChar()) >= 0; ) if (t >= 48 && t <= 57) {
      const c = t - 48;
      e ? o = 10 * o + c : (i !== 0 && (i *= 10), n = 10 * n + c);
    } else if (t === 46) {
      if (i !== 0) break;
      i = 1;
    } else if (t === 45) O("Badly formatted number: minus sign in the middle");
    else {
      if (t !== 69 && t !== 101) break;
      if (t = this.peekChar(), t === 43 || t === 45) r = t === 45 ? -1 : 1, this.nextChar();
      else if (t < 48 || t > 57) break;
      e = !0;
    }
    return i !== 0 && (n /= i), e && (n *= 10 ** (r * o)), s * n;
  }
  getString() {
    let t = 1, e = !1;
    const i = this.strBuf;
    i.length = 0;
    let s = this.nextChar();
    for (; ; ) {
      let n = !1;
      switch (0 | s) {
        case -1:
          O("Unterminated string"), e = !0;
          break;
        case 40:
          ++t, i.push("(");
          break;
        case 41:
          --t == 0 ? (this.nextChar(), e = !0) : i.push(")");
          break;
        case 92:
          switch (s = this.nextChar(), s) {
            case -1:
              O("Unterminated string"), e = !0;
              break;
            case 110:
              i.push(`
`);
              break;
            case 114:
              i.push("\r");
              break;
            case 116:
              i.push("	");
              break;
            case 98:
              i.push("\b");
              break;
            case 102:
              i.push("\f");
              break;
            case 92:
            case 40:
            case 41:
              i.push(String.fromCharCode(s));
              break;
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
              let o = 15 & s;
              s = this.nextChar(), n = !0, s >= 48 && s <= 55 && (o = (o << 3) + (15 & s), s = this.nextChar(), s >= 48 && s <= 55 && (n = !1, o = (o << 3) + (15 & s))), i.push(String.fromCharCode(o));
              break;
            case 13:
              this.peekChar() === 10 && this.nextChar();
              break;
            case 10:
              break;
            default:
              i.push(String.fromCharCode(s));
          }
          break;
        default:
          i.push(String.fromCharCode(s));
      }
      if (e) break;
      n || (s = this.nextChar());
    }
    return i.join("");
  }
  getName() {
    let t, e;
    const i = this.strBuf;
    for (i.length = 0; (t = this.nextChar()) >= 0 && !ka[t]; ) if (t === 35) {
      if (t = this.nextChar(), ka[t]) {
        O("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number."), i.push("#");
        break;
      }
      const s = Oc(t);
      if (s !== -1) {
        e = t, t = this.nextChar();
        const n = Oc(t);
        if (n === -1) {
          if (O(`Lexer_getName: Illegal digit (${String.fromCharCode(t)}) in hexadecimal number.`), i.push("#", String.fromCharCode(e)), ka[t]) break;
          i.push(String.fromCharCode(t));
          continue;
        }
        i.push(String.fromCharCode(s << 4 | n));
      } else i.push("#", String.fromCharCode(t));
    } else i.push(String.fromCharCode(t));
    return i.length > 127 && O(`Name token is longer than allowed by the spec: ${i.length}`), at.get(i.join(""));
  }
  _hexStringWarn(t) {
    this._hexStringNumWarn++ != 5 ? this._hexStringNumWarn > 5 || O(`getHexString - ignoring invalid character: ${t}`) : O("getHexString - ignoring additional invalid characters.");
  }
  getHexString() {
    const t = this.strBuf;
    t.length = 0;
    let e = this.currentChar, i = -1, s = -1;
    for (this._hexStringNumWarn = 0; ; ) {
      if (e < 0) {
        O("Unterminated hex string");
        break;
      }
      if (e === 62) {
        this.nextChar();
        break;
      }
      ka[e] !== 1 ? (s = Oc(e), s === -1 ? this._hexStringWarn(e) : i === -1 ? i = s : (t.push(String.fromCharCode(i << 4 | s)), i = -1), e = this.nextChar()) : e = this.nextChar();
    }
    return i !== -1 && t.push(String.fromCharCode(i << 4)), t.join("");
  }
  getObj() {
    let t = !1, e = this.currentChar;
    for (; ; ) {
      if (e < 0) return Ae;
      if (t) e !== 10 && e !== 13 || (t = !1);
      else if (e === 37) t = !0;
      else if (ka[e] !== 1) break;
      e = this.nextChar();
    }
    switch (0 | e) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return this.getNumber();
      case 40:
        return this.getString();
      case 47:
        return this.getName();
      case 91:
        return this.nextChar(), KA.get("[");
      case 93:
        return this.nextChar(), KA.get("]");
      case 60:
        return e = this.nextChar(), e === 60 ? (this.nextChar(), KA.get("<<")) : this.getHexString();
      case 62:
        return e = this.nextChar(), e === 62 ? (this.nextChar(), KA.get(">>")) : KA.get(">");
      case 123:
        return this.nextChar(), KA.get("{");
      case 125:
        return this.nextChar(), KA.get("}");
      case 41:
        throw this.nextChar(), new Ct(`Illegal character: ${e}`);
    }
    let i = String.fromCharCode(e);
    if (e < 32 || e > 127) {
      const o = this.peekChar();
      if (o >= 32 && o <= 127) return this.nextChar(), KA.get(i);
    }
    const s = this.knownCommands;
    let n = s?.[i] !== void 0;
    for (; (e = this.nextChar()) >= 0 && !ka[e]; ) {
      const o = i + String.fromCharCode(e);
      if (n && s[o] === void 0) break;
      if (i.length === 128) throw new Ct(`Command token too long: ${i.length}`);
      i = o, n = s?.[i] !== void 0;
    }
    return i === "true" || i !== "false" && (i === "null" ? null : (i === "BI" && (this.beginInlineImagePos = this.stream.pos), KA.get(i)));
  }
  skipToNextLine() {
    let t = this.currentChar;
    for (; t >= 0; ) {
      if (t === 13) {
        t = this.nextChar(), t === 10 && this.nextChar();
        break;
      }
      if (t === 10) {
        this.nextChar();
        break;
      }
      t = this.nextChar();
    }
  }
}
class T3 {
  static create(t) {
    function e(I, C, d = !1) {
      const u = I.get(C);
      if (Number.isInteger(u) && (d ? u >= 0 : u > 0)) return u;
      throw new Error(`The "${C}" parameter in the linearization dictionary is invalid.`);
    }
    const i = new Es({ lexer: new hi(t), xref: null }), s = i.getObj(), n = i.getObj(), o = i.getObj(), r = i.getObj();
    let c, h;
    if (!(Number.isInteger(s) && Number.isInteger(n) && zA(o, "obj") && r instanceof z && typeof (c = r.get("Linearized")) == "number" && c > 0)) return null;
    if ((h = e(r, "L")) !== t.length) throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
    return { length: h, hints: (function(I) {
      const C = I.get("H");
      let d;
      if (Array.isArray(C) && ((d = C.length) === 2 || d === 4)) {
        for (let u = 0; u < d; u++) {
          const E = C[u];
          if (!(Number.isInteger(E) && E > 0)) throw new Error(`Hint (${u}) in the linearization dictionary is invalid.`);
        }
        return C;
      }
      throw new Error("Hint array in the linearization dictionary is invalid.");
    })(r), objectNumberFirst: e(r, "O"), endFirst: e(r, "E"), numPages: e(r, "N"), mainXRefEntriesOffset: e(r, "T"), pageFirst: r.has("P") ? e(r, "P", !0) : 0 };
  }
}
const K3 = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"], Wc = 2 ** 24 - 1;
class Dl {
  constructor(t = !1) {
    this.codespaceRanges = [[], [], [], []], this.numCodespaceRanges = 0, this._map = [], this.name = "", this.vertical = !1, this.useCMap = null, this.builtInCMap = t;
  }
  addCodespaceRange(t, e, i) {
    this.codespaceRanges[t - 1].push(e, i), this.numCodespaceRanges++;
  }
  mapCidRange(t, e, i) {
    if (e - t > Wc) throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
    for (; t <= e; ) this._map[t++] = i++;
  }
  mapBfRange(t, e, i) {
    if (e - t > Wc) throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
    const s = i.length - 1;
    for (; t <= e; ) {
      this._map[t++] = i;
      const n = i.charCodeAt(s) + 1;
      n > 255 ? i = i.substring(0, s - 1) + String.fromCharCode(i.charCodeAt(s - 1) + 1) + "\0" : i = i.substring(0, s) + String.fromCharCode(n);
    }
  }
  mapBfRangeToArray(t, e, i) {
    if (e - t > Wc) throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
    const s = i.length;
    let n = 0;
    for (; t <= e && n < s; ) this._map[t] = i[n++], ++t;
  }
  mapOne(t, e) {
    this._map[t] = e;
  }
  lookup(t) {
    return this._map[t];
  }
  contains(t) {
    return this._map[t] !== void 0;
  }
  forEach(t) {
    const e = this._map, i = e.length;
    if (i <= 65536) for (let s = 0; s < i; s++) e[s] !== void 0 && t(s, e[s]);
    else for (const s in e) t(s, e[s]);
  }
  charCodeOf(t) {
    const e = this._map;
    if (e.length <= 65536) return e.indexOf(t);
    for (const i in e) if (e[i] === t) return 0 | i;
    return -1;
  }
  getMap() {
    return this._map;
  }
  readCharCode(t, e, i) {
    let s = 0;
    const n = this.codespaceRanges;
    for (let o = 0, r = n.length; o < r; o++) {
      s = (s << 8 | t.charCodeAt(e + o)) >>> 0;
      const c = n[o];
      for (let h = 0, I = c.length; h < I; ) {
        const C = c[h++], d = c[h++];
        if (s >= C && s <= d) return i.charcode = s, void (i.length = o + 1);
      }
    }
    i.charcode = 0, i.length = 1;
  }
  getCharCodeLength(t) {
    const e = this.codespaceRanges;
    for (let i = 0, s = e.length; i < s; i++) {
      const n = e[i];
      for (let o = 0, r = n.length; o < r; ) {
        const c = n[o++], h = n[o++];
        if (t >= c && t <= h) return i + 1;
      }
    }
    return 1;
  }
  get length() {
    return this._map.length;
  }
  get isIdentityCMap() {
    if (this.name !== "Identity-H" && this.name !== "Identity-V" || this._map.length !== 65536) return !1;
    for (let t = 0; t < 65536; t++) if (this._map[t] !== t) return !1;
    return !0;
  }
}
class _a extends Dl {
  constructor(t, e) {
    super(), this.vertical = t, this.addCodespaceRange(e, 0, 65535);
  }
  mapCidRange(t, e, i) {
    oA("should not call mapCidRange");
  }
  mapBfRange(t, e, i) {
    oA("should not call mapBfRange");
  }
  mapBfRangeToArray(t, e, i) {
    oA("should not call mapBfRangeToArray");
  }
  mapOne(t, e) {
    oA("should not call mapCidOne");
  }
  lookup(t) {
    return Number.isInteger(t) && t <= 65535 ? t : void 0;
  }
  contains(t) {
    return Number.isInteger(t) && t <= 65535;
  }
  forEach(t) {
    for (let e = 0; e <= 65535; e++) t(e, e);
  }
  charCodeOf(t) {
    return Number.isInteger(t) && t <= 65535 ? t : -1;
  }
  getMap() {
    const t = new Array(65536);
    for (let e = 0; e <= 65535; e++) t[e] = e;
    return t;
  }
  get length() {
    return 65536;
  }
  get isIdentityCMap() {
    oA("should not access .isIdentityCMap");
  }
}
function vs(A) {
  let t = 0;
  for (let e = 0; e < A.length; e++) t = t << 8 | A.charCodeAt(e);
  return t >>> 0;
}
function la(A) {
  if (typeof A != "string") throw new Ct("Malformed CMap: expected string.");
}
function gE(A) {
  if (!Number.isInteger(A)) throw new Ct("Malformed CMap: expected int.");
}
function q3(A, t) {
  for (; ; ) {
    let e = t.getObj();
    if (e === Ae) break;
    if (zA(e, "endbfchar")) return;
    la(e);
    const i = vs(e);
    e = t.getObj(), la(e);
    const s = e;
    A.mapOne(i, s);
  }
}
function P3(A, t) {
  for (; ; ) {
    let e = t.getObj();
    if (e === Ae) break;
    if (zA(e, "endbfrange")) return;
    la(e);
    const i = vs(e);
    e = t.getObj(), la(e);
    const s = vs(e);
    if (e = t.getObj(), Number.isInteger(e) || typeof e == "string") {
      const n = Number.isInteger(e) ? String.fromCharCode(e) : e;
      A.mapBfRange(i, s, n);
    } else {
      if (!zA(e, "[")) break;
      {
        e = t.getObj();
        const n = [];
        for (; !zA(e, "]") && e !== Ae; ) n.push(e), e = t.getObj();
        A.mapBfRangeToArray(i, s, n);
      }
    }
  }
  throw new Ct("Invalid bf range.");
}
function _3(A, t) {
  for (; ; ) {
    let e = t.getObj();
    if (e === Ae) break;
    if (zA(e, "endcidchar")) return;
    la(e);
    const i = vs(e);
    e = t.getObj(), gE(e);
    const s = e;
    A.mapOne(i, s);
  }
}
function O3(A, t) {
  for (; ; ) {
    let e = t.getObj();
    if (e === Ae) break;
    if (zA(e, "endcidrange")) return;
    la(e);
    const i = vs(e);
    e = t.getObj(), la(e);
    const s = vs(e);
    e = t.getObj(), gE(e);
    const n = e;
    A.mapCidRange(i, s, n);
  }
}
function W3(A, t) {
  for (; ; ) {
    let e = t.getObj();
    if (e === Ae) break;
    if (zA(e, "endcodespacerange")) return;
    if (typeof e != "string") break;
    const i = vs(e);
    if (e = t.getObj(), typeof e != "string") break;
    const s = vs(e);
    A.addCodespaceRange(e.length, i, s);
  }
  throw new Ct("Invalid codespace range.");
}
function j3(A, t) {
  const e = t.getObj();
  Number.isInteger(e) && (A.vertical = !!e);
}
function Z3(A, t) {
  const e = t.getObj();
  e instanceof at && (A.name = e.name);
}
async function cE(A, t, e, i) {
  let s, n;
  t: for (; ; ) try {
    const o = t.getObj();
    if (o === Ae) break;
    if (o instanceof at) o.name === "WMode" ? j3(A, t) : o.name === "CMapName" && Z3(A, t), s = o;
    else if (o instanceof KA) switch (o.cmd) {
      case "endcmap":
        break t;
      case "usecmap":
        s instanceof at && (n = s.name);
        break;
      case "begincodespacerange":
        W3(A, t);
        break;
      case "beginbfchar":
        q3(A, t);
        break;
      case "begincidchar":
        _3(A, t);
        break;
      case "beginbfrange":
        P3(A, t);
        break;
      case "begincidrange":
        O3(A, t);
    }
  } catch (o) {
    if (o instanceof yA) throw o;
    O("Invalid cMap data: " + o);
    continue;
  }
  return !i && n && (i = n), i ? hE(A, e, i) : A;
}
async function hE(A, t, e) {
  if (A.useCMap = await Yh(e, t), A.numCodespaceRanges === 0) {
    const i = A.useCMap.codespaceRanges;
    for (let s = 0; s < i.length; s++) A.codespaceRanges[s] = i[s].slice();
    A.numCodespaceRanges = A.useCMap.numCodespaceRanges;
  }
  return A.useCMap.forEach((function(i, s) {
    A.contains(i) || A.mapOne(i, A.useCMap.lookup(i));
  })), A;
}
async function Yh(A, t) {
  if (A === "Identity-H") return new _a(!1, 2);
  if (A === "Identity-V") return new _a(!0, 2);
  if (!K3.includes(A)) throw new Error("Unknown CMap name: " + A);
  if (!t) throw new Error("Built-in CMap parameters are not provided.");
  const { cMapData: e, compressionType: i } = await t(A), s = new Dl(!0);
  if (i === mQ) return new o3().process(e, s, ((n) => hE(s, t, n)));
  if (i === pQ) {
    const n = new hi(new RA(e));
    return cE(s, n, t, null);
  }
  throw new Error(`Invalid CMap "compressionType" value: ${i}`);
}
class eo {
  static async create({ encoding: t, fetchBuiltInCMap: e, useCMap: i }) {
    if (t instanceof at) return Yh(t.name, e);
    if (t instanceof AA) {
      const s = await cE(new Dl(), new hi(t), e, i);
      return s.isIdentityCMap ? Yh(s.name, e) : s;
    }
    throw new Error("Encoding required.");
  }
}
const V3 = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"], X3 = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"], z3 = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"], lE = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"], $3 = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""], kl = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"], Vi = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""], nr = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"], Sl = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""], Fl = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
function rr(A) {
  switch (A) {
    case "WinAnsiEncoding":
      return nr;
    case "StandardEncoding":
      return Vi;
    case "MacRomanEncoding":
      return kl;
    case "SymbolSetEncoding":
      return Sl;
    case "ZapfDingbatsEncoding":
      return Fl;
    case "ExpertEncoding":
      return lE;
    case "MacExpertEncoding":
      return $3;
    default:
      return null;
  }
}
const wo = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"], jc = 391, Sa = [null, { id: "hstem", min: 2, stackClearing: !0, stem: !0 }, null, { id: "vstem", min: 2, stackClearing: !0, stem: !0 }, { id: "vmoveto", min: 1, stackClearing: !0 }, { id: "rlineto", min: 2, resetStack: !0 }, { id: "hlineto", min: 1, resetStack: !0 }, { id: "vlineto", min: 1, resetStack: !0 }, { id: "rrcurveto", min: 6, resetStack: !0 }, null, { id: "callsubr", min: 1, undefStack: !0 }, { id: "return", min: 0, undefStack: !0 }, null, null, { id: "endchar", min: 0, stackClearing: !0 }, null, null, null, { id: "hstemhm", min: 2, stackClearing: !0, stem: !0 }, { id: "hintmask", min: 0, stackClearing: !0 }, { id: "cntrmask", min: 0, stackClearing: !0 }, { id: "rmoveto", min: 2, stackClearing: !0 }, { id: "hmoveto", min: 1, stackClearing: !0 }, { id: "vstemhm", min: 2, stackClearing: !0, stem: !0 }, { id: "rcurveline", min: 8, resetStack: !0 }, { id: "rlinecurve", min: 8, resetStack: !0 }, { id: "vvcurveto", min: 4, resetStack: !0 }, { id: "hhcurveto", min: 4, resetStack: !0 }, null, { id: "callgsubr", min: 1, undefStack: !0 }, { id: "vhcurveto", min: 4, resetStack: !0 }, { id: "hvcurveto", min: 4, resetStack: !0 }], t5 = [null, null, null, { id: "and", min: 2, stackDelta: -1 }, { id: "or", min: 2, stackDelta: -1 }, { id: "not", min: 1, stackDelta: 0 }, null, null, null, { id: "abs", min: 1, stackDelta: 0 }, { id: "add", min: 2, stackDelta: -1, stackFn(A, t) {
  A[t - 2] = A[t - 2] + A[t - 1];
} }, { id: "sub", min: 2, stackDelta: -1, stackFn(A, t) {
  A[t - 2] = A[t - 2] - A[t - 1];
} }, { id: "div", min: 2, stackDelta: -1, stackFn(A, t) {
  A[t - 2] = A[t - 2] / A[t - 1];
} }, null, { id: "neg", min: 1, stackDelta: 0, stackFn(A, t) {
  A[t - 1] = -A[t - 1];
} }, { id: "eq", min: 2, stackDelta: -1 }, null, null, { id: "drop", min: 1, stackDelta: -1 }, null, { id: "put", min: 2, stackDelta: -2 }, { id: "get", min: 1, stackDelta: 0 }, { id: "ifelse", min: 4, stackDelta: -3 }, { id: "random", min: 0, stackDelta: 1 }, { id: "mul", min: 2, stackDelta: -1, stackFn(A, t) {
  A[t - 2] = A[t - 2] * A[t - 1];
} }, null, { id: "sqrt", min: 1, stackDelta: 0 }, { id: "dup", min: 1, stackDelta: 1 }, { id: "exch", min: 2, stackDelta: 0 }, { id: "index", min: 2, stackDelta: 0 }, { id: "roll", min: 3, stackDelta: -2 }, null, null, null, { id: "hflex", min: 7, resetStack: !0 }, { id: "flex", min: 13, resetStack: !0 }, { id: "hflex1", min: 9, resetStack: !0 }, { id: "flex1", min: 11, resetStack: !0 }];
class Rl {
  constructor(t, e, i) {
    this.bytes = t.getBytes(), this.properties = e, this.seacAnalysisEnabled = !!i;
  }
  parse() {
    const t = this.properties, e = new IE();
    this.cff = e;
    const i = this.parseHeader(), s = this.parseIndex(i.endPos), n = this.parseIndex(s.endPos), o = this.parseIndex(n.endPos), r = this.parseIndex(o.endPos), c = this.parseDict(n.obj.get(0)), h = this.createDict(or, c, e.strings);
    e.header = i.obj, e.names = this.parseNameIndex(s.obj), e.strings = this.parseStringIndex(o.obj), e.topDict = h, e.globalSubrIndex = r.obj, this.parsePrivateDict(e.topDict), e.isCIDFont = h.hasName("ROS");
    const I = h.getByName("CharStrings"), C = this.parseIndex(I).obj, d = h.getByName("FontMatrix");
    d && (t.fontMatrix = d);
    const u = h.getByName("FontBBox");
    let E, p;
    if (u && (t.ascent = Math.max(u[3], u[1]), t.descent = Math.min(u[1], u[3]), t.ascentScaled = !0), e.isCIDFont) {
      const b = this.parseIndex(h.getByName("FDArray")).obj;
      for (let D = 0, S = b.count; D < S; ++D) {
        const R = b.get(D), x = this.createDict(or, this.parseDict(R), e.strings);
        this.parsePrivateDict(x), e.fdArray.push(x);
      }
      p = null, E = this.parseCharsets(h.getByName("charset"), C.count, e.strings, !0), e.fdSelect = this.parseFDSelect(h.getByName("FDSelect"), C.count);
    } else E = this.parseCharsets(h.getByName("charset"), C.count, e.strings, !1), p = this.parseEncoding(h.getByName("Encoding"), t, e.strings, E.charset);
    e.charset = E, e.encoding = p;
    const y = this.parseCharStrings({ charStrings: C, localSubrIndex: h.privateDict.subrsIndex, globalSubrIndex: r.obj, fdSelect: e.fdSelect, fdArray: e.fdArray, privateDict: h.privateDict });
    return e.charStrings = y.charStrings, e.seacs = y.seacs, e.widths = y.widths, e;
  }
  parseHeader() {
    let t = this.bytes;
    const e = t.length;
    let i = 0;
    for (; i < e && t[i] !== 1; ) ++i;
    if (i >= e) throw new Ct("Invalid CFF header");
    i !== 0 && (tA("cff data is shifted"), t = t.subarray(i), this.bytes = t);
    const s = t[0], n = t[1], o = t[2], r = t[3];
    return { obj: new CE(s, n, o, r), endPos: o };
  }
  parseDict(t) {
    let e = 0;
    function i() {
      let r = t[e++];
      return r === 30 ? (function() {
        let c = "";
        const I = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], C = t.length;
        for (; e < C; ) {
          const d = t[e++], u = d >> 4, E = 15 & d;
          if (u === 15 || (c += I[u], E === 15)) break;
          c += I[E];
        }
        return parseFloat(c);
      })() : r === 28 ? (r = t[e++], r = (r << 24 | t[e++] << 16) >> 16, r) : r === 29 ? (r = t[e++], r = r << 8 | t[e++], r = r << 8 | t[e++], r = r << 8 | t[e++], r) : r >= 32 && r <= 246 ? r - 139 : r >= 247 && r <= 250 ? 256 * (r - 247) + t[e++] + 108 : r >= 251 && r <= 254 ? -256 * (r - 251) - t[e++] - 108 : (O('CFFParser_parseDict: "' + r + '" is a reserved command.'), NaN);
    }
    let s = [];
    const n = [];
    e = 0;
    const o = t.length;
    for (; e < o; ) {
      let r = t[e];
      r <= 21 ? (r === 12 && (r = r << 8 | t[++e]), n.push([r, s]), s = [], ++e) : s.push(i());
    }
    return n;
  }
  parseIndex(t) {
    const e = new Ss(), i = this.bytes, s = i[t++] << 8 | i[t++], n = [];
    let o, r, c = t;
    if (s !== 0) {
      const h = i[t++], I = t + (s + 1) * h - 1;
      for (o = 0, r = s + 1; o < r; ++o) {
        let C = 0;
        for (let d = 0; d < h; ++d) C <<= 8, C += i[t++];
        n.push(I + C);
      }
      c = n[s];
    }
    for (o = 0, r = n.length - 1; o < r; ++o) {
      const h = n[o], I = n[o + 1];
      e.add(i.subarray(h, I));
    }
    return { obj: e, endPos: c };
  }
  parseNameIndex(t) {
    const e = [];
    for (let i = 0, s = t.count; i < s; ++i) {
      const n = t.get(i);
      e.push(Re(n));
    }
    return e;
  }
  parseStringIndex(t) {
    const e = new xl();
    for (let i = 0, s = t.count; i < s; ++i) {
      const n = t.get(i);
      e.add(Re(n));
    }
    return e;
  }
  createDict(t, e, i) {
    const s = new t(i);
    for (const [n, o] of e) s.setByKey(n, o);
    return s;
  }
  parseCharString(t, e, i, s) {
    if (!e || t.callDepth > 10) return !1;
    let n = t.stackSize;
    const o = t.stack;
    let r = e.length;
    for (let c = 0; c < r; ) {
      const h = e[c++];
      let I = null;
      if (h === 12) {
        const C = e[c++];
        C === 0 ? (e[c - 2] = 139, e[c - 1] = 22, n = 0) : I = t5[C];
      } else if (h === 28) o[n] = (e[c] << 24 | e[c + 1] << 16) >> 16, c += 2, n++;
      else if (h === 14) {
        if (n >= 4 && (n -= 4, this.seacAnalysisEnabled)) return t.seac = o.slice(n, n + 4), !1;
        I = Sa[h];
      } else if (h >= 32 && h <= 246) o[n] = h - 139, n++;
      else if (h >= 247 && h <= 254) o[n] = h < 251 ? (h - 247 << 8) + e[c] + 108 : -(h - 251 << 8) - e[c] - 108, c++, n++;
      else if (h === 255) o[n] = (e[c] << 24 | e[c + 1] << 16 | e[c + 2] << 8 | e[c + 3]) / 65536, c += 4, n++;
      else if (h === 19 || h === 20) {
        if (t.hints += n >> 1, t.hints === 0) {
          e.copyWithin(c - 1, c, -1), c -= 1, r -= 1;
          continue;
        }
        c += t.hints + 7 >> 3, n %= 2, I = Sa[h];
      } else {
        if (h === 10 || h === 29) {
          const C = h === 10 ? i : s;
          if (!C) return I = Sa[h], O("Missing subrsIndex for " + I.id), !1;
          let d = 32768;
          C.count < 1240 ? d = 107 : C.count < 33900 && (d = 1131);
          const u = o[--n] + d;
          if (u < 0 || u >= C.count || isNaN(u)) return I = Sa[h], O("Out of bounds subrIndex for " + I.id), !1;
          if (t.stackSize = n, t.callDepth++, !this.parseCharString(t, C.get(u), i, s)) return !1;
          t.callDepth--, n = t.stackSize;
          continue;
        }
        if (h === 11) return t.stackSize = n, !0;
        if (h === 0 && c === e.length) e[c - 1] = 14, I = Sa[14];
        else {
          if (h === 9) {
            e.copyWithin(c - 1, c, -1), c -= 1, r -= 1;
            continue;
          }
          I = Sa[h];
        }
      }
      if (I) {
        if (I.stem && (t.hints += n >> 1, h === 3 || h === 23 ? t.hasVStems = !0 : !t.hasVStems || h !== 1 && h !== 18 || (O("CFF stem hints are in wrong order"), e[c - 1] = h === 1 ? 3 : 23)), "min" in I && !t.undefStack && n < I.min) return O("Not enough parameters for " + I.id + "; actual: " + n + ", expected: " + I.min), n === 0 && (e[c - 1] = 14, !0);
        t.firstStackClearing && I.stackClearing && (t.firstStackClearing = !1, n -= I.min, n >= 2 && I.stem ? n %= 2 : n > 1 && O("Found too many parameters for stack-clearing command"), n > 0 && (t.width = o[n - 1])), "stackDelta" in I ? ("stackFn" in I && I.stackFn(o, n), n += I.stackDelta) : I.stackClearing ? n = 0 : I.resetStack ? (n = 0, t.undefStack = !1) : I.undefStack && (n = 0, t.undefStack = !0, t.firstStackClearing = !1);
      }
    }
    return r < e.length && e.fill(14, r), t.stackSize = n, !0;
  }
  parseCharStrings({ charStrings: t, localSubrIndex: e, globalSubrIndex: i, fdSelect: s, fdArray: n, privateDict: o }) {
    const r = [], c = [], h = t.count;
    for (let I = 0; I < h; I++) {
      const C = t.get(I), d = { callDepth: 0, stackSize: 0, stack: [], undefStack: !0, hints: 0, firstStackClearing: !0, seac: null, width: null, hasVStems: !1 };
      let u = !0, E = null, p = o;
      if (s && n.length) {
        const y = s.getFDIndex(I);
        y === -1 && (O("Glyph index is not in fd select."), u = !1), y >= n.length && (O("Invalid fd index for glyph index."), u = !1), u && (p = n[y].privateDict, E = p.subrsIndex);
      } else e && (E = e);
      if (u && (u = this.parseCharString(d, C, E, i)), d.width !== null) {
        const y = p.getByName("nominalWidthX");
        c[I] = y + d.width;
      } else {
        const y = p.getByName("defaultWidthX");
        c[I] = y;
      }
      d.seac !== null && (r[I] = d.seac), u || t.set(I, new Uint8Array([14]));
    }
    return { charStrings: t, seacs: r, widths: c };
  }
  emptyPrivateDictionary(t) {
    const e = this.createDict(gr, [], t.strings);
    t.setByKey(18, [0, 0]), t.privateDict = e;
  }
  parsePrivateDict(t) {
    if (!t.hasName("Private")) return void this.emptyPrivateDictionary(t);
    const e = t.getByName("Private");
    if (!Array.isArray(e) || e.length !== 2) return void t.removeByName("Private");
    const i = e[0], s = e[1];
    if (i === 0 || s >= this.bytes.length) return void this.emptyPrivateDictionary(t);
    const n = s + i, o = this.bytes.subarray(s, n), r = this.parseDict(o), c = this.createDict(gr, r, t.strings);
    if (t.privateDict = c, c.getByName("ExpansionFactor") === 0 && c.setByName("ExpansionFactor", 0.06), !c.getByName("Subrs")) return;
    const h = c.getByName("Subrs"), I = s + h;
    if (h === 0 || I >= this.bytes.length) return void this.emptyPrivateDictionary(t);
    const C = this.parseIndex(I);
    c.subrsIndex = C.obj;
  }
  parseCharsets(t, e, i, s) {
    if (t === 0) return new Yn(!0, Zc.ISO_ADOBE, V3);
    if (t === 1) return new Yn(!0, Zc.EXPERT, X3);
    if (t === 2) return new Yn(!0, Zc.EXPERT_SUBSET, z3);
    const n = this.bytes, o = t, r = n[t++], c = [s ? 0 : ".notdef"];
    let h, I, C;
    switch (e -= 1, r) {
      case 0:
        for (C = 0; C < e; C++) h = n[t++] << 8 | n[t++], c.push(s ? h : i.get(h));
        break;
      case 1:
        for (; c.length <= e; ) for (h = n[t++] << 8 | n[t++], I = n[t++], C = 0; C <= I; C++) c.push(s ? h++ : i.get(h++));
        break;
      case 2:
        for (; c.length <= e; ) for (h = n[t++] << 8 | n[t++], I = n[t++] << 8 | n[t++], C = 0; C <= I; C++) c.push(s ? h++ : i.get(h++));
        break;
      default:
        throw new Ct("Unknown charset format");
    }
    const d = t, u = n.subarray(o, d);
    return new Yn(!1, r, c, u);
  }
  parseEncoding(t, e, i, s) {
    const n = /* @__PURE__ */ Object.create(null), o = this.bytes;
    let r, c, h, I = !1, C = null;
    if (t === 0 || t === 1) {
      I = !0, r = t;
      const d = t ? lE : Vi;
      for (c = 0, h = s.length; c < h; c++) {
        const u = d.indexOf(s[c]);
        u !== -1 && (n[u] = c);
      }
    } else {
      const d = t;
      switch (r = o[t++], 127 & r) {
        case 0:
          const E = o[t++];
          for (c = 1; c <= E; c++) n[o[t++]] = c;
          break;
        case 1:
          const p = o[t++];
          let y = 1;
          for (c = 0; c < p; c++) {
            const b = o[t++], D = o[t++];
            for (let S = b; S <= b + D; S++) n[S] = y++;
          }
          break;
        default:
          throw new Ct(`Unknown encoding format: ${r} in CFF`);
      }
      const u = t;
      128 & r && (o[d] &= 127, (function() {
        const E = o[t++];
        for (c = 0; c < E; c++) {
          const p = o[t++], y = (o[t++] << 8) + (255 & o[t++]);
          n[p] = s.indexOf(i.get(y));
        }
      })()), C = o.subarray(d, u);
    }
    return r &= 127, new i5(I, r, n, C);
  }
  parseFDSelect(t, e) {
    const i = this.bytes, s = i[t++], n = [];
    let o;
    switch (s) {
      case 0:
        for (o = 0; o < e; ++o) {
          const c = i[t++];
          n.push(c);
        }
        break;
      case 3:
        const r = i[t++] << 8 | i[t++];
        for (o = 0; o < r; ++o) {
          let c = i[t++] << 8 | i[t++];
          o === 0 && c !== 0 && (O("parseFDSelect: The first range must have a first GID of 0 -- trying to recover."), c = 0);
          const h = i[t++], I = i[t] << 8 | i[t + 1];
          for (let C = c; C < I; ++C) n.push(h);
        }
        t += 2;
        break;
      default:
        throw new Ct(`parseFDSelect: Unknown format "${s}".`);
    }
    if (n.length !== e) throw new Ct("parseFDSelect: Invalid font data.");
    return new s5(s, n);
  }
}
class IE {
  constructor() {
    this.header = null, this.names = [], this.topDict = null, this.strings = new xl(), this.globalSubrIndex = null, this.encoding = null, this.charset = null, this.charStrings = null, this.fdArray = [], this.fdSelect = null, this.isCIDFont = !1;
  }
  duplicateFirstGlyph() {
    if (this.charStrings.count >= 65535) return void O("Not enough space in charstrings to duplicate first glyph.");
    const t = this.charStrings.get(0);
    this.charStrings.add(t), this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
  }
  hasGlyphId(t) {
    return t < 0 || t >= this.charStrings.count ? !1 : this.charStrings.get(t).length > 0;
  }
}
class CE {
  constructor(t, e, i, s) {
    this.major = t, this.minor = e, this.hdrSize = i, this.offSize = s;
  }
}
class xl {
  constructor() {
    this.strings = [];
  }
  get(t) {
    return t >= 0 && t <= 390 ? wo[t] : t - jc <= this.strings.length ? this.strings[t - jc] : wo[0];
  }
  getSID(t) {
    let e = wo.indexOf(t);
    return e !== -1 ? e : (e = this.strings.indexOf(t), e !== -1 ? e + jc : -1);
  }
  add(t) {
    this.strings.push(t);
  }
  get count() {
    return this.strings.length;
  }
}
class Ss {
  constructor() {
    this.objects = [], this.length = 0;
  }
  add(t) {
    this.length += t.length, this.objects.push(t);
  }
  set(t, e) {
    this.length += e.length - this.objects[t].length, this.objects[t] = e;
  }
  get(t) {
    return this.objects[t];
  }
  get count() {
    return this.objects.length;
  }
}
class uE {
  constructor(t, e) {
    this.keyToNameMap = t.keyToNameMap, this.nameToKeyMap = t.nameToKeyMap, this.defaults = t.defaults, this.types = t.types, this.opcodes = t.opcodes, this.order = t.order, this.strings = e, this.values = /* @__PURE__ */ Object.create(null);
  }
  setByKey(t, e) {
    if (!(t in this.keyToNameMap)) return !1;
    if (e.length === 0) return !0;
    for (const s of e) if (isNaN(s)) return O(`Invalid CFFDict value: "${e}" for key "${t}".`), !0;
    const i = this.types[t];
    return i !== "num" && i !== "sid" && i !== "offset" || (e = e[0]), this.values[t] = e, !0;
  }
  setByName(t, e) {
    if (!(t in this.nameToKeyMap)) throw new Ct(`Invalid dictionary name "${t}"`);
    this.values[this.nameToKeyMap[t]] = e;
  }
  hasName(t) {
    return this.nameToKeyMap[t] in this.values;
  }
  getByName(t) {
    if (!(t in this.nameToKeyMap)) throw new Ct(`Invalid dictionary name ${t}"`);
    const e = this.nameToKeyMap[t];
    return e in this.values ? this.values[e] : this.defaults[e];
  }
  removeByName(t) {
    delete this.values[this.nameToKeyMap[t]];
  }
  static createTables(t) {
    const e = { keyToNameMap: {}, nameToKeyMap: {}, defaults: {}, types: {}, opcodes: {}, order: [] };
    for (const i of t) {
      const s = Array.isArray(i[0]) ? (i[0][0] << 8) + i[0][1] : i[0];
      e.keyToNameMap[s] = i[1], e.nameToKeyMap[i[1]] = s, e.types[s] = i[2], e.defaults[s] = i[3], e.opcodes[s] = Array.isArray(i[0]) ? i[0] : [i[0]], e.order.push(s);
    }
    return e;
  }
}
const A5 = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
class or extends uE {
  static get tables() {
    return bt(this, "tables", this.createTables(A5));
  }
  constructor(t) {
    super(or.tables, t), this.privateDict = null;
  }
}
const e5 = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
class gr extends uE {
  static get tables() {
    return bt(this, "tables", this.createTables(e5));
  }
  constructor(t) {
    super(gr.tables, t), this.subrsIndex = null;
  }
}
const Zc = { ISO_ADOBE: 0, EXPERT: 1, EXPERT_SUBSET: 2 };
class Yn {
  constructor(t, e, i, s) {
    this.predefined = t, this.format = e, this.charset = i, this.raw = s;
  }
}
class i5 {
  constructor(t, e, i, s) {
    this.predefined = t, this.format = e, this.encoding = i, this.raw = s;
  }
}
class s5 {
  constructor(t, e) {
    this.format = t, this.fdSelect = e;
  }
  getFDIndex(t) {
    return t < 0 || t >= this.fdSelect.length ? -1 : this.fdSelect[t];
  }
}
class YC {
  constructor() {
    this.offsets = /* @__PURE__ */ Object.create(null);
  }
  isTracking(t) {
    return t in this.offsets;
  }
  track(t, e) {
    if (t in this.offsets) throw new Ct(`Already tracking location of ${t}`);
    this.offsets[t] = e;
  }
  offset(t) {
    for (const e in this.offsets) this.offsets[e] += t;
  }
  setEntryLocation(t, e, i) {
    if (!(t in this.offsets)) throw new Ct(`Not tracking location of ${t}`);
    const s = i.data, n = this.offsets[t];
    for (let o = 0, r = e.length; o < r; ++o) {
      const c = 5 * o + n, h = c + 1, I = c + 2, C = c + 3, d = c + 4;
      if (s[c] !== 29 || s[h] !== 0 || s[I] !== 0 || s[C] !== 0 || s[d] !== 0) throw new Ct("writing to an offset that is not empty");
      const u = e[o];
      s[c] = 29, s[h] = u >> 24 & 255, s[I] = u >> 16 & 255, s[C] = u >> 8 & 255, s[d] = 255 & u;
    }
  }
}
class br {
  constructor(t) {
    this.cff = t;
  }
  compile() {
    const t = this.cff, e = { data: [], length: 0, add(d) {
      try {
        this.data.push(...d);
      } catch {
        this.data = this.data.concat(d);
      }
      this.length = this.data.length;
    } }, i = this.compileHeader(t.header);
    e.add(i);
    const s = this.compileNameIndex(t.names);
    if (e.add(s), t.isCIDFont && t.topDict.hasName("FontMatrix")) {
      const d = t.topDict.getByName("FontMatrix");
      t.topDict.removeByName("FontMatrix");
      for (const u of t.fdArray) {
        let E = d.slice(0);
        u.hasName("FontMatrix") && (E = PA.transform(E, u.getByName("FontMatrix"))), u.setByName("FontMatrix", E);
      }
    }
    t.topDict.getByName("XUID")?.length > 16 && t.topDict.removeByName("XUID"), t.topDict.setByName("charset", 0);
    let o = this.compileTopDicts([t.topDict], e.length, t.isCIDFont);
    e.add(o.output);
    const r = o.trackers[0], c = this.compileStringIndex(t.strings.strings);
    e.add(c);
    const h = this.compileIndex(t.globalSubrIndex);
    if (e.add(h), t.encoding && t.topDict.hasName("Encoding")) if (t.encoding.predefined) r.setEntryLocation("Encoding", [t.encoding.format], e);
    else {
      const d = this.compileEncoding(t.encoding);
      r.setEntryLocation("Encoding", [e.length], e), e.add(d);
    }
    const I = this.compileCharset(t.charset, t.charStrings.count, t.strings, t.isCIDFont);
    r.setEntryLocation("charset", [e.length], e), e.add(I);
    const C = this.compileCharStrings(t.charStrings);
    if (r.setEntryLocation("CharStrings", [e.length], e), e.add(C), t.isCIDFont) {
      r.setEntryLocation("FDSelect", [e.length], e);
      const d = this.compileFDSelect(t.fdSelect);
      e.add(d), o = this.compileTopDicts(t.fdArray, e.length, !0), r.setEntryLocation("FDArray", [e.length], e), e.add(o.output);
      const u = o.trackers;
      this.compilePrivateDicts(t.fdArray, u, e);
    }
    return this.compilePrivateDicts([t.topDict], [r], e), e.add([0]), e.data;
  }
  encodeNumber(t) {
    return Number.isInteger(t) ? this.encodeInteger(t) : this.encodeFloat(t);
  }
  static get EncodeFloatRegExp() {
    return bt(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
  }
  encodeFloat(t) {
    let e = t.toString();
    const i = br.EncodeFloatRegExp.exec(e);
    if (i) {
      const c = parseFloat("1e" + ((i[2] ? +i[2] : 0) + i[1].length));
      e = (Math.round(t * c) / c).toString();
    }
    let s, n, o = "";
    for (s = 0, n = e.length; s < n; ++s) {
      const c = e[s];
      o += c === "e" ? e[++s] === "-" ? "c" : "b" : c === "." ? "a" : c === "-" ? "e" : c;
    }
    o += 1 & o.length ? "f" : "ff";
    const r = [30];
    for (s = 0, n = o.length; s < n; s += 2) r.push(parseInt(o.substring(s, s + 2), 16));
    return r;
  }
  encodeInteger(t) {
    let e;
    return e = t >= -107 && t <= 107 ? [t + 139] : t >= 108 && t <= 1131 ? [247 + ((t -= 108) >> 8), 255 & t] : t >= -1131 && t <= -108 ? [251 + ((t = -t - 108) >> 8), 255 & t] : t >= -32768 && t <= 32767 ? [28, t >> 8 & 255, 255 & t] : [29, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t], e;
  }
  compileHeader(t) {
    return [t.major, t.minor, 4, t.offSize];
  }
  compileNameIndex(t) {
    const e = new Ss();
    for (const i of t) {
      const s = Math.min(i.length, 127);
      let n = new Array(s);
      for (let o = 0; o < s; o++) {
        let r = i[o];
        (r < "!" || r > "~" || r === "[" || r === "]" || r === "(" || r === ")" || r === "{" || r === "}" || r === "<" || r === ">" || r === "/" || r === "%") && (r = "_"), n[o] = r;
      }
      n = n.join(""), n === "" && (n = "Bad_Font_Name"), e.add(re(n));
    }
    return this.compileIndex(e);
  }
  compileTopDicts(t, e, i) {
    const s = [];
    let n = new Ss();
    for (const o of t) {
      i && (o.removeByName("CIDFontVersion"), o.removeByName("CIDFontRevision"), o.removeByName("CIDFontType"), o.removeByName("CIDCount"), o.removeByName("UIDBase"));
      const r = new YC(), c = this.compileDict(o, r);
      s.push(r), n.add(c), r.offset(e);
    }
    return n = this.compileIndex(n, s), { trackers: s, output: n };
  }
  compilePrivateDicts(t, e, i) {
    for (let s = 0, n = t.length; s < n; ++s) {
      const o = t[s], r = o.privateDict;
      if (!r || !o.hasName("Private")) throw new Ct("There must be a private dictionary.");
      const c = new YC(), h = this.compileDict(r, c);
      let I = i.length;
      if (c.offset(I), h.length || (I = 0), e[s].setEntryLocation("Private", [h.length, I], i), i.add(h), r.subrsIndex && r.hasName("Subrs")) {
        const C = this.compileIndex(r.subrsIndex);
        c.setEntryLocation("Subrs", [h.length], i), i.add(C);
      }
    }
  }
  compileDict(t, e) {
    const i = [];
    for (const s of t.order) {
      if (!(s in t.values)) continue;
      let n = t.values[s], o = t.types[s];
      if (Array.isArray(o) || (o = [o]), Array.isArray(n) || (n = [n]), n.length !== 0) {
        for (let r = 0, c = o.length; r < c; ++r) {
          const h = o[r], I = n[r];
          switch (h) {
            case "num":
            case "sid":
              i.push(...this.encodeNumber(I));
              break;
            case "offset":
              const C = t.keyToNameMap[s];
              e.isTracking(C) || e.track(C, i.length), i.push(29, 0, 0, 0, 0);
              break;
            case "array":
            case "delta":
              i.push(...this.encodeNumber(I));
              for (let d = 1, u = n.length; d < u; ++d) i.push(...this.encodeNumber(n[d]));
              break;
            default:
              throw new Ct(`Unknown data type of ${h}`);
          }
        }
        i.push(...t.opcodes[s]);
      }
    }
    return i;
  }
  compileStringIndex(t) {
    const e = new Ss();
    for (const i of t) e.add(re(i));
    return this.compileIndex(e);
  }
  compileCharStrings(t) {
    const e = new Ss();
    for (let i = 0; i < t.count; i++) {
      const s = t.get(i);
      s.length !== 0 ? e.add(s) : e.add(new Uint8Array([139, 14]));
    }
    return this.compileIndex(e);
  }
  compileCharset(t, e, i, s) {
    let n;
    const o = e - 1;
    if (s) n = new Uint8Array([2, 0, 0, o >> 8 & 255, 255 & o]);
    else {
      n = new Uint8Array(1 + 2 * o), n[0] = 0;
      let r = 0;
      const c = t.charset.length;
      let h = !1;
      for (let I = 1; I < n.length; I += 2) {
        let C = 0;
        if (r < c) {
          const d = t.charset[r++];
          C = i.getSID(d), C === -1 && (C = 0, h || (h = !0, O(`Couldn't find ${d} in CFF strings`)));
        }
        n[I] = C >> 8 & 255, n[I + 1] = 255 & C;
      }
    }
    return this.compileTypedArray(n);
  }
  compileEncoding(t) {
    return this.compileTypedArray(t.raw);
  }
  compileFDSelect(t) {
    const e = t.format;
    let i, s;
    switch (e) {
      case 0:
        for (i = new Uint8Array(1 + t.fdSelect.length), i[0] = e, s = 0; s < t.fdSelect.length; s++) i[s + 1] = t.fdSelect[s];
        break;
      case 3:
        const n = 0;
        let o = t.fdSelect[0];
        const r = [e, 0, 0, n >> 8 & 255, 255 & n, o];
        for (s = 1; s < t.fdSelect.length; s++) {
          const h = t.fdSelect[s];
          h !== o && (r.push(s >> 8 & 255, 255 & s, h), o = h);
        }
        const c = (r.length - 3) / 3;
        r[1] = c >> 8 & 255, r[2] = 255 & c, r.push(s >> 8 & 255, 255 & s), i = new Uint8Array(r);
    }
    return this.compileTypedArray(i);
  }
  compileTypedArray(t) {
    return Array.from(t);
  }
  compileIndex(t, e = []) {
    const i = t.objects, s = i.length;
    if (s === 0) return [0, 0];
    const n = [s >> 8 & 255, 255 & s];
    let o, r, c = 1;
    for (o = 0; o < s; ++o) c += i[o].length;
    r = c < 256 ? 1 : c < 65536 ? 2 : c < 16777216 ? 3 : 4, n.push(r);
    let h = 1;
    for (o = 0; o < s + 1; o++) r === 1 ? n.push(255 & h) : r === 2 ? n.push(h >> 8 & 255, 255 & h) : r === 3 ? n.push(h >> 16 & 255, h >> 8 & 255, 255 & h) : n.push(h >>> 24 & 255, h >> 16 & 255, h >> 8 & 255, 255 & h), i[o] && (h += i[o].length);
    for (o = 0; o < s; o++) e[o] && e[o].offset(n.length), n.push(...i[o]);
    return n;
  }
}
const mi = DA((function(A) {
  A.A = 65, A.AE = 198, A.AEacute = 508, A.AEmacron = 482, A.AEsmall = 63462, A.Aacute = 193, A.Aacutesmall = 63457, A.Abreve = 258, A.Abreveacute = 7854, A.Abrevecyrillic = 1232, A.Abrevedotbelow = 7862, A.Abrevegrave = 7856, A.Abrevehookabove = 7858, A.Abrevetilde = 7860, A.Acaron = 461, A.Acircle = 9398, A.Acircumflex = 194, A.Acircumflexacute = 7844, A.Acircumflexdotbelow = 7852, A.Acircumflexgrave = 7846, A.Acircumflexhookabove = 7848, A.Acircumflexsmall = 63458, A.Acircumflextilde = 7850, A.Acute = 63177, A.Acutesmall = 63412, A.Acyrillic = 1040, A.Adblgrave = 512, A.Adieresis = 196, A.Adieresiscyrillic = 1234, A.Adieresismacron = 478, A.Adieresissmall = 63460, A.Adotbelow = 7840, A.Adotmacron = 480, A.Agrave = 192, A.Agravesmall = 63456, A.Ahookabove = 7842, A.Aiecyrillic = 1236, A.Ainvertedbreve = 514, A.Alpha = 913, A.Alphatonos = 902, A.Amacron = 256, A.Amonospace = 65313, A.Aogonek = 260, A.Aring = 197, A.Aringacute = 506, A.Aringbelow = 7680, A.Aringsmall = 63461, A.Asmall = 63329, A.Atilde = 195, A.Atildesmall = 63459, A.Aybarmenian = 1329, A.B = 66, A.Bcircle = 9399, A.Bdotaccent = 7682, A.Bdotbelow = 7684, A.Becyrillic = 1041, A.Benarmenian = 1330, A.Beta = 914, A.Bhook = 385, A.Blinebelow = 7686, A.Bmonospace = 65314, A.Brevesmall = 63220, A.Bsmall = 63330, A.Btopbar = 386, A.C = 67, A.Caarmenian = 1342, A.Cacute = 262, A.Caron = 63178, A.Caronsmall = 63221, A.Ccaron = 268, A.Ccedilla = 199, A.Ccedillaacute = 7688, A.Ccedillasmall = 63463, A.Ccircle = 9400, A.Ccircumflex = 264, A.Cdot = 266, A.Cdotaccent = 266, A.Cedillasmall = 63416, A.Chaarmenian = 1353, A.Cheabkhasiancyrillic = 1212, A.Checyrillic = 1063, A.Chedescenderabkhasiancyrillic = 1214, A.Chedescendercyrillic = 1206, A.Chedieresiscyrillic = 1268, A.Cheharmenian = 1347, A.Chekhakassiancyrillic = 1227, A.Cheverticalstrokecyrillic = 1208, A.Chi = 935, A.Chook = 391, A.Circumflexsmall = 63222, A.Cmonospace = 65315, A.Coarmenian = 1361, A.Csmall = 63331, A.D = 68, A.DZ = 497, A.DZcaron = 452, A.Daarmenian = 1332, A.Dafrican = 393, A.Dcaron = 270, A.Dcedilla = 7696, A.Dcircle = 9401, A.Dcircumflexbelow = 7698, A.Dcroat = 272, A.Ddotaccent = 7690, A.Ddotbelow = 7692, A.Decyrillic = 1044, A.Deicoptic = 1006, A.Delta = 8710, A.Deltagreek = 916, A.Dhook = 394, A.Dieresis = 63179, A.DieresisAcute = 63180, A.DieresisGrave = 63181, A.Dieresissmall = 63400, A.Digammagreek = 988, A.Djecyrillic = 1026, A.Dlinebelow = 7694, A.Dmonospace = 65316, A.Dotaccentsmall = 63223, A.Dslash = 272, A.Dsmall = 63332, A.Dtopbar = 395, A.Dz = 498, A.Dzcaron = 453, A.Dzeabkhasiancyrillic = 1248, A.Dzecyrillic = 1029, A.Dzhecyrillic = 1039, A.E = 69, A.Eacute = 201, A.Eacutesmall = 63465, A.Ebreve = 276, A.Ecaron = 282, A.Ecedillabreve = 7708, A.Echarmenian = 1333, A.Ecircle = 9402, A.Ecircumflex = 202, A.Ecircumflexacute = 7870, A.Ecircumflexbelow = 7704, A.Ecircumflexdotbelow = 7878, A.Ecircumflexgrave = 7872, A.Ecircumflexhookabove = 7874, A.Ecircumflexsmall = 63466, A.Ecircumflextilde = 7876, A.Ecyrillic = 1028, A.Edblgrave = 516, A.Edieresis = 203, A.Edieresissmall = 63467, A.Edot = 278, A.Edotaccent = 278, A.Edotbelow = 7864, A.Efcyrillic = 1060, A.Egrave = 200, A.Egravesmall = 63464, A.Eharmenian = 1335, A.Ehookabove = 7866, A.Eightroman = 8551, A.Einvertedbreve = 518, A.Eiotifiedcyrillic = 1124, A.Elcyrillic = 1051, A.Elevenroman = 8554, A.Emacron = 274, A.Emacronacute = 7702, A.Emacrongrave = 7700, A.Emcyrillic = 1052, A.Emonospace = 65317, A.Encyrillic = 1053, A.Endescendercyrillic = 1186, A.Eng = 330, A.Enghecyrillic = 1188, A.Enhookcyrillic = 1223, A.Eogonek = 280, A.Eopen = 400, A.Epsilon = 917, A.Epsilontonos = 904, A.Ercyrillic = 1056, A.Ereversed = 398, A.Ereversedcyrillic = 1069, A.Escyrillic = 1057, A.Esdescendercyrillic = 1194, A.Esh = 425, A.Esmall = 63333, A.Eta = 919, A.Etarmenian = 1336, A.Etatonos = 905, A.Eth = 208, A.Ethsmall = 63472, A.Etilde = 7868, A.Etildebelow = 7706, A.Euro = 8364, A.Ezh = 439, A.Ezhcaron = 494, A.Ezhreversed = 440, A.F = 70, A.Fcircle = 9403, A.Fdotaccent = 7710, A.Feharmenian = 1366, A.Feicoptic = 996, A.Fhook = 401, A.Fitacyrillic = 1138, A.Fiveroman = 8548, A.Fmonospace = 65318, A.Fourroman = 8547, A.Fsmall = 63334, A.G = 71, A.GBsquare = 13191, A.Gacute = 500, A.Gamma = 915, A.Gammaafrican = 404, A.Gangiacoptic = 1002, A.Gbreve = 286, A.Gcaron = 486, A.Gcedilla = 290, A.Gcircle = 9404, A.Gcircumflex = 284, A.Gcommaaccent = 290, A.Gdot = 288, A.Gdotaccent = 288, A.Gecyrillic = 1043, A.Ghadarmenian = 1346, A.Ghemiddlehookcyrillic = 1172, A.Ghestrokecyrillic = 1170, A.Gheupturncyrillic = 1168, A.Ghook = 403, A.Gimarmenian = 1331, A.Gjecyrillic = 1027, A.Gmacron = 7712, A.Gmonospace = 65319, A.Grave = 63182, A.Gravesmall = 63328, A.Gsmall = 63335, A.Gsmallhook = 667, A.Gstroke = 484, A.H = 72, A.H18533 = 9679, A.H18543 = 9642, A.H18551 = 9643, A.H22073 = 9633, A.HPsquare = 13259, A.Haabkhasiancyrillic = 1192, A.Hadescendercyrillic = 1202, A.Hardsigncyrillic = 1066, A.Hbar = 294, A.Hbrevebelow = 7722, A.Hcedilla = 7720, A.Hcircle = 9405, A.Hcircumflex = 292, A.Hdieresis = 7718, A.Hdotaccent = 7714, A.Hdotbelow = 7716, A.Hmonospace = 65320, A.Hoarmenian = 1344, A.Horicoptic = 1e3, A.Hsmall = 63336, A.Hungarumlaut = 63183, A.Hungarumlautsmall = 63224, A.Hzsquare = 13200, A.I = 73, A.IAcyrillic = 1071, A.IJ = 306, A.IUcyrillic = 1070, A.Iacute = 205, A.Iacutesmall = 63469, A.Ibreve = 300, A.Icaron = 463, A.Icircle = 9406, A.Icircumflex = 206, A.Icircumflexsmall = 63470, A.Icyrillic = 1030, A.Idblgrave = 520, A.Idieresis = 207, A.Idieresisacute = 7726, A.Idieresiscyrillic = 1252, A.Idieresissmall = 63471, A.Idot = 304, A.Idotaccent = 304, A.Idotbelow = 7882, A.Iebrevecyrillic = 1238, A.Iecyrillic = 1045, A.Ifraktur = 8465, A.Igrave = 204, A.Igravesmall = 63468, A.Ihookabove = 7880, A.Iicyrillic = 1048, A.Iinvertedbreve = 522, A.Iishortcyrillic = 1049, A.Imacron = 298, A.Imacroncyrillic = 1250, A.Imonospace = 65321, A.Iniarmenian = 1339, A.Iocyrillic = 1025, A.Iogonek = 302, A.Iota = 921, A.Iotaafrican = 406, A.Iotadieresis = 938, A.Iotatonos = 906, A.Ismall = 63337, A.Istroke = 407, A.Itilde = 296, A.Itildebelow = 7724, A.Izhitsacyrillic = 1140, A.Izhitsadblgravecyrillic = 1142, A.J = 74, A.Jaarmenian = 1345, A.Jcircle = 9407, A.Jcircumflex = 308, A.Jecyrillic = 1032, A.Jheharmenian = 1355, A.Jmonospace = 65322, A.Jsmall = 63338, A.K = 75, A.KBsquare = 13189, A.KKsquare = 13261, A.Kabashkircyrillic = 1184, A.Kacute = 7728, A.Kacyrillic = 1050, A.Kadescendercyrillic = 1178, A.Kahookcyrillic = 1219, A.Kappa = 922, A.Kastrokecyrillic = 1182, A.Kaverticalstrokecyrillic = 1180, A.Kcaron = 488, A.Kcedilla = 310, A.Kcircle = 9408, A.Kcommaaccent = 310, A.Kdotbelow = 7730, A.Keharmenian = 1364, A.Kenarmenian = 1343, A.Khacyrillic = 1061, A.Kheicoptic = 998, A.Khook = 408, A.Kjecyrillic = 1036, A.Klinebelow = 7732, A.Kmonospace = 65323, A.Koppacyrillic = 1152, A.Koppagreek = 990, A.Ksicyrillic = 1134, A.Ksmall = 63339, A.L = 76, A.LJ = 455, A.LL = 63167, A.Lacute = 313, A.Lambda = 923, A.Lcaron = 317, A.Lcedilla = 315, A.Lcircle = 9409, A.Lcircumflexbelow = 7740, A.Lcommaaccent = 315, A.Ldot = 319, A.Ldotaccent = 319, A.Ldotbelow = 7734, A.Ldotbelowmacron = 7736, A.Liwnarmenian = 1340, A.Lj = 456, A.Ljecyrillic = 1033, A.Llinebelow = 7738, A.Lmonospace = 65324, A.Lslash = 321, A.Lslashsmall = 63225, A.Lsmall = 63340, A.M = 77, A.MBsquare = 13190, A.Macron = 63184, A.Macronsmall = 63407, A.Macute = 7742, A.Mcircle = 9410, A.Mdotaccent = 7744, A.Mdotbelow = 7746, A.Menarmenian = 1348, A.Mmonospace = 65325, A.Msmall = 63341, A.Mturned = 412, A.Mu = 924, A.N = 78, A.NJ = 458, A.Nacute = 323, A.Ncaron = 327, A.Ncedilla = 325, A.Ncircle = 9411, A.Ncircumflexbelow = 7754, A.Ncommaaccent = 325, A.Ndotaccent = 7748, A.Ndotbelow = 7750, A.Nhookleft = 413, A.Nineroman = 8552, A.Nj = 459, A.Njecyrillic = 1034, A.Nlinebelow = 7752, A.Nmonospace = 65326, A.Nowarmenian = 1350, A.Nsmall = 63342, A.Ntilde = 209, A.Ntildesmall = 63473, A.Nu = 925, A.O = 79, A.OE = 338, A.OEsmall = 63226, A.Oacute = 211, A.Oacutesmall = 63475, A.Obarredcyrillic = 1256, A.Obarreddieresiscyrillic = 1258, A.Obreve = 334, A.Ocaron = 465, A.Ocenteredtilde = 415, A.Ocircle = 9412, A.Ocircumflex = 212, A.Ocircumflexacute = 7888, A.Ocircumflexdotbelow = 7896, A.Ocircumflexgrave = 7890, A.Ocircumflexhookabove = 7892, A.Ocircumflexsmall = 63476, A.Ocircumflextilde = 7894, A.Ocyrillic = 1054, A.Odblacute = 336, A.Odblgrave = 524, A.Odieresis = 214, A.Odieresiscyrillic = 1254, A.Odieresissmall = 63478, A.Odotbelow = 7884, A.Ogoneksmall = 63227, A.Ograve = 210, A.Ogravesmall = 63474, A.Oharmenian = 1365, A.Ohm = 8486, A.Ohookabove = 7886, A.Ohorn = 416, A.Ohornacute = 7898, A.Ohorndotbelow = 7906, A.Ohorngrave = 7900, A.Ohornhookabove = 7902, A.Ohorntilde = 7904, A.Ohungarumlaut = 336, A.Oi = 418, A.Oinvertedbreve = 526, A.Omacron = 332, A.Omacronacute = 7762, A.Omacrongrave = 7760, A.Omega = 8486, A.Omegacyrillic = 1120, A.Omegagreek = 937, A.Omegaroundcyrillic = 1146, A.Omegatitlocyrillic = 1148, A.Omegatonos = 911, A.Omicron = 927, A.Omicrontonos = 908, A.Omonospace = 65327, A.Oneroman = 8544, A.Oogonek = 490, A.Oogonekmacron = 492, A.Oopen = 390, A.Oslash = 216, A.Oslashacute = 510, A.Oslashsmall = 63480, A.Osmall = 63343, A.Ostrokeacute = 510, A.Otcyrillic = 1150, A.Otilde = 213, A.Otildeacute = 7756, A.Otildedieresis = 7758, A.Otildesmall = 63477, A.P = 80, A.Pacute = 7764, A.Pcircle = 9413, A.Pdotaccent = 7766, A.Pecyrillic = 1055, A.Peharmenian = 1354, A.Pemiddlehookcyrillic = 1190, A.Phi = 934, A.Phook = 420, A.Pi = 928, A.Piwrarmenian = 1363, A.Pmonospace = 65328, A.Psi = 936, A.Psicyrillic = 1136, A.Psmall = 63344, A.Q = 81, A.Qcircle = 9414, A.Qmonospace = 65329, A.Qsmall = 63345, A.R = 82, A.Raarmenian = 1356, A.Racute = 340, A.Rcaron = 344, A.Rcedilla = 342, A.Rcircle = 9415, A.Rcommaaccent = 342, A.Rdblgrave = 528, A.Rdotaccent = 7768, A.Rdotbelow = 7770, A.Rdotbelowmacron = 7772, A.Reharmenian = 1360, A.Rfraktur = 8476, A.Rho = 929, A.Ringsmall = 63228, A.Rinvertedbreve = 530, A.Rlinebelow = 7774, A.Rmonospace = 65330, A.Rsmall = 63346, A.Rsmallinverted = 641, A.Rsmallinvertedsuperior = 694, A.S = 83, A.SF010000 = 9484, A.SF020000 = 9492, A.SF030000 = 9488, A.SF040000 = 9496, A.SF050000 = 9532, A.SF060000 = 9516, A.SF070000 = 9524, A.SF080000 = 9500, A.SF090000 = 9508, A.SF100000 = 9472, A.SF110000 = 9474, A.SF190000 = 9569, A.SF200000 = 9570, A.SF210000 = 9558, A.SF220000 = 9557, A.SF230000 = 9571, A.SF240000 = 9553, A.SF250000 = 9559, A.SF260000 = 9565, A.SF270000 = 9564, A.SF280000 = 9563, A.SF360000 = 9566, A.SF370000 = 9567, A.SF380000 = 9562, A.SF390000 = 9556, A.SF400000 = 9577, A.SF410000 = 9574, A.SF420000 = 9568, A.SF430000 = 9552, A.SF440000 = 9580, A.SF450000 = 9575, A.SF460000 = 9576, A.SF470000 = 9572, A.SF480000 = 9573, A.SF490000 = 9561, A.SF500000 = 9560, A.SF510000 = 9554, A.SF520000 = 9555, A.SF530000 = 9579, A.SF540000 = 9578, A.Sacute = 346, A.Sacutedotaccent = 7780, A.Sampigreek = 992, A.Scaron = 352, A.Scarondotaccent = 7782, A.Scaronsmall = 63229, A.Scedilla = 350, A.Schwa = 399, A.Schwacyrillic = 1240, A.Schwadieresiscyrillic = 1242, A.Scircle = 9416, A.Scircumflex = 348, A.Scommaaccent = 536, A.Sdotaccent = 7776, A.Sdotbelow = 7778, A.Sdotbelowdotaccent = 7784, A.Seharmenian = 1357, A.Sevenroman = 8550, A.Shaarmenian = 1351, A.Shacyrillic = 1064, A.Shchacyrillic = 1065, A.Sheicoptic = 994, A.Shhacyrillic = 1210, A.Shimacoptic = 1004, A.Sigma = 931, A.Sixroman = 8549, A.Smonospace = 65331, A.Softsigncyrillic = 1068, A.Ssmall = 63347, A.Stigmagreek = 986, A.T = 84, A.Tau = 932, A.Tbar = 358, A.Tcaron = 356, A.Tcedilla = 354, A.Tcircle = 9417, A.Tcircumflexbelow = 7792, A.Tcommaaccent = 354, A.Tdotaccent = 7786, A.Tdotbelow = 7788, A.Tecyrillic = 1058, A.Tedescendercyrillic = 1196, A.Tenroman = 8553, A.Tetsecyrillic = 1204, A.Theta = 920, A.Thook = 428, A.Thorn = 222, A.Thornsmall = 63486, A.Threeroman = 8546, A.Tildesmall = 63230, A.Tiwnarmenian = 1359, A.Tlinebelow = 7790, A.Tmonospace = 65332, A.Toarmenian = 1337, A.Tonefive = 444, A.Tonesix = 388, A.Tonetwo = 423, A.Tretroflexhook = 430, A.Tsecyrillic = 1062, A.Tshecyrillic = 1035, A.Tsmall = 63348, A.Twelveroman = 8555, A.Tworoman = 8545, A.U = 85, A.Uacute = 218, A.Uacutesmall = 63482, A.Ubreve = 364, A.Ucaron = 467, A.Ucircle = 9418, A.Ucircumflex = 219, A.Ucircumflexbelow = 7798, A.Ucircumflexsmall = 63483, A.Ucyrillic = 1059, A.Udblacute = 368, A.Udblgrave = 532, A.Udieresis = 220, A.Udieresisacute = 471, A.Udieresisbelow = 7794, A.Udieresiscaron = 473, A.Udieresiscyrillic = 1264, A.Udieresisgrave = 475, A.Udieresismacron = 469, A.Udieresissmall = 63484, A.Udotbelow = 7908, A.Ugrave = 217, A.Ugravesmall = 63481, A.Uhookabove = 7910, A.Uhorn = 431, A.Uhornacute = 7912, A.Uhorndotbelow = 7920, A.Uhorngrave = 7914, A.Uhornhookabove = 7916, A.Uhorntilde = 7918, A.Uhungarumlaut = 368, A.Uhungarumlautcyrillic = 1266, A.Uinvertedbreve = 534, A.Ukcyrillic = 1144, A.Umacron = 362, A.Umacroncyrillic = 1262, A.Umacrondieresis = 7802, A.Umonospace = 65333, A.Uogonek = 370, A.Upsilon = 933, A.Upsilon1 = 978, A.Upsilonacutehooksymbolgreek = 979, A.Upsilonafrican = 433, A.Upsilondieresis = 939, A.Upsilondieresishooksymbolgreek = 980, A.Upsilonhooksymbol = 978, A.Upsilontonos = 910, A.Uring = 366, A.Ushortcyrillic = 1038, A.Usmall = 63349, A.Ustraightcyrillic = 1198, A.Ustraightstrokecyrillic = 1200, A.Utilde = 360, A.Utildeacute = 7800, A.Utildebelow = 7796, A.V = 86, A.Vcircle = 9419, A.Vdotbelow = 7806, A.Vecyrillic = 1042, A.Vewarmenian = 1358, A.Vhook = 434, A.Vmonospace = 65334, A.Voarmenian = 1352, A.Vsmall = 63350, A.Vtilde = 7804, A.W = 87, A.Wacute = 7810, A.Wcircle = 9420, A.Wcircumflex = 372, A.Wdieresis = 7812, A.Wdotaccent = 7814, A.Wdotbelow = 7816, A.Wgrave = 7808, A.Wmonospace = 65335, A.Wsmall = 63351, A.X = 88, A.Xcircle = 9421, A.Xdieresis = 7820, A.Xdotaccent = 7818, A.Xeharmenian = 1341, A.Xi = 926, A.Xmonospace = 65336, A.Xsmall = 63352, A.Y = 89, A.Yacute = 221, A.Yacutesmall = 63485, A.Yatcyrillic = 1122, A.Ycircle = 9422, A.Ycircumflex = 374, A.Ydieresis = 376, A.Ydieresissmall = 63487, A.Ydotaccent = 7822, A.Ydotbelow = 7924, A.Yericyrillic = 1067, A.Yerudieresiscyrillic = 1272, A.Ygrave = 7922, A.Yhook = 435, A.Yhookabove = 7926, A.Yiarmenian = 1349, A.Yicyrillic = 1031, A.Yiwnarmenian = 1362, A.Ymonospace = 65337, A.Ysmall = 63353, A.Ytilde = 7928, A.Yusbigcyrillic = 1130, A.Yusbigiotifiedcyrillic = 1132, A.Yuslittlecyrillic = 1126, A.Yuslittleiotifiedcyrillic = 1128, A.Z = 90, A.Zaarmenian = 1334, A.Zacute = 377, A.Zcaron = 381, A.Zcaronsmall = 63231, A.Zcircle = 9423, A.Zcircumflex = 7824, A.Zdot = 379, A.Zdotaccent = 379, A.Zdotbelow = 7826, A.Zecyrillic = 1047, A.Zedescendercyrillic = 1176, A.Zedieresiscyrillic = 1246, A.Zeta = 918, A.Zhearmenian = 1338, A.Zhebrevecyrillic = 1217, A.Zhecyrillic = 1046, A.Zhedescendercyrillic = 1174, A.Zhedieresiscyrillic = 1244, A.Zlinebelow = 7828, A.Zmonospace = 65338, A.Zsmall = 63354, A.Zstroke = 437, A.a = 97, A.aabengali = 2438, A.aacute = 225, A.aadeva = 2310, A.aagujarati = 2694, A.aagurmukhi = 2566, A.aamatragurmukhi = 2622, A.aarusquare = 13059, A.aavowelsignbengali = 2494, A.aavowelsigndeva = 2366, A.aavowelsigngujarati = 2750, A.abbreviationmarkarmenian = 1375, A.abbreviationsigndeva = 2416, A.abengali = 2437, A.abopomofo = 12570, A.abreve = 259, A.abreveacute = 7855, A.abrevecyrillic = 1233, A.abrevedotbelow = 7863, A.abrevegrave = 7857, A.abrevehookabove = 7859, A.abrevetilde = 7861, A.acaron = 462, A.acircle = 9424, A.acircumflex = 226, A.acircumflexacute = 7845, A.acircumflexdotbelow = 7853, A.acircumflexgrave = 7847, A.acircumflexhookabove = 7849, A.acircumflextilde = 7851, A.acute = 180, A.acutebelowcmb = 791, A.acutecmb = 769, A.acutecomb = 769, A.acutedeva = 2388, A.acutelowmod = 719, A.acutetonecmb = 833, A.acyrillic = 1072, A.adblgrave = 513, A.addakgurmukhi = 2673, A.adeva = 2309, A.adieresis = 228, A.adieresiscyrillic = 1235, A.adieresismacron = 479, A.adotbelow = 7841, A.adotmacron = 481, A.ae = 230, A.aeacute = 509, A.aekorean = 12624, A.aemacron = 483, A.afii00208 = 8213, A.afii08941 = 8356, A.afii10017 = 1040, A.afii10018 = 1041, A.afii10019 = 1042, A.afii10020 = 1043, A.afii10021 = 1044, A.afii10022 = 1045, A.afii10023 = 1025, A.afii10024 = 1046, A.afii10025 = 1047, A.afii10026 = 1048, A.afii10027 = 1049, A.afii10028 = 1050, A.afii10029 = 1051, A.afii10030 = 1052, A.afii10031 = 1053, A.afii10032 = 1054, A.afii10033 = 1055, A.afii10034 = 1056, A.afii10035 = 1057, A.afii10036 = 1058, A.afii10037 = 1059, A.afii10038 = 1060, A.afii10039 = 1061, A.afii10040 = 1062, A.afii10041 = 1063, A.afii10042 = 1064, A.afii10043 = 1065, A.afii10044 = 1066, A.afii10045 = 1067, A.afii10046 = 1068, A.afii10047 = 1069, A.afii10048 = 1070, A.afii10049 = 1071, A.afii10050 = 1168, A.afii10051 = 1026, A.afii10052 = 1027, A.afii10053 = 1028, A.afii10054 = 1029, A.afii10055 = 1030, A.afii10056 = 1031, A.afii10057 = 1032, A.afii10058 = 1033, A.afii10059 = 1034, A.afii10060 = 1035, A.afii10061 = 1036, A.afii10062 = 1038, A.afii10063 = 63172, A.afii10064 = 63173, A.afii10065 = 1072, A.afii10066 = 1073, A.afii10067 = 1074, A.afii10068 = 1075, A.afii10069 = 1076, A.afii10070 = 1077, A.afii10071 = 1105, A.afii10072 = 1078, A.afii10073 = 1079, A.afii10074 = 1080, A.afii10075 = 1081, A.afii10076 = 1082, A.afii10077 = 1083, A.afii10078 = 1084, A.afii10079 = 1085, A.afii10080 = 1086, A.afii10081 = 1087, A.afii10082 = 1088, A.afii10083 = 1089, A.afii10084 = 1090, A.afii10085 = 1091, A.afii10086 = 1092, A.afii10087 = 1093, A.afii10088 = 1094, A.afii10089 = 1095, A.afii10090 = 1096, A.afii10091 = 1097, A.afii10092 = 1098, A.afii10093 = 1099, A.afii10094 = 1100, A.afii10095 = 1101, A.afii10096 = 1102, A.afii10097 = 1103, A.afii10098 = 1169, A.afii10099 = 1106, A.afii10100 = 1107, A.afii10101 = 1108, A.afii10102 = 1109, A.afii10103 = 1110, A.afii10104 = 1111, A.afii10105 = 1112, A.afii10106 = 1113, A.afii10107 = 1114, A.afii10108 = 1115, A.afii10109 = 1116, A.afii10110 = 1118, A.afii10145 = 1039, A.afii10146 = 1122, A.afii10147 = 1138, A.afii10148 = 1140, A.afii10192 = 63174, A.afii10193 = 1119, A.afii10194 = 1123, A.afii10195 = 1139, A.afii10196 = 1141, A.afii10831 = 63175, A.afii10832 = 63176, A.afii10846 = 1241, A.afii299 = 8206, A.afii300 = 8207, A.afii301 = 8205, A.afii57381 = 1642, A.afii57388 = 1548, A.afii57392 = 1632, A.afii57393 = 1633, A.afii57394 = 1634, A.afii57395 = 1635, A.afii57396 = 1636, A.afii57397 = 1637, A.afii57398 = 1638, A.afii57399 = 1639, A.afii57400 = 1640, A.afii57401 = 1641, A.afii57403 = 1563, A.afii57407 = 1567, A.afii57409 = 1569, A.afii57410 = 1570, A.afii57411 = 1571, A.afii57412 = 1572, A.afii57413 = 1573, A.afii57414 = 1574, A.afii57415 = 1575, A.afii57416 = 1576, A.afii57417 = 1577, A.afii57418 = 1578, A.afii57419 = 1579, A.afii57420 = 1580, A.afii57421 = 1581, A.afii57422 = 1582, A.afii57423 = 1583, A.afii57424 = 1584, A.afii57425 = 1585, A.afii57426 = 1586, A.afii57427 = 1587, A.afii57428 = 1588, A.afii57429 = 1589, A.afii57430 = 1590, A.afii57431 = 1591, A.afii57432 = 1592, A.afii57433 = 1593, A.afii57434 = 1594, A.afii57440 = 1600, A.afii57441 = 1601, A.afii57442 = 1602, A.afii57443 = 1603, A.afii57444 = 1604, A.afii57445 = 1605, A.afii57446 = 1606, A.afii57448 = 1608, A.afii57449 = 1609, A.afii57450 = 1610, A.afii57451 = 1611, A.afii57452 = 1612, A.afii57453 = 1613, A.afii57454 = 1614, A.afii57455 = 1615, A.afii57456 = 1616, A.afii57457 = 1617, A.afii57458 = 1618, A.afii57470 = 1607, A.afii57505 = 1700, A.afii57506 = 1662, A.afii57507 = 1670, A.afii57508 = 1688, A.afii57509 = 1711, A.afii57511 = 1657, A.afii57512 = 1672, A.afii57513 = 1681, A.afii57514 = 1722, A.afii57519 = 1746, A.afii57534 = 1749, A.afii57636 = 8362, A.afii57645 = 1470, A.afii57658 = 1475, A.afii57664 = 1488, A.afii57665 = 1489, A.afii57666 = 1490, A.afii57667 = 1491, A.afii57668 = 1492, A.afii57669 = 1493, A.afii57670 = 1494, A.afii57671 = 1495, A.afii57672 = 1496, A.afii57673 = 1497, A.afii57674 = 1498, A.afii57675 = 1499, A.afii57676 = 1500, A.afii57677 = 1501, A.afii57678 = 1502, A.afii57679 = 1503, A.afii57680 = 1504, A.afii57681 = 1505, A.afii57682 = 1506, A.afii57683 = 1507, A.afii57684 = 1508, A.afii57685 = 1509, A.afii57686 = 1510, A.afii57687 = 1511, A.afii57688 = 1512, A.afii57689 = 1513, A.afii57690 = 1514, A.afii57694 = 64298, A.afii57695 = 64299, A.afii57700 = 64331, A.afii57705 = 64287, A.afii57716 = 1520, A.afii57717 = 1521, A.afii57718 = 1522, A.afii57723 = 64309, A.afii57793 = 1460, A.afii57794 = 1461, A.afii57795 = 1462, A.afii57796 = 1467, A.afii57797 = 1464, A.afii57798 = 1463, A.afii57799 = 1456, A.afii57800 = 1458, A.afii57801 = 1457, A.afii57802 = 1459, A.afii57803 = 1474, A.afii57804 = 1473, A.afii57806 = 1465, A.afii57807 = 1468, A.afii57839 = 1469, A.afii57841 = 1471, A.afii57842 = 1472, A.afii57929 = 700, A.afii61248 = 8453, A.afii61289 = 8467, A.afii61352 = 8470, A.afii61573 = 8236, A.afii61574 = 8237, A.afii61575 = 8238, A.afii61664 = 8204, A.afii63167 = 1645, A.afii64937 = 701, A.agrave = 224, A.agujarati = 2693, A.agurmukhi = 2565, A.ahiragana = 12354, A.ahookabove = 7843, A.aibengali = 2448, A.aibopomofo = 12574, A.aideva = 2320, A.aiecyrillic = 1237, A.aigujarati = 2704, A.aigurmukhi = 2576, A.aimatragurmukhi = 2632, A.ainarabic = 1593, A.ainfinalarabic = 65226, A.aininitialarabic = 65227, A.ainmedialarabic = 65228, A.ainvertedbreve = 515, A.aivowelsignbengali = 2504, A.aivowelsigndeva = 2376, A.aivowelsigngujarati = 2760, A.akatakana = 12450, A.akatakanahalfwidth = 65393, A.akorean = 12623, A.alef = 1488, A.alefarabic = 1575, A.alefdageshhebrew = 64304, A.aleffinalarabic = 65166, A.alefhamzaabovearabic = 1571, A.alefhamzaabovefinalarabic = 65156, A.alefhamzabelowarabic = 1573, A.alefhamzabelowfinalarabic = 65160, A.alefhebrew = 1488, A.aleflamedhebrew = 64335, A.alefmaddaabovearabic = 1570, A.alefmaddaabovefinalarabic = 65154, A.alefmaksuraarabic = 1609, A.alefmaksurafinalarabic = 65264, A.alefmaksurainitialarabic = 65267, A.alefmaksuramedialarabic = 65268, A.alefpatahhebrew = 64302, A.alefqamatshebrew = 64303, A.aleph = 8501, A.allequal = 8780, A.alpha = 945, A.alphatonos = 940, A.amacron = 257, A.amonospace = 65345, A.ampersand = 38, A.ampersandmonospace = 65286, A.ampersandsmall = 63270, A.amsquare = 13250, A.anbopomofo = 12578, A.angbopomofo = 12580, A.angbracketleft = 12296, A.angbracketright = 12297, A.angkhankhuthai = 3674, A.angle = 8736, A.anglebracketleft = 12296, A.anglebracketleftvertical = 65087, A.anglebracketright = 12297, A.anglebracketrightvertical = 65088, A.angleleft = 9001, A.angleright = 9002, A.angstrom = 8491, A.anoteleia = 903, A.anudattadeva = 2386, A.anusvarabengali = 2434, A.anusvaradeva = 2306, A.anusvaragujarati = 2690, A.aogonek = 261, A.apaatosquare = 13056, A.aparen = 9372, A.apostrophearmenian = 1370, A.apostrophemod = 700, A.apple = 63743, A.approaches = 8784, A.approxequal = 8776, A.approxequalorimage = 8786, A.approximatelyequal = 8773, A.araeaekorean = 12686, A.araeakorean = 12685, A.arc = 8978, A.arighthalfring = 7834, A.aring = 229, A.aringacute = 507, A.aringbelow = 7681, A.arrowboth = 8596, A.arrowdashdown = 8675, A.arrowdashleft = 8672, A.arrowdashright = 8674, A.arrowdashup = 8673, A.arrowdblboth = 8660, A.arrowdbldown = 8659, A.arrowdblleft = 8656, A.arrowdblright = 8658, A.arrowdblup = 8657, A.arrowdown = 8595, A.arrowdownleft = 8601, A.arrowdownright = 8600, A.arrowdownwhite = 8681, A.arrowheaddownmod = 709, A.arrowheadleftmod = 706, A.arrowheadrightmod = 707, A.arrowheadupmod = 708, A.arrowhorizex = 63719, A.arrowleft = 8592, A.arrowleftdbl = 8656, A.arrowleftdblstroke = 8653, A.arrowleftoverright = 8646, A.arrowleftwhite = 8678, A.arrowright = 8594, A.arrowrightdblstroke = 8655, A.arrowrightheavy = 10142, A.arrowrightoverleft = 8644, A.arrowrightwhite = 8680, A.arrowtableft = 8676, A.arrowtabright = 8677, A.arrowup = 8593, A.arrowupdn = 8597, A.arrowupdnbse = 8616, A.arrowupdownbase = 8616, A.arrowupleft = 8598, A.arrowupleftofdown = 8645, A.arrowupright = 8599, A.arrowupwhite = 8679, A.arrowvertex = 63718, A.asciicircum = 94, A.asciicircummonospace = 65342, A.asciitilde = 126, A.asciitildemonospace = 65374, A.ascript = 593, A.ascriptturned = 594, A.asmallhiragana = 12353, A.asmallkatakana = 12449, A.asmallkatakanahalfwidth = 65383, A.asterisk = 42, A.asteriskaltonearabic = 1645, A.asteriskarabic = 1645, A.asteriskmath = 8727, A.asteriskmonospace = 65290, A.asterisksmall = 65121, A.asterism = 8258, A.asuperior = 63209, A.asymptoticallyequal = 8771, A.at = 64, A.atilde = 227, A.atmonospace = 65312, A.atsmall = 65131, A.aturned = 592, A.aubengali = 2452, A.aubopomofo = 12576, A.audeva = 2324, A.augujarati = 2708, A.augurmukhi = 2580, A.aulengthmarkbengali = 2519, A.aumatragurmukhi = 2636, A.auvowelsignbengali = 2508, A.auvowelsigndeva = 2380, A.auvowelsigngujarati = 2764, A.avagrahadeva = 2365, A.aybarmenian = 1377, A.ayin = 1506, A.ayinaltonehebrew = 64288, A.ayinhebrew = 1506, A.b = 98, A.babengali = 2476, A.backslash = 92, A.backslashmonospace = 65340, A.badeva = 2348, A.bagujarati = 2732, A.bagurmukhi = 2604, A.bahiragana = 12400, A.bahtthai = 3647, A.bakatakana = 12496, A.bar = 124, A.barmonospace = 65372, A.bbopomofo = 12549, A.bcircle = 9425, A.bdotaccent = 7683, A.bdotbelow = 7685, A.beamedsixteenthnotes = 9836, A.because = 8757, A.becyrillic = 1073, A.beharabic = 1576, A.behfinalarabic = 65168, A.behinitialarabic = 65169, A.behiragana = 12409, A.behmedialarabic = 65170, A.behmeeminitialarabic = 64671, A.behmeemisolatedarabic = 64520, A.behnoonfinalarabic = 64621, A.bekatakana = 12505, A.benarmenian = 1378, A.bet = 1489, A.beta = 946, A.betasymbolgreek = 976, A.betdagesh = 64305, A.betdageshhebrew = 64305, A.bethebrew = 1489, A.betrafehebrew = 64332, A.bhabengali = 2477, A.bhadeva = 2349, A.bhagujarati = 2733, A.bhagurmukhi = 2605, A.bhook = 595, A.bihiragana = 12403, A.bikatakana = 12499, A.bilabialclick = 664, A.bindigurmukhi = 2562, A.birusquare = 13105, A.blackcircle = 9679, A.blackdiamond = 9670, A.blackdownpointingtriangle = 9660, A.blackleftpointingpointer = 9668, A.blackleftpointingtriangle = 9664, A.blacklenticularbracketleft = 12304, A.blacklenticularbracketleftvertical = 65083, A.blacklenticularbracketright = 12305, A.blacklenticularbracketrightvertical = 65084, A.blacklowerlefttriangle = 9699, A.blacklowerrighttriangle = 9698, A.blackrectangle = 9644, A.blackrightpointingpointer = 9658, A.blackrightpointingtriangle = 9654, A.blacksmallsquare = 9642, A.blacksmilingface = 9787, A.blacksquare = 9632, A.blackstar = 9733, A.blackupperlefttriangle = 9700, A.blackupperrighttriangle = 9701, A.blackuppointingsmalltriangle = 9652, A.blackuppointingtriangle = 9650, A.blank = 9251, A.blinebelow = 7687, A.block = 9608, A.bmonospace = 65346, A.bobaimaithai = 3610, A.bohiragana = 12412, A.bokatakana = 12508, A.bparen = 9373, A.bqsquare = 13251, A.braceex = 63732, A.braceleft = 123, A.braceleftbt = 63731, A.braceleftmid = 63730, A.braceleftmonospace = 65371, A.braceleftsmall = 65115, A.bracelefttp = 63729, A.braceleftvertical = 65079, A.braceright = 125, A.bracerightbt = 63742, A.bracerightmid = 63741, A.bracerightmonospace = 65373, A.bracerightsmall = 65116, A.bracerighttp = 63740, A.bracerightvertical = 65080, A.bracketleft = 91, A.bracketleftbt = 63728, A.bracketleftex = 63727, A.bracketleftmonospace = 65339, A.bracketlefttp = 63726, A.bracketright = 93, A.bracketrightbt = 63739, A.bracketrightex = 63738, A.bracketrightmonospace = 65341, A.bracketrighttp = 63737, A.breve = 728, A.brevebelowcmb = 814, A.brevecmb = 774, A.breveinvertedbelowcmb = 815, A.breveinvertedcmb = 785, A.breveinverteddoublecmb = 865, A.bridgebelowcmb = 810, A.bridgeinvertedbelowcmb = 826, A.brokenbar = 166, A.bstroke = 384, A.bsuperior = 63210, A.btopbar = 387, A.buhiragana = 12406, A.bukatakana = 12502, A.bullet = 8226, A.bulletinverse = 9688, A.bulletoperator = 8729, A.bullseye = 9678, A.c = 99, A.caarmenian = 1390, A.cabengali = 2458, A.cacute = 263, A.cadeva = 2330, A.cagujarati = 2714, A.cagurmukhi = 2586, A.calsquare = 13192, A.candrabindubengali = 2433, A.candrabinducmb = 784, A.candrabindudeva = 2305, A.candrabindugujarati = 2689, A.capslock = 8682, A.careof = 8453, A.caron = 711, A.caronbelowcmb = 812, A.caroncmb = 780, A.carriagereturn = 8629, A.cbopomofo = 12568, A.ccaron = 269, A.ccedilla = 231, A.ccedillaacute = 7689, A.ccircle = 9426, A.ccircumflex = 265, A.ccurl = 597, A.cdot = 267, A.cdotaccent = 267, A.cdsquare = 13253, A.cedilla = 184, A.cedillacmb = 807, A.cent = 162, A.centigrade = 8451, A.centinferior = 63199, A.centmonospace = 65504, A.centoldstyle = 63394, A.centsuperior = 63200, A.chaarmenian = 1401, A.chabengali = 2459, A.chadeva = 2331, A.chagujarati = 2715, A.chagurmukhi = 2587, A.chbopomofo = 12564, A.cheabkhasiancyrillic = 1213, A.checkmark = 10003, A.checyrillic = 1095, A.chedescenderabkhasiancyrillic = 1215, A.chedescendercyrillic = 1207, A.chedieresiscyrillic = 1269, A.cheharmenian = 1395, A.chekhakassiancyrillic = 1228, A.cheverticalstrokecyrillic = 1209, A.chi = 967, A.chieuchacirclekorean = 12919, A.chieuchaparenkorean = 12823, A.chieuchcirclekorean = 12905, A.chieuchkorean = 12618, A.chieuchparenkorean = 12809, A.chochangthai = 3594, A.chochanthai = 3592, A.chochingthai = 3593, A.chochoethai = 3596, A.chook = 392, A.cieucacirclekorean = 12918, A.cieucaparenkorean = 12822, A.cieuccirclekorean = 12904, A.cieuckorean = 12616, A.cieucparenkorean = 12808, A.cieucuparenkorean = 12828, A.circle = 9675, A.circlecopyrt = 169, A.circlemultiply = 8855, A.circleot = 8857, A.circleplus = 8853, A.circlepostalmark = 12342, A.circlewithlefthalfblack = 9680, A.circlewithrighthalfblack = 9681, A.circumflex = 710, A.circumflexbelowcmb = 813, A.circumflexcmb = 770, A.clear = 8999, A.clickalveolar = 450, A.clickdental = 448, A.clicklateral = 449, A.clickretroflex = 451, A.club = 9827, A.clubsuitblack = 9827, A.clubsuitwhite = 9831, A.cmcubedsquare = 13220, A.cmonospace = 65347, A.cmsquaredsquare = 13216, A.coarmenian = 1409, A.colon = 58, A.colonmonetary = 8353, A.colonmonospace = 65306, A.colonsign = 8353, A.colonsmall = 65109, A.colontriangularhalfmod = 721, A.colontriangularmod = 720, A.comma = 44, A.commaabovecmb = 787, A.commaaboverightcmb = 789, A.commaaccent = 63171, A.commaarabic = 1548, A.commaarmenian = 1373, A.commainferior = 63201, A.commamonospace = 65292, A.commareversedabovecmb = 788, A.commareversedmod = 701, A.commasmall = 65104, A.commasuperior = 63202, A.commaturnedabovecmb = 786, A.commaturnedmod = 699, A.compass = 9788, A.congruent = 8773, A.contourintegral = 8750, A.control = 8963, A.controlACK = 6, A.controlBEL = 7, A.controlBS = 8, A.controlCAN = 24, A.controlCR = 13, A.controlDC1 = 17, A.controlDC2 = 18, A.controlDC3 = 19, A.controlDC4 = 20, A.controlDEL = 127, A.controlDLE = 16, A.controlEM = 25, A.controlENQ = 5, A.controlEOT = 4, A.controlESC = 27, A.controlETB = 23, A.controlETX = 3, A.controlFF = 12, A.controlFS = 28, A.controlGS = 29, A.controlHT = 9, A.controlLF = 10, A.controlNAK = 21, A.controlNULL = 0, A.controlRS = 30, A.controlSI = 15, A.controlSO = 14, A.controlSOT = 2, A.controlSTX = 1, A.controlSUB = 26, A.controlSYN = 22, A.controlUS = 31, A.controlVT = 11, A.copyright = 169, A.copyrightsans = 63721, A.copyrightserif = 63193, A.cornerbracketleft = 12300, A.cornerbracketlefthalfwidth = 65378, A.cornerbracketleftvertical = 65089, A.cornerbracketright = 12301, A.cornerbracketrighthalfwidth = 65379, A.cornerbracketrightvertical = 65090, A.corporationsquare = 13183, A.cosquare = 13255, A.coverkgsquare = 13254, A.cparen = 9374, A.cruzeiro = 8354, A.cstretched = 663, A.curlyand = 8911, A.curlyor = 8910, A.currency = 164, A.cyrBreve = 63185, A.cyrFlex = 63186, A.cyrbreve = 63188, A.cyrflex = 63189, A.d = 100, A.daarmenian = 1380, A.dabengali = 2470, A.dadarabic = 1590, A.dadeva = 2342, A.dadfinalarabic = 65214, A.dadinitialarabic = 65215, A.dadmedialarabic = 65216, A.dagesh = 1468, A.dageshhebrew = 1468, A.dagger = 8224, A.daggerdbl = 8225, A.dagujarati = 2726, A.dagurmukhi = 2598, A.dahiragana = 12384, A.dakatakana = 12480, A.dalarabic = 1583, A.dalet = 1491, A.daletdagesh = 64307, A.daletdageshhebrew = 64307, A.dalethebrew = 1491, A.dalfinalarabic = 65194, A.dammaarabic = 1615, A.dammalowarabic = 1615, A.dammatanaltonearabic = 1612, A.dammatanarabic = 1612, A.danda = 2404, A.dargahebrew = 1447, A.dargalefthebrew = 1447, A.dasiapneumatacyrilliccmb = 1157, A.dblGrave = 63187, A.dblanglebracketleft = 12298, A.dblanglebracketleftvertical = 65085, A.dblanglebracketright = 12299, A.dblanglebracketrightvertical = 65086, A.dblarchinvertedbelowcmb = 811, A.dblarrowleft = 8660, A.dblarrowright = 8658, A.dbldanda = 2405, A.dblgrave = 63190, A.dblgravecmb = 783, A.dblintegral = 8748, A.dbllowline = 8215, A.dbllowlinecmb = 819, A.dbloverlinecmb = 831, A.dblprimemod = 698, A.dblverticalbar = 8214, A.dblverticallineabovecmb = 782, A.dbopomofo = 12553, A.dbsquare = 13256, A.dcaron = 271, A.dcedilla = 7697, A.dcircle = 9427, A.dcircumflexbelow = 7699, A.dcroat = 273, A.ddabengali = 2465, A.ddadeva = 2337, A.ddagujarati = 2721, A.ddagurmukhi = 2593, A.ddalarabic = 1672, A.ddalfinalarabic = 64393, A.dddhadeva = 2396, A.ddhabengali = 2466, A.ddhadeva = 2338, A.ddhagujarati = 2722, A.ddhagurmukhi = 2594, A.ddotaccent = 7691, A.ddotbelow = 7693, A.decimalseparatorarabic = 1643, A.decimalseparatorpersian = 1643, A.decyrillic = 1076, A.degree = 176, A.dehihebrew = 1453, A.dehiragana = 12391, A.deicoptic = 1007, A.dekatakana = 12487, A.deleteleft = 9003, A.deleteright = 8998, A.delta = 948, A.deltaturned = 397, A.denominatorminusonenumeratorbengali = 2552, A.dezh = 676, A.dhabengali = 2471, A.dhadeva = 2343, A.dhagujarati = 2727, A.dhagurmukhi = 2599, A.dhook = 599, A.dialytikatonos = 901, A.dialytikatonoscmb = 836, A.diamond = 9830, A.diamondsuitwhite = 9826, A.dieresis = 168, A.dieresisacute = 63191, A.dieresisbelowcmb = 804, A.dieresiscmb = 776, A.dieresisgrave = 63192, A.dieresistonos = 901, A.dihiragana = 12386, A.dikatakana = 12482, A.dittomark = 12291, A.divide = 247, A.divides = 8739, A.divisionslash = 8725, A.djecyrillic = 1106, A.dkshade = 9619, A.dlinebelow = 7695, A.dlsquare = 13207, A.dmacron = 273, A.dmonospace = 65348, A.dnblock = 9604, A.dochadathai = 3598, A.dodekthai = 3604, A.dohiragana = 12393, A.dokatakana = 12489, A.dollar = 36, A.dollarinferior = 63203, A.dollarmonospace = 65284, A.dollaroldstyle = 63268, A.dollarsmall = 65129, A.dollarsuperior = 63204, A.dong = 8363, A.dorusquare = 13094, A.dotaccent = 729, A.dotaccentcmb = 775, A.dotbelowcmb = 803, A.dotbelowcomb = 803, A.dotkatakana = 12539, A.dotlessi = 305, A.dotlessj = 63166, A.dotlessjstrokehook = 644, A.dotmath = 8901, A.dottedcircle = 9676, A.doubleyodpatah = 64287, A.doubleyodpatahhebrew = 64287, A.downtackbelowcmb = 798, A.downtackmod = 725, A.dparen = 9375, A.dsuperior = 63211, A.dtail = 598, A.dtopbar = 396, A.duhiragana = 12389, A.dukatakana = 12485, A.dz = 499, A.dzaltone = 675, A.dzcaron = 454, A.dzcurl = 677, A.dzeabkhasiancyrillic = 1249, A.dzecyrillic = 1109, A.dzhecyrillic = 1119, A.e = 101, A.eacute = 233, A.earth = 9793, A.ebengali = 2447, A.ebopomofo = 12572, A.ebreve = 277, A.ecandradeva = 2317, A.ecandragujarati = 2701, A.ecandravowelsigndeva = 2373, A.ecandravowelsigngujarati = 2757, A.ecaron = 283, A.ecedillabreve = 7709, A.echarmenian = 1381, A.echyiwnarmenian = 1415, A.ecircle = 9428, A.ecircumflex = 234, A.ecircumflexacute = 7871, A.ecircumflexbelow = 7705, A.ecircumflexdotbelow = 7879, A.ecircumflexgrave = 7873, A.ecircumflexhookabove = 7875, A.ecircumflextilde = 7877, A.ecyrillic = 1108, A.edblgrave = 517, A.edeva = 2319, A.edieresis = 235, A.edot = 279, A.edotaccent = 279, A.edotbelow = 7865, A.eegurmukhi = 2575, A.eematragurmukhi = 2631, A.efcyrillic = 1092, A.egrave = 232, A.egujarati = 2703, A.eharmenian = 1383, A.ehbopomofo = 12573, A.ehiragana = 12360, A.ehookabove = 7867, A.eibopomofo = 12575, A.eight = 56, A.eightarabic = 1640, A.eightbengali = 2542, A.eightcircle = 9319, A.eightcircleinversesansserif = 10129, A.eightdeva = 2414, A.eighteencircle = 9329, A.eighteenparen = 9349, A.eighteenperiod = 9369, A.eightgujarati = 2798, A.eightgurmukhi = 2670, A.eighthackarabic = 1640, A.eighthangzhou = 12328, A.eighthnotebeamed = 9835, A.eightideographicparen = 12839, A.eightinferior = 8328, A.eightmonospace = 65304, A.eightoldstyle = 63288, A.eightparen = 9339, A.eightperiod = 9359, A.eightpersian = 1784, A.eightroman = 8567, A.eightsuperior = 8312, A.eightthai = 3672, A.einvertedbreve = 519, A.eiotifiedcyrillic = 1125, A.ekatakana = 12456, A.ekatakanahalfwidth = 65396, A.ekonkargurmukhi = 2676, A.ekorean = 12628, A.elcyrillic = 1083, A.element = 8712, A.elevencircle = 9322, A.elevenparen = 9342, A.elevenperiod = 9362, A.elevenroman = 8570, A.ellipsis = 8230, A.ellipsisvertical = 8942, A.emacron = 275, A.emacronacute = 7703, A.emacrongrave = 7701, A.emcyrillic = 1084, A.emdash = 8212, A.emdashvertical = 65073, A.emonospace = 65349, A.emphasismarkarmenian = 1371, A.emptyset = 8709, A.enbopomofo = 12579, A.encyrillic = 1085, A.endash = 8211, A.endashvertical = 65074, A.endescendercyrillic = 1187, A.eng = 331, A.engbopomofo = 12581, A.enghecyrillic = 1189, A.enhookcyrillic = 1224, A.enspace = 8194, A.eogonek = 281, A.eokorean = 12627, A.eopen = 603, A.eopenclosed = 666, A.eopenreversed = 604, A.eopenreversedclosed = 606, A.eopenreversedhook = 605, A.eparen = 9376, A.epsilon = 949, A.epsilontonos = 941, A.equal = 61, A.equalmonospace = 65309, A.equalsmall = 65126, A.equalsuperior = 8316, A.equivalence = 8801, A.erbopomofo = 12582, A.ercyrillic = 1088, A.ereversed = 600, A.ereversedcyrillic = 1101, A.escyrillic = 1089, A.esdescendercyrillic = 1195, A.esh = 643, A.eshcurl = 646, A.eshortdeva = 2318, A.eshortvowelsigndeva = 2374, A.eshreversedloop = 426, A.eshsquatreversed = 645, A.esmallhiragana = 12359, A.esmallkatakana = 12455, A.esmallkatakanahalfwidth = 65386, A.estimated = 8494, A.esuperior = 63212, A.eta = 951, A.etarmenian = 1384, A.etatonos = 942, A.eth = 240, A.etilde = 7869, A.etildebelow = 7707, A.etnahtafoukhhebrew = 1425, A.etnahtafoukhlefthebrew = 1425, A.etnahtahebrew = 1425, A.etnahtalefthebrew = 1425, A.eturned = 477, A.eukorean = 12641, A.euro = 8364, A.evowelsignbengali = 2503, A.evowelsigndeva = 2375, A.evowelsigngujarati = 2759, A.exclam = 33, A.exclamarmenian = 1372, A.exclamdbl = 8252, A.exclamdown = 161, A.exclamdownsmall = 63393, A.exclammonospace = 65281, A.exclamsmall = 63265, A.existential = 8707, A.ezh = 658, A.ezhcaron = 495, A.ezhcurl = 659, A.ezhreversed = 441, A.ezhtail = 442, A.f = 102, A.fadeva = 2398, A.fagurmukhi = 2654, A.fahrenheit = 8457, A.fathaarabic = 1614, A.fathalowarabic = 1614, A.fathatanarabic = 1611, A.fbopomofo = 12552, A.fcircle = 9429, A.fdotaccent = 7711, A.feharabic = 1601, A.feharmenian = 1414, A.fehfinalarabic = 65234, A.fehinitialarabic = 65235, A.fehmedialarabic = 65236, A.feicoptic = 997, A.female = 9792, A.ff = 64256, A.f_f = 64256, A.ffi = 64259, A.f_f_i = 64259, A.ffl = 64260, A.f_f_l = 64260, A.fi = 64257, A.f_i = 64257, A.fifteencircle = 9326, A.fifteenparen = 9346, A.fifteenperiod = 9366, A.figuredash = 8210, A.filledbox = 9632, A.filledrect = 9644, A.finalkaf = 1498, A.finalkafdagesh = 64314, A.finalkafdageshhebrew = 64314, A.finalkafhebrew = 1498, A.finalmem = 1501, A.finalmemhebrew = 1501, A.finalnun = 1503, A.finalnunhebrew = 1503, A.finalpe = 1507, A.finalpehebrew = 1507, A.finaltsadi = 1509, A.finaltsadihebrew = 1509, A.firsttonechinese = 713, A.fisheye = 9673, A.fitacyrillic = 1139, A.five = 53, A.fivearabic = 1637, A.fivebengali = 2539, A.fivecircle = 9316, A.fivecircleinversesansserif = 10126, A.fivedeva = 2411, A.fiveeighths = 8541, A.fivegujarati = 2795, A.fivegurmukhi = 2667, A.fivehackarabic = 1637, A.fivehangzhou = 12325, A.fiveideographicparen = 12836, A.fiveinferior = 8325, A.fivemonospace = 65301, A.fiveoldstyle = 63285, A.fiveparen = 9336, A.fiveperiod = 9356, A.fivepersian = 1781, A.fiveroman = 8564, A.fivesuperior = 8309, A.fivethai = 3669, A.fl = 64258, A.f_l = 64258, A.florin = 402, A.fmonospace = 65350, A.fmsquare = 13209, A.fofanthai = 3615, A.fofathai = 3613, A.fongmanthai = 3663, A.forall = 8704, A.four = 52, A.fourarabic = 1636, A.fourbengali = 2538, A.fourcircle = 9315, A.fourcircleinversesansserif = 10125, A.fourdeva = 2410, A.fourgujarati = 2794, A.fourgurmukhi = 2666, A.fourhackarabic = 1636, A.fourhangzhou = 12324, A.fourideographicparen = 12835, A.fourinferior = 8324, A.fourmonospace = 65300, A.fournumeratorbengali = 2551, A.fouroldstyle = 63284, A.fourparen = 9335, A.fourperiod = 9355, A.fourpersian = 1780, A.fourroman = 8563, A.foursuperior = 8308, A.fourteencircle = 9325, A.fourteenparen = 9345, A.fourteenperiod = 9365, A.fourthai = 3668, A.fourthtonechinese = 715, A.fparen = 9377, A.fraction = 8260, A.franc = 8355, A.g = 103, A.gabengali = 2455, A.gacute = 501, A.gadeva = 2327, A.gafarabic = 1711, A.gaffinalarabic = 64403, A.gafinitialarabic = 64404, A.gafmedialarabic = 64405, A.gagujarati = 2711, A.gagurmukhi = 2583, A.gahiragana = 12364, A.gakatakana = 12460, A.gamma = 947, A.gammalatinsmall = 611, A.gammasuperior = 736, A.gangiacoptic = 1003, A.gbopomofo = 12557, A.gbreve = 287, A.gcaron = 487, A.gcedilla = 291, A.gcircle = 9430, A.gcircumflex = 285, A.gcommaaccent = 291, A.gdot = 289, A.gdotaccent = 289, A.gecyrillic = 1075, A.gehiragana = 12370, A.gekatakana = 12466, A.geometricallyequal = 8785, A.gereshaccenthebrew = 1436, A.gereshhebrew = 1523, A.gereshmuqdamhebrew = 1437, A.germandbls = 223, A.gershayimaccenthebrew = 1438, A.gershayimhebrew = 1524, A.getamark = 12307, A.ghabengali = 2456, A.ghadarmenian = 1394, A.ghadeva = 2328, A.ghagujarati = 2712, A.ghagurmukhi = 2584, A.ghainarabic = 1594, A.ghainfinalarabic = 65230, A.ghaininitialarabic = 65231, A.ghainmedialarabic = 65232, A.ghemiddlehookcyrillic = 1173, A.ghestrokecyrillic = 1171, A.gheupturncyrillic = 1169, A.ghhadeva = 2394, A.ghhagurmukhi = 2650, A.ghook = 608, A.ghzsquare = 13203, A.gihiragana = 12366, A.gikatakana = 12462, A.gimarmenian = 1379, A.gimel = 1490, A.gimeldagesh = 64306, A.gimeldageshhebrew = 64306, A.gimelhebrew = 1490, A.gjecyrillic = 1107, A.glottalinvertedstroke = 446, A.glottalstop = 660, A.glottalstopinverted = 662, A.glottalstopmod = 704, A.glottalstopreversed = 661, A.glottalstopreversedmod = 705, A.glottalstopreversedsuperior = 740, A.glottalstopstroke = 673, A.glottalstopstrokereversed = 674, A.gmacron = 7713, A.gmonospace = 65351, A.gohiragana = 12372, A.gokatakana = 12468, A.gparen = 9378, A.gpasquare = 13228, A.gradient = 8711, A.grave = 96, A.gravebelowcmb = 790, A.gravecmb = 768, A.gravecomb = 768, A.gravedeva = 2387, A.gravelowmod = 718, A.gravemonospace = 65344, A.gravetonecmb = 832, A.greater = 62, A.greaterequal = 8805, A.greaterequalorless = 8923, A.greatermonospace = 65310, A.greaterorequivalent = 8819, A.greaterorless = 8823, A.greateroverequal = 8807, A.greatersmall = 65125, A.gscript = 609, A.gstroke = 485, A.guhiragana = 12368, A.guillemotleft = 171, A.guillemotright = 187, A.guilsinglleft = 8249, A.guilsinglright = 8250, A.gukatakana = 12464, A.guramusquare = 13080, A.gysquare = 13257, A.h = 104, A.haabkhasiancyrillic = 1193, A.haaltonearabic = 1729, A.habengali = 2489, A.hadescendercyrillic = 1203, A.hadeva = 2361, A.hagujarati = 2745, A.hagurmukhi = 2617, A.haharabic = 1581, A.hahfinalarabic = 65186, A.hahinitialarabic = 65187, A.hahiragana = 12399, A.hahmedialarabic = 65188, A.haitusquare = 13098, A.hakatakana = 12495, A.hakatakanahalfwidth = 65418, A.halantgurmukhi = 2637, A.hamzaarabic = 1569, A.hamzalowarabic = 1569, A.hangulfiller = 12644, A.hardsigncyrillic = 1098, A.harpoonleftbarbup = 8636, A.harpoonrightbarbup = 8640, A.hasquare = 13258, A.hatafpatah = 1458, A.hatafpatah16 = 1458, A.hatafpatah23 = 1458, A.hatafpatah2f = 1458, A.hatafpatahhebrew = 1458, A.hatafpatahnarrowhebrew = 1458, A.hatafpatahquarterhebrew = 1458, A.hatafpatahwidehebrew = 1458, A.hatafqamats = 1459, A.hatafqamats1b = 1459, A.hatafqamats28 = 1459, A.hatafqamats34 = 1459, A.hatafqamatshebrew = 1459, A.hatafqamatsnarrowhebrew = 1459, A.hatafqamatsquarterhebrew = 1459, A.hatafqamatswidehebrew = 1459, A.hatafsegol = 1457, A.hatafsegol17 = 1457, A.hatafsegol24 = 1457, A.hatafsegol30 = 1457, A.hatafsegolhebrew = 1457, A.hatafsegolnarrowhebrew = 1457, A.hatafsegolquarterhebrew = 1457, A.hatafsegolwidehebrew = 1457, A.hbar = 295, A.hbopomofo = 12559, A.hbrevebelow = 7723, A.hcedilla = 7721, A.hcircle = 9431, A.hcircumflex = 293, A.hdieresis = 7719, A.hdotaccent = 7715, A.hdotbelow = 7717, A.he = 1492, A.heart = 9829, A.heartsuitblack = 9829, A.heartsuitwhite = 9825, A.hedagesh = 64308, A.hedageshhebrew = 64308, A.hehaltonearabic = 1729, A.heharabic = 1607, A.hehebrew = 1492, A.hehfinalaltonearabic = 64423, A.hehfinalalttwoarabic = 65258, A.hehfinalarabic = 65258, A.hehhamzaabovefinalarabic = 64421, A.hehhamzaaboveisolatedarabic = 64420, A.hehinitialaltonearabic = 64424, A.hehinitialarabic = 65259, A.hehiragana = 12408, A.hehmedialaltonearabic = 64425, A.hehmedialarabic = 65260, A.heiseierasquare = 13179, A.hekatakana = 12504, A.hekatakanahalfwidth = 65421, A.hekutaarusquare = 13110, A.henghook = 615, A.herutusquare = 13113, A.het = 1495, A.hethebrew = 1495, A.hhook = 614, A.hhooksuperior = 689, A.hieuhacirclekorean = 12923, A.hieuhaparenkorean = 12827, A.hieuhcirclekorean = 12909, A.hieuhkorean = 12622, A.hieuhparenkorean = 12813, A.hihiragana = 12402, A.hikatakana = 12498, A.hikatakanahalfwidth = 65419, A.hiriq = 1460, A.hiriq14 = 1460, A.hiriq21 = 1460, A.hiriq2d = 1460, A.hiriqhebrew = 1460, A.hiriqnarrowhebrew = 1460, A.hiriqquarterhebrew = 1460, A.hiriqwidehebrew = 1460, A.hlinebelow = 7830, A.hmonospace = 65352, A.hoarmenian = 1392, A.hohipthai = 3627, A.hohiragana = 12411, A.hokatakana = 12507, A.hokatakanahalfwidth = 65422, A.holam = 1465, A.holam19 = 1465, A.holam26 = 1465, A.holam32 = 1465, A.holamhebrew = 1465, A.holamnarrowhebrew = 1465, A.holamquarterhebrew = 1465, A.holamwidehebrew = 1465, A.honokhukthai = 3630, A.hookabovecomb = 777, A.hookcmb = 777, A.hookpalatalizedbelowcmb = 801, A.hookretroflexbelowcmb = 802, A.hoonsquare = 13122, A.horicoptic = 1001, A.horizontalbar = 8213, A.horncmb = 795, A.hotsprings = 9832, A.house = 8962, A.hparen = 9379, A.hsuperior = 688, A.hturned = 613, A.huhiragana = 12405, A.huiitosquare = 13107, A.hukatakana = 12501, A.hukatakanahalfwidth = 65420, A.hungarumlaut = 733, A.hungarumlautcmb = 779, A.hv = 405, A.hyphen = 45, A.hypheninferior = 63205, A.hyphenmonospace = 65293, A.hyphensmall = 65123, A.hyphensuperior = 63206, A.hyphentwo = 8208, A.i = 105, A.iacute = 237, A.iacyrillic = 1103, A.ibengali = 2439, A.ibopomofo = 12583, A.ibreve = 301, A.icaron = 464, A.icircle = 9432, A.icircumflex = 238, A.icyrillic = 1110, A.idblgrave = 521, A.ideographearthcircle = 12943, A.ideographfirecircle = 12939, A.ideographicallianceparen = 12863, A.ideographiccallparen = 12858, A.ideographiccentrecircle = 12965, A.ideographicclose = 12294, A.ideographiccomma = 12289, A.ideographiccommaleft = 65380, A.ideographiccongratulationparen = 12855, A.ideographiccorrectcircle = 12963, A.ideographicearthparen = 12847, A.ideographicenterpriseparen = 12861, A.ideographicexcellentcircle = 12957, A.ideographicfestivalparen = 12864, A.ideographicfinancialcircle = 12950, A.ideographicfinancialparen = 12854, A.ideographicfireparen = 12843, A.ideographichaveparen = 12850, A.ideographichighcircle = 12964, A.ideographiciterationmark = 12293, A.ideographiclaborcircle = 12952, A.ideographiclaborparen = 12856, A.ideographicleftcircle = 12967, A.ideographiclowcircle = 12966, A.ideographicmedicinecircle = 12969, A.ideographicmetalparen = 12846, A.ideographicmoonparen = 12842, A.ideographicnameparen = 12852, A.ideographicperiod = 12290, A.ideographicprintcircle = 12958, A.ideographicreachparen = 12867, A.ideographicrepresentparen = 12857, A.ideographicresourceparen = 12862, A.ideographicrightcircle = 12968, A.ideographicsecretcircle = 12953, A.ideographicselfparen = 12866, A.ideographicsocietyparen = 12851, A.ideographicspace = 12288, A.ideographicspecialparen = 12853, A.ideographicstockparen = 12849, A.ideographicstudyparen = 12859, A.ideographicsunparen = 12848, A.ideographicsuperviseparen = 12860, A.ideographicwaterparen = 12844, A.ideographicwoodparen = 12845, A.ideographiczero = 12295, A.ideographmetalcircle = 12942, A.ideographmooncircle = 12938, A.ideographnamecircle = 12948, A.ideographsuncircle = 12944, A.ideographwatercircle = 12940, A.ideographwoodcircle = 12941, A.ideva = 2311, A.idieresis = 239, A.idieresisacute = 7727, A.idieresiscyrillic = 1253, A.idotbelow = 7883, A.iebrevecyrillic = 1239, A.iecyrillic = 1077, A.ieungacirclekorean = 12917, A.ieungaparenkorean = 12821, A.ieungcirclekorean = 12903, A.ieungkorean = 12615, A.ieungparenkorean = 12807, A.igrave = 236, A.igujarati = 2695, A.igurmukhi = 2567, A.ihiragana = 12356, A.ihookabove = 7881, A.iibengali = 2440, A.iicyrillic = 1080, A.iideva = 2312, A.iigujarati = 2696, A.iigurmukhi = 2568, A.iimatragurmukhi = 2624, A.iinvertedbreve = 523, A.iishortcyrillic = 1081, A.iivowelsignbengali = 2496, A.iivowelsigndeva = 2368, A.iivowelsigngujarati = 2752, A.ij = 307, A.ikatakana = 12452, A.ikatakanahalfwidth = 65394, A.ikorean = 12643, A.ilde = 732, A.iluyhebrew = 1452, A.imacron = 299, A.imacroncyrillic = 1251, A.imageorapproximatelyequal = 8787, A.imatragurmukhi = 2623, A.imonospace = 65353, A.increment = 8710, A.infinity = 8734, A.iniarmenian = 1387, A.integral = 8747, A.integralbottom = 8993, A.integralbt = 8993, A.integralex = 63733, A.integraltop = 8992, A.integraltp = 8992, A.intersection = 8745, A.intisquare = 13061, A.invbullet = 9688, A.invcircle = 9689, A.invsmileface = 9787, A.iocyrillic = 1105, A.iogonek = 303, A.iota = 953, A.iotadieresis = 970, A.iotadieresistonos = 912, A.iotalatin = 617, A.iotatonos = 943, A.iparen = 9380, A.irigurmukhi = 2674, A.ismallhiragana = 12355, A.ismallkatakana = 12451, A.ismallkatakanahalfwidth = 65384, A.issharbengali = 2554, A.istroke = 616, A.isuperior = 63213, A.iterationhiragana = 12445, A.iterationkatakana = 12541, A.itilde = 297, A.itildebelow = 7725, A.iubopomofo = 12585, A.iucyrillic = 1102, A.ivowelsignbengali = 2495, A.ivowelsigndeva = 2367, A.ivowelsigngujarati = 2751, A.izhitsacyrillic = 1141, A.izhitsadblgravecyrillic = 1143, A.j = 106, A.jaarmenian = 1393, A.jabengali = 2460, A.jadeva = 2332, A.jagujarati = 2716, A.jagurmukhi = 2588, A.jbopomofo = 12560, A.jcaron = 496, A.jcircle = 9433, A.jcircumflex = 309, A.jcrossedtail = 669, A.jdotlessstroke = 607, A.jecyrillic = 1112, A.jeemarabic = 1580, A.jeemfinalarabic = 65182, A.jeeminitialarabic = 65183, A.jeemmedialarabic = 65184, A.jeharabic = 1688, A.jehfinalarabic = 64395, A.jhabengali = 2461, A.jhadeva = 2333, A.jhagujarati = 2717, A.jhagurmukhi = 2589, A.jheharmenian = 1403, A.jis = 12292, A.jmonospace = 65354, A.jparen = 9381, A.jsuperior = 690, A.k = 107, A.kabashkircyrillic = 1185, A.kabengali = 2453, A.kacute = 7729, A.kacyrillic = 1082, A.kadescendercyrillic = 1179, A.kadeva = 2325, A.kaf = 1499, A.kafarabic = 1603, A.kafdagesh = 64315, A.kafdageshhebrew = 64315, A.kaffinalarabic = 65242, A.kafhebrew = 1499, A.kafinitialarabic = 65243, A.kafmedialarabic = 65244, A.kafrafehebrew = 64333, A.kagujarati = 2709, A.kagurmukhi = 2581, A.kahiragana = 12363, A.kahookcyrillic = 1220, A.kakatakana = 12459, A.kakatakanahalfwidth = 65398, A.kappa = 954, A.kappasymbolgreek = 1008, A.kapyeounmieumkorean = 12657, A.kapyeounphieuphkorean = 12676, A.kapyeounpieupkorean = 12664, A.kapyeounssangpieupkorean = 12665, A.karoriisquare = 13069, A.kashidaautoarabic = 1600, A.kashidaautonosidebearingarabic = 1600, A.kasmallkatakana = 12533, A.kasquare = 13188, A.kasraarabic = 1616, A.kasratanarabic = 1613, A.kastrokecyrillic = 1183, A.katahiraprolongmarkhalfwidth = 65392, A.kaverticalstrokecyrillic = 1181, A.kbopomofo = 12558, A.kcalsquare = 13193, A.kcaron = 489, A.kcedilla = 311, A.kcircle = 9434, A.kcommaaccent = 311, A.kdotbelow = 7731, A.keharmenian = 1412, A.kehiragana = 12369, A.kekatakana = 12465, A.kekatakanahalfwidth = 65401, A.kenarmenian = 1391, A.kesmallkatakana = 12534, A.kgreenlandic = 312, A.khabengali = 2454, A.khacyrillic = 1093, A.khadeva = 2326, A.khagujarati = 2710, A.khagurmukhi = 2582, A.khaharabic = 1582, A.khahfinalarabic = 65190, A.khahinitialarabic = 65191, A.khahmedialarabic = 65192, A.kheicoptic = 999, A.khhadeva = 2393, A.khhagurmukhi = 2649, A.khieukhacirclekorean = 12920, A.khieukhaparenkorean = 12824, A.khieukhcirclekorean = 12906, A.khieukhkorean = 12619, A.khieukhparenkorean = 12810, A.khokhaithai = 3586, A.khokhonthai = 3589, A.khokhuatthai = 3587, A.khokhwaithai = 3588, A.khomutthai = 3675, A.khook = 409, A.khorakhangthai = 3590, A.khzsquare = 13201, A.kihiragana = 12365, A.kikatakana = 12461, A.kikatakanahalfwidth = 65399, A.kiroguramusquare = 13077, A.kiromeetorusquare = 13078, A.kirosquare = 13076, A.kiyeokacirclekorean = 12910, A.kiyeokaparenkorean = 12814, A.kiyeokcirclekorean = 12896, A.kiyeokkorean = 12593, A.kiyeokparenkorean = 12800, A.kiyeoksioskorean = 12595, A.kjecyrillic = 1116, A.klinebelow = 7733, A.klsquare = 13208, A.kmcubedsquare = 13222, A.kmonospace = 65355, A.kmsquaredsquare = 13218, A.kohiragana = 12371, A.kohmsquare = 13248, A.kokaithai = 3585, A.kokatakana = 12467, A.kokatakanahalfwidth = 65402, A.kooposquare = 13086, A.koppacyrillic = 1153, A.koreanstandardsymbol = 12927, A.koroniscmb = 835, A.kparen = 9382, A.kpasquare = 13226, A.ksicyrillic = 1135, A.ktsquare = 13263, A.kturned = 670, A.kuhiragana = 12367, A.kukatakana = 12463, A.kukatakanahalfwidth = 65400, A.kvsquare = 13240, A.kwsquare = 13246, A.l = 108, A.labengali = 2482, A.lacute = 314, A.ladeva = 2354, A.lagujarati = 2738, A.lagurmukhi = 2610, A.lakkhangyaothai = 3653, A.lamaleffinalarabic = 65276, A.lamalefhamzaabovefinalarabic = 65272, A.lamalefhamzaaboveisolatedarabic = 65271, A.lamalefhamzabelowfinalarabic = 65274, A.lamalefhamzabelowisolatedarabic = 65273, A.lamalefisolatedarabic = 65275, A.lamalefmaddaabovefinalarabic = 65270, A.lamalefmaddaaboveisolatedarabic = 65269, A.lamarabic = 1604, A.lambda = 955, A.lambdastroke = 411, A.lamed = 1500, A.lameddagesh = 64316, A.lameddageshhebrew = 64316, A.lamedhebrew = 1500, A.lamfinalarabic = 65246, A.lamhahinitialarabic = 64714, A.laminitialarabic = 65247, A.lamjeeminitialarabic = 64713, A.lamkhahinitialarabic = 64715, A.lamlamhehisolatedarabic = 65010, A.lammedialarabic = 65248, A.lammeemhahinitialarabic = 64904, A.lammeeminitialarabic = 64716, A.largecircle = 9711, A.lbar = 410, A.lbelt = 620, A.lbopomofo = 12556, A.lcaron = 318, A.lcedilla = 316, A.lcircle = 9435, A.lcircumflexbelow = 7741, A.lcommaaccent = 316, A.ldot = 320, A.ldotaccent = 320, A.ldotbelow = 7735, A.ldotbelowmacron = 7737, A.leftangleabovecmb = 794, A.lefttackbelowcmb = 792, A.less = 60, A.lessequal = 8804, A.lessequalorgreater = 8922, A.lessmonospace = 65308, A.lessorequivalent = 8818, A.lessorgreater = 8822, A.lessoverequal = 8806, A.lesssmall = 65124, A.lezh = 622, A.lfblock = 9612, A.lhookretroflex = 621, A.lira = 8356, A.liwnarmenian = 1388, A.lj = 457, A.ljecyrillic = 1113, A.ll = 63168, A.lladeva = 2355, A.llagujarati = 2739, A.llinebelow = 7739, A.llladeva = 2356, A.llvocalicbengali = 2529, A.llvocalicdeva = 2401, A.llvocalicvowelsignbengali = 2531, A.llvocalicvowelsigndeva = 2403, A.lmiddletilde = 619, A.lmonospace = 65356, A.lmsquare = 13264, A.lochulathai = 3628, A.logicaland = 8743, A.logicalnot = 172, A.logicalnotreversed = 8976, A.logicalor = 8744, A.lolingthai = 3621, A.longs = 383, A.lowlinecenterline = 65102, A.lowlinecmb = 818, A.lowlinedashed = 65101, A.lozenge = 9674, A.lparen = 9383, A.lslash = 322, A.lsquare = 8467, A.lsuperior = 63214, A.ltshade = 9617, A.luthai = 3622, A.lvocalicbengali = 2444, A.lvocalicdeva = 2316, A.lvocalicvowelsignbengali = 2530, A.lvocalicvowelsigndeva = 2402, A.lxsquare = 13267, A.m = 109, A.mabengali = 2478, A.macron = 175, A.macronbelowcmb = 817, A.macroncmb = 772, A.macronlowmod = 717, A.macronmonospace = 65507, A.macute = 7743, A.madeva = 2350, A.magujarati = 2734, A.magurmukhi = 2606, A.mahapakhhebrew = 1444, A.mahapakhlefthebrew = 1444, A.mahiragana = 12414, A.maichattawalowleftthai = 63637, A.maichattawalowrightthai = 63636, A.maichattawathai = 3659, A.maichattawaupperleftthai = 63635, A.maieklowleftthai = 63628, A.maieklowrightthai = 63627, A.maiekthai = 3656, A.maiekupperleftthai = 63626, A.maihanakatleftthai = 63620, A.maihanakatthai = 3633, A.maitaikhuleftthai = 63625, A.maitaikhuthai = 3655, A.maitholowleftthai = 63631, A.maitholowrightthai = 63630, A.maithothai = 3657, A.maithoupperleftthai = 63629, A.maitrilowleftthai = 63634, A.maitrilowrightthai = 63633, A.maitrithai = 3658, A.maitriupperleftthai = 63632, A.maiyamokthai = 3654, A.makatakana = 12510, A.makatakanahalfwidth = 65423, A.male = 9794, A.mansyonsquare = 13127, A.maqafhebrew = 1470, A.mars = 9794, A.masoracirclehebrew = 1455, A.masquare = 13187, A.mbopomofo = 12551, A.mbsquare = 13268, A.mcircle = 9436, A.mcubedsquare = 13221, A.mdotaccent = 7745, A.mdotbelow = 7747, A.meemarabic = 1605, A.meemfinalarabic = 65250, A.meeminitialarabic = 65251, A.meemmedialarabic = 65252, A.meemmeeminitialarabic = 64721, A.meemmeemisolatedarabic = 64584, A.meetorusquare = 13133, A.mehiragana = 12417, A.meizierasquare = 13182, A.mekatakana = 12513, A.mekatakanahalfwidth = 65426, A.mem = 1502, A.memdagesh = 64318, A.memdageshhebrew = 64318, A.memhebrew = 1502, A.menarmenian = 1396, A.merkhahebrew = 1445, A.merkhakefulahebrew = 1446, A.merkhakefulalefthebrew = 1446, A.merkhalefthebrew = 1445, A.mhook = 625, A.mhzsquare = 13202, A.middledotkatakanahalfwidth = 65381, A.middot = 183, A.mieumacirclekorean = 12914, A.mieumaparenkorean = 12818, A.mieumcirclekorean = 12900, A.mieumkorean = 12609, A.mieumpansioskorean = 12656, A.mieumparenkorean = 12804, A.mieumpieupkorean = 12654, A.mieumsioskorean = 12655, A.mihiragana = 12415, A.mikatakana = 12511, A.mikatakanahalfwidth = 65424, A.minus = 8722, A.minusbelowcmb = 800, A.minuscircle = 8854, A.minusmod = 727, A.minusplus = 8723, A.minute = 8242, A.miribaarusquare = 13130, A.mirisquare = 13129, A.mlonglegturned = 624, A.mlsquare = 13206, A.mmcubedsquare = 13219, A.mmonospace = 65357, A.mmsquaredsquare = 13215, A.mohiragana = 12418, A.mohmsquare = 13249, A.mokatakana = 12514, A.mokatakanahalfwidth = 65427, A.molsquare = 13270, A.momathai = 3617, A.moverssquare = 13223, A.moverssquaredsquare = 13224, A.mparen = 9384, A.mpasquare = 13227, A.mssquare = 13235, A.msuperior = 63215, A.mturned = 623, A.mu = 181, A.mu1 = 181, A.muasquare = 13186, A.muchgreater = 8811, A.muchless = 8810, A.mufsquare = 13196, A.mugreek = 956, A.mugsquare = 13197, A.muhiragana = 12416, A.mukatakana = 12512, A.mukatakanahalfwidth = 65425, A.mulsquare = 13205, A.multiply = 215, A.mumsquare = 13211, A.munahhebrew = 1443, A.munahlefthebrew = 1443, A.musicalnote = 9834, A.musicalnotedbl = 9835, A.musicflatsign = 9837, A.musicsharpsign = 9839, A.mussquare = 13234, A.muvsquare = 13238, A.muwsquare = 13244, A.mvmegasquare = 13241, A.mvsquare = 13239, A.mwmegasquare = 13247, A.mwsquare = 13245, A.n = 110, A.nabengali = 2472, A.nabla = 8711, A.nacute = 324, A.nadeva = 2344, A.nagujarati = 2728, A.nagurmukhi = 2600, A.nahiragana = 12394, A.nakatakana = 12490, A.nakatakanahalfwidth = 65413, A.napostrophe = 329, A.nasquare = 13185, A.nbopomofo = 12555, A.nbspace = 160, A.ncaron = 328, A.ncedilla = 326, A.ncircle = 9437, A.ncircumflexbelow = 7755, A.ncommaaccent = 326, A.ndotaccent = 7749, A.ndotbelow = 7751, A.nehiragana = 12397, A.nekatakana = 12493, A.nekatakanahalfwidth = 65416, A.newsheqelsign = 8362, A.nfsquare = 13195, A.ngabengali = 2457, A.ngadeva = 2329, A.ngagujarati = 2713, A.ngagurmukhi = 2585, A.ngonguthai = 3591, A.nhiragana = 12435, A.nhookleft = 626, A.nhookretroflex = 627, A.nieunacirclekorean = 12911, A.nieunaparenkorean = 12815, A.nieuncieuckorean = 12597, A.nieuncirclekorean = 12897, A.nieunhieuhkorean = 12598, A.nieunkorean = 12596, A.nieunpansioskorean = 12648, A.nieunparenkorean = 12801, A.nieunsioskorean = 12647, A.nieuntikeutkorean = 12646, A.nihiragana = 12395, A.nikatakana = 12491, A.nikatakanahalfwidth = 65414, A.nikhahitleftthai = 63641, A.nikhahitthai = 3661, A.nine = 57, A.ninearabic = 1641, A.ninebengali = 2543, A.ninecircle = 9320, A.ninecircleinversesansserif = 10130, A.ninedeva = 2415, A.ninegujarati = 2799, A.ninegurmukhi = 2671, A.ninehackarabic = 1641, A.ninehangzhou = 12329, A.nineideographicparen = 12840, A.nineinferior = 8329, A.ninemonospace = 65305, A.nineoldstyle = 63289, A.nineparen = 9340, A.nineperiod = 9360, A.ninepersian = 1785, A.nineroman = 8568, A.ninesuperior = 8313, A.nineteencircle = 9330, A.nineteenparen = 9350, A.nineteenperiod = 9370, A.ninethai = 3673, A.nj = 460, A.njecyrillic = 1114, A.nkatakana = 12531, A.nkatakanahalfwidth = 65437, A.nlegrightlong = 414, A.nlinebelow = 7753, A.nmonospace = 65358, A.nmsquare = 13210, A.nnabengali = 2467, A.nnadeva = 2339, A.nnagujarati = 2723, A.nnagurmukhi = 2595, A.nnnadeva = 2345, A.nohiragana = 12398, A.nokatakana = 12494, A.nokatakanahalfwidth = 65417, A.nonbreakingspace = 160, A.nonenthai = 3603, A.nonuthai = 3609, A.noonarabic = 1606, A.noonfinalarabic = 65254, A.noonghunnaarabic = 1722, A.noonghunnafinalarabic = 64415, A.nooninitialarabic = 65255, A.noonjeeminitialarabic = 64722, A.noonjeemisolatedarabic = 64587, A.noonmedialarabic = 65256, A.noonmeeminitialarabic = 64725, A.noonmeemisolatedarabic = 64590, A.noonnoonfinalarabic = 64653, A.notcontains = 8716, A.notelement = 8713, A.notelementof = 8713, A.notequal = 8800, A.notgreater = 8815, A.notgreaternorequal = 8817, A.notgreaternorless = 8825, A.notidentical = 8802, A.notless = 8814, A.notlessnorequal = 8816, A.notparallel = 8742, A.notprecedes = 8832, A.notsubset = 8836, A.notsucceeds = 8833, A.notsuperset = 8837, A.nowarmenian = 1398, A.nparen = 9385, A.nssquare = 13233, A.nsuperior = 8319, A.ntilde = 241, A.nu = 957, A.nuhiragana = 12396, A.nukatakana = 12492, A.nukatakanahalfwidth = 65415, A.nuktabengali = 2492, A.nuktadeva = 2364, A.nuktagujarati = 2748, A.nuktagurmukhi = 2620, A.numbersign = 35, A.numbersignmonospace = 65283, A.numbersignsmall = 65119, A.numeralsigngreek = 884, A.numeralsignlowergreek = 885, A.numero = 8470, A.nun = 1504, A.nundagesh = 64320, A.nundageshhebrew = 64320, A.nunhebrew = 1504, A.nvsquare = 13237, A.nwsquare = 13243, A.nyabengali = 2462, A.nyadeva = 2334, A.nyagujarati = 2718, A.nyagurmukhi = 2590, A.o = 111, A.oacute = 243, A.oangthai = 3629, A.obarred = 629, A.obarredcyrillic = 1257, A.obarreddieresiscyrillic = 1259, A.obengali = 2451, A.obopomofo = 12571, A.obreve = 335, A.ocandradeva = 2321, A.ocandragujarati = 2705, A.ocandravowelsigndeva = 2377, A.ocandravowelsigngujarati = 2761, A.ocaron = 466, A.ocircle = 9438, A.ocircumflex = 244, A.ocircumflexacute = 7889, A.ocircumflexdotbelow = 7897, A.ocircumflexgrave = 7891, A.ocircumflexhookabove = 7893, A.ocircumflextilde = 7895, A.ocyrillic = 1086, A.odblacute = 337, A.odblgrave = 525, A.odeva = 2323, A.odieresis = 246, A.odieresiscyrillic = 1255, A.odotbelow = 7885, A.oe = 339, A.oekorean = 12634, A.ogonek = 731, A.ogonekcmb = 808, A.ograve = 242, A.ogujarati = 2707, A.oharmenian = 1413, A.ohiragana = 12362, A.ohookabove = 7887, A.ohorn = 417, A.ohornacute = 7899, A.ohorndotbelow = 7907, A.ohorngrave = 7901, A.ohornhookabove = 7903, A.ohorntilde = 7905, A.ohungarumlaut = 337, A.oi = 419, A.oinvertedbreve = 527, A.okatakana = 12458, A.okatakanahalfwidth = 65397, A.okorean = 12631, A.olehebrew = 1451, A.omacron = 333, A.omacronacute = 7763, A.omacrongrave = 7761, A.omdeva = 2384, A.omega = 969, A.omega1 = 982, A.omegacyrillic = 1121, A.omegalatinclosed = 631, A.omegaroundcyrillic = 1147, A.omegatitlocyrillic = 1149, A.omegatonos = 974, A.omgujarati = 2768, A.omicron = 959, A.omicrontonos = 972, A.omonospace = 65359, A.one = 49, A.onearabic = 1633, A.onebengali = 2535, A.onecircle = 9312, A.onecircleinversesansserif = 10122, A.onedeva = 2407, A.onedotenleader = 8228, A.oneeighth = 8539, A.onefitted = 63196, A.onegujarati = 2791, A.onegurmukhi = 2663, A.onehackarabic = 1633, A.onehalf = 189, A.onehangzhou = 12321, A.oneideographicparen = 12832, A.oneinferior = 8321, A.onemonospace = 65297, A.onenumeratorbengali = 2548, A.oneoldstyle = 63281, A.oneparen = 9332, A.oneperiod = 9352, A.onepersian = 1777, A.onequarter = 188, A.oneroman = 8560, A.onesuperior = 185, A.onethai = 3665, A.onethird = 8531, A.oogonek = 491, A.oogonekmacron = 493, A.oogurmukhi = 2579, A.oomatragurmukhi = 2635, A.oopen = 596, A.oparen = 9386, A.openbullet = 9702, A.option = 8997, A.ordfeminine = 170, A.ordmasculine = 186, A.orthogonal = 8735, A.oshortdeva = 2322, A.oshortvowelsigndeva = 2378, A.oslash = 248, A.oslashacute = 511, A.osmallhiragana = 12361, A.osmallkatakana = 12457, A.osmallkatakanahalfwidth = 65387, A.ostrokeacute = 511, A.osuperior = 63216, A.otcyrillic = 1151, A.otilde = 245, A.otildeacute = 7757, A.otildedieresis = 7759, A.oubopomofo = 12577, A.overline = 8254, A.overlinecenterline = 65098, A.overlinecmb = 773, A.overlinedashed = 65097, A.overlinedblwavy = 65100, A.overlinewavy = 65099, A.overscore = 175, A.ovowelsignbengali = 2507, A.ovowelsigndeva = 2379, A.ovowelsigngujarati = 2763, A.p = 112, A.paampssquare = 13184, A.paasentosquare = 13099, A.pabengali = 2474, A.pacute = 7765, A.padeva = 2346, A.pagedown = 8671, A.pageup = 8670, A.pagujarati = 2730, A.pagurmukhi = 2602, A.pahiragana = 12401, A.paiyannoithai = 3631, A.pakatakana = 12497, A.palatalizationcyrilliccmb = 1156, A.palochkacyrillic = 1216, A.pansioskorean = 12671, A.paragraph = 182, A.parallel = 8741, A.parenleft = 40, A.parenleftaltonearabic = 64830, A.parenleftbt = 63725, A.parenleftex = 63724, A.parenleftinferior = 8333, A.parenleftmonospace = 65288, A.parenleftsmall = 65113, A.parenleftsuperior = 8317, A.parenlefttp = 63723, A.parenleftvertical = 65077, A.parenright = 41, A.parenrightaltonearabic = 64831, A.parenrightbt = 63736, A.parenrightex = 63735, A.parenrightinferior = 8334, A.parenrightmonospace = 65289, A.parenrightsmall = 65114, A.parenrightsuperior = 8318, A.parenrighttp = 63734, A.parenrightvertical = 65078, A.partialdiff = 8706, A.paseqhebrew = 1472, A.pashtahebrew = 1433, A.pasquare = 13225, A.patah = 1463, A.patah11 = 1463, A.patah1d = 1463, A.patah2a = 1463, A.patahhebrew = 1463, A.patahnarrowhebrew = 1463, A.patahquarterhebrew = 1463, A.patahwidehebrew = 1463, A.pazerhebrew = 1441, A.pbopomofo = 12550, A.pcircle = 9439, A.pdotaccent = 7767, A.pe = 1508, A.pecyrillic = 1087, A.pedagesh = 64324, A.pedageshhebrew = 64324, A.peezisquare = 13115, A.pefinaldageshhebrew = 64323, A.peharabic = 1662, A.peharmenian = 1402, A.pehebrew = 1508, A.pehfinalarabic = 64343, A.pehinitialarabic = 64344, A.pehiragana = 12410, A.pehmedialarabic = 64345, A.pekatakana = 12506, A.pemiddlehookcyrillic = 1191, A.perafehebrew = 64334, A.percent = 37, A.percentarabic = 1642, A.percentmonospace = 65285, A.percentsmall = 65130, A.period = 46, A.periodarmenian = 1417, A.periodcentered = 183, A.periodhalfwidth = 65377, A.periodinferior = 63207, A.periodmonospace = 65294, A.periodsmall = 65106, A.periodsuperior = 63208, A.perispomenigreekcmb = 834, A.perpendicular = 8869, A.perthousand = 8240, A.peseta = 8359, A.pfsquare = 13194, A.phabengali = 2475, A.phadeva = 2347, A.phagujarati = 2731, A.phagurmukhi = 2603, A.phi = 966, A.phi1 = 981, A.phieuphacirclekorean = 12922, A.phieuphaparenkorean = 12826, A.phieuphcirclekorean = 12908, A.phieuphkorean = 12621, A.phieuphparenkorean = 12812, A.philatin = 632, A.phinthuthai = 3642, A.phisymbolgreek = 981, A.phook = 421, A.phophanthai = 3614, A.phophungthai = 3612, A.phosamphaothai = 3616, A.pi = 960, A.pieupacirclekorean = 12915, A.pieupaparenkorean = 12819, A.pieupcieuckorean = 12662, A.pieupcirclekorean = 12901, A.pieupkiyeokkorean = 12658, A.pieupkorean = 12610, A.pieupparenkorean = 12805, A.pieupsioskiyeokkorean = 12660, A.pieupsioskorean = 12612, A.pieupsiostikeutkorean = 12661, A.pieupthieuthkorean = 12663, A.pieuptikeutkorean = 12659, A.pihiragana = 12404, A.pikatakana = 12500, A.pisymbolgreek = 982, A.piwrarmenian = 1411, A.planckover2pi = 8463, A.planckover2pi1 = 8463, A.plus = 43, A.plusbelowcmb = 799, A.pluscircle = 8853, A.plusminus = 177, A.plusmod = 726, A.plusmonospace = 65291, A.plussmall = 65122, A.plussuperior = 8314, A.pmonospace = 65360, A.pmsquare = 13272, A.pohiragana = 12413, A.pointingindexdownwhite = 9759, A.pointingindexleftwhite = 9756, A.pointingindexrightwhite = 9758, A.pointingindexupwhite = 9757, A.pokatakana = 12509, A.poplathai = 3611, A.postalmark = 12306, A.postalmarkface = 12320, A.pparen = 9387, A.precedes = 8826, A.prescription = 8478, A.primemod = 697, A.primereversed = 8245, A.product = 8719, A.projective = 8965, A.prolongedkana = 12540, A.propellor = 8984, A.propersubset = 8834, A.propersuperset = 8835, A.proportion = 8759, A.proportional = 8733, A.psi = 968, A.psicyrillic = 1137, A.psilipneumatacyrilliccmb = 1158, A.pssquare = 13232, A.puhiragana = 12407, A.pukatakana = 12503, A.pvsquare = 13236, A.pwsquare = 13242, A.q = 113, A.qadeva = 2392, A.qadmahebrew = 1448, A.qafarabic = 1602, A.qaffinalarabic = 65238, A.qafinitialarabic = 65239, A.qafmedialarabic = 65240, A.qamats = 1464, A.qamats10 = 1464, A.qamats1a = 1464, A.qamats1c = 1464, A.qamats27 = 1464, A.qamats29 = 1464, A.qamats33 = 1464, A.qamatsde = 1464, A.qamatshebrew = 1464, A.qamatsnarrowhebrew = 1464, A.qamatsqatanhebrew = 1464, A.qamatsqatannarrowhebrew = 1464, A.qamatsqatanquarterhebrew = 1464, A.qamatsqatanwidehebrew = 1464, A.qamatsquarterhebrew = 1464, A.qamatswidehebrew = 1464, A.qarneyparahebrew = 1439, A.qbopomofo = 12561, A.qcircle = 9440, A.qhook = 672, A.qmonospace = 65361, A.qof = 1511, A.qofdagesh = 64327, A.qofdageshhebrew = 64327, A.qofhebrew = 1511, A.qparen = 9388, A.quarternote = 9833, A.qubuts = 1467, A.qubuts18 = 1467, A.qubuts25 = 1467, A.qubuts31 = 1467, A.qubutshebrew = 1467, A.qubutsnarrowhebrew = 1467, A.qubutsquarterhebrew = 1467, A.qubutswidehebrew = 1467, A.question = 63, A.questionarabic = 1567, A.questionarmenian = 1374, A.questiondown = 191, A.questiondownsmall = 63423, A.questiongreek = 894, A.questionmonospace = 65311, A.questionsmall = 63295, A.quotedbl = 34, A.quotedblbase = 8222, A.quotedblleft = 8220, A.quotedblmonospace = 65282, A.quotedblprime = 12318, A.quotedblprimereversed = 12317, A.quotedblright = 8221, A.quoteleft = 8216, A.quoteleftreversed = 8219, A.quotereversed = 8219, A.quoteright = 8217, A.quoterightn = 329, A.quotesinglbase = 8218, A.quotesingle = 39, A.quotesinglemonospace = 65287, A.r = 114, A.raarmenian = 1404, A.rabengali = 2480, A.racute = 341, A.radeva = 2352, A.radical = 8730, A.radicalex = 63717, A.radoverssquare = 13230, A.radoverssquaredsquare = 13231, A.radsquare = 13229, A.rafe = 1471, A.rafehebrew = 1471, A.ragujarati = 2736, A.ragurmukhi = 2608, A.rahiragana = 12425, A.rakatakana = 12521, A.rakatakanahalfwidth = 65431, A.ralowerdiagonalbengali = 2545, A.ramiddlediagonalbengali = 2544, A.ramshorn = 612, A.ratio = 8758, A.rbopomofo = 12566, A.rcaron = 345, A.rcedilla = 343, A.rcircle = 9441, A.rcommaaccent = 343, A.rdblgrave = 529, A.rdotaccent = 7769, A.rdotbelow = 7771, A.rdotbelowmacron = 7773, A.referencemark = 8251, A.reflexsubset = 8838, A.reflexsuperset = 8839, A.registered = 174, A.registersans = 63720, A.registerserif = 63194, A.reharabic = 1585, A.reharmenian = 1408, A.rehfinalarabic = 65198, A.rehiragana = 12428, A.rekatakana = 12524, A.rekatakanahalfwidth = 65434, A.resh = 1512, A.reshdageshhebrew = 64328, A.reshhebrew = 1512, A.reversedtilde = 8765, A.reviahebrew = 1431, A.reviamugrashhebrew = 1431, A.revlogicalnot = 8976, A.rfishhook = 638, A.rfishhookreversed = 639, A.rhabengali = 2525, A.rhadeva = 2397, A.rho = 961, A.rhook = 637, A.rhookturned = 635, A.rhookturnedsuperior = 693, A.rhosymbolgreek = 1009, A.rhotichookmod = 734, A.rieulacirclekorean = 12913, A.rieulaparenkorean = 12817, A.rieulcirclekorean = 12899, A.rieulhieuhkorean = 12608, A.rieulkiyeokkorean = 12602, A.rieulkiyeoksioskorean = 12649, A.rieulkorean = 12601, A.rieulmieumkorean = 12603, A.rieulpansioskorean = 12652, A.rieulparenkorean = 12803, A.rieulphieuphkorean = 12607, A.rieulpieupkorean = 12604, A.rieulpieupsioskorean = 12651, A.rieulsioskorean = 12605, A.rieulthieuthkorean = 12606, A.rieultikeutkorean = 12650, A.rieulyeorinhieuhkorean = 12653, A.rightangle = 8735, A.righttackbelowcmb = 793, A.righttriangle = 8895, A.rihiragana = 12426, A.rikatakana = 12522, A.rikatakanahalfwidth = 65432, A.ring = 730, A.ringbelowcmb = 805, A.ringcmb = 778, A.ringhalfleft = 703, A.ringhalfleftarmenian = 1369, A.ringhalfleftbelowcmb = 796, A.ringhalfleftcentered = 723, A.ringhalfright = 702, A.ringhalfrightbelowcmb = 825, A.ringhalfrightcentered = 722, A.rinvertedbreve = 531, A.rittorusquare = 13137, A.rlinebelow = 7775, A.rlongleg = 636, A.rlonglegturned = 634, A.rmonospace = 65362, A.rohiragana = 12429, A.rokatakana = 12525, A.rokatakanahalfwidth = 65435, A.roruathai = 3619, A.rparen = 9389, A.rrabengali = 2524, A.rradeva = 2353, A.rragurmukhi = 2652, A.rreharabic = 1681, A.rrehfinalarabic = 64397, A.rrvocalicbengali = 2528, A.rrvocalicdeva = 2400, A.rrvocalicgujarati = 2784, A.rrvocalicvowelsignbengali = 2500, A.rrvocalicvowelsigndeva = 2372, A.rrvocalicvowelsigngujarati = 2756, A.rsuperior = 63217, A.rtblock = 9616, A.rturned = 633, A.rturnedsuperior = 692, A.ruhiragana = 12427, A.rukatakana = 12523, A.rukatakanahalfwidth = 65433, A.rupeemarkbengali = 2546, A.rupeesignbengali = 2547, A.rupiah = 63197, A.ruthai = 3620, A.rvocalicbengali = 2443, A.rvocalicdeva = 2315, A.rvocalicgujarati = 2699, A.rvocalicvowelsignbengali = 2499, A.rvocalicvowelsigndeva = 2371, A.rvocalicvowelsigngujarati = 2755, A.s = 115, A.sabengali = 2488, A.sacute = 347, A.sacutedotaccent = 7781, A.sadarabic = 1589, A.sadeva = 2360, A.sadfinalarabic = 65210, A.sadinitialarabic = 65211, A.sadmedialarabic = 65212, A.sagujarati = 2744, A.sagurmukhi = 2616, A.sahiragana = 12373, A.sakatakana = 12469, A.sakatakanahalfwidth = 65403, A.sallallahoualayhewasallamarabic = 65018, A.samekh = 1505, A.samekhdagesh = 64321, A.samekhdageshhebrew = 64321, A.samekhhebrew = 1505, A.saraaathai = 3634, A.saraaethai = 3649, A.saraaimaimalaithai = 3652, A.saraaimaimuanthai = 3651, A.saraamthai = 3635, A.saraathai = 3632, A.saraethai = 3648, A.saraiileftthai = 63622, A.saraiithai = 3637, A.saraileftthai = 63621, A.saraithai = 3636, A.saraothai = 3650, A.saraueeleftthai = 63624, A.saraueethai = 3639, A.saraueleftthai = 63623, A.sarauethai = 3638, A.sarauthai = 3640, A.sarauuthai = 3641, A.sbopomofo = 12569, A.scaron = 353, A.scarondotaccent = 7783, A.scedilla = 351, A.schwa = 601, A.schwacyrillic = 1241, A.schwadieresiscyrillic = 1243, A.schwahook = 602, A.scircle = 9442, A.scircumflex = 349, A.scommaaccent = 537, A.sdotaccent = 7777, A.sdotbelow = 7779, A.sdotbelowdotaccent = 7785, A.seagullbelowcmb = 828, A.second = 8243, A.secondtonechinese = 714, A.section = 167, A.seenarabic = 1587, A.seenfinalarabic = 65202, A.seeninitialarabic = 65203, A.seenmedialarabic = 65204, A.segol = 1462, A.segol13 = 1462, A.segol1f = 1462, A.segol2c = 1462, A.segolhebrew = 1462, A.segolnarrowhebrew = 1462, A.segolquarterhebrew = 1462, A.segoltahebrew = 1426, A.segolwidehebrew = 1462, A.seharmenian = 1405, A.sehiragana = 12379, A.sekatakana = 12475, A.sekatakanahalfwidth = 65406, A.semicolon = 59, A.semicolonarabic = 1563, A.semicolonmonospace = 65307, A.semicolonsmall = 65108, A.semivoicedmarkkana = 12444, A.semivoicedmarkkanahalfwidth = 65439, A.sentisquare = 13090, A.sentosquare = 13091, A.seven = 55, A.sevenarabic = 1639, A.sevenbengali = 2541, A.sevencircle = 9318, A.sevencircleinversesansserif = 10128, A.sevendeva = 2413, A.seveneighths = 8542, A.sevengujarati = 2797, A.sevengurmukhi = 2669, A.sevenhackarabic = 1639, A.sevenhangzhou = 12327, A.sevenideographicparen = 12838, A.seveninferior = 8327, A.sevenmonospace = 65303, A.sevenoldstyle = 63287, A.sevenparen = 9338, A.sevenperiod = 9358, A.sevenpersian = 1783, A.sevenroman = 8566, A.sevensuperior = 8311, A.seventeencircle = 9328, A.seventeenparen = 9348, A.seventeenperiod = 9368, A.seventhai = 3671, A.sfthyphen = 173, A.shaarmenian = 1399, A.shabengali = 2486, A.shacyrillic = 1096, A.shaddaarabic = 1617, A.shaddadammaarabic = 64609, A.shaddadammatanarabic = 64606, A.shaddafathaarabic = 64608, A.shaddakasraarabic = 64610, A.shaddakasratanarabic = 64607, A.shade = 9618, A.shadedark = 9619, A.shadelight = 9617, A.shademedium = 9618, A.shadeva = 2358, A.shagujarati = 2742, A.shagurmukhi = 2614, A.shalshelethebrew = 1427, A.shbopomofo = 12565, A.shchacyrillic = 1097, A.sheenarabic = 1588, A.sheenfinalarabic = 65206, A.sheeninitialarabic = 65207, A.sheenmedialarabic = 65208, A.sheicoptic = 995, A.sheqel = 8362, A.sheqelhebrew = 8362, A.sheva = 1456, A.sheva115 = 1456, A.sheva15 = 1456, A.sheva22 = 1456, A.sheva2e = 1456, A.shevahebrew = 1456, A.shevanarrowhebrew = 1456, A.shevaquarterhebrew = 1456, A.shevawidehebrew = 1456, A.shhacyrillic = 1211, A.shimacoptic = 1005, A.shin = 1513, A.shindagesh = 64329, A.shindageshhebrew = 64329, A.shindageshshindot = 64300, A.shindageshshindothebrew = 64300, A.shindageshsindot = 64301, A.shindageshsindothebrew = 64301, A.shindothebrew = 1473, A.shinhebrew = 1513, A.shinshindot = 64298, A.shinshindothebrew = 64298, A.shinsindot = 64299, A.shinsindothebrew = 64299, A.shook = 642, A.sigma = 963, A.sigma1 = 962, A.sigmafinal = 962, A.sigmalunatesymbolgreek = 1010, A.sihiragana = 12375, A.sikatakana = 12471, A.sikatakanahalfwidth = 65404, A.siluqhebrew = 1469, A.siluqlefthebrew = 1469, A.similar = 8764, A.sindothebrew = 1474, A.siosacirclekorean = 12916, A.siosaparenkorean = 12820, A.sioscieuckorean = 12670, A.sioscirclekorean = 12902, A.sioskiyeokkorean = 12666, A.sioskorean = 12613, A.siosnieunkorean = 12667, A.siosparenkorean = 12806, A.siospieupkorean = 12669, A.siostikeutkorean = 12668, A.six = 54, A.sixarabic = 1638, A.sixbengali = 2540, A.sixcircle = 9317, A.sixcircleinversesansserif = 10127, A.sixdeva = 2412, A.sixgujarati = 2796, A.sixgurmukhi = 2668, A.sixhackarabic = 1638, A.sixhangzhou = 12326, A.sixideographicparen = 12837, A.sixinferior = 8326, A.sixmonospace = 65302, A.sixoldstyle = 63286, A.sixparen = 9337, A.sixperiod = 9357, A.sixpersian = 1782, A.sixroman = 8565, A.sixsuperior = 8310, A.sixteencircle = 9327, A.sixteencurrencydenominatorbengali = 2553, A.sixteenparen = 9347, A.sixteenperiod = 9367, A.sixthai = 3670, A.slash = 47, A.slashmonospace = 65295, A.slong = 383, A.slongdotaccent = 7835, A.smileface = 9786, A.smonospace = 65363, A.sofpasuqhebrew = 1475, A.softhyphen = 173, A.softsigncyrillic = 1100, A.sohiragana = 12381, A.sokatakana = 12477, A.sokatakanahalfwidth = 65407, A.soliduslongoverlaycmb = 824, A.solidusshortoverlaycmb = 823, A.sorusithai = 3625, A.sosalathai = 3624, A.sosothai = 3595, A.sosuathai = 3626, A.space = 32, A.spacehackarabic = 32, A.spade = 9824, A.spadesuitblack = 9824, A.spadesuitwhite = 9828, A.sparen = 9390, A.squarebelowcmb = 827, A.squarecc = 13252, A.squarecm = 13213, A.squarediagonalcrosshatchfill = 9641, A.squarehorizontalfill = 9636, A.squarekg = 13199, A.squarekm = 13214, A.squarekmcapital = 13262, A.squareln = 13265, A.squarelog = 13266, A.squaremg = 13198, A.squaremil = 13269, A.squaremm = 13212, A.squaremsquared = 13217, A.squareorthogonalcrosshatchfill = 9638, A.squareupperlefttolowerrightfill = 9639, A.squareupperrighttolowerleftfill = 9640, A.squareverticalfill = 9637, A.squarewhitewithsmallblack = 9635, A.srsquare = 13275, A.ssabengali = 2487, A.ssadeva = 2359, A.ssagujarati = 2743, A.ssangcieuckorean = 12617, A.ssanghieuhkorean = 12677, A.ssangieungkorean = 12672, A.ssangkiyeokkorean = 12594, A.ssangnieunkorean = 12645, A.ssangpieupkorean = 12611, A.ssangsioskorean = 12614, A.ssangtikeutkorean = 12600, A.ssuperior = 63218, A.sterling = 163, A.sterlingmonospace = 65505, A.strokelongoverlaycmb = 822, A.strokeshortoverlaycmb = 821, A.subset = 8834, A.subsetnotequal = 8842, A.subsetorequal = 8838, A.succeeds = 8827, A.suchthat = 8715, A.suhiragana = 12377, A.sukatakana = 12473, A.sukatakanahalfwidth = 65405, A.sukunarabic = 1618, A.summation = 8721, A.sun = 9788, A.superset = 8835, A.supersetnotequal = 8843, A.supersetorequal = 8839, A.svsquare = 13276, A.syouwaerasquare = 13180, A.t = 116, A.tabengali = 2468, A.tackdown = 8868, A.tackleft = 8867, A.tadeva = 2340, A.tagujarati = 2724, A.tagurmukhi = 2596, A.taharabic = 1591, A.tahfinalarabic = 65218, A.tahinitialarabic = 65219, A.tahiragana = 12383, A.tahmedialarabic = 65220, A.taisyouerasquare = 13181, A.takatakana = 12479, A.takatakanahalfwidth = 65408, A.tatweelarabic = 1600, A.tau = 964, A.tav = 1514, A.tavdages = 64330, A.tavdagesh = 64330, A.tavdageshhebrew = 64330, A.tavhebrew = 1514, A.tbar = 359, A.tbopomofo = 12554, A.tcaron = 357, A.tccurl = 680, A.tcedilla = 355, A.tcheharabic = 1670, A.tchehfinalarabic = 64379, A.tchehinitialarabic = 64380, A.tchehmedialarabic = 64381, A.tcircle = 9443, A.tcircumflexbelow = 7793, A.tcommaaccent = 355, A.tdieresis = 7831, A.tdotaccent = 7787, A.tdotbelow = 7789, A.tecyrillic = 1090, A.tedescendercyrillic = 1197, A.teharabic = 1578, A.tehfinalarabic = 65174, A.tehhahinitialarabic = 64674, A.tehhahisolatedarabic = 64524, A.tehinitialarabic = 65175, A.tehiragana = 12390, A.tehjeeminitialarabic = 64673, A.tehjeemisolatedarabic = 64523, A.tehmarbutaarabic = 1577, A.tehmarbutafinalarabic = 65172, A.tehmedialarabic = 65176, A.tehmeeminitialarabic = 64676, A.tehmeemisolatedarabic = 64526, A.tehnoonfinalarabic = 64627, A.tekatakana = 12486, A.tekatakanahalfwidth = 65411, A.telephone = 8481, A.telephoneblack = 9742, A.telishagedolahebrew = 1440, A.telishaqetanahebrew = 1449, A.tencircle = 9321, A.tenideographicparen = 12841, A.tenparen = 9341, A.tenperiod = 9361, A.tenroman = 8569, A.tesh = 679, A.tet = 1496, A.tetdagesh = 64312, A.tetdageshhebrew = 64312, A.tethebrew = 1496, A.tetsecyrillic = 1205, A.tevirhebrew = 1435, A.tevirlefthebrew = 1435, A.thabengali = 2469, A.thadeva = 2341, A.thagujarati = 2725, A.thagurmukhi = 2597, A.thalarabic = 1584, A.thalfinalarabic = 65196, A.thanthakhatlowleftthai = 63640, A.thanthakhatlowrightthai = 63639, A.thanthakhatthai = 3660, A.thanthakhatupperleftthai = 63638, A.theharabic = 1579, A.thehfinalarabic = 65178, A.thehinitialarabic = 65179, A.thehmedialarabic = 65180, A.thereexists = 8707, A.therefore = 8756, A.theta = 952, A.theta1 = 977, A.thetasymbolgreek = 977, A.thieuthacirclekorean = 12921, A.thieuthaparenkorean = 12825, A.thieuthcirclekorean = 12907, A.thieuthkorean = 12620, A.thieuthparenkorean = 12811, A.thirteencircle = 9324, A.thirteenparen = 9344, A.thirteenperiod = 9364, A.thonangmonthothai = 3601, A.thook = 429, A.thophuthaothai = 3602, A.thorn = 254, A.thothahanthai = 3607, A.thothanthai = 3600, A.thothongthai = 3608, A.thothungthai = 3606, A.thousandcyrillic = 1154, A.thousandsseparatorarabic = 1644, A.thousandsseparatorpersian = 1644, A.three = 51, A.threearabic = 1635, A.threebengali = 2537, A.threecircle = 9314, A.threecircleinversesansserif = 10124, A.threedeva = 2409, A.threeeighths = 8540, A.threegujarati = 2793, A.threegurmukhi = 2665, A.threehackarabic = 1635, A.threehangzhou = 12323, A.threeideographicparen = 12834, A.threeinferior = 8323, A.threemonospace = 65299, A.threenumeratorbengali = 2550, A.threeoldstyle = 63283, A.threeparen = 9334, A.threeperiod = 9354, A.threepersian = 1779, A.threequarters = 190, A.threequartersemdash = 63198, A.threeroman = 8562, A.threesuperior = 179, A.threethai = 3667, A.thzsquare = 13204, A.tihiragana = 12385, A.tikatakana = 12481, A.tikatakanahalfwidth = 65409, A.tikeutacirclekorean = 12912, A.tikeutaparenkorean = 12816, A.tikeutcirclekorean = 12898, A.tikeutkorean = 12599, A.tikeutparenkorean = 12802, A.tilde = 732, A.tildebelowcmb = 816, A.tildecmb = 771, A.tildecomb = 771, A.tildedoublecmb = 864, A.tildeoperator = 8764, A.tildeoverlaycmb = 820, A.tildeverticalcmb = 830, A.timescircle = 8855, A.tipehahebrew = 1430, A.tipehalefthebrew = 1430, A.tippigurmukhi = 2672, A.titlocyrilliccmb = 1155, A.tiwnarmenian = 1407, A.tlinebelow = 7791, A.tmonospace = 65364, A.toarmenian = 1385, A.tohiragana = 12392, A.tokatakana = 12488, A.tokatakanahalfwidth = 65412, A.tonebarextrahighmod = 741, A.tonebarextralowmod = 745, A.tonebarhighmod = 742, A.tonebarlowmod = 744, A.tonebarmidmod = 743, A.tonefive = 445, A.tonesix = 389, A.tonetwo = 424, A.tonos = 900, A.tonsquare = 13095, A.topatakthai = 3599, A.tortoiseshellbracketleft = 12308, A.tortoiseshellbracketleftsmall = 65117, A.tortoiseshellbracketleftvertical = 65081, A.tortoiseshellbracketright = 12309, A.tortoiseshellbracketrightsmall = 65118, A.tortoiseshellbracketrightvertical = 65082, A.totaothai = 3605, A.tpalatalhook = 427, A.tparen = 9391, A.trademark = 8482, A.trademarksans = 63722, A.trademarkserif = 63195, A.tretroflexhook = 648, A.triagdn = 9660, A.triaglf = 9668, A.triagrt = 9658, A.triagup = 9650, A.ts = 678, A.tsadi = 1510, A.tsadidagesh = 64326, A.tsadidageshhebrew = 64326, A.tsadihebrew = 1510, A.tsecyrillic = 1094, A.tsere = 1461, A.tsere12 = 1461, A.tsere1e = 1461, A.tsere2b = 1461, A.tserehebrew = 1461, A.tserenarrowhebrew = 1461, A.tserequarterhebrew = 1461, A.tserewidehebrew = 1461, A.tshecyrillic = 1115, A.tsuperior = 63219, A.ttabengali = 2463, A.ttadeva = 2335, A.ttagujarati = 2719, A.ttagurmukhi = 2591, A.tteharabic = 1657, A.ttehfinalarabic = 64359, A.ttehinitialarabic = 64360, A.ttehmedialarabic = 64361, A.tthabengali = 2464, A.tthadeva = 2336, A.tthagujarati = 2720, A.tthagurmukhi = 2592, A.tturned = 647, A.tuhiragana = 12388, A.tukatakana = 12484, A.tukatakanahalfwidth = 65410, A.tusmallhiragana = 12387, A.tusmallkatakana = 12483, A.tusmallkatakanahalfwidth = 65391, A.twelvecircle = 9323, A.twelveparen = 9343, A.twelveperiod = 9363, A.twelveroman = 8571, A.twentycircle = 9331, A.twentyhangzhou = 21316, A.twentyparen = 9351, A.twentyperiod = 9371, A.two = 50, A.twoarabic = 1634, A.twobengali = 2536, A.twocircle = 9313, A.twocircleinversesansserif = 10123, A.twodeva = 2408, A.twodotenleader = 8229, A.twodotleader = 8229, A.twodotleadervertical = 65072, A.twogujarati = 2792, A.twogurmukhi = 2664, A.twohackarabic = 1634, A.twohangzhou = 12322, A.twoideographicparen = 12833, A.twoinferior = 8322, A.twomonospace = 65298, A.twonumeratorbengali = 2549, A.twooldstyle = 63282, A.twoparen = 9333, A.twoperiod = 9353, A.twopersian = 1778, A.tworoman = 8561, A.twostroke = 443, A.twosuperior = 178, A.twothai = 3666, A.twothirds = 8532, A.u = 117, A.uacute = 250, A.ubar = 649, A.ubengali = 2441, A.ubopomofo = 12584, A.ubreve = 365, A.ucaron = 468, A.ucircle = 9444, A.ucircumflex = 251, A.ucircumflexbelow = 7799, A.ucyrillic = 1091, A.udattadeva = 2385, A.udblacute = 369, A.udblgrave = 533, A.udeva = 2313, A.udieresis = 252, A.udieresisacute = 472, A.udieresisbelow = 7795, A.udieresiscaron = 474, A.udieresiscyrillic = 1265, A.udieresisgrave = 476, A.udieresismacron = 470, A.udotbelow = 7909, A.ugrave = 249, A.ugujarati = 2697, A.ugurmukhi = 2569, A.uhiragana = 12358, A.uhookabove = 7911, A.uhorn = 432, A.uhornacute = 7913, A.uhorndotbelow = 7921, A.uhorngrave = 7915, A.uhornhookabove = 7917, A.uhorntilde = 7919, A.uhungarumlaut = 369, A.uhungarumlautcyrillic = 1267, A.uinvertedbreve = 535, A.ukatakana = 12454, A.ukatakanahalfwidth = 65395, A.ukcyrillic = 1145, A.ukorean = 12636, A.umacron = 363, A.umacroncyrillic = 1263, A.umacrondieresis = 7803, A.umatragurmukhi = 2625, A.umonospace = 65365, A.underscore = 95, A.underscoredbl = 8215, A.underscoremonospace = 65343, A.underscorevertical = 65075, A.underscorewavy = 65103, A.union = 8746, A.universal = 8704, A.uogonek = 371, A.uparen = 9392, A.upblock = 9600, A.upperdothebrew = 1476, A.upsilon = 965, A.upsilondieresis = 971, A.upsilondieresistonos = 944, A.upsilonlatin = 650, A.upsilontonos = 973, A.uptackbelowcmb = 797, A.uptackmod = 724, A.uragurmukhi = 2675, A.uring = 367, A.ushortcyrillic = 1118, A.usmallhiragana = 12357, A.usmallkatakana = 12453, A.usmallkatakanahalfwidth = 65385, A.ustraightcyrillic = 1199, A.ustraightstrokecyrillic = 1201, A.utilde = 361, A.utildeacute = 7801, A.utildebelow = 7797, A.uubengali = 2442, A.uudeva = 2314, A.uugujarati = 2698, A.uugurmukhi = 2570, A.uumatragurmukhi = 2626, A.uuvowelsignbengali = 2498, A.uuvowelsigndeva = 2370, A.uuvowelsigngujarati = 2754, A.uvowelsignbengali = 2497, A.uvowelsigndeva = 2369, A.uvowelsigngujarati = 2753, A.v = 118, A.vadeva = 2357, A.vagujarati = 2741, A.vagurmukhi = 2613, A.vakatakana = 12535, A.vav = 1493, A.vavdagesh = 64309, A.vavdagesh65 = 64309, A.vavdageshhebrew = 64309, A.vavhebrew = 1493, A.vavholam = 64331, A.vavholamhebrew = 64331, A.vavvavhebrew = 1520, A.vavyodhebrew = 1521, A.vcircle = 9445, A.vdotbelow = 7807, A.vecyrillic = 1074, A.veharabic = 1700, A.vehfinalarabic = 64363, A.vehinitialarabic = 64364, A.vehmedialarabic = 64365, A.vekatakana = 12537, A.venus = 9792, A.verticalbar = 124, A.verticallineabovecmb = 781, A.verticallinebelowcmb = 809, A.verticallinelowmod = 716, A.verticallinemod = 712, A.vewarmenian = 1406, A.vhook = 651, A.vikatakana = 12536, A.viramabengali = 2509, A.viramadeva = 2381, A.viramagujarati = 2765, A.visargabengali = 2435, A.visargadeva = 2307, A.visargagujarati = 2691, A.vmonospace = 65366, A.voarmenian = 1400, A.voicediterationhiragana = 12446, A.voicediterationkatakana = 12542, A.voicedmarkkana = 12443, A.voicedmarkkanahalfwidth = 65438, A.vokatakana = 12538, A.vparen = 9393, A.vtilde = 7805, A.vturned = 652, A.vuhiragana = 12436, A.vukatakana = 12532, A.w = 119, A.wacute = 7811, A.waekorean = 12633, A.wahiragana = 12431, A.wakatakana = 12527, A.wakatakanahalfwidth = 65436, A.wakorean = 12632, A.wasmallhiragana = 12430, A.wasmallkatakana = 12526, A.wattosquare = 13143, A.wavedash = 12316, A.wavyunderscorevertical = 65076, A.wawarabic = 1608, A.wawfinalarabic = 65262, A.wawhamzaabovearabic = 1572, A.wawhamzaabovefinalarabic = 65158, A.wbsquare = 13277, A.wcircle = 9446, A.wcircumflex = 373, A.wdieresis = 7813, A.wdotaccent = 7815, A.wdotbelow = 7817, A.wehiragana = 12433, A.weierstrass = 8472, A.wekatakana = 12529, A.wekorean = 12638, A.weokorean = 12637, A.wgrave = 7809, A.whitebullet = 9702, A.whitecircle = 9675, A.whitecircleinverse = 9689, A.whitecornerbracketleft = 12302, A.whitecornerbracketleftvertical = 65091, A.whitecornerbracketright = 12303, A.whitecornerbracketrightvertical = 65092, A.whitediamond = 9671, A.whitediamondcontainingblacksmalldiamond = 9672, A.whitedownpointingsmalltriangle = 9663, A.whitedownpointingtriangle = 9661, A.whiteleftpointingsmalltriangle = 9667, A.whiteleftpointingtriangle = 9665, A.whitelenticularbracketleft = 12310, A.whitelenticularbracketright = 12311, A.whiterightpointingsmalltriangle = 9657, A.whiterightpointingtriangle = 9655, A.whitesmallsquare = 9643, A.whitesmilingface = 9786, A.whitesquare = 9633, A.whitestar = 9734, A.whitetelephone = 9743, A.whitetortoiseshellbracketleft = 12312, A.whitetortoiseshellbracketright = 12313, A.whiteuppointingsmalltriangle = 9653, A.whiteuppointingtriangle = 9651, A.wihiragana = 12432, A.wikatakana = 12528, A.wikorean = 12639, A.wmonospace = 65367, A.wohiragana = 12434, A.wokatakana = 12530, A.wokatakanahalfwidth = 65382, A.won = 8361, A.wonmonospace = 65510, A.wowaenthai = 3623, A.wparen = 9394, A.wring = 7832, A.wsuperior = 695, A.wturned = 653, A.wynn = 447, A.x = 120, A.xabovecmb = 829, A.xbopomofo = 12562, A.xcircle = 9447, A.xdieresis = 7821, A.xdotaccent = 7819, A.xeharmenian = 1389, A.xi = 958, A.xmonospace = 65368, A.xparen = 9395, A.xsuperior = 739, A.y = 121, A.yaadosquare = 13134, A.yabengali = 2479, A.yacute = 253, A.yadeva = 2351, A.yaekorean = 12626, A.yagujarati = 2735, A.yagurmukhi = 2607, A.yahiragana = 12420, A.yakatakana = 12516, A.yakatakanahalfwidth = 65428, A.yakorean = 12625, A.yamakkanthai = 3662, A.yasmallhiragana = 12419, A.yasmallkatakana = 12515, A.yasmallkatakanahalfwidth = 65388, A.yatcyrillic = 1123, A.ycircle = 9448, A.ycircumflex = 375, A.ydieresis = 255, A.ydotaccent = 7823, A.ydotbelow = 7925, A.yeharabic = 1610, A.yehbarreearabic = 1746, A.yehbarreefinalarabic = 64431, A.yehfinalarabic = 65266, A.yehhamzaabovearabic = 1574, A.yehhamzaabovefinalarabic = 65162, A.yehhamzaaboveinitialarabic = 65163, A.yehhamzaabovemedialarabic = 65164, A.yehinitialarabic = 65267, A.yehmedialarabic = 65268, A.yehmeeminitialarabic = 64733, A.yehmeemisolatedarabic = 64600, A.yehnoonfinalarabic = 64660, A.yehthreedotsbelowarabic = 1745, A.yekorean = 12630, A.yen = 165, A.yenmonospace = 65509, A.yeokorean = 12629, A.yeorinhieuhkorean = 12678, A.yerahbenyomohebrew = 1450, A.yerahbenyomolefthebrew = 1450, A.yericyrillic = 1099, A.yerudieresiscyrillic = 1273, A.yesieungkorean = 12673, A.yesieungpansioskorean = 12675, A.yesieungsioskorean = 12674, A.yetivhebrew = 1434, A.ygrave = 7923, A.yhook = 436, A.yhookabove = 7927, A.yiarmenian = 1397, A.yicyrillic = 1111, A.yikorean = 12642, A.yinyang = 9775, A.yiwnarmenian = 1410, A.ymonospace = 65369, A.yod = 1497, A.yoddagesh = 64313, A.yoddageshhebrew = 64313, A.yodhebrew = 1497, A.yodyodhebrew = 1522, A.yodyodpatahhebrew = 64287, A.yohiragana = 12424, A.yoikorean = 12681, A.yokatakana = 12520, A.yokatakanahalfwidth = 65430, A.yokorean = 12635, A.yosmallhiragana = 12423, A.yosmallkatakana = 12519, A.yosmallkatakanahalfwidth = 65390, A.yotgreek = 1011, A.yoyaekorean = 12680, A.yoyakorean = 12679, A.yoyakthai = 3618, A.yoyingthai = 3597, A.yparen = 9396, A.ypogegrammeni = 890, A.ypogegrammenigreekcmb = 837, A.yr = 422, A.yring = 7833, A.ysuperior = 696, A.ytilde = 7929, A.yturned = 654, A.yuhiragana = 12422, A.yuikorean = 12684, A.yukatakana = 12518, A.yukatakanahalfwidth = 65429, A.yukorean = 12640, A.yusbigcyrillic = 1131, A.yusbigiotifiedcyrillic = 1133, A.yuslittlecyrillic = 1127, A.yuslittleiotifiedcyrillic = 1129, A.yusmallhiragana = 12421, A.yusmallkatakana = 12517, A.yusmallkatakanahalfwidth = 65389, A.yuyekorean = 12683, A.yuyeokorean = 12682, A.yyabengali = 2527, A.yyadeva = 2399, A.z = 122, A.zaarmenian = 1382, A.zacute = 378, A.zadeva = 2395, A.zagurmukhi = 2651, A.zaharabic = 1592, A.zahfinalarabic = 65222, A.zahinitialarabic = 65223, A.zahiragana = 12374, A.zahmedialarabic = 65224, A.zainarabic = 1586, A.zainfinalarabic = 65200, A.zakatakana = 12470, A.zaqefgadolhebrew = 1429, A.zaqefqatanhebrew = 1428, A.zarqahebrew = 1432, A.zayin = 1494, A.zayindagesh = 64310, A.zayindageshhebrew = 64310, A.zayinhebrew = 1494, A.zbopomofo = 12567, A.zcaron = 382, A.zcircle = 9449, A.zcircumflex = 7825, A.zcurl = 657, A.zdot = 380, A.zdotaccent = 380, A.zdotbelow = 7827, A.zecyrillic = 1079, A.zedescendercyrillic = 1177, A.zedieresiscyrillic = 1247, A.zehiragana = 12380, A.zekatakana = 12476, A.zero = 48, A.zeroarabic = 1632, A.zerobengali = 2534, A.zerodeva = 2406, A.zerogujarati = 2790, A.zerogurmukhi = 2662, A.zerohackarabic = 1632, A.zeroinferior = 8320, A.zeromonospace = 65296, A.zerooldstyle = 63280, A.zeropersian = 1776, A.zerosuperior = 8304, A.zerothai = 3664, A.zerowidthjoiner = 65279, A.zerowidthnonjoiner = 8204, A.zerowidthspace = 8203, A.zeta = 950, A.zhbopomofo = 12563, A.zhearmenian = 1386, A.zhebrevecyrillic = 1218, A.zhecyrillic = 1078, A.zhedescendercyrillic = 1175, A.zhedieresiscyrillic = 1245, A.zihiragana = 12376, A.zikatakana = 12472, A.zinorhebrew = 1454, A.zlinebelow = 7829, A.zmonospace = 65370, A.zohiragana = 12382, A.zokatakana = 12478, A.zparen = 9397, A.zretroflexhook = 656, A.zstroke = 438, A.zuhiragana = 12378, A.zukatakana = 12474, A[".notdef"] = 0, A.angbracketleftbig = 9001, A.angbracketleftBig = 9001, A.angbracketleftbigg = 9001, A.angbracketleftBigg = 9001, A.angbracketrightBig = 9002, A.angbracketrightbig = 9002, A.angbracketrightBigg = 9002, A.angbracketrightbigg = 9002, A.arrowhookleft = 8618, A.arrowhookright = 8617, A.arrowlefttophalf = 8636, A.arrowleftbothalf = 8637, A.arrownortheast = 8599, A.arrownorthwest = 8598, A.arrowrighttophalf = 8640, A.arrowrightbothalf = 8641, A.arrowsoutheast = 8600, A.arrowsouthwest = 8601, A.backslashbig = 8726, A.backslashBig = 8726, A.backslashBigg = 8726, A.backslashbigg = 8726, A.bardbl = 8214, A.bracehtipdownleft = 65079, A.bracehtipdownright = 65079, A.bracehtipupleft = 65080, A.bracehtipupright = 65080, A.braceleftBig = 123, A.braceleftbig = 123, A.braceleftbigg = 123, A.braceleftBigg = 123, A.bracerightBig = 125, A.bracerightbig = 125, A.bracerightbigg = 125, A.bracerightBigg = 125, A.bracketleftbig = 91, A.bracketleftBig = 91, A.bracketleftbigg = 91, A.bracketleftBigg = 91, A.bracketrightBig = 93, A.bracketrightbig = 93, A.bracketrightbigg = 93, A.bracketrightBigg = 93, A.ceilingleftbig = 8968, A.ceilingleftBig = 8968, A.ceilingleftBigg = 8968, A.ceilingleftbigg = 8968, A.ceilingrightbig = 8969, A.ceilingrightBig = 8969, A.ceilingrightbigg = 8969, A.ceilingrightBigg = 8969, A.circledotdisplay = 8857, A.circledottext = 8857, A.circlemultiplydisplay = 8855, A.circlemultiplytext = 8855, A.circleplusdisplay = 8853, A.circleplustext = 8853, A.contintegraldisplay = 8750, A.contintegraltext = 8750, A.coproductdisplay = 8720, A.coproducttext = 8720, A.floorleftBig = 8970, A.floorleftbig = 8970, A.floorleftbigg = 8970, A.floorleftBigg = 8970, A.floorrightbig = 8971, A.floorrightBig = 8971, A.floorrightBigg = 8971, A.floorrightbigg = 8971, A.hatwide = 770, A.hatwider = 770, A.hatwidest = 770, A.intercal = 7488, A.integraldisplay = 8747, A.integraltext = 8747, A.intersectiondisplay = 8898, A.intersectiontext = 8898, A.logicalanddisplay = 8743, A.logicalandtext = 8743, A.logicalordisplay = 8744, A.logicalortext = 8744, A.parenleftBig = 40, A.parenleftbig = 40, A.parenleftBigg = 40, A.parenleftbigg = 40, A.parenrightBig = 41, A.parenrightbig = 41, A.parenrightBigg = 41, A.parenrightbigg = 41, A.prime = 8242, A.productdisplay = 8719, A.producttext = 8719, A.radicalbig = 8730, A.radicalBig = 8730, A.radicalBigg = 8730, A.radicalbigg = 8730, A.radicalbt = 8730, A.radicaltp = 8730, A.radicalvertex = 8730, A.slashbig = 47, A.slashBig = 47, A.slashBigg = 47, A.slashbigg = 47, A.summationdisplay = 8721, A.summationtext = 8721, A.tildewide = 732, A.tildewider = 732, A.tildewidest = 732, A.uniondisplay = 8899, A.unionmultidisplay = 8846, A.unionmultitext = 8846, A.unionsqdisplay = 8852, A.unionsqtext = 8852, A.uniontext = 8899, A.vextenddouble = 8741, A.vextendsingle = 8739;
})), a5 = DA((function(A) {
  A.space = 32, A.a1 = 9985, A.a2 = 9986, A.a202 = 9987, A.a3 = 9988, A.a4 = 9742, A.a5 = 9990, A.a119 = 9991, A.a118 = 9992, A.a117 = 9993, A.a11 = 9755, A.a12 = 9758, A.a13 = 9996, A.a14 = 9997, A.a15 = 9998, A.a16 = 9999, A.a105 = 1e4, A.a17 = 10001, A.a18 = 10002, A.a19 = 10003, A.a20 = 10004, A.a21 = 10005, A.a22 = 10006, A.a23 = 10007, A.a24 = 10008, A.a25 = 10009, A.a26 = 10010, A.a27 = 10011, A.a28 = 10012, A.a6 = 10013, A.a7 = 10014, A.a8 = 10015, A.a9 = 10016, A.a10 = 10017, A.a29 = 10018, A.a30 = 10019, A.a31 = 10020, A.a32 = 10021, A.a33 = 10022, A.a34 = 10023, A.a35 = 9733, A.a36 = 10025, A.a37 = 10026, A.a38 = 10027, A.a39 = 10028, A.a40 = 10029, A.a41 = 10030, A.a42 = 10031, A.a43 = 10032, A.a44 = 10033, A.a45 = 10034, A.a46 = 10035, A.a47 = 10036, A.a48 = 10037, A.a49 = 10038, A.a50 = 10039, A.a51 = 10040, A.a52 = 10041, A.a53 = 10042, A.a54 = 10043, A.a55 = 10044, A.a56 = 10045, A.a57 = 10046, A.a58 = 10047, A.a59 = 10048, A.a60 = 10049, A.a61 = 10050, A.a62 = 10051, A.a63 = 10052, A.a64 = 10053, A.a65 = 10054, A.a66 = 10055, A.a67 = 10056, A.a68 = 10057, A.a69 = 10058, A.a70 = 10059, A.a71 = 9679, A.a72 = 10061, A.a73 = 9632, A.a74 = 10063, A.a203 = 10064, A.a75 = 10065, A.a204 = 10066, A.a76 = 9650, A.a77 = 9660, A.a78 = 9670, A.a79 = 10070, A.a81 = 9687, A.a82 = 10072, A.a83 = 10073, A.a84 = 10074, A.a97 = 10075, A.a98 = 10076, A.a99 = 10077, A.a100 = 10078, A.a101 = 10081, A.a102 = 10082, A.a103 = 10083, A.a104 = 10084, A.a106 = 10085, A.a107 = 10086, A.a108 = 10087, A.a112 = 9827, A.a111 = 9830, A.a110 = 9829, A.a109 = 9824, A.a120 = 9312, A.a121 = 9313, A.a122 = 9314, A.a123 = 9315, A.a124 = 9316, A.a125 = 9317, A.a126 = 9318, A.a127 = 9319, A.a128 = 9320, A.a129 = 9321, A.a130 = 10102, A.a131 = 10103, A.a132 = 10104, A.a133 = 10105, A.a134 = 10106, A.a135 = 10107, A.a136 = 10108, A.a137 = 10109, A.a138 = 10110, A.a139 = 10111, A.a140 = 10112, A.a141 = 10113, A.a142 = 10114, A.a143 = 10115, A.a144 = 10116, A.a145 = 10117, A.a146 = 10118, A.a147 = 10119, A.a148 = 10120, A.a149 = 10121, A.a150 = 10122, A.a151 = 10123, A.a152 = 10124, A.a153 = 10125, A.a154 = 10126, A.a155 = 10127, A.a156 = 10128, A.a157 = 10129, A.a158 = 10130, A.a159 = 10131, A.a160 = 10132, A.a161 = 8594, A.a163 = 8596, A.a164 = 8597, A.a196 = 10136, A.a165 = 10137, A.a192 = 10138, A.a166 = 10139, A.a167 = 10140, A.a168 = 10141, A.a169 = 10142, A.a170 = 10143, A.a171 = 10144, A.a172 = 10145, A.a173 = 10146, A.a162 = 10147, A.a174 = 10148, A.a175 = 10149, A.a176 = 10150, A.a177 = 10151, A.a178 = 10152, A.a179 = 10153, A.a193 = 10154, A.a180 = 10155, A.a199 = 10156, A.a181 = 10157, A.a200 = 10158, A.a182 = 10159, A.a201 = 10161, A.a183 = 10162, A.a184 = 10163, A.a197 = 10164, A.a185 = 10165, A.a194 = 10166, A.a198 = 10167, A.a186 = 10168, A.a195 = 10169, A.a187 = 10170, A.a188 = 10171, A.a189 = 10172, A.a190 = 10173, A.a191 = 10174, A.a89 = 10088, A.a90 = 10089, A.a93 = 10090, A.a94 = 10091, A.a91 = 10092, A.a92 = 10093, A.a205 = 10094, A.a85 = 10095, A.a206 = 10096, A.a86 = 10097, A.a87 = 10098, A.a88 = 10099, A.a95 = 10100, A.a96 = 10101, A[".notdef"] = 0;
})), n5 = DA((function(A) {
  A[63721] = 169, A[63193] = 169, A[63720] = 174, A[63194] = 174, A[63722] = 8482, A[63195] = 8482, A[63729] = 9127, A[63730] = 9128, A[63731] = 9129, A[63740] = 9131, A[63741] = 9132, A[63742] = 9133, A[63726] = 9121, A[63727] = 9122, A[63728] = 9123, A[63737] = 9124, A[63738] = 9125, A[63739] = 9126, A[63723] = 9115, A[63724] = 9116, A[63725] = 9117, A[63734] = 9118, A[63735] = 9119, A[63736] = 9120;
}));
function Va(A, t) {
  let e = t[A];
  if (e !== void 0) return e;
  if (!A) return -1;
  if (A[0] === "u") {
    const i = A.length;
    let s;
    if (i === 7 && A[1] === "n" && A[2] === "i") s = A.substring(3);
    else {
      if (!(i >= 5 && i <= 7)) return -1;
      s = A.substring(1);
    }
    if (s === s.toUpperCase() && (e = parseInt(s, 16), e >= 0)) return e;
  }
  return -1;
}
const Vc = [[0, 127], [128, 255], [256, 383], [384, 591], [592, 687, 7424, 7551, 7552, 7615], [688, 767, 42752, 42783], [768, 879, 7616, 7679], [880, 1023], [11392, 11519], [1024, 1279, 1280, 1327, 11744, 11775, 42560, 42655], [1328, 1423], [1424, 1535], [42240, 42559], [1536, 1791, 1872, 1919], [1984, 2047], [2304, 2431], [2432, 2559], [2560, 2687], [2688, 2815], [2816, 2943], [2944, 3071], [3072, 3199], [3200, 3327], [3328, 3455], [3584, 3711], [3712, 3839], [4256, 4351, 11520, 11567], [6912, 7039], [4352, 4607], [7680, 7935, 11360, 11391, 42784, 43007], [7936, 8191], [8192, 8303, 11776, 11903], [8304, 8351], [8352, 8399], [8400, 8447], [8448, 8527], [8528, 8591], [8592, 8703, 10224, 10239, 10496, 10623, 11008, 11263], [8704, 8959, 10752, 11007, 10176, 10223, 10624, 10751], [8960, 9215], [9216, 9279], [9280, 9311], [9312, 9471], [9472, 9599], [9600, 9631], [9632, 9727], [9728, 9983], [9984, 10175], [12288, 12351], [12352, 12447], [12448, 12543, 12784, 12799], [12544, 12591, 12704, 12735], [12592, 12687], [43072, 43135], [12800, 13055], [13056, 13311], [44032, 55215], [55296, 57343], [67840, 67871], [19968, 40959, 11904, 12031, 12032, 12255, 12272, 12287, 13312, 19903, 131072, 173791, 12688, 12703], [57344, 63743], [12736, 12783, 63744, 64255, 194560, 195103], [64256, 64335], [64336, 65023], [65056, 65071], [65040, 65055], [65104, 65135], [65136, 65279], [65280, 65519], [65520, 65535], [3840, 4095], [1792, 1871], [1920, 1983], [3456, 3583], [4096, 4255], [4608, 4991, 4992, 5023, 11648, 11743], [5024, 5119], [5120, 5759], [5760, 5791], [5792, 5887], [6016, 6143], [6144, 6319], [10240, 10495], [40960, 42127], [5888, 5919, 5920, 5951, 5952, 5983, 5984, 6015], [66304, 66351], [66352, 66383], [66560, 66639], [118784, 119039, 119040, 119295, 119296, 119375], [119808, 120831], [1044480, 1048573], [65024, 65039, 917760, 917999], [917504, 917631], [6400, 6479], [6480, 6527], [6528, 6623], [6656, 6687], [11264, 11359], [11568, 11647], [19904, 19967], [43008, 43055], [65536, 65663, 65664, 65791, 65792, 65855], [65856, 65935], [66432, 66463], [66464, 66527], [66640, 66687], [66688, 66735], [67584, 67647], [68096, 68191], [119552, 119647], [73728, 74751, 74752, 74879], [119648, 119679], [7040, 7103], [7168, 7247], [7248, 7295], [43136, 43231], [43264, 43311], [43312, 43359], [43520, 43615], [65936, 65999], [66e3, 66047], [66208, 66271, 66176, 66207, 67872, 67903], [127024, 127135, 126976, 127023]];
function r5(A, t = -1) {
  if (t !== -1) {
    const e = Vc[t];
    for (let i = 0, s = e.length; i < s; i += 2) if (A >= e[i] && A <= e[i + 1]) return t;
  }
  for (let e = 0, i = Vc.length; e < i; e++) {
    const s = Vc[e];
    for (let n = 0, o = s.length; n < o; n += 2) if (A >= s[n] && A <= s[n + 1]) return e;
  }
  return -1;
}
const o5 = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u"), Th = /* @__PURE__ */ new Map(), cr = !0, bo = 1, BE = 2, Zo = 4, TC = 32, KC = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
function dE(A, t) {
  if (t[A] !== void 0) return A;
  const e = Va(A, t);
  if (e !== -1) {
    for (const i in t) if (t[i] === e) return i;
  }
  return tA("Unable to recover a standard glyph name for: " + A), A;
}
function QE(A, t, e) {
  const i = /* @__PURE__ */ Object.create(null);
  let s, n, o;
  const r = !!(A.flags & Zo);
  if (A.isInternalFont) for (o = t, n = 0; n < o.length; n++) s = e.indexOf(o[n]), i[n] = s >= 0 ? s : 0;
  else if (A.baseEncodingName) for (o = rr(A.baseEncodingName), n = 0; n < o.length; n++) s = e.indexOf(o[n]), i[n] = s >= 0 ? s : 0;
  else if (r) for (n in t) i[n] = t[n];
  else for (o = Vi, n = 0; n < o.length; n++) s = e.indexOf(o[n]), i[n] = s >= 0 ? s : 0;
  const c = A.differences;
  let h;
  if (c) for (n in c) {
    const I = c[n];
    if (s = e.indexOf(I), s === -1) {
      h || (h = mi());
      const C = dE(I, h);
      C !== I && (s = e.indexOf(C));
    }
    i[n] = s >= 0 ? s : 0;
  }
  return i;
}
function Dr(A) {
  return A.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
}
const g5 = DA(((A) => {
  A[8211] = 65074, A[8212] = 65073, A[8229] = 65072, A[8230] = 65049, A[12289] = 65041, A[12290] = 65042, A[12296] = 65087, A[12297] = 65088, A[12298] = 65085, A[12299] = 65086, A[12300] = 65089, A[12301] = 65090, A[12302] = 65091, A[12303] = 65092, A[12304] = 65083, A[12305] = 65084, A[12308] = 65081, A[12309] = 65082, A[12310] = 65047, A[12311] = 65048, A[65103] = 65076, A[65281] = 65045, A[65288] = 65077, A[65289] = 65078, A[65292] = 65040, A[65306] = 65043, A[65307] = 65044, A[65311] = 65046, A[65339] = 65095, A[65341] = 65096, A[65343] = 65075, A[65371] = 65079, A[65373] = 65080;
})), dg = DA((function(A) {
  A["Times-Roman"] = "Times-Roman", A.Helvetica = "Helvetica", A.Courier = "Courier", A.Symbol = "Symbol", A["Times-Bold"] = "Times-Bold", A["Helvetica-Bold"] = "Helvetica-Bold", A["Courier-Bold"] = "Courier-Bold", A.ZapfDingbats = "ZapfDingbats", A["Times-Italic"] = "Times-Italic", A["Helvetica-Oblique"] = "Helvetica-Oblique", A["Courier-Oblique"] = "Courier-Oblique", A["Times-BoldItalic"] = "Times-BoldItalic", A["Helvetica-BoldOblique"] = "Helvetica-BoldOblique", A["Courier-BoldOblique"] = "Courier-BoldOblique", A.ArialNarrow = "Helvetica", A["ArialNarrow-Bold"] = "Helvetica-Bold", A["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique", A["ArialNarrow-Italic"] = "Helvetica-Oblique", A.ArialBlack = "Helvetica", A["ArialBlack-Bold"] = "Helvetica-Bold", A["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique", A["ArialBlack-Italic"] = "Helvetica-Oblique", A["Arial-Black"] = "Helvetica", A["Arial-Black-Bold"] = "Helvetica-Bold", A["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique", A["Arial-Black-Italic"] = "Helvetica-Oblique", A.Arial = "Helvetica", A["Arial-Bold"] = "Helvetica-Bold", A["Arial-BoldItalic"] = "Helvetica-BoldOblique", A["Arial-Italic"] = "Helvetica-Oblique", A.ArialMT = "Helvetica", A["Arial-BoldItalicMT"] = "Helvetica-BoldOblique", A["Arial-BoldMT"] = "Helvetica-Bold", A["Arial-ItalicMT"] = "Helvetica-Oblique", A["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique", A["Arial-BoldMT-Bold"] = "Helvetica-Bold", A["Arial-ItalicMT-Italic"] = "Helvetica-Oblique", A.ArialUnicodeMS = "Helvetica", A["ArialUnicodeMS-Bold"] = "Helvetica-Bold", A["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique", A["ArialUnicodeMS-Italic"] = "Helvetica-Oblique", A["Courier-BoldItalic"] = "Courier-BoldOblique", A["Courier-Italic"] = "Courier-Oblique", A.CourierNew = "Courier", A["CourierNew-Bold"] = "Courier-Bold", A["CourierNew-BoldItalic"] = "Courier-BoldOblique", A["CourierNew-Italic"] = "Courier-Oblique", A["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique", A["CourierNewPS-BoldMT"] = "Courier-Bold", A["CourierNewPS-ItalicMT"] = "Courier-Oblique", A.CourierNewPSMT = "Courier", A["Helvetica-BoldItalic"] = "Helvetica-BoldOblique", A["Helvetica-Italic"] = "Helvetica-Oblique", A["Symbol-Bold"] = "Symbol", A["Symbol-BoldItalic"] = "Symbol", A["Symbol-Italic"] = "Symbol", A.TimesNewRoman = "Times-Roman", A["TimesNewRoman-Bold"] = "Times-Bold", A["TimesNewRoman-BoldItalic"] = "Times-BoldItalic", A["TimesNewRoman-Italic"] = "Times-Italic", A.TimesNewRomanPS = "Times-Roman", A["TimesNewRomanPS-Bold"] = "Times-Bold", A["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic", A["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic", A["TimesNewRomanPS-BoldMT"] = "Times-Bold", A["TimesNewRomanPS-Italic"] = "Times-Italic", A["TimesNewRomanPS-ItalicMT"] = "Times-Italic", A.TimesNewRomanPSMT = "Times-Roman", A["TimesNewRomanPSMT-Bold"] = "Times-Bold", A["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic", A["TimesNewRomanPSMT-Italic"] = "Times-Italic";
})), c5 = DA((function(A) {
  A.Courier = "FoxitFixed.pfb", A["Courier-Bold"] = "FoxitFixedBold.pfb", A["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb", A["Courier-Oblique"] = "FoxitFixedItalic.pfb", A.Helvetica = "LiberationSans-Regular.ttf", A["Helvetica-Bold"] = "LiberationSans-Bold.ttf", A["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf", A["Helvetica-Oblique"] = "LiberationSans-Italic.ttf", A["Times-Roman"] = "FoxitSerif.pfb", A["Times-Bold"] = "FoxitSerifBold.pfb", A["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb", A["Times-Italic"] = "FoxitSerifItalic.pfb", A.Symbol = "FoxitSymbol.pfb", A.ZapfDingbats = "FoxitDingbats.pfb", A["LiberationSans-Regular"] = "LiberationSans-Regular.ttf", A["LiberationSans-Bold"] = "LiberationSans-Bold.ttf", A["LiberationSans-Italic"] = "LiberationSans-Italic.ttf", A["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
})), EE = DA((function(A) {
  A.Calibri = "Helvetica", A["Calibri-Bold"] = "Helvetica-Bold", A["Calibri-BoldItalic"] = "Helvetica-BoldOblique", A["Calibri-Italic"] = "Helvetica-Oblique", A.CenturyGothic = "Helvetica", A["CenturyGothic-Bold"] = "Helvetica-Bold", A["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique", A["CenturyGothic-Italic"] = "Helvetica-Oblique", A.ComicSansMS = "Comic Sans MS", A["ComicSansMS-Bold"] = "Comic Sans MS-Bold", A["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic", A["ComicSansMS-Italic"] = "Comic Sans MS-Italic", A.Impact = "Helvetica", A["ItcSymbol-Bold"] = "Helvetica-Bold", A["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique", A["ItcSymbol-Book"] = "Helvetica", A["ItcSymbol-BookItalic"] = "Helvetica-Oblique", A["ItcSymbol-Medium"] = "Helvetica", A["ItcSymbol-MediumItalic"] = "Helvetica-Oblique", A.LucidaConsole = "Courier", A["LucidaConsole-Bold"] = "Courier-Bold", A["LucidaConsole-BoldItalic"] = "Courier-BoldOblique", A["LucidaConsole-Italic"] = "Courier-Oblique", A["LucidaSans-Demi"] = "Helvetica-Bold", A["MS-Gothic"] = "MS Gothic", A["MS-Gothic-Bold"] = "MS Gothic-Bold", A["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic", A["MS-Gothic-Italic"] = "MS Gothic-Italic", A["MS-Mincho"] = "MS Mincho", A["MS-Mincho-Bold"] = "MS Mincho-Bold", A["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic", A["MS-Mincho-Italic"] = "MS Mincho-Italic", A["MS-PGothic"] = "MS PGothic", A["MS-PGothic-Bold"] = "MS PGothic-Bold", A["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic", A["MS-PGothic-Italic"] = "MS PGothic-Italic", A["MS-PMincho"] = "MS PMincho", A["MS-PMincho-Bold"] = "MS PMincho-Bold", A["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic", A["MS-PMincho-Italic"] = "MS PMincho-Italic", A.NuptialScript = "Times-Italic", A.SegoeUISymbol = "Helvetica";
})), Nl = DA((function(A) {
  A["Adobe Jenson"] = !0, A["Adobe Text"] = !0, A.Albertus = !0, A.Aldus = !0, A.Alexandria = !0, A.Algerian = !0, A["American Typewriter"] = !0, A.Antiqua = !0, A.Apex = !0, A.Arno = !0, A.Aster = !0, A.Aurora = !0, A.Baskerville = !0, A.Bell = !0, A.Bembo = !0, A["Bembo Schoolbook"] = !0, A.Benguiat = !0, A["Berkeley Old Style"] = !0, A["Bernhard Modern"] = !0, A["Berthold City"] = !0, A.Bodoni = !0, A["Bauer Bodoni"] = !0, A["Book Antiqua"] = !0, A.Bookman = !0, A["Bordeaux Roman"] = !0, A["Californian FB"] = !0, A.Calisto = !0, A.Calvert = !0, A.Capitals = !0, A.Cambria = !0, A.Cartier = !0, A.Caslon = !0, A.Catull = !0, A.Centaur = !0, A["Century Old Style"] = !0, A["Century Schoolbook"] = !0, A.Chaparral = !0, A["Charis SIL"] = !0, A.Cheltenham = !0, A["Cholla Slab"] = !0, A.Clarendon = !0, A.Clearface = !0, A.Cochin = !0, A.Colonna = !0, A["Computer Modern"] = !0, A["Concrete Roman"] = !0, A.Constantia = !0, A["Cooper Black"] = !0, A.Corona = !0, A.Ecotype = !0, A.Egyptienne = !0, A.Elephant = !0, A.Excelsior = !0, A.Fairfield = !0, A["FF Scala"] = !0, A.Folkard = !0, A.Footlight = !0, A.FreeSerif = !0, A["Friz Quadrata"] = !0, A.Garamond = !0, A.Gentium = !0, A.Georgia = !0, A.Gloucester = !0, A["Goudy Old Style"] = !0, A["Goudy Schoolbook"] = !0, A["Goudy Pro Font"] = !0, A.Granjon = !0, A["Guardian Egyptian"] = !0, A.Heather = !0, A.Hercules = !0, A["High Tower Text"] = !0, A.Hiroshige = !0, A["Hoefler Text"] = !0, A["Humana Serif"] = !0, A.Imprint = !0, A["Ionic No. 5"] = !0, A.Janson = !0, A.Joanna = !0, A.Korinna = !0, A.Lexicon = !0, A.LiberationSerif = !0, A["Liberation Serif"] = !0, A["Linux Libertine"] = !0, A.Literaturnaya = !0, A.Lucida = !0, A["Lucida Bright"] = !0, A.Melior = !0, A.Memphis = !0, A.Miller = !0, A.Minion = !0, A.Modern = !0, A["Mona Lisa"] = !0, A["Mrs Eaves"] = !0, A["MS Serif"] = !0, A["Museo Slab"] = !0, A["New York"] = !0, A["Nimbus Roman"] = !0, A["NPS Rawlinson Roadway"] = !0, A.NuptialScript = !0, A.Palatino = !0, A.Perpetua = !0, A.Plantin = !0, A["Plantin Schoolbook"] = !0, A.Playbill = !0, A["Poor Richard"] = !0, A["Rawlinson Roadway"] = !0, A.Renault = !0, A.Requiem = !0, A.Rockwell = !0, A.Roman = !0, A["Rotis Serif"] = !0, A.Sabon = !0, A.Scala = !0, A.Seagull = !0, A.Sistina = !0, A.Souvenir = !0, A.STIX = !0, A["Stone Informal"] = !0, A["Stone Serif"] = !0, A.Sylfaen = !0, A.Times = !0, A.Trajan = !0, A.Trinité = !0, A["Trump Mediaeval"] = !0, A.Utopia = !0, A["Vale Type"] = !0, A["Bitstream Vera"] = !0, A["Vera Serif"] = !0, A.Versailles = !0, A.Wanted = !0, A.Weiss = !0, A["Wide Latin"] = !0, A.Windsor = !0, A.XITS = !0;
})), Kh = DA((function(A) {
  A.Dingbats = !0, A.Symbol = !0, A.ZapfDingbats = !0, A.Wingdings = !0, A["Wingdings-Bold"] = !0, A["Wingdings-Regular"] = !0;
})), qC = DA((function(A) {
  A[2] = 10, A[3] = 32, A[4] = 33, A[5] = 34, A[6] = 35, A[7] = 36, A[8] = 37, A[9] = 38, A[10] = 39, A[11] = 40, A[12] = 41, A[13] = 42, A[14] = 43, A[15] = 44, A[16] = 45, A[17] = 46, A[18] = 47, A[19] = 48, A[20] = 49, A[21] = 50, A[22] = 51, A[23] = 52, A[24] = 53, A[25] = 54, A[26] = 55, A[27] = 56, A[28] = 57, A[29] = 58, A[30] = 894, A[31] = 60, A[32] = 61, A[33] = 62, A[34] = 63, A[35] = 64, A[36] = 65, A[37] = 66, A[38] = 67, A[39] = 68, A[40] = 69, A[41] = 70, A[42] = 71, A[43] = 72, A[44] = 73, A[45] = 74, A[46] = 75, A[47] = 76, A[48] = 77, A[49] = 78, A[50] = 79, A[51] = 80, A[52] = 81, A[53] = 82, A[54] = 83, A[55] = 84, A[56] = 85, A[57] = 86, A[58] = 87, A[59] = 88, A[60] = 89, A[61] = 90, A[62] = 91, A[63] = 92, A[64] = 93, A[65] = 94, A[66] = 95, A[67] = 96, A[68] = 97, A[69] = 98, A[70] = 99, A[71] = 100, A[72] = 101, A[73] = 102, A[74] = 103, A[75] = 104, A[76] = 105, A[77] = 106, A[78] = 107, A[79] = 108, A[80] = 109, A[81] = 110, A[82] = 111, A[83] = 112, A[84] = 113, A[85] = 114, A[86] = 115, A[87] = 116, A[88] = 117, A[89] = 118, A[90] = 119, A[91] = 120, A[92] = 121, A[93] = 122, A[94] = 123, A[95] = 124, A[96] = 125, A[97] = 126, A[98] = 196, A[99] = 197, A[100] = 199, A[101] = 201, A[102] = 209, A[103] = 214, A[104] = 220, A[105] = 225, A[106] = 224, A[107] = 226, A[108] = 228, A[109] = 227, A[110] = 229, A[111] = 231, A[112] = 233, A[113] = 232, A[114] = 234, A[115] = 235, A[116] = 237, A[117] = 236, A[118] = 238, A[119] = 239, A[120] = 241, A[121] = 243, A[122] = 242, A[123] = 244, A[124] = 246, A[125] = 245, A[126] = 250, A[127] = 249, A[128] = 251, A[129] = 252, A[130] = 8224, A[131] = 176, A[132] = 162, A[133] = 163, A[134] = 167, A[135] = 8226, A[136] = 182, A[137] = 223, A[138] = 174, A[139] = 169, A[140] = 8482, A[141] = 180, A[142] = 168, A[143] = 8800, A[144] = 198, A[145] = 216, A[146] = 8734, A[147] = 177, A[148] = 8804, A[149] = 8805, A[150] = 165, A[151] = 181, A[152] = 8706, A[153] = 8721, A[154] = 8719, A[156] = 8747, A[157] = 170, A[158] = 186, A[159] = 8486, A[160] = 230, A[161] = 248, A[162] = 191, A[163] = 161, A[164] = 172, A[165] = 8730, A[166] = 402, A[167] = 8776, A[168] = 8710, A[169] = 171, A[170] = 187, A[171] = 8230, A[179] = 8220, A[180] = 8221, A[181] = 8216, A[182] = 8217, A[200] = 193, A[203] = 205, A[207] = 211, A[210] = 218, A[223] = 711, A[224] = 321, A[225] = 322, A[226] = 352, A[227] = 353, A[228] = 381, A[229] = 382, A[233] = 221, A[234] = 253, A[252] = 263, A[253] = 268, A[254] = 269, A[258] = 258, A[260] = 260, A[261] = 261, A[265] = 280, A[266] = 281, A[267] = 282, A[268] = 283, A[269] = 313, A[275] = 323, A[276] = 324, A[278] = 328, A[283] = 344, A[284] = 345, A[285] = 346, A[286] = 347, A[292] = 367, A[295] = 377, A[296] = 378, A[298] = 380, A[305] = 963, A[306] = 964, A[307] = 966, A[308] = 8215, A[309] = 8252, A[310] = 8319, A[311] = 8359, A[312] = 8592, A[313] = 8593, A[337] = 9552, A[493] = 1039, A[494] = 1040, A[672] = 1488, A[673] = 1489, A[674] = 1490, A[675] = 1491, A[676] = 1492, A[677] = 1493, A[678] = 1494, A[679] = 1495, A[680] = 1496, A[681] = 1497, A[682] = 1498, A[683] = 1499, A[684] = 1500, A[685] = 1501, A[686] = 1502, A[687] = 1503, A[688] = 1504, A[689] = 1505, A[690] = 1506, A[691] = 1507, A[692] = 1508, A[693] = 1509, A[694] = 1510, A[695] = 1511, A[696] = 1512, A[697] = 1513, A[698] = 1514, A[705] = 1524, A[706] = 8362, A[710] = 64288, A[711] = 64298, A[759] = 1617, A[761] = 1776, A[763] = 1778, A[775] = 1652, A[777] = 1764, A[778] = 1780, A[779] = 1781, A[780] = 1782, A[782] = 771, A[783] = 64726, A[786] = 8363, A[788] = 8532, A[790] = 768, A[791] = 769, A[792] = 768, A[795] = 803, A[797] = 64336, A[798] = 64337, A[799] = 64342, A[800] = 64343, A[801] = 64344, A[802] = 64345, A[803] = 64362, A[804] = 64363, A[805] = 64364, A[2424] = 7821, A[2425] = 7822, A[2426] = 7823, A[2427] = 7824, A[2428] = 7825, A[2429] = 7826, A[2430] = 7827, A[2433] = 7682, A[2678] = 8045, A[2679] = 8046, A[2830] = 1552, A[2838] = 686, A[2840] = 751, A[2842] = 753, A[2843] = 754, A[2844] = 755, A[2846] = 757, A[2856] = 767, A[2857] = 848, A[2858] = 849, A[2862] = 853, A[2863] = 854, A[2864] = 855, A[2865] = 861, A[2866] = 862, A[2906] = 7460, A[2908] = 7462, A[2909] = 7463, A[2910] = 7464, A[2912] = 7466, A[2913] = 7467, A[2914] = 7468, A[2916] = 7470, A[2917] = 7471, A[2918] = 7472, A[2920] = 7474, A[2921] = 7475, A[2922] = 7476, A[2924] = 7478, A[2925] = 7479, A[2926] = 7480, A[2928] = 7482, A[2929] = 7483, A[2930] = 7484, A[2932] = 7486, A[2933] = 7487, A[2934] = 7488, A[2936] = 7490, A[2937] = 7491, A[2938] = 7492, A[2940] = 7494, A[2941] = 7495, A[2942] = 7496, A[2944] = 7498, A[2946] = 7500, A[2948] = 7502, A[2950] = 7504, A[2951] = 7505, A[2952] = 7506, A[2954] = 7508, A[2955] = 7509, A[2956] = 7510, A[2958] = 7512, A[2959] = 7513, A[2960] = 7514, A[2962] = 7516, A[2963] = 7517, A[2964] = 7518, A[2966] = 7520, A[2967] = 7521, A[2968] = 7522, A[2970] = 7524, A[2971] = 7525, A[2972] = 7526, A[2974] = 7528, A[2975] = 7529, A[2976] = 7530, A[2978] = 1537, A[2979] = 1538, A[2980] = 1539, A[2982] = 1549, A[2983] = 1551, A[2984] = 1552, A[2986] = 1554, A[2987] = 1555, A[2988] = 1556, A[2990] = 1623, A[2991] = 1624, A[2995] = 1775, A[2999] = 1791, A[3002] = 64290, A[3003] = 64291, A[3004] = 64292, A[3006] = 64294, A[3007] = 64295, A[3008] = 64296, A[3011] = 1900, A[3014] = 8223, A[3015] = 8244, A[3017] = 7532, A[3018] = 7533, A[3019] = 7534, A[3075] = 7590, A[3076] = 7591, A[3079] = 7594, A[3080] = 7595, A[3083] = 7598, A[3084] = 7599, A[3087] = 7602, A[3088] = 7603, A[3091] = 7606, A[3092] = 7607, A[3095] = 7610, A[3096] = 7611, A[3099] = 7614, A[3100] = 7615, A[3103] = 7618, A[3104] = 7619, A[3107] = 8337, A[3108] = 8338, A[3116] = 1884, A[3119] = 1885, A[3120] = 1885, A[3123] = 1886, A[3124] = 1886, A[3127] = 1887, A[3128] = 1887, A[3131] = 1888, A[3132] = 1888, A[3135] = 1889, A[3136] = 1889, A[3139] = 1890, A[3140] = 1890, A[3143] = 1891, A[3144] = 1891, A[3147] = 1892, A[3148] = 1892, A[3153] = 580, A[3154] = 581, A[3157] = 584, A[3158] = 585, A[3161] = 588, A[3162] = 589, A[3165] = 891, A[3166] = 892, A[3169] = 1274, A[3170] = 1275, A[3173] = 1278, A[3174] = 1279, A[3181] = 7622, A[3182] = 7623, A[3282] = 11799, A[3316] = 578, A[3379] = 42785, A[3393] = 1159, A[3416] = 8377;
})), h5 = DA((function(A) {
  A[227] = 322, A[264] = 261, A[291] = 346;
})), l5 = DA((function(A) {
  A[1] = 32, A[4] = 65, A[5] = 192, A[6] = 193, A[9] = 196, A[17] = 66, A[18] = 67, A[21] = 268, A[24] = 68, A[28] = 69, A[29] = 200, A[30] = 201, A[32] = 282, A[38] = 70, A[39] = 71, A[44] = 72, A[47] = 73, A[48] = 204, A[49] = 205, A[58] = 74, A[60] = 75, A[62] = 76, A[68] = 77, A[69] = 78, A[75] = 79, A[76] = 210, A[80] = 214, A[87] = 80, A[89] = 81, A[90] = 82, A[92] = 344, A[94] = 83, A[97] = 352, A[100] = 84, A[104] = 85, A[109] = 220, A[115] = 86, A[116] = 87, A[121] = 88, A[122] = 89, A[124] = 221, A[127] = 90, A[129] = 381, A[258] = 97, A[259] = 224, A[260] = 225, A[263] = 228, A[268] = 261, A[271] = 98, A[272] = 99, A[273] = 263, A[275] = 269, A[282] = 100, A[286] = 101, A[287] = 232, A[288] = 233, A[290] = 283, A[295] = 281, A[296] = 102, A[336] = 103, A[346] = 104, A[349] = 105, A[350] = 236, A[351] = 237, A[361] = 106, A[364] = 107, A[367] = 108, A[371] = 322, A[373] = 109, A[374] = 110, A[381] = 111, A[382] = 242, A[383] = 243, A[386] = 246, A[393] = 112, A[395] = 113, A[396] = 114, A[398] = 345, A[400] = 115, A[401] = 347, A[403] = 353, A[410] = 116, A[437] = 117, A[442] = 252, A[448] = 118, A[449] = 119, A[454] = 120, A[455] = 121, A[457] = 253, A[460] = 122, A[462] = 382, A[463] = 380, A[853] = 44, A[855] = 58, A[856] = 46, A[876] = 47, A[878] = 45, A[882] = 45, A[894] = 40, A[895] = 41, A[896] = 91, A[897] = 93, A[923] = 64, A[1004] = 48, A[1005] = 49, A[1006] = 50, A[1007] = 51, A[1008] = 52, A[1009] = 53, A[1010] = 54, A[1011] = 55, A[1012] = 56, A[1013] = 57, A[1081] = 37, A[1085] = 43, A[1086] = 45;
}));
function PC(A) {
  const t = Dr(A);
  return dg()[t];
}
function _C(A) {
  const t = Dr(A);
  return !!(dg()[t] || EE()[t] || Nl()[t] || Kh()[t]);
}
class Tn {
  constructor(t = []) {
    this._map = t;
  }
  get length() {
    return this._map.length;
  }
  forEach(t) {
    for (const e in this._map) t(e, this._map[e].charCodeAt(0));
  }
  has(t) {
    return this._map[t] !== void 0;
  }
  get(t) {
    return this._map[t];
  }
  charCodeOf(t) {
    const e = this._map;
    if (e.length <= 65536) return e.indexOf(t);
    for (const i in e) if (e[i] === t) return 0 | i;
    return -1;
  }
  amend(t) {
    for (const e in t) this._map[e] = t[e];
  }
}
class ti {
  constructor(t, e) {
    this.firstChar = t, this.lastChar = e;
  }
  get length() {
    return this.lastChar + 1 - this.firstChar;
  }
  forEach(t) {
    for (let e = this.firstChar, i = this.lastChar; e <= i; e++) t(e, e);
  }
  has(t) {
    return this.firstChar <= t && t <= this.lastChar;
  }
  get(t) {
    if (this.firstChar <= t && t <= this.lastChar) return String.fromCharCode(t);
  }
  charCodeOf(t) {
    return Number.isInteger(t) && t >= this.firstChar && t <= this.lastChar ? t : -1;
  }
  amend(t) {
    oA("Should not call amend()");
  }
}
class Xc {
  constructor(t, e) {
    this.properties = e;
    const i = new Rl(t, e, cr);
    this.cff = i.parse(), this.cff.duplicateFirstGlyph();
    const s = new br(this.cff);
    this.seacs = this.cff.seacs;
    try {
      this.data = s.compile();
    } catch {
      O("Failed to compile font " + e.loadedName), this.data = t;
    }
    this._createBuiltInEncoding();
  }
  get numGlyphs() {
    return this.cff.charStrings.count;
  }
  getCharset() {
    return this.cff.charset.charset;
  }
  getGlyphMapping() {
    const t = this.cff, e = this.properties, { cidToGidMap: i, cMap: s } = e, n = t.charset.charset;
    let o, r;
    if (e.composite) {
      let h, I;
      if (i?.length > 0) {
        h = /* @__PURE__ */ Object.create(null);
        for (let C = 0, d = i.length; C < d; C++) {
          const u = i[C];
          u !== void 0 && (h[u] = C);
        }
      }
      if (o = /* @__PURE__ */ Object.create(null), t.isCIDFont) for (r = 0; r < n.length; r++) {
        const C = n[r];
        I = s.charCodeOf(C), h?.[I] !== void 0 && (I = h[I]), o[I] = r;
      }
      else for (r = 0; r < t.charStrings.count; r++) I = s.charCodeOf(r), o[I] = r;
      return o;
    }
    let c = t.encoding ? t.encoding.encoding : null;
    return e.isInternalFont && (c = e.defaultEncoding), o = QE(e, c, n), o;
  }
  hasGlyphId(t) {
    return this.cff.hasGlyphId(t);
  }
  _createBuiltInEncoding() {
    const { charset: t, encoding: e } = this.cff;
    if (!t || !e) return;
    const i = t.charset, s = e.encoding, n = [];
    for (const o in s) {
      const r = s[o];
      if (r >= 0) {
        const c = i[r];
        c && (n[o] = c);
      }
    }
    n.length > 0 && (this.properties.builtInEncoding = n);
  }
}
function Ki(A, t) {
  return (A[t] << 24 | A[t + 1] << 16 | A[t + 2] << 8 | A[t + 3]) >>> 0;
}
function VA(A, t) {
  return A[t] << 8 | A[t + 1];
}
function xa(A, t) {
  return (A[t] << 24 | A[t + 1] << 16) >> 16;
}
function OC(A, t) {
  return A[t] << 24 >> 24;
}
function Os(A, t) {
  return xa(A, t) / 16384;
}
function qh(A) {
  const t = A.length;
  let e = 32768;
  return t < 1240 ? e = 107 : t < 33900 && (e = 1131), e;
}
function I5(A, t, e) {
  const i = VA(A, t + 2) === 1 ? Ki(A, t + 8) : Ki(A, t + 16), s = VA(A, t + i);
  let n, o, r;
  if (s === 4) {
    VA(A, t + i + 2);
    const c = VA(A, t + i + 6) >> 1;
    for (o = t + i + 14, n = [], r = 0; r < c; r++, o += 2) n[r] = { end: VA(A, o) };
    for (o += 2, r = 0; r < c; r++, o += 2) n[r].start = VA(A, o);
    for (r = 0; r < c; r++, o += 2) n[r].idDelta = VA(A, o);
    for (r = 0; r < c; r++, o += 2) {
      let h = VA(A, o);
      if (h !== 0) {
        n[r].ids = [];
        for (let I = 0, C = n[r].end - n[r].start + 1; I < C; I++) n[r].ids[I] = VA(A, o + h), h += 2;
      }
    }
    return n;
  }
  if (s === 12) {
    const c = Ki(A, t + i + 12);
    for (o = t + i + 16, n = [], r = 0; r < c; r++) t = Ki(A, o), n.push({ start: t, end: Ki(A, o + 4), idDelta: Ki(A, o + 8) - t }), o += 12;
    return n;
  }
  throw new Ct(`unsupported cmap: ${s}`);
}
function C5(A, t, e, i) {
  const s = new Rl(new RA(A, t, e - t), {}, i).parse();
  return { glyphs: s.charStrings.objects, subrs: s.topDict.privateDict?.subrsIndex?.objects, gsubrs: s.globalSubrIndex?.objects, isCFFCIDFont: s.isCIDFont, fdSelect: s.fdSelect, fdArray: s.fdArray };
}
function Vo(A, t) {
  const e = t.codePointAt(0);
  let i = 0, s = 0, n = A.length - 1;
  for (; s < n; ) {
    const o = s + n + 1 >> 1;
    e < A[o].start ? n = o - 1 : s = o;
  }
  return A[s].start <= e && e <= A[s].end && (i = A[s].idDelta + (A[s].ids ? A[s].ids[e - A[s].start] : e) & 65535), { charCode: e, glyphId: i };
}
function fE(A, t, e) {
  function i(C, d) {
    t.add(OQ, [C, d]);
  }
  function s(C, d) {
    t.add(WQ, [C, d]);
  }
  function n(C, d, u, E) {
    t.add(Km, [C, d, u, E]);
  }
  let o = 0;
  const r = xa(A, o);
  let c, h = 0, I = 0;
  if (o += 10, r < 0) do {
    c = VA(A, o);
    const C = VA(A, o + 2);
    let d, u;
    o += 4, 1 & c ? (2 & c ? (d = xa(A, o), u = xa(A, o + 2)) : (d = VA(A, o), u = VA(A, o + 2)), o += 4) : 2 & c ? (d = OC(A, o++), u = OC(A, o++)) : (d = A[o++], u = A[o++]), 2 & c ? (h = d, I = u) : (h = 0, I = 0);
    let E = 1, p = 1, y = 0, b = 0;
    8 & c ? (E = p = Os(A, o), o += 2) : 64 & c ? (E = Os(A, o), p = Os(A, o + 2), o += 4) : 128 & c && (E = Os(A, o), y = Os(A, o + 2), b = Os(A, o + 4), p = Os(A, o + 6), o += 8);
    const D = e.glyphs[C];
    D && (t.add(ml), t.add(jQ, [E, y, b, p, h, I]), fE(D, t, e), t.add(pl));
  } while (32 & c);
  else {
    const C = [];
    let d, u;
    for (d = 0; d < r; d++) C.push(VA(A, o)), o += 2;
    o += 2 + VA(A, o);
    const E = C.at(-1) + 1, p = [];
    for (; p.length < E; ) {
      c = A[o++];
      let b = 1;
      for (8 & c && (b += A[o++]); b-- > 0; ) p.push({ flags: c });
    }
    for (d = 0; d < E; d++) {
      switch (18 & p[d].flags) {
        case 0:
          h += xa(A, o), o += 2;
          break;
        case 2:
          h -= A[o++];
          break;
        case 18:
          h += A[o++];
      }
      p[d].x = h;
    }
    for (d = 0; d < E; d++) {
      switch (36 & p[d].flags) {
        case 0:
          I += xa(A, o), o += 2;
          break;
        case 4:
          I -= A[o++];
          break;
        case 36:
          I += A[o++];
      }
      p[d].y = I;
    }
    let y = 0;
    for (o = 0; o < r; o++) {
      const b = C[o], D = p.slice(y, b + 1);
      if (1 & D[0].flags) D.push(D[0]);
      else if (1 & D.at(-1).flags) D.unshift(D.at(-1));
      else {
        const S = { flags: 1, x: (D[0].x + D.at(-1).x) / 2, y: (D[0].y + D.at(-1).y) / 2 };
        D.unshift(S), D.push(S);
      }
      for (i(D[0].x, D[0].y), d = 1, u = D.length; d < u; d++) 1 & D[d].flags ? s(D[d].x, D[d].y) : 1 & D[d + 1].flags ? (n(D[d].x, D[d].y, D[d + 1].x, D[d + 1].y), d++) : n(D[d].x, D[d].y, (D[d].x + D[d + 1].x) / 2, (D[d].y + D[d + 1].y) / 2);
      y = b + 1;
    }
  }
}
function Ph(A, t, e, i) {
  function s(C, d) {
    t.add(OQ, [C, d]);
  }
  function n(C, d) {
    t.add(WQ, [C, d]);
  }
  function o(C, d, u, E, p, y) {
    t.add(Tm, [C, d, u, E, p, y]);
  }
  const r = [];
  let c = 0, h = 0, I = 0;
  (function C(d) {
    let u = 0;
    for (; u < d.length; ) {
      let E, p, y, b, D, S, R, x, N, U = !1, T = d[u++];
      switch (T) {
        case 1:
        case 3:
        case 18:
        case 23:
          I += r.length >> 1, U = !0;
          break;
        case 4:
          h += r.pop(), s(c, h), U = !0;
          break;
        case 5:
          for (; r.length > 0; ) c += r.shift(), h += r.shift(), n(c, h);
          break;
        case 6:
          for (; r.length > 0 && (c += r.shift(), n(c, h), r.length !== 0); ) h += r.shift(), n(c, h);
          break;
        case 7:
          for (; r.length > 0 && (h += r.shift(), n(c, h), r.length !== 0); ) c += r.shift(), n(c, h);
          break;
        case 8:
          for (; r.length > 0; ) E = c + r.shift(), y = h + r.shift(), p = E + r.shift(), b = y + r.shift(), c = p + r.shift(), h = b + r.shift(), o(E, y, p, b, c, h);
          break;
        case 10:
          if (x = r.pop(), N = null, e.isCFFCIDFont) {
            const q = e.fdSelect.getFDIndex(i);
            if (q >= 0 && q < e.fdArray.length) {
              const _ = e.fdArray[q];
              let Y;
              _.privateDict?.subrsIndex && (Y = _.privateDict.subrsIndex.objects), Y && (x += qh(Y), N = Y[x]);
            } else O("Invalid fd index for glyph index.");
          } else N = e.subrs[x + e.subrsBias];
          N && C(N);
          break;
        case 11:
          return;
        case 12:
          switch (T = d[u++], T) {
            case 34:
              E = c + r.shift(), p = E + r.shift(), D = h + r.shift(), c = p + r.shift(), o(E, h, p, D, c, D), E = c + r.shift(), p = E + r.shift(), c = p + r.shift(), o(E, D, p, h, c, h);
              break;
            case 35:
              E = c + r.shift(), y = h + r.shift(), p = E + r.shift(), b = y + r.shift(), c = p + r.shift(), h = b + r.shift(), o(E, y, p, b, c, h), E = c + r.shift(), y = h + r.shift(), p = E + r.shift(), b = y + r.shift(), c = p + r.shift(), h = b + r.shift(), o(E, y, p, b, c, h), r.pop();
              break;
            case 36:
              E = c + r.shift(), D = h + r.shift(), p = E + r.shift(), S = D + r.shift(), c = p + r.shift(), o(E, D, p, S, c, S), E = c + r.shift(), p = E + r.shift(), R = S + r.shift(), c = p + r.shift(), o(E, S, p, R, c, h);
              break;
            case 37:
              const q = c, _ = h;
              E = c + r.shift(), y = h + r.shift(), p = E + r.shift(), b = y + r.shift(), c = p + r.shift(), h = b + r.shift(), o(E, y, p, b, c, h), E = c + r.shift(), y = h + r.shift(), p = E + r.shift(), b = y + r.shift(), c = p, h = b, Math.abs(c - q) > Math.abs(h - _) ? c += r.shift() : h += r.shift(), o(E, y, p, b, c, h);
              break;
            default:
              throw new Ct(`unknown operator: 12 ${T}`);
          }
          break;
        case 14:
          if (r.length >= 4) {
            const q = r.pop(), _ = r.pop();
            h = r.pop(), c = r.pop(), t.add(ml), t.add(Pm, [c, h]);
            let Y = Vo(e.cmap, String.fromCharCode(e.glyphNameMap[Vi[q]]));
            Ph(e.glyphs[Y.glyphId], t, e, Y.glyphId), t.add(pl), Y = Vo(e.cmap, String.fromCharCode(e.glyphNameMap[Vi[_]])), Ph(e.glyphs[Y.glyphId], t, e, Y.glyphId);
          }
          return;
        case 19:
        case 20:
          I += r.length >> 1, u += I + 7 >> 3, U = !0;
          break;
        case 21:
          h += r.pop(), c += r.pop(), s(c, h), U = !0;
          break;
        case 22:
          c += r.pop(), s(c, h), U = !0;
          break;
        case 24:
          for (; r.length > 2; ) E = c + r.shift(), y = h + r.shift(), p = E + r.shift(), b = y + r.shift(), c = p + r.shift(), h = b + r.shift(), o(E, y, p, b, c, h);
          c += r.shift(), h += r.shift(), n(c, h);
          break;
        case 25:
          for (; r.length > 6; ) c += r.shift(), h += r.shift(), n(c, h);
          E = c + r.shift(), y = h + r.shift(), p = E + r.shift(), b = y + r.shift(), c = p + r.shift(), h = b + r.shift(), o(E, y, p, b, c, h);
          break;
        case 26:
          for (r.length % 2 && (c += r.shift()); r.length > 0; ) E = c, y = h + r.shift(), p = E + r.shift(), b = y + r.shift(), c = p, h = b + r.shift(), o(E, y, p, b, c, h);
          break;
        case 27:
          for (r.length % 2 && (h += r.shift()); r.length > 0; ) E = c + r.shift(), y = h, p = E + r.shift(), b = y + r.shift(), c = p + r.shift(), h = b, o(E, y, p, b, c, h);
          break;
        case 28:
          r.push((d[u] << 24 | d[u + 1] << 16) >> 16), u += 2;
          break;
        case 29:
          x = r.pop() + e.gsubrsBias, N = e.gsubrs[x], N && C(N);
          break;
        case 30:
          for (; r.length > 0 && (E = c, y = h + r.shift(), p = E + r.shift(), b = y + r.shift(), c = p + r.shift(), h = b + (r.length === 1 ? r.shift() : 0), o(E, y, p, b, c, h), r.length !== 0); ) E = c + r.shift(), y = h, p = E + r.shift(), b = y + r.shift(), h = b + r.shift(), c = p + (r.length === 1 ? r.shift() : 0), o(E, y, p, b, c, h);
          break;
        case 31:
          for (; r.length > 0 && (E = c + r.shift(), y = h, p = E + r.shift(), b = y + r.shift(), h = b + r.shift(), c = p + (r.length === 1 ? r.shift() : 0), o(E, y, p, b, c, h), r.length !== 0); ) E = c, y = h + r.shift(), p = E + r.shift(), b = y + r.shift(), c = p + r.shift(), h = b + (r.length === 1 ? r.shift() : 0), o(E, y, p, b, c, h);
          break;
        default:
          if (T < 32) throw new Ct(`unknown operator: ${T}`);
          T < 247 ? r.push(T - 139) : T < 251 ? r.push(256 * (T - 247) + d[u++] + 108) : T < 255 ? r.push(256 * -(T - 251) - d[u++] - 108) : (r.push((d[u] << 24 | d[u + 1] << 16 | d[u + 2] << 8 | d[u + 3]) / 65536), u += 4);
      }
      U && (r.length = 0);
    }
  })(A);
}
const WC = [];
class u5 {
  cmds = [];
  add(t, e) {
    if (e) if (Pe(e, null)) this.cmds.push(t, ...e);
    else {
      O(`Commands.add - "${t}" has at least one non-number arg: "${e}".`);
      const i = e.map(((s) => typeof s == "number" ? s : 0));
      this.cmds.push(t, ...i);
    }
    else this.cmds.push(t);
  }
}
class pE {
  constructor(t) {
    this.fontMatrix = t, this.compiledGlyphs = /* @__PURE__ */ Object.create(null), this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
  }
  getPathJs(t) {
    const { charCode: e, glyphId: i } = Vo(this.cmap, t);
    let s, n = this.compiledGlyphs[i];
    if (!n) {
      try {
        n = this.compileGlyph(this.glyphs[i], i);
      } catch (o) {
        n = WC, s = o;
      }
      this.compiledGlyphs[i] = n;
    }
    if (this.compiledCharCodeToGlyphId[e] ??= i, s) throw s;
    return n;
  }
  compileGlyph(t, e) {
    if (!t || t.length === 0 || t[0] === 14) return WC;
    let i = this.fontMatrix;
    if (this.isCFFCIDFont) {
      const n = this.fdSelect.getFDIndex(e);
      n >= 0 && n < this.fdArray.length ? i = this.fdArray[n].getByName("FontMatrix") || aa : O("Invalid fd index for glyph index.");
    }
    const s = new u5();
    return s.add(ml), s.add(jQ, i.slice()), s.add(qm), this.compileGlyphImpl(t, s, e), s.add(pl), s.cmds;
  }
  compileGlyphImpl() {
    oA("Children classes should implement this.");
  }
  hasBuiltPath(t) {
    const { charCode: e, glyphId: i } = Vo(this.cmap, t);
    return this.compiledGlyphs[i] !== void 0 && this.compiledCharCodeToGlyphId[e] !== void 0;
  }
}
class B5 extends pE {
  constructor(t, e, i) {
    super(i || [488e-6, 0, 0, 488e-6, 0, 0]), this.glyphs = t, this.cmap = e;
  }
  compileGlyphImpl(t, e) {
    fE(t, e, this);
  }
}
class d5 extends pE {
  constructor(t, e, i, s) {
    super(i || [1e-3, 0, 0, 1e-3, 0, 0]), this.glyphs = t.glyphs, this.gsubrs = t.gsubrs || [], this.subrs = t.subrs || [], this.cmap = e, this.glyphNameMap = s || mi(), this.gsubrsBias = qh(this.gsubrs), this.subrsBias = qh(this.subrs), this.isCFFCIDFont = t.isCFFCIDFont, this.fdSelect = t.fdSelect, this.fdArray = t.fdArray;
  }
  compileGlyphImpl(t, e, i) {
    Ph(t, e, this, i);
  }
}
class Q5 {
  static create(t, e) {
    const i = new Uint8Array(t.data);
    let s, n, o, r, c, h;
    const I = VA(i, 4);
    for (let C = 0, d = 12; C < I; C++, d += 16) {
      const u = Re(i.subarray(d, d + 4)), E = Ki(i, d + 8), p = Ki(i, d + 12);
      switch (u) {
        case "cmap":
          s = I5(i, E);
          break;
        case "glyf":
          n = i.subarray(E, E + p);
          break;
        case "loca":
          o = i.subarray(E, E + p);
          break;
        case "head":
          h = VA(i, E + 18), c = VA(i, E + 50);
          break;
        case "CFF ":
          r = C5(i, E, E + p, e);
      }
    }
    if (n) {
      const C = h ? [1 / h, 0, 0, 1 / h, 0, 0] : t.fontMatrix;
      return new B5((function(d, u, E) {
        let p, y;
        E ? (p = 4, y = Ki) : (p = 2, y = (S, R) => 2 * VA(S, R));
        const b = [];
        let D = y(u, 0);
        for (let S = p; S < u.length; S += p) {
          const R = y(u, S);
          b.push(d.subarray(D, R)), D = R;
        }
        return b;
      })(n, o, c), s, C);
    }
    return new d5(r, s, t.fontMatrix, t.glyphNameMap);
  }
}
const E5 = DA((function(A) {
  A.Courier = 600, A["Courier-Bold"] = 600, A["Courier-BoldOblique"] = 600, A["Courier-Oblique"] = 600, A.Helvetica = DA((function(t) {
    t.space = 278, t.exclam = 278, t.quotedbl = 355, t.numbersign = 556, t.dollar = 556, t.percent = 889, t.ampersand = 667, t.quoteright = 222, t.parenleft = 333, t.parenright = 333, t.asterisk = 389, t.plus = 584, t.comma = 278, t.hyphen = 333, t.period = 278, t.slash = 278, t.zero = 556, t.one = 556, t.two = 556, t.three = 556, t.four = 556, t.five = 556, t.six = 556, t.seven = 556, t.eight = 556, t.nine = 556, t.colon = 278, t.semicolon = 278, t.less = 584, t.equal = 584, t.greater = 584, t.question = 556, t.at = 1015, t.A = 667, t.B = 667, t.C = 722, t.D = 722, t.E = 667, t.F = 611, t.G = 778, t.H = 722, t.I = 278, t.J = 500, t.K = 667, t.L = 556, t.M = 833, t.N = 722, t.O = 778, t.P = 667, t.Q = 778, t.R = 722, t.S = 667, t.T = 611, t.U = 722, t.V = 667, t.W = 944, t.X = 667, t.Y = 667, t.Z = 611, t.bracketleft = 278, t.backslash = 278, t.bracketright = 278, t.asciicircum = 469, t.underscore = 556, t.quoteleft = 222, t.a = 556, t.b = 556, t.c = 500, t.d = 556, t.e = 556, t.f = 278, t.g = 556, t.h = 556, t.i = 222, t.j = 222, t.k = 500, t.l = 222, t.m = 833, t.n = 556, t.o = 556, t.p = 556, t.q = 556, t.r = 333, t.s = 500, t.t = 278, t.u = 556, t.v = 500, t.w = 722, t.x = 500, t.y = 500, t.z = 500, t.braceleft = 334, t.bar = 260, t.braceright = 334, t.asciitilde = 584, t.exclamdown = 333, t.cent = 556, t.sterling = 556, t.fraction = 167, t.yen = 556, t.florin = 556, t.section = 556, t.currency = 556, t.quotesingle = 191, t.quotedblleft = 333, t.guillemotleft = 556, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 500, t.fl = 500, t.endash = 556, t.dagger = 556, t.daggerdbl = 556, t.periodcentered = 278, t.paragraph = 537, t.bullet = 350, t.quotesinglbase = 222, t.quotedblbase = 333, t.quotedblright = 333, t.guillemotright = 556, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 611, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 1e3, t.ordfeminine = 370, t.Lslash = 556, t.Oslash = 778, t.OE = 1e3, t.ordmasculine = 365, t.ae = 889, t.dotlessi = 278, t.lslash = 222, t.oslash = 611, t.oe = 944, t.germandbls = 611, t.Idieresis = 278, t.eacute = 556, t.abreve = 556, t.uhungarumlaut = 556, t.ecaron = 556, t.Ydieresis = 667, t.divide = 584, t.Yacute = 667, t.Acircumflex = 667, t.aacute = 556, t.Ucircumflex = 722, t.yacute = 500, t.scommaaccent = 500, t.ecircumflex = 556, t.Uring = 722, t.Udieresis = 722, t.aogonek = 556, t.Uacute = 722, t.uogonek = 556, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 737, t.Emacron = 667, t.ccaron = 500, t.aring = 556, t.Ncommaaccent = 722, t.lacute = 222, t.agrave = 556, t.Tcommaaccent = 611, t.Cacute = 722, t.atilde = 556, t.Edotaccent = 667, t.scaron = 500, t.scedilla = 500, t.iacute = 278, t.lozenge = 471, t.Rcaron = 722, t.Gcommaaccent = 778, t.ucircumflex = 556, t.acircumflex = 556, t.Amacron = 667, t.rcaron = 333, t.ccedilla = 500, t.Zdotaccent = 611, t.Thorn = 667, t.Omacron = 778, t.Racute = 722, t.Sacute = 667, t.dcaron = 643, t.Umacron = 722, t.uring = 556, t.threesuperior = 333, t.Ograve = 778, t.Agrave = 667, t.Abreve = 667, t.multiply = 584, t.uacute = 556, t.Tcaron = 611, t.partialdiff = 476, t.ydieresis = 500, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 556, t.edieresis = 556, t.cacute = 500, t.nacute = 556, t.umacron = 556, t.Ncaron = 722, t.Iacute = 278, t.plusminus = 584, t.brokenbar = 260, t.registered = 737, t.Gbreve = 778, t.Idotaccent = 278, t.summation = 600, t.Egrave = 667, t.racute = 333, t.omacron = 556, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 722, t.lcommaaccent = 222, t.tcaron = 317, t.eogonek = 556, t.Uogonek = 722, t.Aacute = 667, t.Adieresis = 667, t.egrave = 556, t.zacute = 500, t.iogonek = 222, t.Oacute = 778, t.oacute = 556, t.amacron = 556, t.sacute = 500, t.idieresis = 278, t.Ocircumflex = 778, t.Ugrave = 722, t.Delta = 612, t.thorn = 556, t.twosuperior = 333, t.Odieresis = 778, t.mu = 556, t.igrave = 278, t.ohungarumlaut = 556, t.Eogonek = 667, t.dcroat = 556, t.threequarters = 834, t.Scedilla = 667, t.lcaron = 299, t.Kcommaaccent = 667, t.Lacute = 556, t.trademark = 1e3, t.edotaccent = 556, t.Igrave = 278, t.Imacron = 278, t.Lcaron = 556, t.onehalf = 834, t.lessequal = 549, t.ocircumflex = 556, t.ntilde = 556, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 556, t.gbreve = 556, t.onequarter = 834, t.Scaron = 667, t.Scommaaccent = 667, t.Ohungarumlaut = 778, t.degree = 400, t.ograve = 556, t.Ccaron = 722, t.ugrave = 556, t.radical = 453, t.Dcaron = 722, t.rcommaaccent = 333, t.Ntilde = 722, t.otilde = 556, t.Rcommaaccent = 722, t.Lcommaaccent = 556, t.Atilde = 667, t.Aogonek = 667, t.Aring = 667, t.Otilde = 778, t.zdotaccent = 500, t.Ecaron = 667, t.Iogonek = 278, t.kcommaaccent = 500, t.minus = 584, t.Icircumflex = 278, t.ncaron = 556, t.tcommaaccent = 278, t.logicalnot = 584, t.odieresis = 556, t.udieresis = 556, t.notequal = 549, t.gcommaaccent = 556, t.eth = 556, t.zcaron = 500, t.ncommaaccent = 556, t.onesuperior = 333, t.imacron = 278, t.Euro = 556;
  })), A["Helvetica-Bold"] = DA((function(t) {
    t.space = 278, t.exclam = 333, t.quotedbl = 474, t.numbersign = 556, t.dollar = 556, t.percent = 889, t.ampersand = 722, t.quoteright = 278, t.parenleft = 333, t.parenright = 333, t.asterisk = 389, t.plus = 584, t.comma = 278, t.hyphen = 333, t.period = 278, t.slash = 278, t.zero = 556, t.one = 556, t.two = 556, t.three = 556, t.four = 556, t.five = 556, t.six = 556, t.seven = 556, t.eight = 556, t.nine = 556, t.colon = 333, t.semicolon = 333, t.less = 584, t.equal = 584, t.greater = 584, t.question = 611, t.at = 975, t.A = 722, t.B = 722, t.C = 722, t.D = 722, t.E = 667, t.F = 611, t.G = 778, t.H = 722, t.I = 278, t.J = 556, t.K = 722, t.L = 611, t.M = 833, t.N = 722, t.O = 778, t.P = 667, t.Q = 778, t.R = 722, t.S = 667, t.T = 611, t.U = 722, t.V = 667, t.W = 944, t.X = 667, t.Y = 667, t.Z = 611, t.bracketleft = 333, t.backslash = 278, t.bracketright = 333, t.asciicircum = 584, t.underscore = 556, t.quoteleft = 278, t.a = 556, t.b = 611, t.c = 556, t.d = 611, t.e = 556, t.f = 333, t.g = 611, t.h = 611, t.i = 278, t.j = 278, t.k = 556, t.l = 278, t.m = 889, t.n = 611, t.o = 611, t.p = 611, t.q = 611, t.r = 389, t.s = 556, t.t = 333, t.u = 611, t.v = 556, t.w = 778, t.x = 556, t.y = 556, t.z = 500, t.braceleft = 389, t.bar = 280, t.braceright = 389, t.asciitilde = 584, t.exclamdown = 333, t.cent = 556, t.sterling = 556, t.fraction = 167, t.yen = 556, t.florin = 556, t.section = 556, t.currency = 556, t.quotesingle = 238, t.quotedblleft = 500, t.guillemotleft = 556, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 611, t.fl = 611, t.endash = 556, t.dagger = 556, t.daggerdbl = 556, t.periodcentered = 278, t.paragraph = 556, t.bullet = 350, t.quotesinglbase = 278, t.quotedblbase = 500, t.quotedblright = 500, t.guillemotright = 556, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 611, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 1e3, t.ordfeminine = 370, t.Lslash = 611, t.Oslash = 778, t.OE = 1e3, t.ordmasculine = 365, t.ae = 889, t.dotlessi = 278, t.lslash = 278, t.oslash = 611, t.oe = 944, t.germandbls = 611, t.Idieresis = 278, t.eacute = 556, t.abreve = 556, t.uhungarumlaut = 611, t.ecaron = 556, t.Ydieresis = 667, t.divide = 584, t.Yacute = 667, t.Acircumflex = 722, t.aacute = 556, t.Ucircumflex = 722, t.yacute = 556, t.scommaaccent = 556, t.ecircumflex = 556, t.Uring = 722, t.Udieresis = 722, t.aogonek = 556, t.Uacute = 722, t.uogonek = 611, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 737, t.Emacron = 667, t.ccaron = 556, t.aring = 556, t.Ncommaaccent = 722, t.lacute = 278, t.agrave = 556, t.Tcommaaccent = 611, t.Cacute = 722, t.atilde = 556, t.Edotaccent = 667, t.scaron = 556, t.scedilla = 556, t.iacute = 278, t.lozenge = 494, t.Rcaron = 722, t.Gcommaaccent = 778, t.ucircumflex = 611, t.acircumflex = 556, t.Amacron = 722, t.rcaron = 389, t.ccedilla = 556, t.Zdotaccent = 611, t.Thorn = 667, t.Omacron = 778, t.Racute = 722, t.Sacute = 667, t.dcaron = 743, t.Umacron = 722, t.uring = 611, t.threesuperior = 333, t.Ograve = 778, t.Agrave = 722, t.Abreve = 722, t.multiply = 584, t.uacute = 611, t.Tcaron = 611, t.partialdiff = 494, t.ydieresis = 556, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 556, t.edieresis = 556, t.cacute = 556, t.nacute = 611, t.umacron = 611, t.Ncaron = 722, t.Iacute = 278, t.plusminus = 584, t.brokenbar = 280, t.registered = 737, t.Gbreve = 778, t.Idotaccent = 278, t.summation = 600, t.Egrave = 667, t.racute = 389, t.omacron = 611, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 722, t.lcommaaccent = 278, t.tcaron = 389, t.eogonek = 556, t.Uogonek = 722, t.Aacute = 722, t.Adieresis = 722, t.egrave = 556, t.zacute = 500, t.iogonek = 278, t.Oacute = 778, t.oacute = 611, t.amacron = 556, t.sacute = 556, t.idieresis = 278, t.Ocircumflex = 778, t.Ugrave = 722, t.Delta = 612, t.thorn = 611, t.twosuperior = 333, t.Odieresis = 778, t.mu = 611, t.igrave = 278, t.ohungarumlaut = 611, t.Eogonek = 667, t.dcroat = 611, t.threequarters = 834, t.Scedilla = 667, t.lcaron = 400, t.Kcommaaccent = 722, t.Lacute = 611, t.trademark = 1e3, t.edotaccent = 556, t.Igrave = 278, t.Imacron = 278, t.Lcaron = 611, t.onehalf = 834, t.lessequal = 549, t.ocircumflex = 611, t.ntilde = 611, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 556, t.gbreve = 611, t.onequarter = 834, t.Scaron = 667, t.Scommaaccent = 667, t.Ohungarumlaut = 778, t.degree = 400, t.ograve = 611, t.Ccaron = 722, t.ugrave = 611, t.radical = 549, t.Dcaron = 722, t.rcommaaccent = 389, t.Ntilde = 722, t.otilde = 611, t.Rcommaaccent = 722, t.Lcommaaccent = 611, t.Atilde = 722, t.Aogonek = 722, t.Aring = 722, t.Otilde = 778, t.zdotaccent = 500, t.Ecaron = 667, t.Iogonek = 278, t.kcommaaccent = 556, t.minus = 584, t.Icircumflex = 278, t.ncaron = 611, t.tcommaaccent = 333, t.logicalnot = 584, t.odieresis = 611, t.udieresis = 611, t.notequal = 549, t.gcommaaccent = 611, t.eth = 611, t.zcaron = 500, t.ncommaaccent = 611, t.onesuperior = 333, t.imacron = 278, t.Euro = 556;
  })), A["Helvetica-BoldOblique"] = DA((function(t) {
    t.space = 278, t.exclam = 333, t.quotedbl = 474, t.numbersign = 556, t.dollar = 556, t.percent = 889, t.ampersand = 722, t.quoteright = 278, t.parenleft = 333, t.parenright = 333, t.asterisk = 389, t.plus = 584, t.comma = 278, t.hyphen = 333, t.period = 278, t.slash = 278, t.zero = 556, t.one = 556, t.two = 556, t.three = 556, t.four = 556, t.five = 556, t.six = 556, t.seven = 556, t.eight = 556, t.nine = 556, t.colon = 333, t.semicolon = 333, t.less = 584, t.equal = 584, t.greater = 584, t.question = 611, t.at = 975, t.A = 722, t.B = 722, t.C = 722, t.D = 722, t.E = 667, t.F = 611, t.G = 778, t.H = 722, t.I = 278, t.J = 556, t.K = 722, t.L = 611, t.M = 833, t.N = 722, t.O = 778, t.P = 667, t.Q = 778, t.R = 722, t.S = 667, t.T = 611, t.U = 722, t.V = 667, t.W = 944, t.X = 667, t.Y = 667, t.Z = 611, t.bracketleft = 333, t.backslash = 278, t.bracketright = 333, t.asciicircum = 584, t.underscore = 556, t.quoteleft = 278, t.a = 556, t.b = 611, t.c = 556, t.d = 611, t.e = 556, t.f = 333, t.g = 611, t.h = 611, t.i = 278, t.j = 278, t.k = 556, t.l = 278, t.m = 889, t.n = 611, t.o = 611, t.p = 611, t.q = 611, t.r = 389, t.s = 556, t.t = 333, t.u = 611, t.v = 556, t.w = 778, t.x = 556, t.y = 556, t.z = 500, t.braceleft = 389, t.bar = 280, t.braceright = 389, t.asciitilde = 584, t.exclamdown = 333, t.cent = 556, t.sterling = 556, t.fraction = 167, t.yen = 556, t.florin = 556, t.section = 556, t.currency = 556, t.quotesingle = 238, t.quotedblleft = 500, t.guillemotleft = 556, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 611, t.fl = 611, t.endash = 556, t.dagger = 556, t.daggerdbl = 556, t.periodcentered = 278, t.paragraph = 556, t.bullet = 350, t.quotesinglbase = 278, t.quotedblbase = 500, t.quotedblright = 500, t.guillemotright = 556, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 611, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 1e3, t.ordfeminine = 370, t.Lslash = 611, t.Oslash = 778, t.OE = 1e3, t.ordmasculine = 365, t.ae = 889, t.dotlessi = 278, t.lslash = 278, t.oslash = 611, t.oe = 944, t.germandbls = 611, t.Idieresis = 278, t.eacute = 556, t.abreve = 556, t.uhungarumlaut = 611, t.ecaron = 556, t.Ydieresis = 667, t.divide = 584, t.Yacute = 667, t.Acircumflex = 722, t.aacute = 556, t.Ucircumflex = 722, t.yacute = 556, t.scommaaccent = 556, t.ecircumflex = 556, t.Uring = 722, t.Udieresis = 722, t.aogonek = 556, t.Uacute = 722, t.uogonek = 611, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 737, t.Emacron = 667, t.ccaron = 556, t.aring = 556, t.Ncommaaccent = 722, t.lacute = 278, t.agrave = 556, t.Tcommaaccent = 611, t.Cacute = 722, t.atilde = 556, t.Edotaccent = 667, t.scaron = 556, t.scedilla = 556, t.iacute = 278, t.lozenge = 494, t.Rcaron = 722, t.Gcommaaccent = 778, t.ucircumflex = 611, t.acircumflex = 556, t.Amacron = 722, t.rcaron = 389, t.ccedilla = 556, t.Zdotaccent = 611, t.Thorn = 667, t.Omacron = 778, t.Racute = 722, t.Sacute = 667, t.dcaron = 743, t.Umacron = 722, t.uring = 611, t.threesuperior = 333, t.Ograve = 778, t.Agrave = 722, t.Abreve = 722, t.multiply = 584, t.uacute = 611, t.Tcaron = 611, t.partialdiff = 494, t.ydieresis = 556, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 556, t.edieresis = 556, t.cacute = 556, t.nacute = 611, t.umacron = 611, t.Ncaron = 722, t.Iacute = 278, t.plusminus = 584, t.brokenbar = 280, t.registered = 737, t.Gbreve = 778, t.Idotaccent = 278, t.summation = 600, t.Egrave = 667, t.racute = 389, t.omacron = 611, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 722, t.lcommaaccent = 278, t.tcaron = 389, t.eogonek = 556, t.Uogonek = 722, t.Aacute = 722, t.Adieresis = 722, t.egrave = 556, t.zacute = 500, t.iogonek = 278, t.Oacute = 778, t.oacute = 611, t.amacron = 556, t.sacute = 556, t.idieresis = 278, t.Ocircumflex = 778, t.Ugrave = 722, t.Delta = 612, t.thorn = 611, t.twosuperior = 333, t.Odieresis = 778, t.mu = 611, t.igrave = 278, t.ohungarumlaut = 611, t.Eogonek = 667, t.dcroat = 611, t.threequarters = 834, t.Scedilla = 667, t.lcaron = 400, t.Kcommaaccent = 722, t.Lacute = 611, t.trademark = 1e3, t.edotaccent = 556, t.Igrave = 278, t.Imacron = 278, t.Lcaron = 611, t.onehalf = 834, t.lessequal = 549, t.ocircumflex = 611, t.ntilde = 611, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 556, t.gbreve = 611, t.onequarter = 834, t.Scaron = 667, t.Scommaaccent = 667, t.Ohungarumlaut = 778, t.degree = 400, t.ograve = 611, t.Ccaron = 722, t.ugrave = 611, t.radical = 549, t.Dcaron = 722, t.rcommaaccent = 389, t.Ntilde = 722, t.otilde = 611, t.Rcommaaccent = 722, t.Lcommaaccent = 611, t.Atilde = 722, t.Aogonek = 722, t.Aring = 722, t.Otilde = 778, t.zdotaccent = 500, t.Ecaron = 667, t.Iogonek = 278, t.kcommaaccent = 556, t.minus = 584, t.Icircumflex = 278, t.ncaron = 611, t.tcommaaccent = 333, t.logicalnot = 584, t.odieresis = 611, t.udieresis = 611, t.notequal = 549, t.gcommaaccent = 611, t.eth = 611, t.zcaron = 500, t.ncommaaccent = 611, t.onesuperior = 333, t.imacron = 278, t.Euro = 556;
  })), A["Helvetica-Oblique"] = DA((function(t) {
    t.space = 278, t.exclam = 278, t.quotedbl = 355, t.numbersign = 556, t.dollar = 556, t.percent = 889, t.ampersand = 667, t.quoteright = 222, t.parenleft = 333, t.parenright = 333, t.asterisk = 389, t.plus = 584, t.comma = 278, t.hyphen = 333, t.period = 278, t.slash = 278, t.zero = 556, t.one = 556, t.two = 556, t.three = 556, t.four = 556, t.five = 556, t.six = 556, t.seven = 556, t.eight = 556, t.nine = 556, t.colon = 278, t.semicolon = 278, t.less = 584, t.equal = 584, t.greater = 584, t.question = 556, t.at = 1015, t.A = 667, t.B = 667, t.C = 722, t.D = 722, t.E = 667, t.F = 611, t.G = 778, t.H = 722, t.I = 278, t.J = 500, t.K = 667, t.L = 556, t.M = 833, t.N = 722, t.O = 778, t.P = 667, t.Q = 778, t.R = 722, t.S = 667, t.T = 611, t.U = 722, t.V = 667, t.W = 944, t.X = 667, t.Y = 667, t.Z = 611, t.bracketleft = 278, t.backslash = 278, t.bracketright = 278, t.asciicircum = 469, t.underscore = 556, t.quoteleft = 222, t.a = 556, t.b = 556, t.c = 500, t.d = 556, t.e = 556, t.f = 278, t.g = 556, t.h = 556, t.i = 222, t.j = 222, t.k = 500, t.l = 222, t.m = 833, t.n = 556, t.o = 556, t.p = 556, t.q = 556, t.r = 333, t.s = 500, t.t = 278, t.u = 556, t.v = 500, t.w = 722, t.x = 500, t.y = 500, t.z = 500, t.braceleft = 334, t.bar = 260, t.braceright = 334, t.asciitilde = 584, t.exclamdown = 333, t.cent = 556, t.sterling = 556, t.fraction = 167, t.yen = 556, t.florin = 556, t.section = 556, t.currency = 556, t.quotesingle = 191, t.quotedblleft = 333, t.guillemotleft = 556, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 500, t.fl = 500, t.endash = 556, t.dagger = 556, t.daggerdbl = 556, t.periodcentered = 278, t.paragraph = 537, t.bullet = 350, t.quotesinglbase = 222, t.quotedblbase = 333, t.quotedblright = 333, t.guillemotright = 556, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 611, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 1e3, t.ordfeminine = 370, t.Lslash = 556, t.Oslash = 778, t.OE = 1e3, t.ordmasculine = 365, t.ae = 889, t.dotlessi = 278, t.lslash = 222, t.oslash = 611, t.oe = 944, t.germandbls = 611, t.Idieresis = 278, t.eacute = 556, t.abreve = 556, t.uhungarumlaut = 556, t.ecaron = 556, t.Ydieresis = 667, t.divide = 584, t.Yacute = 667, t.Acircumflex = 667, t.aacute = 556, t.Ucircumflex = 722, t.yacute = 500, t.scommaaccent = 500, t.ecircumflex = 556, t.Uring = 722, t.Udieresis = 722, t.aogonek = 556, t.Uacute = 722, t.uogonek = 556, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 737, t.Emacron = 667, t.ccaron = 500, t.aring = 556, t.Ncommaaccent = 722, t.lacute = 222, t.agrave = 556, t.Tcommaaccent = 611, t.Cacute = 722, t.atilde = 556, t.Edotaccent = 667, t.scaron = 500, t.scedilla = 500, t.iacute = 278, t.lozenge = 471, t.Rcaron = 722, t.Gcommaaccent = 778, t.ucircumflex = 556, t.acircumflex = 556, t.Amacron = 667, t.rcaron = 333, t.ccedilla = 500, t.Zdotaccent = 611, t.Thorn = 667, t.Omacron = 778, t.Racute = 722, t.Sacute = 667, t.dcaron = 643, t.Umacron = 722, t.uring = 556, t.threesuperior = 333, t.Ograve = 778, t.Agrave = 667, t.Abreve = 667, t.multiply = 584, t.uacute = 556, t.Tcaron = 611, t.partialdiff = 476, t.ydieresis = 500, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 556, t.edieresis = 556, t.cacute = 500, t.nacute = 556, t.umacron = 556, t.Ncaron = 722, t.Iacute = 278, t.plusminus = 584, t.brokenbar = 260, t.registered = 737, t.Gbreve = 778, t.Idotaccent = 278, t.summation = 600, t.Egrave = 667, t.racute = 333, t.omacron = 556, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 722, t.lcommaaccent = 222, t.tcaron = 317, t.eogonek = 556, t.Uogonek = 722, t.Aacute = 667, t.Adieresis = 667, t.egrave = 556, t.zacute = 500, t.iogonek = 222, t.Oacute = 778, t.oacute = 556, t.amacron = 556, t.sacute = 500, t.idieresis = 278, t.Ocircumflex = 778, t.Ugrave = 722, t.Delta = 612, t.thorn = 556, t.twosuperior = 333, t.Odieresis = 778, t.mu = 556, t.igrave = 278, t.ohungarumlaut = 556, t.Eogonek = 667, t.dcroat = 556, t.threequarters = 834, t.Scedilla = 667, t.lcaron = 299, t.Kcommaaccent = 667, t.Lacute = 556, t.trademark = 1e3, t.edotaccent = 556, t.Igrave = 278, t.Imacron = 278, t.Lcaron = 556, t.onehalf = 834, t.lessequal = 549, t.ocircumflex = 556, t.ntilde = 556, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 556, t.gbreve = 556, t.onequarter = 834, t.Scaron = 667, t.Scommaaccent = 667, t.Ohungarumlaut = 778, t.degree = 400, t.ograve = 556, t.Ccaron = 722, t.ugrave = 556, t.radical = 453, t.Dcaron = 722, t.rcommaaccent = 333, t.Ntilde = 722, t.otilde = 556, t.Rcommaaccent = 722, t.Lcommaaccent = 556, t.Atilde = 667, t.Aogonek = 667, t.Aring = 667, t.Otilde = 778, t.zdotaccent = 500, t.Ecaron = 667, t.Iogonek = 278, t.kcommaaccent = 500, t.minus = 584, t.Icircumflex = 278, t.ncaron = 556, t.tcommaaccent = 278, t.logicalnot = 584, t.odieresis = 556, t.udieresis = 556, t.notequal = 549, t.gcommaaccent = 556, t.eth = 556, t.zcaron = 500, t.ncommaaccent = 556, t.onesuperior = 333, t.imacron = 278, t.Euro = 556;
  })), A.Symbol = DA((function(t) {
    t.space = 250, t.exclam = 333, t.universal = 713, t.numbersign = 500, t.existential = 549, t.percent = 833, t.ampersand = 778, t.suchthat = 439, t.parenleft = 333, t.parenright = 333, t.asteriskmath = 500, t.plus = 549, t.comma = 250, t.minus = 549, t.period = 250, t.slash = 278, t.zero = 500, t.one = 500, t.two = 500, t.three = 500, t.four = 500, t.five = 500, t.six = 500, t.seven = 500, t.eight = 500, t.nine = 500, t.colon = 278, t.semicolon = 278, t.less = 549, t.equal = 549, t.greater = 549, t.question = 444, t.congruent = 549, t.Alpha = 722, t.Beta = 667, t.Chi = 722, t.Delta = 612, t.Epsilon = 611, t.Phi = 763, t.Gamma = 603, t.Eta = 722, t.Iota = 333, t.theta1 = 631, t.Kappa = 722, t.Lambda = 686, t.Mu = 889, t.Nu = 722, t.Omicron = 722, t.Pi = 768, t.Theta = 741, t.Rho = 556, t.Sigma = 592, t.Tau = 611, t.Upsilon = 690, t.sigma1 = 439, t.Omega = 768, t.Xi = 645, t.Psi = 795, t.Zeta = 611, t.bracketleft = 333, t.therefore = 863, t.bracketright = 333, t.perpendicular = 658, t.underscore = 500, t.radicalex = 500, t.alpha = 631, t.beta = 549, t.chi = 549, t.delta = 494, t.epsilon = 439, t.phi = 521, t.gamma = 411, t.eta = 603, t.iota = 329, t.phi1 = 603, t.kappa = 549, t.lambda = 549, t.mu = 576, t.nu = 521, t.omicron = 549, t.pi = 549, t.theta = 521, t.rho = 549, t.sigma = 603, t.tau = 439, t.upsilon = 576, t.omega1 = 713, t.omega = 686, t.xi = 493, t.psi = 686, t.zeta = 494, t.braceleft = 480, t.bar = 200, t.braceright = 480, t.similar = 549, t.Euro = 750, t.Upsilon1 = 620, t.minute = 247, t.lessequal = 549, t.fraction = 167, t.infinity = 713, t.florin = 500, t.club = 753, t.diamond = 753, t.heart = 753, t.spade = 753, t.arrowboth = 1042, t.arrowleft = 987, t.arrowup = 603, t.arrowright = 987, t.arrowdown = 603, t.degree = 400, t.plusminus = 549, t.second = 411, t.greaterequal = 549, t.multiply = 549, t.proportional = 713, t.partialdiff = 494, t.bullet = 460, t.divide = 549, t.notequal = 549, t.equivalence = 549, t.approxequal = 549, t.ellipsis = 1e3, t.arrowvertex = 603, t.arrowhorizex = 1e3, t.carriagereturn = 658, t.aleph = 823, t.Ifraktur = 686, t.Rfraktur = 795, t.weierstrass = 987, t.circlemultiply = 768, t.circleplus = 768, t.emptyset = 823, t.intersection = 768, t.union = 768, t.propersuperset = 713, t.reflexsuperset = 713, t.notsubset = 713, t.propersubset = 713, t.reflexsubset = 713, t.element = 713, t.notelement = 713, t.angle = 768, t.gradient = 713, t.registerserif = 790, t.copyrightserif = 790, t.trademarkserif = 890, t.product = 823, t.radical = 549, t.dotmath = 250, t.logicalnot = 713, t.logicaland = 603, t.logicalor = 603, t.arrowdblboth = 1042, t.arrowdblleft = 987, t.arrowdblup = 603, t.arrowdblright = 987, t.arrowdbldown = 603, t.lozenge = 494, t.angleleft = 329, t.registersans = 790, t.copyrightsans = 790, t.trademarksans = 786, t.summation = 713, t.parenlefttp = 384, t.parenleftex = 384, t.parenleftbt = 384, t.bracketlefttp = 384, t.bracketleftex = 384, t.bracketleftbt = 384, t.bracelefttp = 494, t.braceleftmid = 494, t.braceleftbt = 494, t.braceex = 494, t.angleright = 329, t.integral = 274, t.integraltp = 686, t.integralex = 686, t.integralbt = 686, t.parenrighttp = 384, t.parenrightex = 384, t.parenrightbt = 384, t.bracketrighttp = 384, t.bracketrightex = 384, t.bracketrightbt = 384, t.bracerighttp = 494, t.bracerightmid = 494, t.bracerightbt = 494, t.apple = 790;
  })), A["Times-Roman"] = DA((function(t) {
    t.space = 250, t.exclam = 333, t.quotedbl = 408, t.numbersign = 500, t.dollar = 500, t.percent = 833, t.ampersand = 778, t.quoteright = 333, t.parenleft = 333, t.parenright = 333, t.asterisk = 500, t.plus = 564, t.comma = 250, t.hyphen = 333, t.period = 250, t.slash = 278, t.zero = 500, t.one = 500, t.two = 500, t.three = 500, t.four = 500, t.five = 500, t.six = 500, t.seven = 500, t.eight = 500, t.nine = 500, t.colon = 278, t.semicolon = 278, t.less = 564, t.equal = 564, t.greater = 564, t.question = 444, t.at = 921, t.A = 722, t.B = 667, t.C = 667, t.D = 722, t.E = 611, t.F = 556, t.G = 722, t.H = 722, t.I = 333, t.J = 389, t.K = 722, t.L = 611, t.M = 889, t.N = 722, t.O = 722, t.P = 556, t.Q = 722, t.R = 667, t.S = 556, t.T = 611, t.U = 722, t.V = 722, t.W = 944, t.X = 722, t.Y = 722, t.Z = 611, t.bracketleft = 333, t.backslash = 278, t.bracketright = 333, t.asciicircum = 469, t.underscore = 500, t.quoteleft = 333, t.a = 444, t.b = 500, t.c = 444, t.d = 500, t.e = 444, t.f = 333, t.g = 500, t.h = 500, t.i = 278, t.j = 278, t.k = 500, t.l = 278, t.m = 778, t.n = 500, t.o = 500, t.p = 500, t.q = 500, t.r = 333, t.s = 389, t.t = 278, t.u = 500, t.v = 500, t.w = 722, t.x = 500, t.y = 500, t.z = 444, t.braceleft = 480, t.bar = 200, t.braceright = 480, t.asciitilde = 541, t.exclamdown = 333, t.cent = 500, t.sterling = 500, t.fraction = 167, t.yen = 500, t.florin = 500, t.section = 500, t.currency = 500, t.quotesingle = 180, t.quotedblleft = 444, t.guillemotleft = 500, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 556, t.fl = 556, t.endash = 500, t.dagger = 500, t.daggerdbl = 500, t.periodcentered = 250, t.paragraph = 453, t.bullet = 350, t.quotesinglbase = 333, t.quotedblbase = 444, t.quotedblright = 444, t.guillemotright = 500, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 444, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 889, t.ordfeminine = 276, t.Lslash = 611, t.Oslash = 722, t.OE = 889, t.ordmasculine = 310, t.ae = 667, t.dotlessi = 278, t.lslash = 278, t.oslash = 500, t.oe = 722, t.germandbls = 500, t.Idieresis = 333, t.eacute = 444, t.abreve = 444, t.uhungarumlaut = 500, t.ecaron = 444, t.Ydieresis = 722, t.divide = 564, t.Yacute = 722, t.Acircumflex = 722, t.aacute = 444, t.Ucircumflex = 722, t.yacute = 500, t.scommaaccent = 389, t.ecircumflex = 444, t.Uring = 722, t.Udieresis = 722, t.aogonek = 444, t.Uacute = 722, t.uogonek = 500, t.Edieresis = 611, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 760, t.Emacron = 611, t.ccaron = 444, t.aring = 444, t.Ncommaaccent = 722, t.lacute = 278, t.agrave = 444, t.Tcommaaccent = 611, t.Cacute = 667, t.atilde = 444, t.Edotaccent = 611, t.scaron = 389, t.scedilla = 389, t.iacute = 278, t.lozenge = 471, t.Rcaron = 667, t.Gcommaaccent = 722, t.ucircumflex = 500, t.acircumflex = 444, t.Amacron = 722, t.rcaron = 333, t.ccedilla = 444, t.Zdotaccent = 611, t.Thorn = 556, t.Omacron = 722, t.Racute = 667, t.Sacute = 556, t.dcaron = 588, t.Umacron = 722, t.uring = 500, t.threesuperior = 300, t.Ograve = 722, t.Agrave = 722, t.Abreve = 722, t.multiply = 564, t.uacute = 500, t.Tcaron = 611, t.partialdiff = 476, t.ydieresis = 500, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 611, t.adieresis = 444, t.edieresis = 444, t.cacute = 444, t.nacute = 500, t.umacron = 500, t.Ncaron = 722, t.Iacute = 333, t.plusminus = 564, t.brokenbar = 200, t.registered = 760, t.Gbreve = 722, t.Idotaccent = 333, t.summation = 600, t.Egrave = 611, t.racute = 333, t.omacron = 500, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 667, t.lcommaaccent = 278, t.tcaron = 326, t.eogonek = 444, t.Uogonek = 722, t.Aacute = 722, t.Adieresis = 722, t.egrave = 444, t.zacute = 444, t.iogonek = 278, t.Oacute = 722, t.oacute = 500, t.amacron = 444, t.sacute = 389, t.idieresis = 278, t.Ocircumflex = 722, t.Ugrave = 722, t.Delta = 612, t.thorn = 500, t.twosuperior = 300, t.Odieresis = 722, t.mu = 500, t.igrave = 278, t.ohungarumlaut = 500, t.Eogonek = 611, t.dcroat = 500, t.threequarters = 750, t.Scedilla = 556, t.lcaron = 344, t.Kcommaaccent = 722, t.Lacute = 611, t.trademark = 980, t.edotaccent = 444, t.Igrave = 333, t.Imacron = 333, t.Lcaron = 611, t.onehalf = 750, t.lessequal = 549, t.ocircumflex = 500, t.ntilde = 500, t.Uhungarumlaut = 722, t.Eacute = 611, t.emacron = 444, t.gbreve = 500, t.onequarter = 750, t.Scaron = 556, t.Scommaaccent = 556, t.Ohungarumlaut = 722, t.degree = 400, t.ograve = 500, t.Ccaron = 667, t.ugrave = 500, t.radical = 453, t.Dcaron = 722, t.rcommaaccent = 333, t.Ntilde = 722, t.otilde = 500, t.Rcommaaccent = 667, t.Lcommaaccent = 611, t.Atilde = 722, t.Aogonek = 722, t.Aring = 722, t.Otilde = 722, t.zdotaccent = 444, t.Ecaron = 611, t.Iogonek = 333, t.kcommaaccent = 500, t.minus = 564, t.Icircumflex = 333, t.ncaron = 500, t.tcommaaccent = 278, t.logicalnot = 564, t.odieresis = 500, t.udieresis = 500, t.notequal = 549, t.gcommaaccent = 500, t.eth = 500, t.zcaron = 444, t.ncommaaccent = 500, t.onesuperior = 300, t.imacron = 278, t.Euro = 500;
  })), A["Times-Bold"] = DA((function(t) {
    t.space = 250, t.exclam = 333, t.quotedbl = 555, t.numbersign = 500, t.dollar = 500, t.percent = 1e3, t.ampersand = 833, t.quoteright = 333, t.parenleft = 333, t.parenright = 333, t.asterisk = 500, t.plus = 570, t.comma = 250, t.hyphen = 333, t.period = 250, t.slash = 278, t.zero = 500, t.one = 500, t.two = 500, t.three = 500, t.four = 500, t.five = 500, t.six = 500, t.seven = 500, t.eight = 500, t.nine = 500, t.colon = 333, t.semicolon = 333, t.less = 570, t.equal = 570, t.greater = 570, t.question = 500, t.at = 930, t.A = 722, t.B = 667, t.C = 722, t.D = 722, t.E = 667, t.F = 611, t.G = 778, t.H = 778, t.I = 389, t.J = 500, t.K = 778, t.L = 667, t.M = 944, t.N = 722, t.O = 778, t.P = 611, t.Q = 778, t.R = 722, t.S = 556, t.T = 667, t.U = 722, t.V = 722, t.W = 1e3, t.X = 722, t.Y = 722, t.Z = 667, t.bracketleft = 333, t.backslash = 278, t.bracketright = 333, t.asciicircum = 581, t.underscore = 500, t.quoteleft = 333, t.a = 500, t.b = 556, t.c = 444, t.d = 556, t.e = 444, t.f = 333, t.g = 500, t.h = 556, t.i = 278, t.j = 333, t.k = 556, t.l = 278, t.m = 833, t.n = 556, t.o = 500, t.p = 556, t.q = 556, t.r = 444, t.s = 389, t.t = 333, t.u = 556, t.v = 500, t.w = 722, t.x = 500, t.y = 500, t.z = 444, t.braceleft = 394, t.bar = 220, t.braceright = 394, t.asciitilde = 520, t.exclamdown = 333, t.cent = 500, t.sterling = 500, t.fraction = 167, t.yen = 500, t.florin = 500, t.section = 500, t.currency = 500, t.quotesingle = 278, t.quotedblleft = 500, t.guillemotleft = 500, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 556, t.fl = 556, t.endash = 500, t.dagger = 500, t.daggerdbl = 500, t.periodcentered = 250, t.paragraph = 540, t.bullet = 350, t.quotesinglbase = 333, t.quotedblbase = 500, t.quotedblright = 500, t.guillemotright = 500, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 500, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 1e3, t.ordfeminine = 300, t.Lslash = 667, t.Oslash = 778, t.OE = 1e3, t.ordmasculine = 330, t.ae = 722, t.dotlessi = 278, t.lslash = 278, t.oslash = 500, t.oe = 722, t.germandbls = 556, t.Idieresis = 389, t.eacute = 444, t.abreve = 500, t.uhungarumlaut = 556, t.ecaron = 444, t.Ydieresis = 722, t.divide = 570, t.Yacute = 722, t.Acircumflex = 722, t.aacute = 500, t.Ucircumflex = 722, t.yacute = 500, t.scommaaccent = 389, t.ecircumflex = 444, t.Uring = 722, t.Udieresis = 722, t.aogonek = 500, t.Uacute = 722, t.uogonek = 556, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 747, t.Emacron = 667, t.ccaron = 444, t.aring = 500, t.Ncommaaccent = 722, t.lacute = 278, t.agrave = 500, t.Tcommaaccent = 667, t.Cacute = 722, t.atilde = 500, t.Edotaccent = 667, t.scaron = 389, t.scedilla = 389, t.iacute = 278, t.lozenge = 494, t.Rcaron = 722, t.Gcommaaccent = 778, t.ucircumflex = 556, t.acircumflex = 500, t.Amacron = 722, t.rcaron = 444, t.ccedilla = 444, t.Zdotaccent = 667, t.Thorn = 611, t.Omacron = 778, t.Racute = 722, t.Sacute = 556, t.dcaron = 672, t.Umacron = 722, t.uring = 556, t.threesuperior = 300, t.Ograve = 778, t.Agrave = 722, t.Abreve = 722, t.multiply = 570, t.uacute = 556, t.Tcaron = 667, t.partialdiff = 494, t.ydieresis = 500, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 500, t.edieresis = 444, t.cacute = 444, t.nacute = 556, t.umacron = 556, t.Ncaron = 722, t.Iacute = 389, t.plusminus = 570, t.brokenbar = 220, t.registered = 747, t.Gbreve = 778, t.Idotaccent = 389, t.summation = 600, t.Egrave = 667, t.racute = 444, t.omacron = 500, t.Zacute = 667, t.Zcaron = 667, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 722, t.lcommaaccent = 278, t.tcaron = 416, t.eogonek = 444, t.Uogonek = 722, t.Aacute = 722, t.Adieresis = 722, t.egrave = 444, t.zacute = 444, t.iogonek = 278, t.Oacute = 778, t.oacute = 500, t.amacron = 500, t.sacute = 389, t.idieresis = 278, t.Ocircumflex = 778, t.Ugrave = 722, t.Delta = 612, t.thorn = 556, t.twosuperior = 300, t.Odieresis = 778, t.mu = 556, t.igrave = 278, t.ohungarumlaut = 500, t.Eogonek = 667, t.dcroat = 556, t.threequarters = 750, t.Scedilla = 556, t.lcaron = 394, t.Kcommaaccent = 778, t.Lacute = 667, t.trademark = 1e3, t.edotaccent = 444, t.Igrave = 389, t.Imacron = 389, t.Lcaron = 667, t.onehalf = 750, t.lessequal = 549, t.ocircumflex = 500, t.ntilde = 556, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 444, t.gbreve = 500, t.onequarter = 750, t.Scaron = 556, t.Scommaaccent = 556, t.Ohungarumlaut = 778, t.degree = 400, t.ograve = 500, t.Ccaron = 722, t.ugrave = 556, t.radical = 549, t.Dcaron = 722, t.rcommaaccent = 444, t.Ntilde = 722, t.otilde = 500, t.Rcommaaccent = 722, t.Lcommaaccent = 667, t.Atilde = 722, t.Aogonek = 722, t.Aring = 722, t.Otilde = 778, t.zdotaccent = 444, t.Ecaron = 667, t.Iogonek = 389, t.kcommaaccent = 556, t.minus = 570, t.Icircumflex = 389, t.ncaron = 556, t.tcommaaccent = 333, t.logicalnot = 570, t.odieresis = 500, t.udieresis = 556, t.notequal = 549, t.gcommaaccent = 500, t.eth = 500, t.zcaron = 444, t.ncommaaccent = 556, t.onesuperior = 300, t.imacron = 278, t.Euro = 500;
  })), A["Times-BoldItalic"] = DA((function(t) {
    t.space = 250, t.exclam = 389, t.quotedbl = 555, t.numbersign = 500, t.dollar = 500, t.percent = 833, t.ampersand = 778, t.quoteright = 333, t.parenleft = 333, t.parenright = 333, t.asterisk = 500, t.plus = 570, t.comma = 250, t.hyphen = 333, t.period = 250, t.slash = 278, t.zero = 500, t.one = 500, t.two = 500, t.three = 500, t.four = 500, t.five = 500, t.six = 500, t.seven = 500, t.eight = 500, t.nine = 500, t.colon = 333, t.semicolon = 333, t.less = 570, t.equal = 570, t.greater = 570, t.question = 500, t.at = 832, t.A = 667, t.B = 667, t.C = 667, t.D = 722, t.E = 667, t.F = 667, t.G = 722, t.H = 778, t.I = 389, t.J = 500, t.K = 667, t.L = 611, t.M = 889, t.N = 722, t.O = 722, t.P = 611, t.Q = 722, t.R = 667, t.S = 556, t.T = 611, t.U = 722, t.V = 667, t.W = 889, t.X = 667, t.Y = 611, t.Z = 611, t.bracketleft = 333, t.backslash = 278, t.bracketright = 333, t.asciicircum = 570, t.underscore = 500, t.quoteleft = 333, t.a = 500, t.b = 500, t.c = 444, t.d = 500, t.e = 444, t.f = 333, t.g = 500, t.h = 556, t.i = 278, t.j = 278, t.k = 500, t.l = 278, t.m = 778, t.n = 556, t.o = 500, t.p = 500, t.q = 500, t.r = 389, t.s = 389, t.t = 278, t.u = 556, t.v = 444, t.w = 667, t.x = 500, t.y = 444, t.z = 389, t.braceleft = 348, t.bar = 220, t.braceright = 348, t.asciitilde = 570, t.exclamdown = 389, t.cent = 500, t.sterling = 500, t.fraction = 167, t.yen = 500, t.florin = 500, t.section = 500, t.currency = 500, t.quotesingle = 278, t.quotedblleft = 500, t.guillemotleft = 500, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 556, t.fl = 556, t.endash = 500, t.dagger = 500, t.daggerdbl = 500, t.periodcentered = 250, t.paragraph = 500, t.bullet = 350, t.quotesinglbase = 333, t.quotedblbase = 500, t.quotedblright = 500, t.guillemotright = 500, t.ellipsis = 1e3, t.perthousand = 1e3, t.questiondown = 500, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 1e3, t.AE = 944, t.ordfeminine = 266, t.Lslash = 611, t.Oslash = 722, t.OE = 944, t.ordmasculine = 300, t.ae = 722, t.dotlessi = 278, t.lslash = 278, t.oslash = 500, t.oe = 722, t.germandbls = 500, t.Idieresis = 389, t.eacute = 444, t.abreve = 500, t.uhungarumlaut = 556, t.ecaron = 444, t.Ydieresis = 611, t.divide = 570, t.Yacute = 611, t.Acircumflex = 667, t.aacute = 500, t.Ucircumflex = 722, t.yacute = 444, t.scommaaccent = 389, t.ecircumflex = 444, t.Uring = 722, t.Udieresis = 722, t.aogonek = 500, t.Uacute = 722, t.uogonek = 556, t.Edieresis = 667, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 747, t.Emacron = 667, t.ccaron = 444, t.aring = 500, t.Ncommaaccent = 722, t.lacute = 278, t.agrave = 500, t.Tcommaaccent = 611, t.Cacute = 667, t.atilde = 500, t.Edotaccent = 667, t.scaron = 389, t.scedilla = 389, t.iacute = 278, t.lozenge = 494, t.Rcaron = 667, t.Gcommaaccent = 722, t.ucircumflex = 556, t.acircumflex = 500, t.Amacron = 667, t.rcaron = 389, t.ccedilla = 444, t.Zdotaccent = 611, t.Thorn = 611, t.Omacron = 722, t.Racute = 667, t.Sacute = 556, t.dcaron = 608, t.Umacron = 722, t.uring = 556, t.threesuperior = 300, t.Ograve = 722, t.Agrave = 667, t.Abreve = 667, t.multiply = 570, t.uacute = 556, t.Tcaron = 611, t.partialdiff = 494, t.ydieresis = 444, t.Nacute = 722, t.icircumflex = 278, t.Ecircumflex = 667, t.adieresis = 500, t.edieresis = 444, t.cacute = 444, t.nacute = 556, t.umacron = 556, t.Ncaron = 722, t.Iacute = 389, t.plusminus = 570, t.brokenbar = 220, t.registered = 747, t.Gbreve = 722, t.Idotaccent = 389, t.summation = 600, t.Egrave = 667, t.racute = 389, t.omacron = 500, t.Zacute = 611, t.Zcaron = 611, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 667, t.lcommaaccent = 278, t.tcaron = 366, t.eogonek = 444, t.Uogonek = 722, t.Aacute = 667, t.Adieresis = 667, t.egrave = 444, t.zacute = 389, t.iogonek = 278, t.Oacute = 722, t.oacute = 500, t.amacron = 500, t.sacute = 389, t.idieresis = 278, t.Ocircumflex = 722, t.Ugrave = 722, t.Delta = 612, t.thorn = 500, t.twosuperior = 300, t.Odieresis = 722, t.mu = 576, t.igrave = 278, t.ohungarumlaut = 500, t.Eogonek = 667, t.dcroat = 500, t.threequarters = 750, t.Scedilla = 556, t.lcaron = 382, t.Kcommaaccent = 667, t.Lacute = 611, t.trademark = 1e3, t.edotaccent = 444, t.Igrave = 389, t.Imacron = 389, t.Lcaron = 611, t.onehalf = 750, t.lessequal = 549, t.ocircumflex = 500, t.ntilde = 556, t.Uhungarumlaut = 722, t.Eacute = 667, t.emacron = 444, t.gbreve = 500, t.onequarter = 750, t.Scaron = 556, t.Scommaaccent = 556, t.Ohungarumlaut = 722, t.degree = 400, t.ograve = 500, t.Ccaron = 667, t.ugrave = 556, t.radical = 549, t.Dcaron = 722, t.rcommaaccent = 389, t.Ntilde = 722, t.otilde = 500, t.Rcommaaccent = 667, t.Lcommaaccent = 611, t.Atilde = 667, t.Aogonek = 667, t.Aring = 667, t.Otilde = 722, t.zdotaccent = 389, t.Ecaron = 667, t.Iogonek = 389, t.kcommaaccent = 500, t.minus = 606, t.Icircumflex = 389, t.ncaron = 556, t.tcommaaccent = 278, t.logicalnot = 606, t.odieresis = 500, t.udieresis = 556, t.notequal = 549, t.gcommaaccent = 500, t.eth = 500, t.zcaron = 389, t.ncommaaccent = 556, t.onesuperior = 300, t.imacron = 278, t.Euro = 500;
  })), A["Times-Italic"] = DA((function(t) {
    t.space = 250, t.exclam = 333, t.quotedbl = 420, t.numbersign = 500, t.dollar = 500, t.percent = 833, t.ampersand = 778, t.quoteright = 333, t.parenleft = 333, t.parenright = 333, t.asterisk = 500, t.plus = 675, t.comma = 250, t.hyphen = 333, t.period = 250, t.slash = 278, t.zero = 500, t.one = 500, t.two = 500, t.three = 500, t.four = 500, t.five = 500, t.six = 500, t.seven = 500, t.eight = 500, t.nine = 500, t.colon = 333, t.semicolon = 333, t.less = 675, t.equal = 675, t.greater = 675, t.question = 500, t.at = 920, t.A = 611, t.B = 611, t.C = 667, t.D = 722, t.E = 611, t.F = 611, t.G = 722, t.H = 722, t.I = 333, t.J = 444, t.K = 667, t.L = 556, t.M = 833, t.N = 667, t.O = 722, t.P = 611, t.Q = 722, t.R = 611, t.S = 500, t.T = 556, t.U = 722, t.V = 611, t.W = 833, t.X = 611, t.Y = 556, t.Z = 556, t.bracketleft = 389, t.backslash = 278, t.bracketright = 389, t.asciicircum = 422, t.underscore = 500, t.quoteleft = 333, t.a = 500, t.b = 500, t.c = 444, t.d = 500, t.e = 444, t.f = 278, t.g = 500, t.h = 500, t.i = 278, t.j = 278, t.k = 444, t.l = 278, t.m = 722, t.n = 500, t.o = 500, t.p = 500, t.q = 500, t.r = 389, t.s = 389, t.t = 278, t.u = 500, t.v = 444, t.w = 667, t.x = 444, t.y = 444, t.z = 389, t.braceleft = 400, t.bar = 275, t.braceright = 400, t.asciitilde = 541, t.exclamdown = 389, t.cent = 500, t.sterling = 500, t.fraction = 167, t.yen = 500, t.florin = 500, t.section = 500, t.currency = 500, t.quotesingle = 214, t.quotedblleft = 556, t.guillemotleft = 500, t.guilsinglleft = 333, t.guilsinglright = 333, t.fi = 500, t.fl = 500, t.endash = 500, t.dagger = 500, t.daggerdbl = 500, t.periodcentered = 250, t.paragraph = 523, t.bullet = 350, t.quotesinglbase = 333, t.quotedblbase = 556, t.quotedblright = 556, t.guillemotright = 500, t.ellipsis = 889, t.perthousand = 1e3, t.questiondown = 500, t.grave = 333, t.acute = 333, t.circumflex = 333, t.tilde = 333, t.macron = 333, t.breve = 333, t.dotaccent = 333, t.dieresis = 333, t.ring = 333, t.cedilla = 333, t.hungarumlaut = 333, t.ogonek = 333, t.caron = 333, t.emdash = 889, t.AE = 889, t.ordfeminine = 276, t.Lslash = 556, t.Oslash = 722, t.OE = 944, t.ordmasculine = 310, t.ae = 667, t.dotlessi = 278, t.lslash = 278, t.oslash = 500, t.oe = 667, t.germandbls = 500, t.Idieresis = 333, t.eacute = 444, t.abreve = 500, t.uhungarumlaut = 500, t.ecaron = 444, t.Ydieresis = 556, t.divide = 675, t.Yacute = 556, t.Acircumflex = 611, t.aacute = 500, t.Ucircumflex = 722, t.yacute = 444, t.scommaaccent = 389, t.ecircumflex = 444, t.Uring = 722, t.Udieresis = 722, t.aogonek = 500, t.Uacute = 722, t.uogonek = 500, t.Edieresis = 611, t.Dcroat = 722, t.commaaccent = 250, t.copyright = 760, t.Emacron = 611, t.ccaron = 444, t.aring = 500, t.Ncommaaccent = 667, t.lacute = 278, t.agrave = 500, t.Tcommaaccent = 556, t.Cacute = 667, t.atilde = 500, t.Edotaccent = 611, t.scaron = 389, t.scedilla = 389, t.iacute = 278, t.lozenge = 471, t.Rcaron = 611, t.Gcommaaccent = 722, t.ucircumflex = 500, t.acircumflex = 500, t.Amacron = 611, t.rcaron = 389, t.ccedilla = 444, t.Zdotaccent = 556, t.Thorn = 611, t.Omacron = 722, t.Racute = 611, t.Sacute = 500, t.dcaron = 544, t.Umacron = 722, t.uring = 500, t.threesuperior = 300, t.Ograve = 722, t.Agrave = 611, t.Abreve = 611, t.multiply = 675, t.uacute = 500, t.Tcaron = 556, t.partialdiff = 476, t.ydieresis = 444, t.Nacute = 667, t.icircumflex = 278, t.Ecircumflex = 611, t.adieresis = 500, t.edieresis = 444, t.cacute = 444, t.nacute = 500, t.umacron = 500, t.Ncaron = 667, t.Iacute = 333, t.plusminus = 675, t.brokenbar = 275, t.registered = 760, t.Gbreve = 722, t.Idotaccent = 333, t.summation = 600, t.Egrave = 611, t.racute = 389, t.omacron = 500, t.Zacute = 556, t.Zcaron = 556, t.greaterequal = 549, t.Eth = 722, t.Ccedilla = 667, t.lcommaaccent = 278, t.tcaron = 300, t.eogonek = 444, t.Uogonek = 722, t.Aacute = 611, t.Adieresis = 611, t.egrave = 444, t.zacute = 389, t.iogonek = 278, t.Oacute = 722, t.oacute = 500, t.amacron = 500, t.sacute = 389, t.idieresis = 278, t.Ocircumflex = 722, t.Ugrave = 722, t.Delta = 612, t.thorn = 500, t.twosuperior = 300, t.Odieresis = 722, t.mu = 500, t.igrave = 278, t.ohungarumlaut = 500, t.Eogonek = 611, t.dcroat = 500, t.threequarters = 750, t.Scedilla = 500, t.lcaron = 300, t.Kcommaaccent = 667, t.Lacute = 556, t.trademark = 980, t.edotaccent = 444, t.Igrave = 333, t.Imacron = 333, t.Lcaron = 611, t.onehalf = 750, t.lessequal = 549, t.ocircumflex = 500, t.ntilde = 500, t.Uhungarumlaut = 722, t.Eacute = 611, t.emacron = 444, t.gbreve = 500, t.onequarter = 750, t.Scaron = 500, t.Scommaaccent = 500, t.Ohungarumlaut = 722, t.degree = 400, t.ograve = 500, t.Ccaron = 667, t.ugrave = 500, t.radical = 453, t.Dcaron = 722, t.rcommaaccent = 389, t.Ntilde = 667, t.otilde = 500, t.Rcommaaccent = 611, t.Lcommaaccent = 556, t.Atilde = 611, t.Aogonek = 611, t.Aring = 611, t.Otilde = 722, t.zdotaccent = 389, t.Ecaron = 611, t.Iogonek = 333, t.kcommaaccent = 444, t.minus = 675, t.Icircumflex = 333, t.ncaron = 500, t.tcommaaccent = 278, t.logicalnot = 675, t.odieresis = 500, t.udieresis = 500, t.notequal = 549, t.gcommaaccent = 500, t.eth = 500, t.zcaron = 389, t.ncommaaccent = 500, t.onesuperior = 300, t.imacron = 278, t.Euro = 500;
  })), A.ZapfDingbats = DA((function(t) {
    t.space = 278, t.a1 = 974, t.a2 = 961, t.a202 = 974, t.a3 = 980, t.a4 = 719, t.a5 = 789, t.a119 = 790, t.a118 = 791, t.a117 = 690, t.a11 = 960, t.a12 = 939, t.a13 = 549, t.a14 = 855, t.a15 = 911, t.a16 = 933, t.a105 = 911, t.a17 = 945, t.a18 = 974, t.a19 = 755, t.a20 = 846, t.a21 = 762, t.a22 = 761, t.a23 = 571, t.a24 = 677, t.a25 = 763, t.a26 = 760, t.a27 = 759, t.a28 = 754, t.a6 = 494, t.a7 = 552, t.a8 = 537, t.a9 = 577, t.a10 = 692, t.a29 = 786, t.a30 = 788, t.a31 = 788, t.a32 = 790, t.a33 = 793, t.a34 = 794, t.a35 = 816, t.a36 = 823, t.a37 = 789, t.a38 = 841, t.a39 = 823, t.a40 = 833, t.a41 = 816, t.a42 = 831, t.a43 = 923, t.a44 = 744, t.a45 = 723, t.a46 = 749, t.a47 = 790, t.a48 = 792, t.a49 = 695, t.a50 = 776, t.a51 = 768, t.a52 = 792, t.a53 = 759, t.a54 = 707, t.a55 = 708, t.a56 = 682, t.a57 = 701, t.a58 = 826, t.a59 = 815, t.a60 = 789, t.a61 = 789, t.a62 = 707, t.a63 = 687, t.a64 = 696, t.a65 = 689, t.a66 = 786, t.a67 = 787, t.a68 = 713, t.a69 = 791, t.a70 = 785, t.a71 = 791, t.a72 = 873, t.a73 = 761, t.a74 = 762, t.a203 = 762, t.a75 = 759, t.a204 = 759, t.a76 = 892, t.a77 = 892, t.a78 = 788, t.a79 = 784, t.a81 = 438, t.a82 = 138, t.a83 = 277, t.a84 = 415, t.a97 = 392, t.a98 = 392, t.a99 = 668, t.a100 = 668, t.a89 = 390, t.a90 = 390, t.a93 = 317, t.a94 = 317, t.a91 = 276, t.a92 = 276, t.a205 = 509, t.a85 = 509, t.a206 = 410, t.a86 = 410, t.a87 = 234, t.a88 = 234, t.a95 = 334, t.a96 = 334, t.a101 = 732, t.a102 = 544, t.a103 = 544, t.a104 = 910, t.a106 = 667, t.a107 = 760, t.a108 = 760, t.a112 = 776, t.a111 = 595, t.a110 = 694, t.a109 = 626, t.a120 = 788, t.a121 = 788, t.a122 = 788, t.a123 = 788, t.a124 = 788, t.a125 = 788, t.a126 = 788, t.a127 = 788, t.a128 = 788, t.a129 = 788, t.a130 = 788, t.a131 = 788, t.a132 = 788, t.a133 = 788, t.a134 = 788, t.a135 = 788, t.a136 = 788, t.a137 = 788, t.a138 = 788, t.a139 = 788, t.a140 = 788, t.a141 = 788, t.a142 = 788, t.a143 = 788, t.a144 = 788, t.a145 = 788, t.a146 = 788, t.a147 = 788, t.a148 = 788, t.a149 = 788, t.a150 = 788, t.a151 = 788, t.a152 = 788, t.a153 = 788, t.a154 = 788, t.a155 = 788, t.a156 = 788, t.a157 = 788, t.a158 = 788, t.a159 = 788, t.a160 = 894, t.a161 = 838, t.a163 = 1016, t.a164 = 458, t.a196 = 748, t.a165 = 924, t.a192 = 748, t.a166 = 918, t.a167 = 927, t.a168 = 928, t.a169 = 928, t.a170 = 834, t.a171 = 873, t.a172 = 828, t.a173 = 924, t.a162 = 924, t.a174 = 917, t.a175 = 930, t.a176 = 931, t.a177 = 463, t.a178 = 883, t.a179 = 836, t.a193 = 836, t.a180 = 867, t.a199 = 867, t.a181 = 696, t.a200 = 696, t.a182 = 874, t.a201 = 874, t.a183 = 760, t.a184 = 946, t.a197 = 771, t.a185 = 865, t.a194 = 771, t.a198 = 888, t.a186 = 967, t.a195 = 888, t.a187 = 831, t.a188 = 873, t.a189 = 927, t.a190 = 970, t.a191 = 918;
  }));
})), f5 = DA((function(A) {
  A.Courier = { ascent: 629, descent: -157, capHeight: 562, xHeight: -426 }, A["Courier-Bold"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 439 }, A["Courier-Oblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 }, A["Courier-BoldOblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 }, A.Helvetica = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 }, A["Helvetica-Bold"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 }, A["Helvetica-Oblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 }, A["Helvetica-BoldOblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 }, A["Times-Roman"] = { ascent: 683, descent: -217, capHeight: 662, xHeight: 450 }, A["Times-Bold"] = { ascent: 683, descent: -217, capHeight: 676, xHeight: 461 }, A["Times-Italic"] = { ascent: 683, descent: -217, capHeight: 653, xHeight: 441 }, A["Times-BoldItalic"] = { ascent: 683, descent: -217, capHeight: 669, xHeight: 462 }, A.Symbol = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN }, A.ZapfDingbats = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN };
}));
class p5 {
  constructor({ glyfTable: t, isGlyphLocationsLong: e, locaTable: i, numGlyphs: s }) {
    this.glyphs = [];
    const n = new DataView(i.buffer, i.byteOffset, i.byteLength), o = new DataView(t.buffer, t.byteOffset, t.byteLength), r = e ? 4 : 2;
    let c = e ? n.getUint32(0) : 2 * n.getUint16(0), h = 0;
    for (let I = 0; I < s; I++) {
      h += r;
      const C = e ? n.getUint32(h) : 2 * n.getUint16(h);
      if (C === c) {
        this.glyphs.push(new hr({}));
        continue;
      }
      const d = hr.parse(c, o);
      this.glyphs.push(d), c = C;
    }
  }
  getSize() {
    return this.glyphs.reduce(((t, e) => t + (e.getSize() + 3 & -4)), 0);
  }
  write() {
    const t = this.getSize(), e = new DataView(new ArrayBuffer(t)), i = t > 131070, s = i ? 4 : 2, n = new DataView(new ArrayBuffer((this.glyphs.length + 1) * s));
    i ? n.setUint32(0, 0) : n.setUint16(0, 0);
    let o = 0, r = 0;
    for (const c of this.glyphs) o += c.write(o, e), o = o + 3 & -4, r += s, i ? n.setUint32(r, o) : n.setUint16(r, o >> 1);
    return { isLocationLong: i, loca: new Uint8Array(n.buffer), glyf: new Uint8Array(e.buffer) };
  }
  scale(t) {
    for (let e = 0, i = this.glyphs.length; e < i; e++) this.glyphs[e].scale(t[e]);
  }
}
class hr {
  constructor({ header: t = null, simple: e = null, composites: i = null }) {
    this.header = t, this.simple = e, this.composites = i;
  }
  static parse(t, e) {
    const [i, s] = Gl.parse(t, e);
    if (t += i, s.numberOfContours < 0) {
      const o = [];
      for (; ; ) {
        const [r, c] = Ml.parse(t, e);
        if (t += r, o.push(c), !(32 & c.flags)) break;
      }
      return new hr({ header: s, composites: o });
    }
    const n = vl.parse(t, e, s.numberOfContours);
    return new hr({ header: s, simple: n });
  }
  getSize() {
    if (!this.header) return 0;
    const t = this.simple ? this.simple.getSize() : this.composites.reduce(((e, i) => e + i.getSize()), 0);
    return this.header.getSize() + t;
  }
  write(t, e) {
    if (!this.header) return 0;
    const i = t;
    if (t += this.header.write(t, e), this.simple) t += this.simple.write(t, e);
    else for (const s of this.composites) t += s.write(t, e);
    return t - i;
  }
  scale(t) {
    if (!this.header) return;
    const e = (this.header.xMin + this.header.xMax) / 2;
    if (this.header.scale(e, t), this.simple) this.simple.scale(e, t);
    else for (const i of this.composites) i.scale(e, t);
  }
}
class Gl {
  constructor({ numberOfContours: t, xMin: e, yMin: i, xMax: s, yMax: n }) {
    this.numberOfContours = t, this.xMin = e, this.yMin = i, this.xMax = s, this.yMax = n;
  }
  static parse(t, e) {
    return [10, new Gl({ numberOfContours: e.getInt16(t), xMin: e.getInt16(t + 2), yMin: e.getInt16(t + 4), xMax: e.getInt16(t + 6), yMax: e.getInt16(t + 8) })];
  }
  getSize() {
    return 10;
  }
  write(t, e) {
    return e.setInt16(t, this.numberOfContours), e.setInt16(t + 2, this.xMin), e.setInt16(t + 4, this.yMin), e.setInt16(t + 6, this.xMax), e.setInt16(t + 8, this.yMax), 10;
  }
  scale(t, e) {
    this.xMin = Math.round(t + (this.xMin - t) * e), this.xMax = Math.round(t + (this.xMax - t) * e);
  }
}
class m5 {
  constructor({ flags: t, xCoordinates: e, yCoordinates: i }) {
    this.xCoordinates = e, this.yCoordinates = i, this.flags = t;
  }
}
class vl {
  constructor({ contours: t, instructions: e }) {
    this.contours = t, this.instructions = e;
  }
  static parse(t, e, i) {
    const s = [];
    for (let y = 0; y < i; y++) {
      const b = e.getUint16(t);
      t += 2, s.push(b);
    }
    const n = s[i - 1] + 1, o = e.getUint16(t);
    t += 2;
    const r = new Uint8Array(e).slice(t, t + o);
    t += o;
    const c = [];
    for (let y = 0; y < n; t++, y++) {
      let b = e.getUint8(t);
      if (c.push(b), 8 & b) {
        const D = e.getUint8(++t);
        b ^= 8;
        for (let S = 0; S < D; S++) c.push(b);
        y += D;
      }
    }
    const h = [];
    let I = [], C = [], d = [];
    const u = [];
    let E = 0, p = 0;
    for (let y = 0; y < n; y++) {
      const b = c[y];
      if (2 & b) {
        const D = e.getUint8(t++);
        p += 16 & b ? D : -D, I.push(p);
      } else 16 & b || (p += e.getInt16(t), t += 2), I.push(p);
      s[E] === y && (E++, h.push(I), I = []);
    }
    p = 0, E = 0;
    for (let y = 0; y < n; y++) {
      const b = c[y];
      if (4 & b) {
        const D = e.getUint8(t++);
        p += 32 & b ? D : -D, C.push(p);
      } else 32 & b || (p += e.getInt16(t), t += 2), C.push(p);
      d.push(1 & b | 64 & b), s[E] === y && (I = h[E], E++, u.push(new m5({ flags: d, xCoordinates: I, yCoordinates: C })), C = [], d = []);
    }
    return new vl({ contours: u, instructions: r });
  }
  getSize() {
    let t = 2 * this.contours.length + 2 + this.instructions.length, e = 0, i = 0;
    for (const s of this.contours) {
      t += s.flags.length;
      for (let n = 0, o = s.xCoordinates.length; n < o; n++) {
        const r = s.xCoordinates[n], c = s.yCoordinates[n];
        let h = Math.abs(r - e);
        h > 255 ? t += 2 : h > 0 && (t += 1), e = r, h = Math.abs(c - i), h > 255 ? t += 2 : h > 0 && (t += 1), i = c;
      }
    }
    return t;
  }
  write(t, e) {
    const i = t, s = [], n = [], o = [];
    let r = 0, c = 0;
    for (const h of this.contours) {
      for (let I = 0, C = h.xCoordinates.length; I < C; I++) {
        let d = h.flags[I];
        const u = h.xCoordinates[I];
        let E = u - r;
        if (E === 0) d |= 16, s.push(0);
        else {
          const y = Math.abs(E);
          y <= 255 ? (d |= E >= 0 ? 18 : 2, s.push(y)) : s.push(E);
        }
        r = u;
        const p = h.yCoordinates[I];
        if (E = p - c, E === 0) d |= 32, n.push(0);
        else {
          const y = Math.abs(E);
          y <= 255 ? (d |= E >= 0 ? 36 : 4, n.push(y)) : n.push(E);
        }
        c = p, o.push(d);
      }
      e.setUint16(t, s.length - 1), t += 2;
    }
    e.setUint16(t, this.instructions.length), t += 2, this.instructions.length && (new Uint8Array(e.buffer, 0, e.buffer.byteLength).set(this.instructions, t), t += this.instructions.length);
    for (const h of o) e.setUint8(t++, h);
    for (let h = 0, I = s.length; h < I; h++) {
      const C = s[h], d = o[h];
      2 & d ? e.setUint8(t++, C) : 16 & d || (e.setInt16(t, C), t += 2);
    }
    for (let h = 0, I = n.length; h < I; h++) {
      const C = n[h], d = o[h];
      4 & d ? e.setUint8(t++, C) : 32 & d || (e.setInt16(t, C), t += 2);
    }
    return t - i;
  }
  scale(t, e) {
    for (const i of this.contours) if (i.xCoordinates.length !== 0) for (let s = 0, n = i.xCoordinates.length; s < n; s++) i.xCoordinates[s] = Math.round(t + (i.xCoordinates[s] - t) * e);
  }
}
class Ml {
  constructor({ flags: t, glyphIndex: e, argument1: i, argument2: s, transf: n, instructions: o }) {
    this.flags = t, this.glyphIndex = e, this.argument1 = i, this.argument2 = s, this.transf = n, this.instructions = o;
  }
  static parse(t, e) {
    const i = t, s = [];
    let n = e.getUint16(t);
    const o = e.getUint16(t + 2);
    let r, c;
    t += 4, 1 & n ? (2 & n ? (r = e.getInt16(t), c = e.getInt16(t + 2)) : (r = e.getUint16(t), c = e.getUint16(t + 2)), t += 4, n ^= 1) : (2 & n ? (r = e.getInt8(t), c = e.getInt8(t + 1)) : (r = e.getUint8(t), c = e.getUint8(t + 1)), t += 2), 8 & n ? (s.push(e.getUint16(t)), t += 2) : 64 & n ? (s.push(e.getUint16(t), e.getUint16(t + 2)), t += 4) : 128 & n && (s.push(e.getUint16(t), e.getUint16(t + 2), e.getUint16(t + 4), e.getUint16(t + 6)), t += 8);
    let h = null;
    if (256 & n) {
      const I = e.getUint16(t);
      t += 2, h = new Uint8Array(e).slice(t, t + I), t += I;
    }
    return [t - i, new Ml({ flags: n, glyphIndex: o, argument1: r, argument2: c, transf: s, instructions: h })];
  }
  getSize() {
    let t = 4 + 2 * this.transf.length;
    return 256 & this.flags && (t += 2 + this.instructions.length), t += 2, 2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (t += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (t += 2), t;
  }
  write(t, e) {
    const i = t;
    return 2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= 1) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= 1), e.setUint16(t, this.flags), e.setUint16(t + 2, this.glyphIndex), t += 4, 1 & this.flags ? (2 & this.flags ? (e.setInt16(t, this.argument1), e.setInt16(t + 2, this.argument2)) : (e.setUint16(t, this.argument1), e.setUint16(t + 2, this.argument2)), t += 4) : (e.setUint8(t, this.argument1), e.setUint8(t + 1, this.argument2), t += 2), 256 & this.flags && (e.setUint16(t, this.instructions.length), t += 2, this.instructions.length && (new Uint8Array(e.buffer, 0, e.buffer.byteLength).set(this.instructions, t), t += this.instructions.length)), t - i;
  }
  scale(t, e) {
  }
}
function io(A, t, e) {
  A[t] = e >> 8 & 255, A[t + 1] = 255 & e;
}
function zc(A, t, e) {
  A[t] = e >> 24 & 255, A[t + 1] = e >> 16 & 255, A[t + 2] = e >> 8 & 255, A[t + 3] = 255 & e;
}
function y5(A, t, e) {
  if (e instanceof Uint8Array) A.set(e, t);
  else if (typeof e == "string") for (let i = 0, s = e.length; i < s; i++) A[t++] = 255 & e.charCodeAt(i);
  else for (const i of e) A[t++] = 255 & i;
}
class lr {
  constructor(t) {
    this.sfnt = t, this.tables = /* @__PURE__ */ Object.create(null);
  }
  static getSearchParams(t, e) {
    let i = 1, s = 0;
    for (; (i ^ t) > i; ) i <<= 1, s++;
    const n = i * e;
    return { range: n, entry: s, rangeShift: e * t - n };
  }
  toArray() {
    let t = this.sfnt;
    const e = this.tables, i = Object.keys(e);
    i.sort();
    const s = i.length;
    let n, o, r, c, h, I = 12 + 16 * s;
    const C = [I];
    for (n = 0; n < s; n++)
      c = e[i[n]], I += (c.length + 3 & -4) >>> 0, C.push(I);
    const d = new Uint8Array(I);
    for (n = 0; n < s; n++) c = e[i[n]], y5(d, C[n], c);
    t === "true" && (t = ne(65536)), d[0] = 255 & t.charCodeAt(0), d[1] = 255 & t.charCodeAt(1), d[2] = 255 & t.charCodeAt(2), d[3] = 255 & t.charCodeAt(3), io(d, 4, s);
    const u = lr.getSearchParams(s, 16);
    for (io(d, 6, u.range), io(d, 8, u.entry), io(d, 10, u.rangeShift), I = 12, n = 0; n < s; n++) {
      h = i[n], d[I] = 255 & h.charCodeAt(0), d[I + 1] = 255 & h.charCodeAt(1), d[I + 2] = 255 & h.charCodeAt(2), d[I + 3] = 255 & h.charCodeAt(3);
      let E = 0;
      for (o = C[n], r = C[n + 1]; o < r; o += 4)
        E = E + bA(d, o) >>> 0;
      zc(d, I + 4, E), zc(d, I + 8, C[n]), zc(d, I + 12, e[h].length), I += 16;
    }
    return d;
  }
  addTable(t, e) {
    if (t in this.tables) throw new Error("Table " + t + " already exists");
    this.tables[t] = e;
  }
}
const w5 = [4], b5 = [5], D5 = [6], k5 = [7], S5 = [8], F5 = [12, 35], $c = [14], jC = [21], ZC = [22], R5 = [30], x5 = [31];
class N5 {
  constructor() {
    this.width = 0, this.lsb = 0, this.flexing = !1, this.output = [], this.stack = [];
  }
  convert(t, e, i) {
    const s = t.length;
    let n, o, r, c = !1;
    for (let h = 0; h < s; h++) {
      let I = t[h];
      if (I < 32) {
        switch (I === 12 && (I = (I << 8) + t[++h]), I) {
          case 1:
          case 3:
          case 9:
          case 3072:
          case 3073:
          case 3074:
          case 3105:
            this.stack = [];
            break;
          case 4:
            if (this.flexing) {
              if (this.stack.length < 1) {
                c = !0;
                break;
              }
              const p = this.stack.pop();
              this.stack.push(0, p);
              break;
            }
            c = this.executeCommand(1, w5);
            break;
          case 5:
            c = this.executeCommand(2, b5);
            break;
          case 6:
            c = this.executeCommand(1, D5);
            break;
          case 7:
            c = this.executeCommand(1, k5);
            break;
          case 8:
            c = this.executeCommand(6, S5);
            break;
          case 10:
            if (this.stack.length < 1) {
              c = !0;
              break;
            }
            if (r = this.stack.pop(), !e[r]) {
              c = !0;
              break;
            }
            c = this.convert(e[r], e, i);
            break;
          case 11:
            return c;
          case 13:
            if (this.stack.length < 2) {
              c = !0;
              break;
            }
            n = this.stack.pop(), o = this.stack.pop(), this.lsb = o, this.width = n, this.stack.push(n, o), c = this.executeCommand(2, ZC);
            break;
          case 14:
            this.output.push($c[0]);
            break;
          case 21:
            if (this.flexing) break;
            c = this.executeCommand(2, jC);
            break;
          case 22:
            if (this.flexing) {
              this.stack.push(0);
              break;
            }
            c = this.executeCommand(1, ZC);
            break;
          case 30:
            c = this.executeCommand(4, R5);
            break;
          case 31:
            c = this.executeCommand(4, x5);
            break;
          case 3078:
            if (i) {
              const p = this.stack.at(-5);
              this.seac = this.stack.splice(-4, 4), this.seac[0] += this.lsb - p, c = this.executeCommand(0, $c);
            } else c = this.executeCommand(4, $c);
            break;
          case 3079:
            if (this.stack.length < 4) {
              c = !0;
              break;
            }
            this.stack.pop(), n = this.stack.pop();
            const C = this.stack.pop();
            o = this.stack.pop(), this.lsb = o, this.width = n, this.stack.push(n, o, C), c = this.executeCommand(3, jC);
            break;
          case 3084:
            if (this.stack.length < 2) {
              c = !0;
              break;
            }
            const d = this.stack.pop(), u = this.stack.pop();
            this.stack.push(u / d);
            break;
          case 3088:
            if (this.stack.length < 2) {
              c = !0;
              break;
            }
            r = this.stack.pop();
            const E = this.stack.pop();
            if (r === 0 && E === 3) {
              const p = this.stack.splice(-17, 17);
              this.stack.push(p[2] + p[0], p[3] + p[1], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14]), c = this.executeCommand(13, F5, !0), this.flexing = !1, this.stack.push(p[15], p[16]);
            } else r === 1 && E === 0 && (this.flexing = !0);
            break;
          case 3089:
            break;
          default:
            O('Unknown type 1 charstring command of "' + I + '"');
        }
        if (c) break;
      } else I <= 246 ? I -= 139 : I = I <= 250 ? 256 * (I - 247) + t[++h] + 108 : I <= 254 ? -256 * (I - 251) - t[++h] - 108 : (255 & t[++h]) << 24 | (255 & t[++h]) << 16 | (255 & t[++h]) << 8 | 255 & t[++h], this.stack.push(I);
    }
    return c;
  }
  executeCommand(t, e, i) {
    const s = this.stack.length;
    if (t > s) return !0;
    const n = s - t;
    for (let o = n; o < s; o++) {
      let r = this.stack[o];
      Number.isInteger(r) ? this.output.push(28, r >> 8 & 255, 255 & r) : (r = 65536 * r | 0, this.output.push(255, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r));
    }
    return this.output.push(...e), i ? this.stack.splice(n, t) : this.stack.length = 0, !1;
  }
}
function pi(A) {
  return A >= 48 && A <= 57 || A >= 65 && A <= 70 || A >= 97 && A <= 102;
}
function VC(A, t, e) {
  if (e >= A.length) return new Uint8Array(0);
  let i, s, n = 0 | t;
  for (i = 0; i < e; i++) n = 52845 * (A[i] + n) + 22719 & 65535;
  const o = A.length - e, r = new Uint8Array(o);
  for (i = e, s = 0; s < o; i++, s++) {
    const c = A[i];
    r[s] = c ^ n >> 8, n = 52845 * (c + n) + 22719 & 65535;
  }
  return r;
}
function XC(A) {
  return A === 47 || A === 91 || A === 93 || A === 123 || A === 125 || A === 40 || A === 41;
}
class zC {
  constructor(t, e, i) {
    if (e) {
      const s = t.getBytes(), n = !((pi(s[0]) || qe(s[0])) && pi(s[1]) && pi(s[2]) && pi(s[3]) && pi(s[4]) && pi(s[5]) && pi(s[6]) && pi(s[7]));
      t = new RA(n ? VC(s, 55665, 4) : (function(o, r, c) {
        let h = 0 | r;
        const I = o.length, C = new Uint8Array(I >>> 1);
        let d, u;
        for (d = 0, u = 0; d < I; d++) {
          const E = o[d];
          if (!pi(E)) continue;
          let p;
          for (d++; d < I && !pi(p = o[d]); ) d++;
          if (d < I) {
            const y = parseInt(String.fromCharCode(E, p), 16);
            C[u++] = y ^ h >> 8, h = 52845 * (y + h) + 22719 & 65535;
          }
        }
        return C.slice(c, u);
      })(s, 55665, 4));
    }
    this.seacAnalysisEnabled = !!i, this.stream = t, this.nextChar();
  }
  readNumberArray() {
    this.getToken();
    const t = [];
    for (; ; ) {
      const e = this.getToken();
      if (e === null || e === "]" || e === "}") break;
      t.push(parseFloat(e || 0));
    }
    return t;
  }
  readNumber() {
    const t = this.getToken();
    return parseFloat(t || 0);
  }
  readInt() {
    const t = this.getToken();
    return 0 | parseInt(t || 0, 10);
  }
  readBoolean() {
    return this.getToken() === "true" ? 1 : 0;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  prevChar() {
    return this.stream.skip(-2), this.currentChar = this.stream.getByte();
  }
  getToken() {
    let t = !1, e = this.currentChar;
    for (; ; ) {
      if (e === -1) return null;
      if (t) e !== 10 && e !== 13 || (t = !1);
      else if (e === 37) t = !0;
      else if (!qe(e)) break;
      e = this.nextChar();
    }
    if (XC(e)) return this.nextChar(), String.fromCharCode(e);
    let i = "";
    do
      i += String.fromCharCode(e), e = this.nextChar();
    while (e >= 0 && !qe(e) && !XC(e));
    return i;
  }
  readCharStrings(t, e) {
    return e === -1 ? t : VC(t, 4330, e);
  }
  extractFontProgram(t) {
    const e = this.stream, i = [], s = [], n = /* @__PURE__ */ Object.create(null);
    n.lenIV = 4;
    const o = { subrs: [], charstrings: [], properties: { privateData: n } };
    let r, c, h, I;
    for (; (r = this.getToken()) !== null; ) if (r === "/") switch (r = this.getToken(), r) {
      case "CharStrings":
        for (this.getToken(), this.getToken(), this.getToken(), this.getToken(); r = this.getToken(), r !== null && r !== "end"; ) {
          if (r !== "/") continue;
          const d = this.getToken();
          c = this.readInt(), this.getToken(), h = c > 0 ? e.getBytes(c) : new Uint8Array(0), I = o.properties.privateData.lenIV;
          const u = this.readCharStrings(h, I);
          this.nextChar(), r = this.getToken(), r === "noaccess" ? this.getToken() : r === "/" && this.prevChar(), s.push({ glyph: d, encoded: u });
        }
        break;
      case "Subrs":
        for (this.readInt(), this.getToken(); this.getToken() === "dup"; ) {
          const d = this.readInt();
          c = this.readInt(), this.getToken(), h = c > 0 ? e.getBytes(c) : new Uint8Array(0), I = o.properties.privateData.lenIV;
          const u = this.readCharStrings(h, I);
          this.nextChar(), r = this.getToken(), r === "noaccess" && this.getToken(), i[d] = u;
        }
        break;
      case "BlueValues":
      case "OtherBlues":
      case "FamilyBlues":
      case "FamilyOtherBlues":
        const C = this.readNumberArray();
        C.length > 0 && C.length;
        break;
      case "StemSnapH":
      case "StemSnapV":
        o.properties.privateData[r] = this.readNumberArray();
        break;
      case "StdHW":
      case "StdVW":
        o.properties.privateData[r] = this.readNumberArray()[0];
        break;
      case "BlueShift":
      case "lenIV":
      case "BlueFuzz":
      case "BlueScale":
      case "LanguageGroup":
        o.properties.privateData[r] = this.readNumber();
        break;
      case "ExpansionFactor":
        o.properties.privateData[r] = this.readNumber() || 0.06;
        break;
      case "ForceBold":
        o.properties.privateData[r] = this.readBoolean();
    }
    for (const { encoded: C, glyph: d } of s) {
      const u = new N5(), E = u.convert(C, i, this.seacAnalysisEnabled);
      let p = u.output;
      E && (p = [14]);
      const y = { glyphName: d, charstring: p, width: u.width, lsb: u.lsb, seac: u.seac };
      if (d === ".notdef" ? o.charstrings.unshift(y) : o.charstrings.push(y), t.builtInEncoding) {
        const b = t.builtInEncoding.indexOf(d);
        b > -1 && t.widths[b] === void 0 && b >= t.firstChar && b <= t.lastChar && (t.widths[b] = u.width);
      }
    }
    return o;
  }
  extractFontHeader(t) {
    let e;
    for (; (e = this.getToken()) !== null; ) if (e === "/") switch (e = this.getToken(), e) {
      case "FontMatrix":
        const i = this.readNumberArray();
        t.fontMatrix = i;
        break;
      case "Encoding":
        const s = this.getToken();
        let n;
        if (/^\d+$/.test(s)) {
          n = [];
          const r = 0 | parseInt(s, 10);
          this.getToken();
          for (let c = 0; c < r; c++) {
            for (e = this.getToken(); e !== "dup" && e !== "def"; ) if (e = this.getToken(), e === null) return;
            if (e === "def") break;
            const h = this.readInt();
            this.getToken();
            const I = this.getToken();
            n[h] = I, this.getToken();
          }
        } else n = rr(s);
        t.builtInEncoding = n;
        break;
      case "FontBBox":
        const o = this.readNumberArray();
        t.ascent = Math.max(o[3], o[1]), t.descent = Math.min(o[1], o[3]), t.ascentScaled = !0;
    }
  }
}
function $C(A, t, e) {
  const i = A.length, s = t.length, n = i - s;
  let o = e, r = !1;
  for (; o < n; ) {
    let c = 0;
    for (; c < s && A[o + c] === t[c]; ) c++;
    if (c >= s) {
      for (o += c; o < i && qe(A[o]); ) o++;
      r = !0;
      break;
    }
    o++;
  }
  return { found: r, length: o };
}
class G5 {
  constructor(t, e, i) {
    let s = i.length1;
    i.length2;
    let n = e.peekBytes(6);
    const o = n[0] === 128 && n[1] === 1;
    o && (e.skip(6), s = n[5] << 24 | n[4] << 16 | n[3] << 8 | n[2]);
    const r = (function(u, E) {
      const p = [101, 101, 120, 101, 99], y = u.pos;
      let b, D, S, R;
      try {
        b = u.getBytes(E), D = b.length;
      } catch {
      }
      if (D === E && (S = $C(b, p, E - 2 * p.length), S.found && S.length === E)) return { stream: new RA(b), length: E };
      for (O('Invalid "Length1" property in Type1 font -- trying to recover.'), u.pos = y; S = $C(u.peekBytes(2048), p, 0), S.length !== 0; ) if (u.pos += S.length, S.found) {
        R = u.pos - y;
        break;
      }
      return u.pos = y, R ? { stream: new RA(u.getBytes(R)), length: R } : (O('Unable to recover "Length1" property in Type1 font -- using as is.'), { stream: new RA(u.getBytes(E)), length: E });
    })(e, s);
    new zC(r.stream, !1, cr).extractFontHeader(i), o && (n = e.getBytes(6), n[5], n[4], n[3], n[2]);
    const c = (function(u) {
      const E = u.getBytes();
      if (E.length === 0) throw new Ct("getEexecBlock - no font program found.");
      return { stream: new RA(E), length: E.length };
    })(e), h = new zC(c.stream, !0, cr).extractFontProgram(i);
    for (const u in h.properties) i[u] = h.properties[u];
    const I = h.charstrings, C = this.getType2Charstrings(I), d = this.getType2Subrs(h.subrs);
    this.charstrings = I, this.data = this.wrap(t, C, this.charstrings, d, i), this.seacs = this.getSeacs(h.charstrings);
  }
  get numGlyphs() {
    return this.charstrings.length + 1;
  }
  getCharset() {
    const t = [".notdef"];
    for (const { glyphName: e } of this.charstrings) t.push(e);
    return t;
  }
  getGlyphMapping(t) {
    const e = this.charstrings;
    if (t.composite) {
      const r = /* @__PURE__ */ Object.create(null);
      for (let c = 0, h = e.length; c < h; c++)
        r[t.cMap.charCodeOf(c)] = c + 1;
      return r;
    }
    const i = [".notdef"];
    let s, n;
    for (n = 0; n < e.length; n++) i.push(e[n].glyphName);
    const o = t.builtInEncoding;
    if (o) {
      s = /* @__PURE__ */ Object.create(null);
      for (const r in o) n = i.indexOf(o[r]), n >= 0 && (s[r] = n);
    }
    return QE(t, s, i);
  }
  hasGlyphId(t) {
    return t < 0 || t >= this.numGlyphs ? !1 : t === 0 ? !0 : this.charstrings[t - 1].charstring.length > 0;
  }
  getSeacs(t) {
    const e = [];
    for (let i = 0, s = t.length; i < s; i++) {
      const n = t[i];
      n.seac && (e[i + 1] = n.seac);
    }
    return e;
  }
  getType2Charstrings(t) {
    const e = [];
    for (const i of t) e.push(i.charstring);
    return e;
  }
  getType2Subrs(t) {
    let e = 0;
    const i = t.length;
    e = i < 1133 ? 107 : i < 33769 ? 1131 : 32768;
    const s = [];
    let n;
    for (n = 0; n < e; n++) s.push([11]);
    for (n = 0; n < i; n++) s.push(t[n]);
    return s;
  }
  wrap(t, e, i, s, n) {
    const o = new IE();
    o.header = new CE(1, 0, 4, 4), o.names = [t];
    const r = new or();
    r.setByName("version", 391), r.setByName("Notice", 392), r.setByName("FullName", 393), r.setByName("FamilyName", 394), r.setByName("Weight", 395), r.setByName("Encoding", null), r.setByName("FontMatrix", n.fontMatrix), r.setByName("FontBBox", n.bbox), r.setByName("charset", null), r.setByName("CharStrings", null), r.setByName("Private", null), o.topDict = r;
    const c = new xl();
    c.add("Version 0.11"), c.add("See original notice"), c.add(t), c.add(t), c.add("Medium"), o.strings = c, o.globalSubrIndex = new Ss();
    const h = e.length, I = [".notdef"];
    let C, d;
    for (C = 0; C < h; C++) {
      const b = i[C].glyphName;
      wo.indexOf(b) === -1 && c.add(b), I.push(b);
    }
    o.charset = new Yn(!1, 0, I);
    const u = new Ss();
    for (u.add([139, 14]), C = 0; C < h; C++) u.add(e[C]);
    o.charStrings = u;
    const E = new gr();
    E.setByName("Subrs", null);
    const p = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
    for (C = 0, d = p.length; C < d; C++) {
      const b = p[C];
      if (!(b in n.privateData)) continue;
      const D = n.privateData[b];
      if (Array.isArray(D)) for (let S = D.length - 1; S > 0; S--) D[S] -= D[S - 1];
      E.setByName(b, D);
    }
    o.topDict.privateDict = E;
    const y = new Ss();
    for (C = 0, d = s.length; C < d; C++) y.add(s[C]);
    return E.subrsIndex = y, new br(o).compile();
  }
}
const Ti = [[57344, 63743], [1048576, 1114109]], zs = 1e3, t1 = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "systemFontInfo", "type", "vertical"], v5 = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
function th(A) {
  if (!A.fontMatrix || A.fontMatrix[0] === aa[0]) return;
  const t = 1e-3 / A.fontMatrix[0], e = A.widths;
  for (const i in e) e[i] *= t;
  A.defaultWidth *= t;
}
function A1(A) {
  if (!A.fallbackToUnicode || A.toUnicode instanceof ti) return;
  const t = [];
  for (const e in A.fallbackToUnicode) A.toUnicode.has(e) || (t[e] = A.fallbackToUnicode[e]);
  t.length > 0 && A.toUnicode.amend(t);
}
class M5 {
  constructor(t, e, i, s, n, o, r, c, h) {
    this.originalCharCode = t, this.fontChar = e, this.unicode = i, this.accent = s, this.width = n, this.vmetric = o, this.operatorListId = r, this.isSpace = c, this.isInFont = h;
  }
  get category() {
    return bt(this, "category", (function(t) {
      const e = Th.get(t);
      if (e) return e;
      const i = t.match(o5), s = { isWhitespace: !!i?.[1], isZeroWidthDiacritic: !!i?.[2], isInvisibleFormatMark: !!i?.[3] };
      return Th.set(t, s), s;
    })(this.unicode), !0);
  }
}
function Ws(A, t) {
  return (A << 8) + t;
}
function Dn(A, t, e) {
  A[t + 1] = e, A[t] = e >>> 8;
}
function Ve(A, t) {
  const e = (A << 8) + t;
  return 32768 & e ? e - 65536 : e;
}
function IA(A) {
  return String.fromCharCode(A >> 8 & 255, 255 & A);
}
function js(A) {
  return A > 32767 ? A = 32767 : A < -32768 && (A = -32768), String.fromCharCode(A >> 8 & 255, 255 & A);
}
function mE(A) {
  return Re(A.peekBytes(4)) === "ttcf";
}
function L5(A, { type: t, subtype: e, composite: i }) {
  let s, n;
  return (function(o) {
    const r = o.peekBytes(4);
    return bA(r, 0) === 65536 || Re(r) === "true";
  })(A) || mE(A) ? s = i ? "CIDFontType2" : "TrueType" : (function(o) {
    return Re(o.peekBytes(4)) === "OTTO";
  })(A) ? s = i ? "CIDFontType2" : "OpenType" : (function(o) {
    const r = o.peekBytes(2);
    return r[0] === 37 && r[1] === 33 || r[0] === 128 && r[1] === 1;
  })(A) ? s = i ? "CIDFontType0" : t === "MMType1" ? "MMType1" : "Type1" : (function(o) {
    const r = o.peekBytes(4);
    return r[0] >= 1 && r[3] >= 1 && r[3] <= 4;
  })(A) ? i ? (s = "CIDFontType0", n = "CIDFontType0C") : (s = t === "MMType1" ? "MMType1" : "Type1", n = "Type1C") : (O("getFontFileType: Unable to detect correct font file Type/Subtype."), s = t, n = e), [s, n];
}
function so(A, t) {
  for (const e in t) A[+e] = t[e];
}
function Ah(A, t, e) {
  const i = [];
  let s;
  for (let n = 0, o = A.length; n < o; n++) s = Va(A[n], t), s !== -1 && (i[n] = s);
  for (const n in e) s = Va(e[n], t), s !== -1 && (i[+n] = s);
  return i;
}
function U5(A) {
  return A.platform === 1 && A.encoding === 0 && A.language === 0;
}
function e1(A) {
  return A.platform === 3 && A.encoding === 1 && A.language === 1033;
}
function eh(A, t, e = !1) {
  switch (t.length) {
    case 1:
      return t.charCodeAt(0);
    case 2:
      return t.charCodeAt(0) << 8 | t.charCodeAt(1);
  }
  const i = `Unsupported CID string (charCode ${A}): "${t}".`;
  if (e) throw new Ct(i);
  return O(i), t;
}
function i1(A, t, e, i) {
  const s = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ new Map(), o = [], r = /* @__PURE__ */ new Set();
  let c = 0, h = Ti[c][0], I = Ti[c][1];
  const C = (d) => Ti[0][0] <= d && d <= Ti[0][1] || Ti[1][0] <= d && d <= Ti[1][1];
  for (const d in A) {
    let u = A[d];
    if (!t(u)) continue;
    if (h > I) {
      if (c++, c >= Ti.length) {
        O("Ran out of space in font private use area.");
        break;
      }
      h = Ti[c][0], I = Ti[c][1];
    }
    const E = h++;
    u === 0 && (u = e);
    let p = i.get(d);
    typeof p == "string" && (p = p.codePointAt(0)), !p || C(p) || r.has(u) || (n.set(p, u), r.add(u)), s[E] = u, o[d] = E;
  }
  return { toFontChar: o, charCodeToGlyphId: s, toUnicodeExtraMap: n, nextAvailableFontCharCode: h };
}
function s1(A, t, e) {
  const i = (function(Y, ht, ut) {
    const j = [];
    for (const Z in Y) Y[Z] >= ut || j.push({ fontCharCode: 0 | Z, glyphId: Y[Z] });
    if (ht) for (const [Z, st] of ht) st >= ut || j.push({ fontCharCode: Z, glyphId: st });
    j.length === 0 && j.push({ fontCharCode: 0, glyphId: 0 }), j.sort((function(Z, st) {
      return Z.fontCharCode - st.fontCharCode;
    }));
    const it = [], tt = j.length;
    for (let Z = 0; Z < tt; ) {
      const st = j[Z].fontCharCode, dt = [j[Z].glyphId];
      ++Z;
      let ct = st;
      for (; Z < tt && ct + 1 === j[Z].fontCharCode && (dt.push(j[Z].glyphId), ++ct, ++Z, ct !== 65535); ) ;
      it.push([st, ct, dt]);
    }
    return it;
  })(A, t, e), s = i.at(-1)[1] > 65535 ? 2 : 1;
  let n, o, r, c, h = "\0\0" + IA(s) + "\0\0" + ne(4 + 8 * s);
  for (n = i.length - 1; n >= 0 && !(i[n][0] <= 65535); --n) ;
  const I = n + 1;
  i[n][0] < 65535 && i[n][1] === 65535 && (i[n][1] = 65534);
  const C = i[n][1] < 65535 ? 1 : 0, d = I + C, u = lr.getSearchParams(d, 2);
  let E, p, y, b, D = "", S = "", R = "", x = "", N = "", U = 0;
  for (n = 0, o = I; n < o; n++) {
    E = i[n], p = E[0], y = E[1], D += IA(p), S += IA(y), b = E[2];
    let Y = !0;
    for (r = 1, c = b.length; r < c; ++r) if (b[r] !== b[r - 1] + 1) {
      Y = !1;
      break;
    }
    if (Y)
      R += IA(b[0] - p & 65535), x += IA(0);
    else {
      const ht = 2 * (d - n) + 2 * U;
      for (U += y - p + 1, R += IA(0), x += IA(ht), r = 0, c = b.length; r < c; ++r) N += IA(b[r]);
    }
  }
  C > 0 && (S += "ÿÿ", D += "ÿÿ", R += "\0", x += "\0\0");
  const T = "\0\0" + IA(2 * d) + IA(u.range) + IA(u.entry) + IA(u.rangeShift) + S + "\0\0" + D + R + x + N;
  let q = "", _ = "";
  if (s > 1) {
    for (h += `\0\0
` + ne(4 + 8 * s + 4 + T.length), q = "", n = 0, o = i.length; n < o; n++) {
      E = i[n], p = E[0], b = E[2];
      let Y = b[0];
      for (r = 1, c = b.length; r < c; ++r) b[r] !== b[r - 1] + 1 && (y = E[0] + r - 1, q += ne(p) + ne(y) + ne(Y), p = y + 1, Y = b[r]);
      q += ne(p) + ne(E[1]) + ne(Y);
    }
    _ = "\0\f\0\0" + ne(q.length + 16) + "\0\0\0\0" + ne(q.length / 12);
  }
  return h + "\0" + IA(T.length + 4) + T + _ + q;
}
function a1(A, t, e) {
  e ||= { unitsPerEm: 0, yMax: 0, yMin: 0, ascent: 0, descent: 0 };
  let i = 0, s = 0, n = 0, o = 0, r = null, c = 0, h = -1;
  if (t) {
    for (let b in t) if (b |= 0, (r > b || !r) && (r = b), c < b && (c = b), h = r5(b, h), h < 32) i |= 1 << h;
    else if (h < 64) s |= 1 << h - 32;
    else if (h < 96) n |= 1 << h - 64;
    else {
      if (!(h < 123)) throw new Ct("Unicode ranges Bits > 123 are reserved for internal usage");
      o |= 1 << h - 96;
    }
    c > 65535 && (c = 65535);
  } else r = 0, c = 255;
  const I = A.bbox || [0, 0, 0, 0], C = e.unitsPerEm || (A.fontMatrix ? 1 / Math.max(...A.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3), d = A.ascentScaled ? 1 : C / zs, u = e.ascent || Math.round(d * (A.ascent || I[3]));
  let E = e.descent || Math.round(d * (A.descent || I[1]));
  E > 0 && A.descent > 0 && I[1] < 0 && (E = -E);
  const p = e.yMax || u, y = -e.yMin || -E;
  return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode(A.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + ne(i) + ne(s) + ne(n) + ne(o) + "*21*" + IA(A.italicAngle ? 1 : 0) + IA(r || A.firstChar) + IA(c || A.lastChar) + IA(u) + IA(E) + "\0d" + IA(p) + IA(y) + "\0\0\0\0\0\0\0\0" + IA(A.xHeight) + IA(A.capHeight) + IA(0) + IA(r || A.firstChar) + "\0";
}
function n1(A) {
  return "\0\0\0" + ne(Math.floor(65536 * A.italicAngle)) + "\0\0\0\0" + ne(A.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
}
function H5(A) {
  return A.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
function ih(A, t) {
  t || (t = [[], []]);
  const e = [t[0][0] || "Original licence", t[0][1] || A, t[0][2] || "Unknown", t[0][3] || "uniqueID", t[0][4] || A, t[0][5] || "Version 0.11", t[0][6] || H5(A), t[0][7] || "Unknown", t[0][8] || "Unknown", t[0][9] || "Unknown"], i = [];
  let s, n, o, r, c;
  for (s = 0, n = e.length; s < n; s++) {
    c = t[1][s] || e[s];
    const y = [];
    for (o = 0, r = c.length; o < r; o++) y.push(IA(c.charCodeAt(o)));
    i.push(y.join(""));
  }
  const h = [e, i], I = ["\0", "\0"], C = ["\0\0", "\0"], d = ["\0\0", "	"], u = e.length * I.length;
  let E = "\0\0" + IA(u) + IA(12 * u + 6), p = 0;
  for (s = 0, n = I.length; s < n; s++) {
    const y = h[s];
    for (o = 0, r = y.length; o < r; o++)
      c = y[o], E += I[s] + C[s] + d[s] + IA(o) + IA(c.length) + IA(p), p += c.length;
  }
  return E += e.join("") + i.join(""), E;
}
class r1 {
  constructor(t, e, i) {
    this.name = t, this.psName = null, this.mimetype = null, this.disableFontFace = !1, this.loadedName = i.loadedName, this.isType3Font = i.isType3Font, this.missingFile = !1, this.cssFontInfo = i.cssFontInfo, this._charsCache = /* @__PURE__ */ Object.create(null), this._glyphCache = /* @__PURE__ */ Object.create(null);
    let s = !!(i.flags & BE);
    if (!s && !i.isSimulatedFlags) {
      const h = t.replaceAll(/[,_]/g, "-").split("-", 1)[0], I = Nl();
      for (const C of h.split("+")) if (I[C]) {
        s = !0;
        break;
      }
    }
    this.isSerifFont = s, this.isSymbolicFont = !!(i.flags & Zo), this.isMonospace = !!(i.flags & bo);
    let { type: n, subtype: o } = i;
    this.type = n, this.subtype = o, this.systemFontInfo = i.systemFontInfo;
    const r = t.match(/^InvalidPDFjsFont_(.*)_\d+$/);
    if (this.isInvalidPDFjsFont = !!r, this.isInvalidPDFjsFont ? this.fallbackName = r[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif", this.systemFontInfo?.guessFallback && (this.systemFontInfo.guessFallback = !1, this.systemFontInfo.css += `,${this.fallbackName}`), this.differences = i.differences, this.widths = i.widths, this.defaultWidth = i.defaultWidth, this.composite = i.composite, this.cMap = i.cMap, this.capHeight = i.capHeight / zs, this.ascent = i.ascent / zs, this.descent = i.descent / zs, this.lineHeight = this.ascent - this.descent, this.fontMatrix = i.fontMatrix, this.bbox = i.bbox, this.defaultEncoding = i.defaultEncoding, this.toUnicode = i.toUnicode, this.toFontChar = [], i.type === "Type3") {
      for (let h = 0; h < 256; h++) this.toFontChar[h] = this.differences[h] || i.defaultEncoding[h];
      return;
    }
    if (this.cidEncoding = i.cidEncoding || "", this.vertical = !!i.vertical, this.vertical && (this.vmetrics = i.vmetrics, this.defaultVMetrics = i.defaultVMetrics), !e || e.isEmpty) return e && O('Font file is empty in "' + t + '" (' + this.loadedName + ")"), void this.fallbackToSystemFont(i);
    let c;
    [n, o] = L5(e, i), n === this.type && o === this.subtype || tA(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${n}/${o}.`);
    try {
      switch (n) {
        case "MMType1":
          tA("MMType1 font (" + t + "), falling back to Type1.");
        case "Type1":
        case "CIDFontType0":
          this.mimetype = "font/opentype";
          const h = o === "Type1C" || o === "CIDFontType0C" ? new Xc(e, i) : new G5(t, e, i);
          th(i), c = this.convert(t, h, i);
          break;
        case "OpenType":
        case "TrueType":
        case "CIDFontType2":
          this.mimetype = "font/opentype", c = this.checkAndRepair(t, e, i), this.isOpenType && (th(i), n = "OpenType");
          break;
        default:
          throw new Ct(`Font ${n} is not supported`);
      }
    } catch (h) {
      return O(h), void this.fallbackToSystemFont(i);
    }
    A1(i), this.data = c, this.type = n, this.subtype = o, this.fontMatrix = i.fontMatrix, this.widths = i.widths, this.defaultWidth = i.defaultWidth, this.toUnicode = i.toUnicode, this.seacMap = i.seacMap;
  }
  get renderer() {
    return bt(this, "renderer", Q5.create(this, cr));
  }
  exportData(t = !1) {
    const e = t ? [...t1, ...v5] : t1, i = /* @__PURE__ */ Object.create(null);
    let s, n;
    for (s of e) n = this[s], n !== void 0 && (i[s] = n);
    return i;
  }
  fallbackToSystemFont(t) {
    this.missingFile = !0;
    const { name: e, type: i } = this;
    let s = Dr(e);
    const n = dg(), o = EE(), r = !!n[s], c = !(!o[s] || !n[o[s]]);
    s = n[s] || o[s] || s;
    const h = f5()[s];
    h && (isNaN(this.ascent) && (this.ascent = h.ascent / zs), isNaN(this.descent) && (this.descent = h.descent / zs), isNaN(this.capHeight) && (this.capHeight = h.capHeight / zs)), this.bold = /bold/gi.test(s), this.italic = /oblique|italic/gi.test(s), this.black = /Black/g.test(e);
    const I = /Narrow/g.test(e);
    if (this.remeasure = (!r || I) && Object.keys(this.widths).length > 0, (r || c) && i === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
      const C = t.cidToGidMap, d = [];
      if (so(d, qC()), /Arial-?Black/i.test(e) ? so(d, h5()) : /Calibri/i.test(e) && so(d, l5()), C) {
        for (const u in d) {
          const E = d[u];
          C[E] !== void 0 && (d[+u] = C[E]);
        }
        C.length !== this.toUnicode.length && t.hasIncludedToUnicodeMap && this.toUnicode instanceof ti && this.toUnicode.forEach((function(u, E) {
          const p = d[u];
          C[p] === void 0 && (d[+u] = E);
        }));
      }
      this.toUnicode instanceof ti || this.toUnicode.forEach((function(u, E) {
        d[+u] = E;
      })), this.toFontChar = d, this.toUnicode = new Tn(d);
    } else if (/Symbol/i.test(s)) this.toFontChar = Ah(Sl, mi(), this.differences);
    else if (/Dingbats/i.test(s)) this.toFontChar = Ah(Fl, a5(), this.differences);
    else if (r || c) {
      const C = Ah(this.defaultEncoding, mi(), this.differences);
      i !== "CIDFontType2" || this.cidEncoding.startsWith("Identity-") || this.toUnicode instanceof ti || this.toUnicode.forEach((function(d, u) {
        C[+d] = u;
      })), this.toFontChar = C;
    } else {
      const C = mi(), d = [];
      this.toUnicode.forEach(((u, E) => {
        if (!this.composite) {
          const p = Va(this.differences[u] || this.defaultEncoding[u], C);
          p !== -1 && (E = p);
        }
        d[+u] = E;
      })), this.composite && this.toUnicode instanceof ti && /Tahoma|Verdana/i.test(e) && so(d, qC()), this.toFontChar = d;
    }
    A1(t), this.loadedName = s.split("-", 1)[0];
  }
  checkAndRepair(t, e, i) {
    const s = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
    function n(j, it) {
      const tt = /* @__PURE__ */ Object.create(null);
      tt["OS/2"] = null, tt.cmap = null, tt.head = null, tt.hhea = null, tt.hmtx = null, tt.maxp = null, tt.name = null, tt.post = null;
      for (let Z = 0; Z < it; Z++) {
        const st = o(j);
        s.includes(st.tag) && st.length !== 0 && (tt[st.tag] = st);
      }
      return tt;
    }
    function o(j) {
      const it = j.getString(4), tt = j.getInt32() >>> 0, Z = j.getInt32() >>> 0, st = j.getInt32() >>> 0, dt = j.pos;
      j.pos = j.start || 0, j.skip(Z);
      const ct = j.getBytes(st);
      return j.pos = dt, it === "head" && (ct[8] = ct[9] = ct[10] = ct[11] = 0, ct[17] |= 32), { tag: it, checksum: tt, length: st, offset: Z, data: ct };
    }
    function r(j) {
      return { version: j.getString(4), numTables: j.getUint16(), searchRange: j.getUint16(), entrySelector: j.getUint16(), rangeShift: j.getUint16() };
    }
    function c(j, it, tt, Z, st, dt) {
      const ct = { length: 0, sizeOfInstructions: 0 };
      if (it < 0 || it >= j.length || tt > j.length || tt - it <= 12) return ct;
      const M = j.subarray(it, tt), H = Ve(M[2], M[3]), W = Ve(M[4], M[5]), lt = Ve(M[6], M[7]), $ = Ve(M[8], M[9]);
      H > lt && (Dn(M, 2, lt), Dn(M, 6, H)), W > $ && (Dn(M, 4, $), Dn(M, 8, W));
      const ot = Ve(M[0], M[1]);
      if (ot < 0) return ot < -1 || (Z.set(M, st), ct.length = M.length), ct;
      let V, rt = 10, Bt = 0;
      for (V = 0; V < ot; V++)
        Bt = (M[rt] << 8 | M[rt + 1]) + 1, rt += 2;
      const Rt = rt, Ft = M[rt] << 8 | M[rt + 1];
      ct.sizeOfInstructions = Ft, rt += 2 + Ft;
      const ft = rt;
      let Kt = 0;
      for (V = 0; V < Bt; V++) {
        const vt = M[rt++];
        192 & vt && (M[rt - 1] = 63 & vt);
        let Ht = 2;
        2 & vt ? Ht = 1 : 16 & vt && (Ht = 0);
        let Jt = 2;
        4 & vt ? Jt = 1 : 32 & vt && (Jt = 0);
        const Gt = Ht + Jt;
        if (Kt += Gt, 8 & vt) {
          const Zt = M[rt++];
          Zt === 0 && (M[rt - 1] ^= 8), V += Zt, Kt += Zt * Gt;
        }
      }
      if (Kt === 0) return ct;
      let yt = rt + Kt;
      return yt > M.length ? ct : !dt && Ft > 0 ? (Z.set(M.subarray(0, Rt), st), Z.set([0, 0], st + Rt), Z.set(M.subarray(ft, yt), st + Rt + 2), yt -= Ft, M.length - yt > 3 && (yt = yt + 3 & -4), ct.length = yt, ct) : M.length - yt > 3 ? (yt = yt + 3 & -4, Z.set(M.subarray(0, yt), st), ct.length = yt, ct) : (Z.set(M, st), ct.length = M.length, ct);
    }
    function h(j) {
      const it = (e.start || 0) + j.offset;
      e.pos = it;
      const tt = [[], []], Z = [], st = j.length, dt = it + st;
      if (e.getUint16() !== 0 || st < 6) return [tt, Z];
      const ct = e.getUint16(), M = e.getUint16();
      let H, W;
      for (H = 0; H < ct && e.pos + 12 <= dt; H++) {
        const lt = { platform: e.getUint16(), encoding: e.getUint16(), language: e.getUint16(), name: e.getUint16(), length: e.getUint16(), offset: e.getUint16() };
        (U5(lt) || e1(lt)) && Z.push(lt);
      }
      for (H = 0, W = Z.length; H < W; H++) {
        const lt = Z[H];
        if (lt.length <= 0) continue;
        const $ = it + M + lt.offset;
        if ($ + lt.length > dt) continue;
        e.pos = $;
        const ot = lt.name;
        if (lt.encoding) {
          let V = "";
          for (let rt = 0, Bt = lt.length; rt < Bt; rt += 2) V += String.fromCharCode(e.getUint16());
          tt[1][ot] = V;
        } else tt[0][ot] = e.getString(lt.length);
      }
      return [tt, Z];
    }
    const I = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
    function C(j, it) {
      let tt, Z, st, dt, ct, M = j.data, H = 0, W = 0, lt = 0;
      const $ = [], ot = [], V = [];
      let rt = it.tooComplexToFollowFunctions, Bt = !1, Rt = 0, Ft = 0;
      for (let Kt = M.length; H < Kt; ) {
        const yt = M[H++];
        if (yt === 64) if (Z = M[H++], Bt || Ft) H += Z;
        else for (tt = 0; tt < Z; tt++) $.push(M[H++]);
        else if (yt === 65) if (Z = M[H++], Bt || Ft) H += 2 * Z;
        else for (tt = 0; tt < Z; tt++) st = M[H++], $.push(st << 8 | M[H++]);
        else if ((248 & yt) == 176) if (Z = yt - 176 + 1, Bt || Ft) H += Z;
        else for (tt = 0; tt < Z; tt++) $.push(M[H++]);
        else if ((248 & yt) == 184) if (Z = yt - 184 + 1, Bt || Ft) H += 2 * Z;
        else for (tt = 0; tt < Z; tt++) st = M[H++], $.push(st << 8 | M[H++]);
        else if (yt !== 43 || rt) if (yt !== 44 || rt) {
          if (yt === 45) if (Bt) Bt = !1, W = H;
          else {
            if (ct = ot.pop(), !ct) return O("TT: ENDF bad stack"), void (it.hintsValid = !1);
            dt = V.pop(), M = ct.data, H = ct.i, it.functionsStackDeltas[dt] = $.length - ct.stackTop;
          }
          else if (yt === 137) (Bt || Ft) && (O("TT: nested IDEFs not allowed"), rt = !0), Bt = !0, lt = H;
          else if (yt === 88) ++Rt;
          else if (yt === 27) Ft = Rt;
          else if (yt === 89) Ft === Rt && (Ft = 0), --Rt;
          else if (yt === 28 && !Bt && !Ft) {
            const vt = $.at(-1);
            vt > 0 && (H += vt - 1);
          }
        } else (Bt || Ft) && (O("TT: nested FDEFs not allowed"), rt = !0), Bt = !0, lt = H, dt = $.pop(), it.functionsDefined[dt] = { data: M, i: H };
        else if (!Bt && !Ft) {
          if (dt = $.at(-1), isNaN(dt)) tA("TT: CALL empty stack (or invalid entry).");
          else if (it.functionsUsed[dt] = !0, dt in it.functionsStackDeltas) {
            const vt = $.length + it.functionsStackDeltas[dt];
            if (vt < 0) return O("TT: CALL invalid functions stack delta."), void (it.hintsValid = !1);
            $.length = vt;
          } else if (dt in it.functionsDefined && !V.includes(dt)) {
            if (ot.push({ data: M, i: H, stackTop: $.length - 1 }), V.push(dt), ct = it.functionsDefined[dt], !ct) return O("TT: CALL non-existent function"), void (it.hintsValid = !1);
            M = ct.data, H = ct.i;
          }
        }
        if (!Bt && !Ft) {
          let vt = 0;
          for (yt <= 142 ? vt = I[yt] : yt >= 192 && yt <= 223 ? vt = -1 : yt >= 224 && (vt = -2), yt >= 113 && yt <= 117 && (Z = $.pop(), isNaN(Z) || (vt = 2 * -Z)); vt < 0 && $.length > 0; ) $.pop(), vt++;
          for (; vt > 0; ) $.push(NaN), vt--;
        }
      }
      it.tooComplexToFollowFunctions = rt;
      const ft = [M];
      H > M.length && ft.push(new Uint8Array(H - M.length)), lt > W && (O("TT: complementing a missing function tail"), ft.push(new Uint8Array([34, 45]))), (function(Kt, yt) {
        if (yt.length > 1) {
          let vt, Ht, Jt = 0;
          for (vt = 0, Ht = yt.length; vt < Ht; vt++) Jt += yt[vt].length;
          Jt = Jt + 3 & -4;
          const Gt = new Uint8Array(Jt);
          let Zt = 0;
          for (vt = 0, Ht = yt.length; vt < Ht; vt++) Gt.set(yt[vt], Zt), Zt += yt[vt].length;
          Kt.data = Gt, Kt.length = Jt;
        }
      })(j, ft);
    }
    let d, u, E, p;
    if (mE(e = new RA(new Uint8Array(e.getBytes())))) {
      const j = (function(it, tt) {
        const { numFonts: Z, offsetTable: st } = (function(M) {
          const H = M.getString(4);
          pe(H === "ttcf", "Must be a TrueType Collection font.");
          const W = M.getUint16(), lt = M.getUint16(), $ = M.getInt32() >>> 0, ot = [];
          for (let rt = 0; rt < $; rt++) ot.push(M.getInt32() >>> 0);
          const V = { ttcTag: H, majorVersion: W, minorVersion: lt, numFonts: $, offsetTable: ot };
          switch (W) {
            case 1:
              return V;
            case 2:
              return V.dsigTag = M.getInt32() >>> 0, V.dsigLength = M.getInt32() >>> 0, V.dsigOffset = M.getInt32() >>> 0, V;
          }
          throw new Ct(`Invalid TrueType Collection majorVersion: ${W}.`);
        })(it), dt = tt.split("+");
        let ct;
        for (let M = 0; M < Z; M++) {
          it.pos = (it.start || 0) + st[M];
          const H = r(it), W = n(it, H.numTables);
          if (!W.name) throw new Ct('TrueType Collection font must contain a "name" table.');
          const [lt] = h(W.name);
          for (let $ = 0, ot = lt.length; $ < ot; $++) for (let V = 0, rt = lt[$].length; V < rt; V++) {
            const Bt = lt[$][V]?.replaceAll(/\s/g, "");
            if (Bt) {
              if (Bt === tt) return { header: H, tables: W };
              if (!(dt.length < 2)) for (const Rt of dt) Bt === Rt && (ct = { name: Rt, header: H, tables: W });
            }
          }
        }
        if (ct) return O(`TrueType Collection does not contain "${tt}" font, falling back to "${ct.name}" font instead.`), { header: ct.header, tables: ct.tables };
        throw new Ct(`TrueType Collection does not contain "${tt}" font.`);
      })(e, this.name);
      d = j.header, u = j.tables;
    } else d = r(e), u = n(e, d.numTables);
    const y = !u["CFF "];
    if (y) {
      if (!u.loca) throw new Ct('Required "loca" table is not found');
      u.glyf || (O('Required "glyf" table is not found -- trying to recover.'), u.glyf = { tag: "glyf", data: new Uint8Array(0) }), this.isOpenType = !1;
    } else {
      const j = i.composite && (i.cidToGidMap?.length > 0 || !(i.cMap instanceof _a));
      if (d.version === "OTTO" && !j || !u.head || !u.hhea || !u.maxp || !u.post) return p = new RA(u["CFF "].data), E = new Xc(p, i), th(i), this.convert(t, E, i);
      delete u.glyf, delete u.loca, delete u.fpgm, delete u.prep, delete u["cvt "], this.isOpenType = !0;
    }
    if (!u.maxp) throw new Ct('Required "maxp" table is not found');
    e.pos = (e.start || 0) + u.maxp.offset;
    let b = e.getInt32();
    const D = e.getUint16();
    if (b !== 65536 && b !== 20480) {
      if (u.maxp.length === 6) b = 20480;
      else {
        if (!(u.maxp.length >= 32)) throw new Ct('"maxp" table has a wrong version number');
        b = 65536;
      }
      (function(j, it, tt) {
        j[it + 3] = 255 & tt, j[it + 2] = tt >>> 8, j[it + 1] = tt >>> 16, j[it] = tt >>> 24;
      })(u.maxp.data, 0, b);
    }
    if (i.scaleFactors?.length === D && y) {
      const { scaleFactors: j } = i, it = Ws(u.head.data[50], u.head.data[51]), tt = new p5({ glyfTable: u.glyf.data, isGlyphLocationsLong: it, locaTable: u.loca.data, numGlyphs: D });
      tt.scale(j);
      const { glyf: Z, loca: st, isLocationLong: dt } = tt.write();
      u.glyf.data = Z, u.loca.data = st, dt !== !!it && (u.head.data[50] = 0, u.head.data[51] = dt ? 1 : 0);
      const ct = u.hmtx.data;
      for (let M = 0; M < D; M++) {
        const H = 4 * M, W = Math.round(j[M] * Ws(ct[H], ct[H + 1]));
        ct[H] = W >> 8 & 255, ct[H + 1] = 255 & W, Dn(ct, H + 2, Math.round(j[M] * Ve(ct[H + 2], ct[H + 3])));
      }
    }
    let S = D + 1, R = !0;
    S > 65535 && (R = !1, S = D, O("Not enough space in glyfs to duplicate first glyph."));
    let x = 0, N = 0;
    b >= 65536 && u.maxp.length >= 32 && (e.pos += 8, e.getUint16() > 2 && (u.maxp.data[14] = 0, u.maxp.data[15] = 2), e.pos += 4, x = e.getUint16(), e.pos += 4, N = e.getUint16()), u.maxp.data[4] = S >> 8, u.maxp.data[5] = 255 & S;
    const U = (function(j, it, tt, Z) {
      const st = { functionsDefined: [], functionsUsed: [], functionsStackDeltas: [], tooComplexToFollowFunctions: !1, hintsValid: !0 };
      if (j && C(j, st), it && C(it, st), j && (function(dt, ct) {
        if (!dt.tooComplexToFollowFunctions) {
          if (dt.functionsDefined.length > ct) return O("TT: more functions defined than expected"), void (dt.hintsValid = !1);
          for (let M = 0, H = dt.functionsUsed.length; M < H; M++) {
            if (M > ct) return O("TT: invalid function id: " + M), void (dt.hintsValid = !1);
            if (dt.functionsUsed[M] && !dt.functionsDefined[M]) return O("TT: undefined function: " + M), void (dt.hintsValid = !1);
          }
        }
      })(st, Z), tt && 1 & tt.length) {
        const dt = new Uint8Array(tt.length + 1);
        dt.set(tt.data), tt.data = dt;
      }
      return st.hintsValid;
    })(u.fpgm, u.prep, u["cvt "], x);
    if (U || (delete u.fpgm, delete u.prep, delete u["cvt "]), (function(j, it, tt, Z, st, dt) {
      if (!it) return void (tt && (tt.data = null));
      j.pos = (j.start || 0) + it.offset, j.pos += 4, j.pos += 2, j.pos += 2, j.pos += 2, j.pos += 2, j.pos += 2, j.pos += 2, j.pos += 2, j.pos += 2, j.pos += 2;
      const ct = j.getUint16();
      j.pos += 8, j.pos += 2;
      let M = j.getUint16();
      ct !== 0 && (2 & Ws(Z.data[44], Z.data[45]) || (it.data[22] = 0, it.data[23] = 0)), M > st && (tA(`The numOfMetrics (${M}) should not be greater than the numGlyphs (${st}).`), M = st, it.data[34] = (65280 & M) >> 8, it.data[35] = 255 & M);
      const H = st - M - (tt.length - 4 * M >> 1);
      if (H > 0) {
        const W = new Uint8Array(tt.length + 2 * H);
        W.set(tt.data), dt && (W[tt.length] = tt.data[2], W[tt.length + 1] = tt.data[3]), tt.data = W;
      }
    })(e, u.hhea, u.hmtx, u.head, S, R), !u.head) throw new Ct('Required "head" table is not found');
    (function(j, it, tt) {
      const Z = j.data, st = (dt = Z[0], ct = Z[1], M = Z[2], H = Z[3], (dt << 24) + (ct << 16) + (M << 8) + H);
      var dt, ct, M, H;
      st >> 16 != 1 && (tA("Attempting to fix invalid version in head table: " + st), Z[0] = 0, Z[1] = 1, Z[2] = 0, Z[3] = 0);
      const W = Ws(Z[50], Z[51]);
      if (W < 0 || W > 1) {
        tA("Attempting to fix invalid indexToLocFormat in head table: " + W);
        const lt = it + 1;
        if (tt === lt << 1) Z[50] = 0, Z[51] = 0;
        else {
          if (tt !== lt << 2) throw new Ct("Could not fix indexToLocFormat: " + W);
          Z[50] = 0, Z[51] = 1;
        }
      }
    })(u.head, D, y ? u.loca.length : 0);
    let T = /* @__PURE__ */ Object.create(null);
    if (y) {
      const j = Ws(u.head.data[50], u.head.data[51]), it = (function(tt, Z, st, dt, ct, M, H) {
        let W, lt, $;
        dt ? (W = 4, lt = function(Gt, Zt) {
          return Gt[Zt] << 24 | Gt[Zt + 1] << 16 | Gt[Zt + 2] << 8 | Gt[Zt + 3];
        }, $ = function(Gt, Zt, qt) {
          Gt[Zt] = qt >>> 24 & 255, Gt[Zt + 1] = qt >> 16 & 255, Gt[Zt + 2] = qt >> 8 & 255, Gt[Zt + 3] = 255 & qt;
        }) : (W = 2, lt = function(Gt, Zt) {
          return Gt[Zt] << 9 | Gt[Zt + 1] << 1;
        }, $ = function(Gt, Zt, qt) {
          Gt[Zt] = qt >> 9 & 255, Gt[Zt + 1] = qt >> 1 & 255;
        });
        const ot = M ? st + 1 : st, V = W * (1 + ot), rt = new Uint8Array(V);
        rt.set(tt.data.subarray(0, V)), tt.data = rt;
        const Bt = Z.data, Rt = Bt.length, Ft = new Uint8Array(Rt);
        let ft, Kt;
        const yt = [];
        for (ft = 0, Kt = 0; ft < st + 1; ft++, Kt += W) {
          let Gt = lt(rt, Kt);
          Gt > Rt && (Gt = Rt), yt.push({ index: ft, offset: Gt, endOffset: 0 });
        }
        for (yt.sort(((Gt, Zt) => Gt.offset - Zt.offset)), ft = 0; ft < st; ft++) yt[ft].endOffset = yt[ft + 1].offset;
        for (yt.sort(((Gt, Zt) => Gt.index - Zt.index)), ft = 0; ft < st; ft++) {
          const { offset: Gt, endOffset: Zt } = yt[ft];
          if (Gt !== 0 || Zt !== 0) break;
          const qt = yt[ft + 1].offset;
          if (qt !== 0) {
            yt[ft].endOffset = qt;
            break;
          }
        }
        const vt = yt.at(-2);
        vt.offset !== 0 && vt.endOffset === 0 && (vt.endOffset = Rt);
        const Ht = /* @__PURE__ */ Object.create(null);
        let Jt = 0;
        for ($(rt, 0, Jt), ft = 0, Kt = W; ft < st; ft++, Kt += W) {
          const Gt = c(Bt, yt[ft].offset, yt[ft].endOffset, Ft, Jt, ct), Zt = Gt.length;
          Zt === 0 && (Ht[ft] = !0), Gt.sizeOfInstructions > H && (H = Gt.sizeOfInstructions), Jt += Zt, $(rt, Kt, Jt);
        }
        if (Jt === 0) {
          const Gt = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
          for (ft = 0, Kt = W; ft < ot; ft++, Kt += W) $(rt, Kt, Gt.length);
          Z.data = Gt;
        } else if (M) {
          const Gt = lt(rt, W);
          Ft.length > Gt + Jt ? Z.data = Ft.subarray(0, Gt + Jt) : (Z.data = new Uint8Array(Gt + Jt), Z.data.set(Ft.subarray(0, Jt))), Z.data.set(Ft.subarray(0, Gt), Jt), $(tt.data, rt.length - W, Jt + Gt);
        } else Z.data = Ft.subarray(0, Jt);
        return { missingGlyphs: Ht, maxSizeOfInstructions: H };
      })(u.loca, u.glyf, D, j, U, R, N);
      T = it.missingGlyphs, b >= 65536 && u.maxp.length >= 32 && (u.maxp.data[26] = it.maxSizeOfInstructions >> 8, u.maxp.data[27] = 255 & it.maxSizeOfInstructions);
    }
    if (!u.hhea) throw new Ct('Required "hhea" table is not found');
    u.hhea.data[10] === 0 && u.hhea.data[11] === 0 && (u.hhea.data[10] = 255, u.hhea.data[11] = 255);
    const q = { unitsPerEm: Ws(u.head.data[18], u.head.data[19]), yMax: Ve(u.head.data[42], u.head.data[43]), yMin: Ve(u.head.data[38], u.head.data[39]), ascent: Ve(u.hhea.data[4], u.hhea.data[5]), descent: Ve(u.hhea.data[6], u.hhea.data[7]), lineGap: Ve(u.hhea.data[8], u.hhea.data[9]) };
    this.ascent = q.ascent / q.unitsPerEm, this.descent = q.descent / q.unitsPerEm, this.lineGap = q.lineGap / q.unitsPerEm, this.cssFontInfo?.lineHeight ? (this.lineHeight = this.cssFontInfo.metrics.lineHeight, this.lineGap = this.cssFontInfo.metrics.lineGap) : this.lineHeight = this.ascent - this.descent + this.lineGap, u.post && (function(j, it, tt) {
      const Z = (e.start || 0) + j.offset;
      e.pos = Z;
      const st = Z + j.length, dt = e.getInt32();
      let ct;
      e.skip(28);
      let M, H = !0;
      switch (dt) {
        case 65536:
          ct = KC;
          break;
        case 131072:
          const W = e.getUint16();
          if (W !== tt) {
            H = !1;
            break;
          }
          const lt = [];
          for (M = 0; M < W; ++M) {
            const V = e.getUint16();
            if (V >= 32768) {
              H = !1;
              break;
            }
            lt.push(V);
          }
          if (!H) break;
          const $ = [], ot = [];
          for (; e.pos < st; ) {
            const V = e.getByte();
            for (ot.length = V, M = 0; M < V; ++M) ot[M] = String.fromCharCode(e.getByte());
            $.push(ot.join(""));
          }
          for (ct = [], M = 0; M < W; ++M) {
            const V = lt[M];
            V < 258 ? ct.push(KC[V]) : ct.push($[V - 258]);
          }
          break;
        case 196608:
          break;
        default:
          O("Unknown/unsupported post table version " + dt), H = !1, it.defaultEncoding && (ct = it.defaultEncoding);
      }
      it.glyphNames = ct;
    })(u.post, i, D), u.post = { tag: "post", data: n1(i) };
    const _ = /* @__PURE__ */ Object.create(null);
    function Y(j) {
      return !T[j];
    }
    if (i.composite) {
      const j = i.cidToGidMap || [], it = j.length === 0;
      i.cMap.forEach((function(tt, Z) {
        if (typeof Z == "string" && (Z = eh(tt, Z, !0)), Z > 65535) throw new Ct("Max size of CID is 65,535");
        let st = -1;
        it ? st = Z : j[Z] !== void 0 && (st = j[Z]), st >= 0 && st < D && Y(st) && (_[tt] = st);
      }));
    } else {
      const j = (function(ct, M, H, W) {
        if (!ct) return O("No cmap table available."), { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: !1 };
        let lt, $ = (M.start || 0) + ct.offset;
        M.pos = $, M.skip(2);
        const ot = M.getUint16();
        let V, rt = !1;
        for (let yt = 0; yt < ot; yt++) {
          const vt = M.getUint16(), Ht = M.getUint16(), Jt = M.getInt32() >>> 0;
          let Gt = !1;
          if (V?.platformId !== vt || V?.encodingId !== Ht) {
            if (vt !== 0 || Ht !== 0 && Ht !== 1 && Ht !== 3) if (vt === 1 && Ht === 0) Gt = !0;
            else if (vt !== 3 || Ht !== 1 || !W && V) {
              if (H && vt === 3 && Ht === 0) {
                Gt = !0;
                let Zt = !0;
                if (yt < ot - 1) {
                  const qt = M.peekBytes(2);
                  Ws(qt[0], qt[1]) < vt && (Zt = !1);
                }
                Zt && (rt = !0);
              }
            } else Gt = !0, H || (rt = !0);
            else Gt = !0;
            if (Gt && (V = { platformId: vt, encodingId: Ht, offset: Jt }), rt) break;
          }
        }
        if (V && (M.pos = $ + V.offset), !V || M.peekByte() === -1) return O("Could not find a preferred cmap table."), { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: !1 };
        const Bt = M.getUint16();
        let Rt = !1;
        const Ft = [];
        let ft, Kt;
        if (Bt === 0) {
          for (M.skip(4), ft = 0; ft < 256; ft++) {
            const yt = M.getByte();
            yt && Ft.push({ charCode: ft, glyphId: yt });
          }
          Rt = !0;
        } else if (Bt === 2) {
          M.skip(4);
          const yt = [];
          let vt = 0;
          for (let Jt = 0; Jt < 256; Jt++) {
            const Gt = M.getUint16() >> 3;
            yt.push(Gt), vt = Math.max(Gt, vt);
          }
          const Ht = [];
          for (let Jt = 0; Jt <= vt; Jt++) Ht.push({ firstCode: M.getUint16(), entryCount: M.getUint16(), idDelta: Ve(M.getByte(), M.getByte()), idRangePos: M.pos + M.getUint16() });
          for (let Jt = 0; Jt < 256; Jt++) if (yt[Jt] === 0) M.pos = Ht[0].idRangePos + 2 * Jt, Kt = M.getUint16(), Ft.push({ charCode: Jt, glyphId: Kt });
          else {
            const Gt = Ht[yt[Jt]];
            for (ft = 0; ft < Gt.entryCount; ft++) {
              const Zt = (Jt << 8) + ft + Gt.firstCode;
              M.pos = Gt.idRangePos + 2 * ft, Kt = M.getUint16(), Kt !== 0 && (Kt = (Kt + Gt.idDelta) % 65536), Ft.push({ charCode: Zt, glyphId: Kt });
            }
          }
        } else if (Bt === 4) {
          M.skip(4);
          const yt = M.getUint16() >> 1;
          M.skip(6);
          const vt = [];
          let Ht;
          for (Ht = 0; Ht < yt; Ht++) vt.push({ end: M.getUint16() });
          for (M.skip(2), Ht = 0; Ht < yt; Ht++) vt[Ht].start = M.getUint16();
          for (Ht = 0; Ht < yt; Ht++) vt[Ht].delta = M.getUint16();
          let Jt, Gt = 0;
          for (Ht = 0; Ht < yt; Ht++) {
            lt = vt[Ht];
            const qt = M.getUint16();
            qt ? (Jt = (qt >> 1) - (yt - Ht), lt.offsetIndex = Jt, Gt = Math.max(Gt, Jt + lt.end - lt.start + 1)) : lt.offsetIndex = -1;
          }
          const Zt = [];
          for (ft = 0; ft < Gt; ft++) Zt.push(M.getUint16());
          for (Ht = 0; Ht < yt; Ht++) {
            lt = vt[Ht], $ = lt.start;
            const qt = lt.end, Xt = lt.delta;
            for (Jt = lt.offsetIndex, ft = $; ft <= qt; ft++) ft !== 65535 && (Kt = Jt < 0 ? ft : Zt[Jt + ft - $], Kt = Kt + Xt & 65535, Ft.push({ charCode: ft, glyphId: Kt }));
          }
        } else if (Bt === 6) {
          M.skip(4);
          const yt = M.getUint16(), vt = M.getUint16();
          for (ft = 0; ft < vt; ft++) {
            Kt = M.getUint16();
            const Ht = yt + ft;
            Ft.push({ charCode: Ht, glyphId: Kt });
          }
        } else {
          if (Bt !== 12) return O("cmap table has unsupported format: " + Bt), { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: !1 };
          {
            M.skip(10);
            const yt = M.getInt32() >>> 0;
            for (ft = 0; ft < yt; ft++) {
              const vt = M.getInt32() >>> 0, Ht = M.getInt32() >>> 0;
              let Jt = M.getInt32() >>> 0;
              for (let Gt = vt; Gt <= Ht; Gt++) Ft.push({ charCode: Gt, glyphId: Jt++ });
            }
          }
        }
        Ft.sort((function(yt, vt) {
          return yt.charCode - vt.charCode;
        }));
        for (let yt = 1; yt < Ft.length; yt++) Ft[yt - 1].charCode === Ft[yt].charCode && (Ft.splice(yt, 1), yt--);
        return { platformId: V.platformId, encodingId: V.encodingId, mappings: Ft, hasShortCmap: Rt };
      })(u.cmap, e, this.isSymbolicFont, i.hasEncoding), it = j.platformId, tt = j.encodingId, Z = j.mappings;
      let st = [], dt = !1;
      if (!i.hasEncoding || i.baseEncodingName !== "MacRomanEncoding" && i.baseEncodingName !== "WinAnsiEncoding" || (st = rr(i.baseEncodingName)), i.hasEncoding && !this.isSymbolicFont && (it === 3 && tt === 1 || it === 1 && tt === 0)) {
        const ct = mi();
        for (let M = 0; M < 256; M++) {
          let H;
          if (H = this.differences[M] !== void 0 ? this.differences[M] : st.length && st[M] !== "" ? st[M] : Vi[M], !H) continue;
          const W = dE(H, ct);
          let lt;
          if (it === 3 && tt === 1 ? lt = ct[W] : it === 1 && tt === 0 && (lt = kl.indexOf(W)), lt === void 0) {
            if (!i.glyphNames && i.hasIncludedToUnicodeMap && !(this.toUnicode instanceof ti)) {
              const $ = this.toUnicode.get(M);
              $ && (lt = $.codePointAt(0));
            }
            if (lt === void 0) continue;
          }
          for (const $ of Z) if ($.charCode === lt) {
            _[M] = $.glyphId;
            break;
          }
        }
      } else if (it === 0) {
        for (const ct of Z) _[ct.charCode] = ct.glyphId;
        dt = !0;
      } else if (it === 3 && tt === 0) for (const ct of Z) {
        let M = ct.charCode;
        M >= 61440 && M <= 61695 && (M &= 255), _[M] = ct.glyphId;
      }
      else for (const ct of Z) _[ct.charCode] = ct.glyphId;
      if (i.glyphNames && (st.length || this.differences.length)) for (let ct = 0; ct < 256; ++ct) {
        if (!dt && _[ct] !== void 0) continue;
        const M = this.differences[ct] || st[ct];
        if (!M) continue;
        const H = i.glyphNames.indexOf(M);
        H > 0 && Y(H) && (_[ct] = H);
      }
    }
    _.length === 0 && (_[0] = 0);
    let ht = S - 1;
    if (R || (ht = 0), !i.cssFontInfo) {
      const j = i1(_, Y, ht, this.toUnicode);
      this.toFontChar = j.toFontChar, u.cmap = { tag: "cmap", data: s1(j.charCodeToGlyphId, j.toUnicodeExtraMap, S) }, u["OS/2"] && (function(it, tt) {
        tt.pos = (tt.start || 0) + it.offset;
        const Z = tt.getUint16();
        tt.skip(60);
        const st = tt.getUint16();
        return !(Z < 4 && 768 & st) && !(tt.getUint16() > tt.getUint16()) && (tt.skip(6), tt.getUint16() !== 0 && (it.data[8] = it.data[9] = 0, !0));
      })(u["OS/2"], e) || (u["OS/2"] = { tag: "OS/2", data: a1(i, j.charCodeToGlyphId, q) });
    }
    if (!y) try {
      p = new RA(u["CFF "].data), E = new Rl(p, i, cr).parse(), E.duplicateFirstGlyph();
      const j = new br(E);
      u["CFF "].data = j.compile();
    } catch {
      O("Failed to compile font " + i.loadedName);
    }
    if (u.name) {
      const [j, it] = h(u.name);
      u.name.data = ih(t, j), this.psName = j[0][6] || null, i.composite || (function(tt, Z, st) {
        if (tt.isInternalFont || tt.hasIncludedToUnicodeMap || tt.hasEncoding || tt.toUnicode instanceof ti || !Z || st.length === 0 || tt.defaultEncoding === nr) return;
        for (const H of st) if (!e1(H)) return;
        const dt = nr, ct = [], M = mi();
        for (const H in dt) {
          const W = dt[H];
          if (W === "") continue;
          const lt = M[W];
          lt !== void 0 && (ct[H] = String.fromCharCode(lt));
        }
        ct.length > 0 && tt.toUnicode.amend(ct);
      })(i, this.isSymbolicFont, it);
    } else u.name = { tag: "name", data: ih(this.name) };
    const ut = new lr(d.version);
    for (const j in u) ut.addTable(j, u[j].data);
    return ut.toArray();
  }
  convert(t, e, i) {
    i.fixedPitch = !1, i.builtInEncoding && (function(p, y) {
      if (p.isInternalFont || p.hasIncludedToUnicodeMap || y === p.defaultEncoding || p.toUnicode instanceof ti) return;
      const b = [], D = mi();
      for (const S in y) {
        if (p.hasEncoding && (p.baseEncodingName || p.differences[S] !== void 0)) continue;
        const R = Va(y[S], D);
        R !== -1 && (b[S] = String.fromCharCode(R));
      }
      b.length > 0 && p.toUnicode.amend(b);
    })(i, i.builtInEncoding);
    let s = 1;
    e instanceof Xc && (s = e.numGlyphs - 1);
    const n = e.getGlyphMapping(i);
    let o = null, r = n, c = null;
    i.cssFontInfo || (o = i1(n, e.hasGlyphId.bind(e), s, this.toUnicode), this.toFontChar = o.toFontChar, r = o.charCodeToGlyphId, c = o.toUnicodeExtraMap);
    const h = e.numGlyphs;
    function I(p, y) {
      let b = null;
      for (const D in p) y === p[D] && (b ||= []).push(0 | D);
      return b;
    }
    function C(p, y) {
      for (const b in p) if (y === p[b]) return 0 | b;
      return o.charCodeToGlyphId[o.nextAvailableFontCharCode] = y, o.nextAvailableFontCharCode++;
    }
    const d = e.seacs;
    if (o && d?.length) {
      const p = i.fontMatrix || aa, y = e.getCharset(), b = /* @__PURE__ */ Object.create(null);
      for (let D in d) {
        D |= 0;
        const S = d[D], R = Vi[S[2]], x = Vi[S[3]], N = y.indexOf(R), U = y.indexOf(x);
        if (N < 0 || U < 0) continue;
        const T = { x: S[0] * p[0] + S[1] * p[2] + p[4], y: S[0] * p[1] + S[1] * p[3] + p[5] }, q = I(n, D);
        if (q) for (const _ of q) {
          const Y = o.charCodeToGlyphId, ht = C(Y, N), ut = C(Y, U);
          b[_] = { baseFontCharCode: ht, accentFontCharCode: ut, accentOffset: T };
        }
      }
      i.seacMap = b;
    }
    const u = i.fontMatrix ? 1 / Math.max(...i.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3, E = new lr("OTTO");
    return E.addTable("CFF ", e.data), E.addTable("OS/2", a1(i, r)), E.addTable("cmap", s1(r, c, h)), E.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + js(u) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + js(i.descent) + "ÿ" + js(i.ascent) + IA(i.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0"), E.addTable("hhea", "\0\0\0" + js(i.ascent) + js(i.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + js(i.capHeight) + js(Math.tan(i.italicAngle) * i.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + IA(h)), E.addTable("hmtx", (function() {
      const p = e.charstrings, y = e.cff ? e.cff.widths : null;
      let b = "\0\0\0\0";
      for (let D = 1, S = h; D < S; D++) {
        let R = 0;
        if (p) {
          const x = p[D - 1];
          R = "width" in x ? x.width : 0;
        } else y && (R = Math.ceil(y[D] || 0));
        b += IA(R) + IA(0);
      }
      return b;
    })()), E.addTable("maxp", "\0\0P\0" + IA(h)), E.addTable("name", ih(t)), E.addTable("post", n1(i)), E.toArray();
  }
  get _spaceWidth() {
    const t = ["space", "minus", "one", "i", "I"];
    let e;
    for (const i of t) {
      if (i in this.widths) {
        e = this.widths[i];
        break;
      }
      const s = mi()[i];
      let n = 0;
      if (this.composite && this.cMap.contains(s) && (n = this.cMap.lookup(s), typeof n == "string" && (n = eh(s, n))), !n && this.toUnicode && (n = this.toUnicode.charCodeOf(s)), n <= 0 && (n = s), e = this.widths[n], e) break;
    }
    return bt(this, "_spaceWidth", e || this.defaultWidth);
  }
  _charToGlyph(t, e = !1) {
    let i, s, n, o = this._glyphCache[t];
    if (o?.isSpace === e) return o;
    let r = t;
    this.cMap?.contains(t) && (r = this.cMap.lookup(t), typeof r == "string" && (r = eh(t, r))), s = this.widths[r], typeof s != "number" && (s = this.defaultWidth);
    const c = this.vmetrics?.[r];
    let h = this.toUnicode.get(t) || t;
    typeof h == "number" && (h = String.fromCharCode(h));
    let I = this.toFontChar[t] !== void 0;
    if (i = this.toFontChar[t] || t, this.missingFile) {
      const u = this.differences[t] || this.defaultEncoding[t];
      u !== ".notdef" && u !== "" || this.type !== "Type1" || (i = 32, u === "" && (s ||= this._spaceWidth, h = String.fromCharCode(i))), i = (function(E) {
        return E >= 65520 && E <= 65535 ? 0 : E >= 62976 && E <= 63743 ? n5()[E] || E : E === 173 ? 45 : E;
      })(i);
    }
    this.isType3Font && (n = i);
    let C = null;
    if (this.seacMap?.[t]) {
      I = !0;
      const u = this.seacMap[t];
      i = u.baseFontCharCode, C = { fontChar: String.fromCodePoint(u.accentFontCharCode), offset: u.accentOffset };
    }
    let d = "";
    if (typeof i == "number" && (i <= 1114111 ? d = String.fromCodePoint(i) : O(`charToGlyph - invalid fontCharCode: ${i}`)), this.missingFile && this.vertical && d.length === 1) {
      const u = g5()[d.charCodeAt(0)];
      u && (d = h = String.fromCharCode(u));
    }
    return o = new M5(t, d, h, C, s, c, n, e, I), this._glyphCache[t] = o;
  }
  charsToGlyphs(t) {
    let e = this._charsCache[t];
    if (e) return e;
    if (e = [], this.cMap) {
      const i = /* @__PURE__ */ Object.create(null), s = t.length;
      let n = 0;
      for (; n < s; ) {
        this.cMap.readCharCode(t, n, i);
        const { charcode: o, length: r } = i;
        n += r;
        const c = this._charToGlyph(o, r === 1 && t.charCodeAt(n - 1) === 32);
        e.push(c);
      }
    } else for (let i = 0, s = t.length; i < s; ++i) {
      const n = t.charCodeAt(i), o = this._charToGlyph(n, n === 32);
      e.push(o);
    }
    return this._charsCache[t] = e;
  }
  getCharPositions(t) {
    const e = [];
    if (this.cMap) {
      const i = /* @__PURE__ */ Object.create(null);
      let s = 0;
      for (; s < t.length; ) {
        this.cMap.readCharCode(t, s, i);
        const n = i.length;
        e.push([s, s + n]), s += n;
      }
    } else for (let i = 0, s = t.length; i < s; ++i) e.push([i, i + 1]);
    return e;
  }
  get glyphCacheValues() {
    return Object.values(this._glyphCache);
  }
  encodeString(t) {
    const e = [], i = [], s = () => e.length % 2 == 1, n = this.toUnicode instanceof ti ? (o) => this.toUnicode.charCodeOf(o) : (o) => this.toUnicode.charCodeOf(String.fromCodePoint(o));
    for (let o = 0, r = t.length; o < r; o++) {
      const c = t.codePointAt(o);
      if (c > 55295 && (c < 57344 || c > 65533) && o++, this.toUnicode) {
        const h = n(c);
        if (h !== -1) {
          s() && (e.push(i.join("")), i.length = 0);
          for (let I = (this.cMap ? this.cMap.getCharCodeLength(h) : 1) - 1; I >= 0; I--) i.push(String.fromCharCode(h >> 8 * I & 255));
          continue;
        }
      }
      s() || (e.push(i.join("")), i.length = 0), i.push(String.fromCodePoint(c));
    }
    return e.push(i.join("")), e;
  }
}
class sh {
  constructor(t) {
    this.error = t, this.loadedName = "g_font_error", this.missingFile = !0;
  }
  charsToGlyphs() {
    return [];
  }
  encodeString(t) {
    return [t];
  }
  exportData(t = !1) {
    return { error: this.error };
  }
}
const _h = 2, Do = 3, yE = 4, wE = 5, bE = 6, DE = 7;
class J5 {
  constructor() {
    oA("Cannot initialize Pattern.");
  }
  static parseShading(t, e, i, s, n) {
    const o = t instanceof AA ? t.dict : t, r = o.get("ShadingType");
    try {
      switch (r) {
        case _h:
        case Do:
          return new Y5(o, e, i, s, n);
        case yE:
        case wE:
        case bE:
        case DE:
          return new fs(t, e, i, s, n);
        default:
          throw new Ct("Unsupported ShadingType: " + r);
      }
    } catch (c) {
      if (c instanceof yA) throw c;
      return O(c), new K5();
    }
  }
}
class jn {
  static SMALL_NUMBER = 1e-6;
  getIR() {
    oA("Abstract method `getIR` called.");
  }
}
class Y5 extends jn {
  constructor(t, e, i, s, n) {
    super(), this.shadingType = t.get("ShadingType");
    let o = 0;
    if (this.shadingType === _h ? o = 4 : this.shadingType === Do && (o = 6), this.coordsArr = t.getArray("Coords"), !Pe(this.coordsArr, o)) throw new Ct("RadialAxialShading: Invalid /Coords array.");
    const r = Vt.parse({ cs: t.getRaw("CS") || t.getRaw("ColorSpace"), xref: e, resources: i, pdfFunctionFactory: s, localColorSpaceCache: n });
    this.bbox = Zi(t.getArray("BBox"), null);
    let c = 0, h = 1;
    const I = t.getArray("Domain");
    Pe(I, 2) && ([c, h] = I);
    let C = !1, d = !1;
    const u = t.getArray("Extend");
    var E, p;
    if (E = u, p = 2, Array.isArray(E) && E.length === p && E.every(((ct) => typeof ct == "boolean")) && ([C, d] = u), !(this.shadingType !== Do || C && d)) {
      const [ct, M, H, W, lt, $] = this.coordsArr, ot = Math.hypot(ct - W, M - lt);
      H <= $ + ot && $ <= H + ot && O("Unsupported radial gradient.");
    }
    this.extendStart = C, this.extendEnd = d;
    const y = t.getRaw("Function"), b = s.createFromArray(y), D = (h - c) / 840, S = this.colorStops = [];
    if (c >= h || D <= 0) return void tA("Bad shading domain.");
    const R = new Float32Array(r.numComps), x = new Float32Array(1);
    let N, U = 0;
    x[0] = c, b(x, 0, R, 0);
    let T = r.getRgb(R, 0);
    const q = PA.makeHexColor(T[0], T[1], T[2]);
    S.push([0, q]);
    let _ = 1;
    x[0] = c + D, b(x, 0, R, 0);
    let Y = r.getRgb(R, 0), ht = Y[0] - T[0] + 1, ut = Y[1] - T[1] + 1, j = Y[2] - T[2] + 1, it = Y[0] - T[0] - 1, tt = Y[1] - T[1] - 1, Z = Y[2] - T[2] - 1;
    for (let ct = 2; ct < 840; ct++) {
      x[0] = c + ct * D, b(x, 0, R, 0), N = r.getRgb(R, 0);
      const M = ct - U;
      if (ht = Math.min(ht, (N[0] - T[0] + 1) / M), ut = Math.min(ut, (N[1] - T[1] + 1) / M), j = Math.min(j, (N[2] - T[2] + 1) / M), it = Math.max(it, (N[0] - T[0] - 1) / M), tt = Math.max(tt, (N[1] - T[1] - 1) / M), Z = Math.max(Z, (N[2] - T[2] - 1) / M), !(it <= ht && tt <= ut && Z <= j)) {
        const H = PA.makeHexColor(Y[0], Y[1], Y[2]);
        S.push([_ / 840, H]), ht = N[0] - Y[0] + 1, ut = N[1] - Y[1] + 1, j = N[2] - Y[2] + 1, it = N[0] - Y[0] - 1, tt = N[1] - Y[1] - 1, Z = N[2] - Y[2] - 1, U = _, T = Y;
      }
      _ = ct, Y = N;
    }
    const st = PA.makeHexColor(Y[0], Y[1], Y[2]);
    S.push([1, st]);
    let dt = "transparent";
    t.has("Background") && (N = r.getRgb(t.get("Background"), 0), dt = PA.makeHexColor(N[0], N[1], N[2])), C || (S.unshift([0, dt]), S[1][0] += jn.SMALL_NUMBER), d || (S.at(-1)[0] -= jn.SMALL_NUMBER, S.push([1, dt])), this.colorStops = S;
  }
  getIR() {
    const { coordsArr: t, shadingType: e } = this;
    let i, s, n, o, r;
    return e === _h ? (s = [t[0], t[1]], n = [t[2], t[3]], o = null, r = null, i = "axial") : e === Do ? (s = [t[0], t[1]], n = [t[3], t[4]], o = t[2], r = t[5], i = "radial") : oA(`getPattern type unknown: ${e}`), ["RadialAxial", i, this.bbox, this.colorStops, s, n, o, r];
  }
}
class T5 {
  constructor(t, e) {
    this.stream = t, this.context = e, this.buffer = 0, this.bufferLength = 0;
    const i = e.numComps;
    this.tmpCompsBuf = new Float32Array(i);
    const s = e.colorSpace.numComps;
    this.tmpCsCompsBuf = e.colorFn ? new Float32Array(s) : this.tmpCompsBuf;
  }
  get hasData() {
    if (this.stream.end) return this.stream.pos < this.stream.end;
    if (this.bufferLength > 0) return !0;
    const t = this.stream.getByte();
    return !(t < 0) && (this.buffer = t, this.bufferLength = 8, !0);
  }
  readBits(t) {
    let e = this.buffer, i = this.bufferLength;
    if (t === 32) {
      if (i === 0) return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
      e = e << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
      const s = this.stream.getByte();
      return this.buffer = s & (1 << i) - 1, (e << 8 - i | (255 & s) >> i) >>> 0;
    }
    if (t === 8 && i === 0) return this.stream.getByte();
    for (; i < t; ) e = e << 8 | this.stream.getByte(), i += 8;
    return i -= t, this.bufferLength = i, this.buffer = e & (1 << i) - 1, e >> i;
  }
  align() {
    this.buffer = 0, this.bufferLength = 0;
  }
  readFlag() {
    return this.readBits(this.context.bitsPerFlag);
  }
  readCoordinate() {
    const t = this.context.bitsPerCoordinate, e = this.readBits(t), i = this.readBits(t), s = this.context.decode, n = t < 32 ? 1 / ((1 << t) - 1) : 23283064365386963e-26;
    return [e * n * (s[1] - s[0]) + s[0], i * n * (s[3] - s[2]) + s[2]];
  }
  readComponents() {
    const t = this.context.numComps, e = this.context.bitsPerComponent, i = e < 32 ? 1 / ((1 << e) - 1) : 23283064365386963e-26, s = this.context.decode, n = this.tmpCompsBuf;
    for (let r = 0, c = 4; r < t; r++, c += 2) {
      const h = this.readBits(e);
      n[r] = h * i * (s[c + 1] - s[c]) + s[c];
    }
    const o = this.tmpCsCompsBuf;
    return this.context.colorFn && this.context.colorFn(n, 0, o, 0), this.context.colorSpace.getRgb(o, 0);
  }
}
let kE = /* @__PURE__ */ Object.create(null);
function o1(A) {
  return kE[A] ||= (function(t) {
    const e = [];
    for (let i = 0; i <= t; i++) {
      const s = i / t, n = 1 - s;
      e.push(new Float32Array([n ** 3, 3 * s * n ** 2, 3 * s ** 2 * n, s ** 3]));
    }
    return e;
  })(A);
}
class fs extends jn {
  static MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;
  static MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;
  static TRIANGLE_DENSITY = 20;
  constructor(t, e, i, s, n) {
    if (super(), !(t instanceof AA)) throw new Ct("Mesh data is not a stream");
    const o = t.dict;
    this.shadingType = o.get("ShadingType"), this.bbox = Zi(o.getArray("BBox"), null);
    const r = Vt.parse({ cs: o.getRaw("CS") || o.getRaw("ColorSpace"), xref: e, resources: i, pdfFunctionFactory: s, localColorSpaceCache: n });
    this.background = o.has("Background") ? r.getRgb(o.get("Background"), 0) : null;
    const c = o.getRaw("Function"), h = c ? s.createFromArray(c) : null;
    this.coords = [], this.colors = [], this.figures = [];
    const I = { bitsPerCoordinate: o.get("BitsPerCoordinate"), bitsPerComponent: o.get("BitsPerComponent"), bitsPerFlag: o.get("BitsPerFlag"), decode: o.getArray("Decode"), colorFn: h, colorSpace: r, numComps: h ? 1 : r.numComps }, C = new T5(t, I);
    let d = !1;
    switch (this.shadingType) {
      case yE:
        this._decodeType4Shading(C);
        break;
      case wE:
        const u = 0 | o.get("VerticesPerRow");
        if (u < 2) throw new Ct("Invalid VerticesPerRow");
        this._decodeType5Shading(C, u);
        break;
      case bE:
        this._decodeType6Shading(C), d = !0;
        break;
      case DE:
        this._decodeType7Shading(C), d = !0;
        break;
      default:
        oA("Unsupported mesh type.");
    }
    if (d) {
      this._updateBounds();
      for (let u = 0, E = this.figures.length; u < E; u++) this._buildFigureFromPatch(u);
    }
    this._updateBounds(), this._packData();
  }
  _decodeType4Shading(t) {
    const e = this.coords, i = this.colors, s = [];
    let n = 0;
    for (; t.hasData; ) {
      const o = t.readFlag(), r = t.readCoordinate(), c = t.readComponents();
      if (n === 0) {
        if (!(0 <= o && o <= 2)) throw new Ct("Unknown type4 flag");
        switch (o) {
          case 0:
            n = 3;
            break;
          case 1:
            s.push(s.at(-2), s.at(-1)), n = 1;
            break;
          case 2:
            s.push(s.at(-3), s.at(-1)), n = 1;
        }
      }
      s.push(e.length), e.push(r), i.push(c), n--, t.align();
    }
    this.figures.push({ type: "triangles", coords: new Int32Array(s), colors: new Int32Array(s) });
  }
  _decodeType5Shading(t, e) {
    const i = this.coords, s = this.colors, n = [];
    for (; t.hasData; ) {
      const o = t.readCoordinate(), r = t.readComponents();
      n.push(i.length), i.push(o), s.push(r);
    }
    this.figures.push({ type: "lattice", coords: new Int32Array(n), colors: new Int32Array(n), verticesPerRow: e });
  }
  _decodeType6Shading(t) {
    const e = this.coords, i = this.colors, s = new Int32Array(16), n = new Int32Array(4);
    for (; t.hasData; ) {
      const o = t.readFlag();
      if (!(0 <= o && o <= 3)) throw new Ct("Unknown type6 flag");
      const r = e.length;
      for (let u = 0, E = o !== 0 ? 8 : 12; u < E; u++) e.push(t.readCoordinate());
      const c = i.length;
      for (let u = 0, E = o !== 0 ? 2 : 4; u < E; u++) i.push(t.readComponents());
      let h, I, C, d;
      switch (o) {
        case 0:
          s[12] = r + 3, s[13] = r + 4, s[14] = r + 5, s[15] = r + 6, s[8] = r + 2, s[11] = r + 7, s[4] = r + 1, s[7] = r + 8, s[0] = r, s[1] = r + 11, s[2] = r + 10, s[3] = r + 9, n[2] = c + 1, n[3] = c + 2, n[0] = c, n[1] = c + 3;
          break;
        case 1:
          h = s[12], I = s[13], C = s[14], d = s[15], s[12] = d, s[13] = r + 0, s[14] = r + 1, s[15] = r + 2, s[8] = C, s[11] = r + 3, s[4] = I, s[7] = r + 4, s[0] = h, s[1] = r + 7, s[2] = r + 6, s[3] = r + 5, h = n[2], I = n[3], n[2] = I, n[3] = c, n[0] = h, n[1] = c + 1;
          break;
        case 2:
          h = s[15], I = s[11], s[12] = s[3], s[13] = r + 0, s[14] = r + 1, s[15] = r + 2, s[8] = s[7], s[11] = r + 3, s[4] = I, s[7] = r + 4, s[0] = h, s[1] = r + 7, s[2] = r + 6, s[3] = r + 5, h = n[3], n[2] = n[1], n[3] = c, n[0] = h, n[1] = c + 1;
          break;
        case 3:
          s[12] = s[0], s[13] = r + 0, s[14] = r + 1, s[15] = r + 2, s[8] = s[1], s[11] = r + 3, s[4] = s[2], s[7] = r + 4, s[0] = s[3], s[1] = r + 7, s[2] = r + 6, s[3] = r + 5, n[2] = n[0], n[3] = c, n[0] = n[1], n[1] = c + 1;
      }
      s[5] = e.length, e.push([(-4 * e[s[0]][0] - e[s[15]][0] + 6 * (e[s[4]][0] + e[s[1]][0]) - 2 * (e[s[12]][0] + e[s[3]][0]) + 3 * (e[s[13]][0] + e[s[7]][0])) / 9, (-4 * e[s[0]][1] - e[s[15]][1] + 6 * (e[s[4]][1] + e[s[1]][1]) - 2 * (e[s[12]][1] + e[s[3]][1]) + 3 * (e[s[13]][1] + e[s[7]][1])) / 9]), s[6] = e.length, e.push([(-4 * e[s[3]][0] - e[s[12]][0] + 6 * (e[s[2]][0] + e[s[7]][0]) - 2 * (e[s[0]][0] + e[s[15]][0]) + 3 * (e[s[4]][0] + e[s[14]][0])) / 9, (-4 * e[s[3]][1] - e[s[12]][1] + 6 * (e[s[2]][1] + e[s[7]][1]) - 2 * (e[s[0]][1] + e[s[15]][1]) + 3 * (e[s[4]][1] + e[s[14]][1])) / 9]), s[9] = e.length, e.push([(-4 * e[s[12]][0] - e[s[3]][0] + 6 * (e[s[8]][0] + e[s[13]][0]) - 2 * (e[s[0]][0] + e[s[15]][0]) + 3 * (e[s[11]][0] + e[s[1]][0])) / 9, (-4 * e[s[12]][1] - e[s[3]][1] + 6 * (e[s[8]][1] + e[s[13]][1]) - 2 * (e[s[0]][1] + e[s[15]][1]) + 3 * (e[s[11]][1] + e[s[1]][1])) / 9]), s[10] = e.length, e.push([(-4 * e[s[15]][0] - e[s[0]][0] + 6 * (e[s[11]][0] + e[s[14]][0]) - 2 * (e[s[12]][0] + e[s[3]][0]) + 3 * (e[s[2]][0] + e[s[8]][0])) / 9, (-4 * e[s[15]][1] - e[s[0]][1] + 6 * (e[s[11]][1] + e[s[14]][1]) - 2 * (e[s[12]][1] + e[s[3]][1]) + 3 * (e[s[2]][1] + e[s[8]][1])) / 9]), this.figures.push({ type: "patch", coords: new Int32Array(s), colors: new Int32Array(n) });
    }
  }
  _decodeType7Shading(t) {
    const e = this.coords, i = this.colors, s = new Int32Array(16), n = new Int32Array(4);
    for (; t.hasData; ) {
      const o = t.readFlag();
      if (!(0 <= o && o <= 3)) throw new Ct("Unknown type7 flag");
      const r = e.length;
      for (let u = 0, E = o !== 0 ? 12 : 16; u < E; u++) e.push(t.readCoordinate());
      const c = i.length;
      for (let u = 0, E = o !== 0 ? 2 : 4; u < E; u++) i.push(t.readComponents());
      let h, I, C, d;
      switch (o) {
        case 0:
          s[12] = r + 3, s[13] = r + 4, s[14] = r + 5, s[15] = r + 6, s[8] = r + 2, s[9] = r + 13, s[10] = r + 14, s[11] = r + 7, s[4] = r + 1, s[5] = r + 12, s[6] = r + 15, s[7] = r + 8, s[0] = r, s[1] = r + 11, s[2] = r + 10, s[3] = r + 9, n[2] = c + 1, n[3] = c + 2, n[0] = c, n[1] = c + 3;
          break;
        case 1:
          h = s[12], I = s[13], C = s[14], d = s[15], s[12] = d, s[13] = r + 0, s[14] = r + 1, s[15] = r + 2, s[8] = C, s[9] = r + 9, s[10] = r + 10, s[11] = r + 3, s[4] = I, s[5] = r + 8, s[6] = r + 11, s[7] = r + 4, s[0] = h, s[1] = r + 7, s[2] = r + 6, s[3] = r + 5, h = n[2], I = n[3], n[2] = I, n[3] = c, n[0] = h, n[1] = c + 1;
          break;
        case 2:
          h = s[15], I = s[11], s[12] = s[3], s[13] = r + 0, s[14] = r + 1, s[15] = r + 2, s[8] = s[7], s[9] = r + 9, s[10] = r + 10, s[11] = r + 3, s[4] = I, s[5] = r + 8, s[6] = r + 11, s[7] = r + 4, s[0] = h, s[1] = r + 7, s[2] = r + 6, s[3] = r + 5, h = n[3], n[2] = n[1], n[3] = c, n[0] = h, n[1] = c + 1;
          break;
        case 3:
          s[12] = s[0], s[13] = r + 0, s[14] = r + 1, s[15] = r + 2, s[8] = s[1], s[9] = r + 9, s[10] = r + 10, s[11] = r + 3, s[4] = s[2], s[5] = r + 8, s[6] = r + 11, s[7] = r + 4, s[0] = s[3], s[1] = r + 7, s[2] = r + 6, s[3] = r + 5, n[2] = n[0], n[3] = c, n[0] = n[1], n[1] = c + 1;
      }
      this.figures.push({ type: "patch", coords: new Int32Array(s), colors: new Int32Array(n) });
    }
  }
  _buildFigureFromPatch(t) {
    const e = this.figures[t];
    pe(e.type === "patch", "Unexpected patch mesh figure");
    const i = this.coords, s = this.colors, n = e.coords, o = e.colors, r = Math.min(i[n[0]][0], i[n[3]][0], i[n[12]][0], i[n[15]][0]), c = Math.min(i[n[0]][1], i[n[3]][1], i[n[12]][1], i[n[15]][1]), h = Math.max(i[n[0]][0], i[n[3]][0], i[n[12]][0], i[n[15]][0]), I = Math.max(i[n[0]][1], i[n[3]][1], i[n[12]][1], i[n[15]][1]);
    let C = Math.ceil((h - r) * fs.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
    C = Math.max(fs.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(fs.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, C));
    let d = Math.ceil((I - c) * fs.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
    d = Math.max(fs.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(fs.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, d));
    const u = C + 1, E = new Int32Array((d + 1) * u), p = new Int32Array((d + 1) * u);
    let y = 0;
    const b = new Uint8Array(3), D = new Uint8Array(3), S = s[o[0]], R = s[o[1]], x = s[o[2]], N = s[o[3]], U = o1(d), T = o1(C);
    for (let q = 0; q <= d; q++) {
      b[0] = (S[0] * (d - q) + x[0] * q) / d | 0, b[1] = (S[1] * (d - q) + x[1] * q) / d | 0, b[2] = (S[2] * (d - q) + x[2] * q) / d | 0, D[0] = (R[0] * (d - q) + N[0] * q) / d | 0, D[1] = (R[1] * (d - q) + N[1] * q) / d | 0, D[2] = (R[2] * (d - q) + N[2] * q) / d | 0;
      for (let _ = 0; _ <= C; _++, y++) {
        if (!(q !== 0 && q !== d || _ !== 0 && _ !== C)) continue;
        let Y = 0, ht = 0, ut = 0;
        for (let it = 0; it <= 3; it++) for (let tt = 0; tt <= 3; tt++, ut++) {
          const Z = U[q][it] * T[_][tt];
          Y += i[n[ut]][0] * Z, ht += i[n[ut]][1] * Z;
        }
        E[y] = i.length, i.push([Y, ht]), p[y] = s.length;
        const j = new Uint8Array(3);
        j[0] = (b[0] * (C - _) + D[0] * _) / C | 0, j[1] = (b[1] * (C - _) + D[1] * _) / C | 0, j[2] = (b[2] * (C - _) + D[2] * _) / C | 0, s.push(j);
      }
    }
    E[0] = n[0], p[0] = o[0], E[C] = n[3], p[C] = o[1], E[u * d] = n[12], p[u * d] = o[2], E[u * d + C] = n[15], p[u * d + C] = o[3], this.figures[t] = { type: "lattice", coords: E, colors: p, verticesPerRow: u };
  }
  _updateBounds() {
    let t = this.coords[0][0], e = this.coords[0][1], i = t, s = e;
    for (let n = 1, o = this.coords.length; n < o; n++) {
      const r = this.coords[n][0], c = this.coords[n][1];
      t = t > r ? r : t, e = e > c ? c : e, i = i < r ? r : i, s = s < c ? c : s;
    }
    this.bounds = [t, e, i, s];
  }
  _packData() {
    let t, e, i, s;
    const n = this.coords, o = new Float32Array(2 * n.length);
    for (t = 0, i = 0, e = n.length; t < e; t++) {
      const I = n[t];
      o[i++] = I[0], o[i++] = I[1];
    }
    this.coords = o;
    const r = this.colors, c = new Uint8Array(3 * r.length);
    for (t = 0, i = 0, e = r.length; t < e; t++) {
      const I = r[t];
      c[i++] = I[0], c[i++] = I[1], c[i++] = I[2];
    }
    this.colors = c;
    const h = this.figures;
    for (t = 0, e = h.length; t < e; t++) {
      const I = h[t], C = I.coords, d = I.colors;
      for (i = 0, s = C.length; i < s; i++) C[i] *= 2, d[i] *= 3;
    }
  }
  getIR() {
    const { bounds: t } = this;
    if (t[2] - t[0] == 0 || t[3] - t[1] == 0) throw new Ct(`Invalid MeshShading bounds: [${t}].`);
    return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, t, this.bbox, this.background];
  }
}
class K5 extends jn {
  getIR() {
    return ["Dummy"];
  }
}
function g1(A, t, e) {
  const i = ks(t.getArray("Matrix"), Ci), s = Zi(t.getArray("BBox"), null);
  if (!s || s[2] - s[0] == 0 || s[3] - s[1] == 0) throw new Ct("Invalid getTilingPatternIR /BBox array.");
  const n = t.get("XStep");
  if (typeof n != "number") throw new Ct("Invalid getTilingPatternIR /XStep value.");
  const o = t.get("YStep");
  if (typeof o != "number") throw new Ct("Invalid getTilingPatternIR /YStep value.");
  const r = t.get("PaintType");
  if (!Number.isInteger(r)) throw new Ct("Invalid getTilingPatternIR /PaintType value.");
  const c = t.get("TilingType");
  if (!Number.isInteger(c)) throw new Ct("Invalid getTilingPatternIR /TilingType value.");
  return ["TilingPattern", e, A, i, s, n, o, r, c];
}
const q5 = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], P5 = { lineHeight: 1.2207, lineGap: 0.2207 }, _5 = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], O5 = { lineHeight: 1.2207, lineGap: 0.2207 }, W5 = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], j5 = { lineHeight: 1.2207, lineGap: 0.2207 }, Z5 = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], V5 = { lineHeight: 1.2207, lineGap: 0.2207 }, X5 = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], z5 = { lineHeight: 1.2, lineGap: 0.2 }, $5 = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], t8 = { lineHeight: 1.35, lineGap: 0.2 }, A8 = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], e8 = { lineHeight: 1.35, lineGap: 0.2 }, i8 = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], s8 = { lineHeight: 1.2, lineGap: 0.2 }, kn = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333], Sn = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], Fn = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333], Rn = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], xn = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285], Nn = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], Gn = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285], vn = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], a8 = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], n8 = { lineHeight: 1.2, lineGap: 0.2 }, r8 = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], o8 = { lineHeight: 1.2, lineGap: 0.2 }, g8 = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], c8 = { lineHeight: 1.2, lineGap: 0.2 }, h8 = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], l8 = { lineHeight: 1.2, lineGap: 0.2 }, I8 = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], C8 = { lineHeight: 1.33008, lineGap: 0 }, u8 = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], B8 = { lineHeight: 1.33008, lineGap: 0 }, d8 = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], Q8 = { lineHeight: 1.33008, lineGap: 0 }, E8 = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], f8 = { lineHeight: 1.33008, lineGap: 0 }, p8 = DA((function(A) {
  A["MyriadPro-Regular"] = A["PdfJS-Fallback-Regular"] = { name: "LiberationSans-Regular", factors: h8, baseWidths: Gn, baseMapping: vn, metrics: l8 }, A["MyriadPro-Bold"] = A["PdfJS-Fallback-Bold"] = { name: "LiberationSans-Bold", factors: a8, baseWidths: kn, baseMapping: Sn, metrics: n8 }, A["MyriadPro-It"] = A["MyriadPro-Italic"] = A["PdfJS-Fallback-Italic"] = { name: "LiberationSans-Italic", factors: g8, baseWidths: xn, baseMapping: Nn, metrics: c8 }, A["MyriadPro-BoldIt"] = A["MyriadPro-BoldItalic"] = A["PdfJS-Fallback-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: r8, baseWidths: Fn, baseMapping: Rn, metrics: o8 }, A.ArialMT = A.Arial = A["Arial-Regular"] = { name: "LiberationSans-Regular", baseWidths: Gn, baseMapping: vn }, A["Arial-BoldMT"] = A["Arial-Bold"] = { name: "LiberationSans-Bold", baseWidths: kn, baseMapping: Sn }, A["Arial-ItalicMT"] = A["Arial-Italic"] = { name: "LiberationSans-Italic", baseWidths: xn, baseMapping: Nn }, A["Arial-BoldItalicMT"] = A["Arial-BoldItalic"] = { name: "LiberationSans-BoldItalic", baseWidths: Fn, baseMapping: Rn }, A["Calibri-Regular"] = { name: "LiberationSans-Regular", factors: Z5, baseWidths: Gn, baseMapping: vn, metrics: V5 }, A["Calibri-Bold"] = { name: "LiberationSans-Bold", factors: q5, baseWidths: kn, baseMapping: Sn, metrics: P5 }, A["Calibri-Italic"] = { name: "LiberationSans-Italic", factors: W5, baseWidths: xn, baseMapping: Nn, metrics: j5 }, A["Calibri-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: _5, baseWidths: Fn, baseMapping: Rn, metrics: O5 }, A["Segoeui-Regular"] = { name: "LiberationSans-Regular", factors: E8, baseWidths: Gn, baseMapping: vn, metrics: f8 }, A["Segoeui-Bold"] = { name: "LiberationSans-Bold", factors: I8, baseWidths: kn, baseMapping: Sn, metrics: C8 }, A["Segoeui-Italic"] = { name: "LiberationSans-Italic", factors: d8, baseWidths: xn, baseMapping: Nn, metrics: Q8 }, A["Segoeui-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: u8, baseWidths: Fn, baseMapping: Rn, metrics: B8 }, A["Helvetica-Regular"] = A.Helvetica = { name: "LiberationSans-Regular", factors: i8, baseWidths: Gn, baseMapping: vn, metrics: s8 }, A["Helvetica-Bold"] = { name: "LiberationSans-Bold", factors: X5, baseWidths: kn, baseMapping: Sn, metrics: z5 }, A["Helvetica-Italic"] = { name: "LiberationSans-Italic", factors: A8, baseWidths: xn, baseMapping: Nn, metrics: e8 }, A["Helvetica-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: $5, baseWidths: Fn, baseMapping: Rn, metrics: t8 };
}));
function Ll(A) {
  const t = Dr(A);
  return p8()[t];
}
function SE(A) {
  const t = (function(n) {
    const o = Ll(n);
    if (!o) return null;
    const { baseWidths: r, baseMapping: c, factors: h } = o, I = h ? r.map(((E, p) => E * h[p])) : r;
    let C, d = -2;
    const u = [];
    for (const [E, p] of c.map(((y, b) => [y, b])).sort((([y], [b]) => y - b))) E !== -1 && (E === d + 1 ? (C.push(I[p]), d += 1) : (d = E, C = [I[p]], u.push(E, C)));
    return u;
  })(A), e = new z(null);
  e.set("BaseFont", at.get(A)), e.set("Type", at.get("Font")), e.set("Subtype", at.get("CIDFontType2")), e.set("Encoding", at.get("Identity-H")), e.set("CIDToGIDMap", at.get("Identity")), e.set("W", t), e.set("FirstChar", t[0]), e.set("LastChar", t.at(-2) + t.at(-1).length - 1);
  const i = new z(null);
  e.set("FontDescriptor", i);
  const s = new z(null);
  return s.set("Ordering", "Identity"), s.set("Registry", "Adobe"), s.set("Supplement", 0), e.set("CIDSystemInfo", s), e;
}
class m8 {
  constructor(t) {
    this.lexer = t, this.operators = [], this.token = null, this.prev = null;
  }
  nextToken() {
    this.prev = this.token, this.token = this.lexer.getToken();
  }
  accept(t) {
    return this.token.type === t && (this.nextToken(), !0);
  }
  expect(t) {
    if (this.accept(t)) return !0;
    throw new Ct(`Unexpected symbol: found ${this.token.type} expected ${t}.`);
  }
  parse() {
    return this.nextToken(), this.expect(Ce.LBRACE), this.parseBlock(), this.expect(Ce.RBRACE), this.operators;
  }
  parseBlock() {
    for (; ; ) if (this.accept(Ce.NUMBER)) this.operators.push(this.prev.value);
    else if (this.accept(Ce.OPERATOR)) this.operators.push(this.prev.value);
    else {
      if (!this.accept(Ce.LBRACE)) return;
      this.parseCondition();
    }
  }
  parseCondition() {
    const t = this.operators.length;
    if (this.operators.push(null, null), this.parseBlock(), this.expect(Ce.RBRACE), this.accept(Ce.IF)) this.operators[t] = this.operators.length, this.operators[t + 1] = "jz";
    else {
      if (!this.accept(Ce.LBRACE)) throw new Ct("PS Function: error parsing conditional.");
      {
        const e = this.operators.length;
        this.operators.push(null, null);
        const i = this.operators.length;
        this.parseBlock(), this.expect(Ce.RBRACE), this.expect(Ce.IFELSE), this.operators[e] = this.operators.length, this.operators[e + 1] = "j", this.operators[t] = i, this.operators[t + 1] = "jz";
      }
    }
  }
}
const Ce = { LBRACE: 0, RBRACE: 1, NUMBER: 2, OPERATOR: 3, IF: 4, IFELSE: 5 };
class Ke {
  static get opCache() {
    return bt(this, "opCache", /* @__PURE__ */ Object.create(null));
  }
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  static getOperator(t) {
    return Ke.opCache[t] ||= new Ke(Ce.OPERATOR, t);
  }
  static get LBRACE() {
    return bt(this, "LBRACE", new Ke(Ce.LBRACE, "{"));
  }
  static get RBRACE() {
    return bt(this, "RBRACE", new Ke(Ce.RBRACE, "}"));
  }
  static get IF() {
    return bt(this, "IF", new Ke(Ce.IF, "IF"));
  }
  static get IFELSE() {
    return bt(this, "IFELSE", new Ke(Ce.IFELSE, "IFELSE"));
  }
}
class y8 {
  constructor(t) {
    this.stream = t, this.nextChar(), this.strBuf = [];
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  getToken() {
    let t = !1, e = this.currentChar;
    for (; ; ) {
      if (e < 0) return Ae;
      if (t) e !== 10 && e !== 13 || (t = !1);
      else if (e === 37) t = !0;
      else if (!qe(e)) break;
      e = this.nextChar();
    }
    switch (0 | e) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return new Ke(Ce.NUMBER, this.getNumber());
      case 123:
        return this.nextChar(), Ke.LBRACE;
      case 125:
        return this.nextChar(), Ke.RBRACE;
    }
    const i = this.strBuf;
    for (i.length = 0, i[0] = String.fromCharCode(e); (e = this.nextChar()) >= 0 && (e >= 65 && e <= 90 || e >= 97 && e <= 122); ) i.push(String.fromCharCode(e));
    const s = i.join("");
    switch (s.toLowerCase()) {
      case "if":
        return Ke.IF;
      case "ifelse":
        return Ke.IFELSE;
      default:
        return Ke.getOperator(s);
    }
  }
  getNumber() {
    let t = this.currentChar;
    const e = this.strBuf;
    for (e.length = 0, e[0] = String.fromCharCode(t); (t = this.nextChar()) >= 0 && (t >= 48 && t <= 57 || t === 45 || t === 46); ) e.push(String.fromCharCode(t));
    const i = parseFloat(e.join(""));
    if (isNaN(i)) throw new Ct(`Invalid floating point number: ${i}`);
    return i;
  }
}
class an {
  constructor(t) {
    this._onlyRefs = t?.onlyRefs === !0, this._onlyRefs || (this._nameRefMap = /* @__PURE__ */ new Map(), this._imageMap = /* @__PURE__ */ new Map()), this._imageCache = new Ii();
  }
  getByName(t) {
    this._onlyRefs && oA("Should not call `getByName` method.");
    const e = this._nameRefMap.get(t);
    return e ? this.getByRef(e) : this._imageMap.get(t) || null;
  }
  getByRef(t) {
    return this._imageCache.get(t) || null;
  }
  set(t, e, i) {
    oA("Abstract method `set` called.");
  }
}
class c1 extends an {
  set(t, e = null, i) {
    if (typeof t != "string") throw new Error('LocalImageCache.set - expected "name" argument.');
    if (e)
      return this._imageCache.has(e) ? void 0 : (this._nameRefMap.set(t, e), void this._imageCache.put(e, i));
    this._imageMap.has(t) || this._imageMap.set(t, i);
  }
}
class FE extends an {
  set(t = null, e = null, i) {
    if (typeof t != "string" && !e) throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
    if (e)
      return this._imageCache.has(e) ? void 0 : (t !== null && this._nameRefMap.set(t, e), void this._imageCache.put(e, i));
    this._imageMap.has(t) || this._imageMap.set(t, i);
  }
}
class w8 extends an {
  constructor(t) {
    super({ onlyRefs: !0 });
  }
  set(t = null, e, i) {
    if (!e) throw new Error('LocalFunctionCache.set - expected "ref" argument.');
    this._imageCache.has(e) || this._imageCache.put(e, i);
  }
}
class h1 extends an {
  set(t, e = null, i) {
    if (typeof t != "string") throw new Error('LocalGStateCache.set - expected "name" argument.');
    if (e)
      return this._imageCache.has(e) ? void 0 : (this._nameRefMap.set(t, e), void this._imageCache.put(e, i));
    this._imageMap.has(t) || this._imageMap.set(t, i);
  }
}
class b8 extends an {
  constructor(t) {
    super({ onlyRefs: !0 });
  }
  set(t = null, e, i) {
    if (!e) throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
    this._imageCache.has(e) || this._imageCache.put(e, i);
  }
}
class D8 extends an {
  constructor(t) {
    super({ onlyRefs: !0 });
  }
  set(t = null, e, i) {
    if (!e) throw new Error('RegionalImageCache.set - expected "ref" argument.');
    this._imageCache.has(e) || this._imageCache.put(e, i);
  }
}
class La {
  static NUM_PAGES_THRESHOLD = 2;
  static MIN_IMAGES_TO_CACHE = 10;
  static MAX_BYTE_SIZE = 5e7;
  #t = new XA();
  constructor() {
    this._refCache = new Ii(), this._imageCache = new Ii();
  }
  get #A() {
    let t = 0;
    for (const e of this._imageCache) t += e.byteSize;
    return t;
  }
  get #e() {
    return !(this._imageCache.size < La.MIN_IMAGES_TO_CACHE) && !(this.#A < La.MAX_BYTE_SIZE);
  }
  shouldCache(t, e) {
    let i = this._refCache.get(t);
    return i || (i = /* @__PURE__ */ new Set(), this._refCache.put(t, i)), i.add(e), !(i.size < La.NUM_PAGES_THRESHOLD) && !(!this._imageCache.has(t) && this.#e);
  }
  addDecodeFailed(t) {
    this.#t.put(t);
  }
  hasDecodeFailed(t) {
    return this.#t.has(t);
  }
  addByteSize(t, e) {
    const i = this._imageCache.get(t);
    i && (i.byteSize || (i.byteSize = e));
  }
  getData(t, e) {
    const i = this._refCache.get(t);
    if (!i || i.size < La.NUM_PAGES_THRESHOLD) return null;
    const s = this._imageCache.get(t);
    return s ? (i.add(e), s) : null;
  }
  setData(t, e) {
    if (!this._refCache.has(t)) throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
    this._imageCache.has(t) || (this.#e ? O("GlobalImageCache.setData - cache limit reached.") : this._imageCache.put(t, e));
  }
  clear(t = !1) {
    t || (this.#t.clear(), this._refCache.clear()), this._imageCache.clear();
  }
}
class RE {
  constructor({ xref: t, isEvalSupported: e = !0 }) {
    this.xref = t, this.isEvalSupported = e !== !1;
  }
  create(t) {
    const e = this.getCached(t);
    if (e) return e;
    const i = l1.parse({ xref: this.xref, isEvalSupported: this.isEvalSupported, fn: t instanceof St ? this.xref.fetch(t) : t });
    return this._cache(t, i), i;
  }
  createFromArray(t) {
    const e = this.getCached(t);
    if (e) return e;
    const i = l1.parseArray({ xref: this.xref, isEvalSupported: this.isEvalSupported, fnObj: t instanceof St ? this.xref.fetch(t) : t });
    return this._cache(t, i), i;
  }
  getCached(t) {
    let e;
    if (t instanceof St ? e = t : t instanceof z ? e = t.objId : t instanceof AA && (e = t.dict?.objId), e) {
      const i = this._localFunctionCache.getByRef(e);
      if (i) return i;
    }
    return null;
  }
  _cache(t, e) {
    if (!e) throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
    let i;
    t instanceof St ? i = t : t instanceof z ? i = t.objId : t instanceof AA && (i = t.dict?.objId), i && this._localFunctionCache.set(null, i, e);
  }
  get _localFunctionCache() {
    return bt(this, "_localFunctionCache", new w8());
  }
}
function Xe(A) {
  return Array.isArray(A) ? Pe(A, null) ? A : A.map(((t) => +t)) : null;
}
class l1 {
  static getSampleArray(t, e, i, s) {
    let n, o, r = 1;
    for (n = 0, o = t.length; n < o; n++) r *= t[n];
    r *= e;
    const c = new Array(r);
    let h = 0, I = 0;
    const C = 1 / (2 ** i - 1), d = s.getBytes((r * i + 7) / 8);
    let u = 0;
    for (n = 0; n < r; n++) {
      for (; h < i; ) I <<= 8, I |= d[u++], h += 8;
      h -= i, c[n] = (I >> h) * C, I &= (1 << h) - 1;
    }
    return c;
  }
  static parse({ xref: t, isEvalSupported: e, fn: i }) {
    const s = i.dict || i;
    switch (s.get("FunctionType")) {
      case 0:
        return this.constructSampled({ xref: t, isEvalSupported: e, fn: i, dict: s });
      case 1:
        break;
      case 2:
        return this.constructInterpolated({ xref: t, isEvalSupported: e, dict: s });
      case 3:
        return this.constructStiched({ xref: t, isEvalSupported: e, dict: s });
      case 4:
        return this.constructPostScript({ xref: t, isEvalSupported: e, fn: i, dict: s });
    }
    throw new Ct("Unknown type of function");
  }
  static parseArray({ xref: t, isEvalSupported: e, fnObj: i }) {
    if (!Array.isArray(i)) return this.parse({ xref: t, isEvalSupported: e, fn: i });
    const s = [];
    for (const n of i) s.push(this.parse({ xref: t, isEvalSupported: e, fn: t.fetchIfRef(n) }));
    return function(n, o, r, c) {
      for (let h = 0, I = s.length; h < I; h++) s[h](n, o, r, c + h);
    };
  }
  static constructSampled({ xref: t, isEvalSupported: e, fn: i, dict: s }) {
    function n(b) {
      const D = b.length, S = [];
      let R = 0;
      for (let x = 0; x < D; x += 2) S[R++] = [b[x], b[x + 1]];
      return S;
    }
    function o(b, D, S, R, x) {
      return R + (x - R) / (S - D) * (b - D);
    }
    let r = Xe(s.getArray("Domain")), c = Xe(s.getArray("Range"));
    if (!r || !c) throw new Ct("No domain or range");
    const h = r.length / 2, I = c.length / 2;
    r = n(r), c = n(c);
    const C = Xe(s.getArray("Size")), d = s.get("BitsPerSample"), u = s.get("Order") || 1;
    u !== 1 && tA("No support for cubic spline interpolation: " + u);
    let E = Xe(s.getArray("Encode"));
    if (E) E = n(E);
    else {
      E = [];
      for (let b = 0; b < h; ++b) E.push([0, C[b] - 1]);
    }
    let p = Xe(s.getArray("Decode"));
    p = p ? n(p) : c;
    const y = this.getSampleArray(C, I, d, i);
    return function(b, D, S, R) {
      const x = 1 << h, N = new Float64Array(x), U = new Uint32Array(x);
      let T, q;
      for (q = 0; q < x; q++) N[q] = 1;
      let _ = I, Y = 1;
      for (T = 0; T < h; ++T) {
        const ht = r[T][0], ut = r[T][1];
        let j = o(Math.min(Math.max(b[D + T], ht), ut), ht, ut, E[T][0], E[T][1]);
        const it = C[T];
        j = Math.min(Math.max(j, 0), it - 1);
        const tt = j < it - 1 ? Math.floor(j) : j - 1, Z = tt + 1 - j, st = j - tt, dt = tt * _, ct = dt + _;
        for (q = 0; q < x; q++) q & Y ? (N[q] *= st, U[q] += ct) : (N[q] *= Z, U[q] += dt);
        _ *= it, Y <<= 1;
      }
      for (q = 0; q < I; ++q) {
        let ht = 0;
        for (T = 0; T < x; T++) ht += y[U[T] + q] * N[T];
        ht = o(ht, 0, 1, p[q][0], p[q][1]), S[R + q] = Math.min(Math.max(ht, c[q][0]), c[q][1]);
      }
    };
  }
  static constructInterpolated({ xref: t, isEvalSupported: e, dict: i }) {
    const s = Xe(i.getArray("C0")) || [0], n = Xe(i.getArray("C1")) || [1], o = i.get("N"), r = [];
    for (let h = 0, I = s.length; h < I; ++h) r.push(n[h] - s[h]);
    const c = r.length;
    return function(h, I, C, d) {
      const u = o === 1 ? h[I] : h[I] ** o;
      for (let E = 0; E < c; ++E) C[d + E] = s[E] + u * r[E];
    };
  }
  static constructStiched({ xref: t, isEvalSupported: e, dict: i }) {
    const s = Xe(i.getArray("Domain"));
    if (!s) throw new Ct("No domain");
    if (s.length / 2 !== 1) throw new Ct("Bad domain for stiched function");
    const n = [];
    for (const h of i.get("Functions")) n.push(this.parse({ xref: t, isEvalSupported: e, fn: t.fetchIfRef(h) }));
    const o = Xe(i.getArray("Bounds")), r = Xe(i.getArray("Encode")), c = new Float32Array(1);
    return function(h, I, C, d) {
      const u = (function(R, x, N) {
        return R > N ? R = N : R < x && (R = x), R;
      })(h[I], s[0], s[1]), E = o.length;
      let p;
      for (p = 0; p < E && !(u < o[p]); ++p) ;
      let y = s[0];
      p > 0 && (y = o[p - 1]);
      let b = s[1];
      p < o.length && (b = o[p]);
      const D = r[2 * p], S = r[2 * p + 1];
      c[0] = y === b ? D : D + (u - y) * (S - D) / (b - y), n[p](c, 0, C, d);
    };
  }
  static constructPostScript({ xref: t, isEvalSupported: e, fn: i, dict: s }) {
    const n = Xe(s.getArray("Domain")), o = Xe(s.getArray("Range"));
    if (!n) throw new Ct("No domain.");
    if (!o) throw new Ct("No range.");
    const r = new y8(i), c = new m8(r).parse();
    if (e && es.isEvalSupported) {
      const p = new v8().compile(c, n, o);
      if (p) return new Function("src", "srcOffset", "dest", "destOffset", p);
    }
    tA("Unable to compile PS function");
    const h = o.length >> 1, I = n.length >> 1, C = new k8(c), d = /* @__PURE__ */ Object.create(null);
    let u = 8192;
    const E = new Float32Array(I);
    return function(p, y, b, D) {
      let S, R, x = "";
      const N = E;
      for (S = 0; S < I; S++) R = p[y + S], N[S] = R, x += R + "_";
      const U = d[x];
      if (U !== void 0) return void b.set(U, D);
      const T = new Float32Array(h), q = C.execute(N), _ = q.length - h;
      for (S = 0; S < h; S++) {
        R = q[_ + S];
        let Y = o[2 * S];
        R < Y ? R = Y : (Y = o[2 * S + 1], R > Y && (R = Y)), T[S] = R;
      }
      u > 0 && (u--, d[x] = T), b.set(T, D);
    };
  }
}
function ah(A) {
  let t;
  if (A instanceof z) t = A;
  else {
    if (!(A instanceof AA)) return !1;
    t = A.dict;
  }
  return t.has("FunctionType");
}
class Xo {
  static MAX_STACK_SIZE = 100;
  constructor(t) {
    this.stack = t ? Array.from(t) : [];
  }
  push(t) {
    if (this.stack.length >= Xo.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
    this.stack.push(t);
  }
  pop() {
    if (this.stack.length <= 0) throw new Error("PostScript function stack underflow.");
    return this.stack.pop();
  }
  copy(t) {
    if (this.stack.length + t >= Xo.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
    const e = this.stack;
    for (let i = e.length - t, s = t - 1; s >= 0; s--, i++) e.push(e[i]);
  }
  index(t) {
    this.push(this.stack[this.stack.length - t - 1]);
  }
  roll(t, e) {
    const i = this.stack, s = i.length - t, n = i.length - 1, o = s + (e - Math.floor(e / t) * t);
    for (let r = s, c = n; r < c; r++, c--) {
      const h = i[r];
      i[r] = i[c], i[c] = h;
    }
    for (let r = s, c = o - 1; r < c; r++, c--) {
      const h = i[r];
      i[r] = i[c], i[c] = h;
    }
    for (let r = o, c = n; r < c; r++, c--) {
      const h = i[r];
      i[r] = i[c], i[c] = h;
    }
  }
}
class k8 {
  constructor(t) {
    this.operators = t;
  }
  execute(t) {
    const e = new Xo(t);
    let i = 0;
    const s = this.operators, n = s.length;
    let o, r, c;
    for (; i < n; ) if (o = s[i++], typeof o != "number") switch (o) {
      case "jz":
        c = e.pop(), r = e.pop(), r || (i = c);
        break;
      case "j":
        r = e.pop(), i = r;
        break;
      case "abs":
        r = e.pop(), e.push(Math.abs(r));
        break;
      case "add":
        c = e.pop(), r = e.pop(), e.push(r + c);
        break;
      case "and":
        c = e.pop(), r = e.pop(), typeof r == "boolean" && typeof c == "boolean" ? e.push(r && c) : e.push(r & c);
        break;
      case "atan":
        c = e.pop(), r = e.pop(), r = Math.atan2(r, c) / Math.PI * 180, r < 0 && (r += 360), e.push(r);
        break;
      case "bitshift":
        c = e.pop(), r = e.pop(), r > 0 ? e.push(r << c) : e.push(r >> c);
        break;
      case "ceiling":
        r = e.pop(), e.push(Math.ceil(r));
        break;
      case "copy":
        r = e.pop(), e.copy(r);
        break;
      case "cos":
        r = e.pop(), e.push(Math.cos(r % 360 / 180 * Math.PI));
        break;
      case "cvi":
        r = 0 | e.pop(), e.push(r);
        break;
      case "cvr":
        break;
      case "div":
        c = e.pop(), r = e.pop(), e.push(r / c);
        break;
      case "dup":
        e.copy(1);
        break;
      case "eq":
        c = e.pop(), r = e.pop(), e.push(r === c);
        break;
      case "exch":
        e.roll(2, 1);
        break;
      case "exp":
        c = e.pop(), r = e.pop(), e.push(r ** c);
        break;
      case "false":
        e.push(!1);
        break;
      case "floor":
        r = e.pop(), e.push(Math.floor(r));
        break;
      case "ge":
        c = e.pop(), r = e.pop(), e.push(r >= c);
        break;
      case "gt":
        c = e.pop(), r = e.pop(), e.push(r > c);
        break;
      case "idiv":
        c = e.pop(), r = e.pop(), e.push(r / c | 0);
        break;
      case "index":
        r = e.pop(), e.index(r);
        break;
      case "le":
        c = e.pop(), r = e.pop(), e.push(r <= c);
        break;
      case "ln":
        r = e.pop(), e.push(Math.log(r));
        break;
      case "log":
        r = e.pop(), e.push(Math.log10(r));
        break;
      case "lt":
        c = e.pop(), r = e.pop(), e.push(r < c);
        break;
      case "mod":
        c = e.pop(), r = e.pop(), e.push(r % c);
        break;
      case "mul":
        c = e.pop(), r = e.pop(), e.push(r * c);
        break;
      case "ne":
        c = e.pop(), r = e.pop(), e.push(r !== c);
        break;
      case "neg":
        r = e.pop(), e.push(-r);
        break;
      case "not":
        r = e.pop(), typeof r == "boolean" ? e.push(!r) : e.push(~r);
        break;
      case "or":
        c = e.pop(), r = e.pop(), typeof r == "boolean" && typeof c == "boolean" ? e.push(r || c) : e.push(r | c);
        break;
      case "pop":
        e.pop();
        break;
      case "roll":
        c = e.pop(), r = e.pop(), e.roll(r, c);
        break;
      case "round":
        r = e.pop(), e.push(Math.round(r));
        break;
      case "sin":
        r = e.pop(), e.push(Math.sin(r % 360 / 180 * Math.PI));
        break;
      case "sqrt":
        r = e.pop(), e.push(Math.sqrt(r));
        break;
      case "sub":
        c = e.pop(), r = e.pop(), e.push(r - c);
        break;
      case "true":
        e.push(!0);
        break;
      case "truncate":
        r = e.pop(), r = r < 0 ? Math.ceil(r) : Math.floor(r), e.push(r);
        break;
      case "xor":
        c = e.pop(), r = e.pop(), typeof r == "boolean" && typeof c == "boolean" ? e.push(r !== c) : e.push(r ^ c);
        break;
      default:
        throw new Ct(`Unknown operator ${o}`);
    }
    else e.push(o);
    return e.stack;
  }
}
class nn {
  constructor(t) {
    this.type = t;
  }
  visit(t) {
    oA("abstract method");
  }
}
class S8 extends nn {
  constructor(t, e, i) {
    super("args"), this.index = t, this.min = e, this.max = i;
  }
  visit(t) {
    t.visitArgument(this);
  }
}
class ra extends nn {
  constructor(t) {
    super("literal"), this.number = t, this.min = t, this.max = t;
  }
  visit(t) {
    t.visitLiteral(this);
  }
}
class Ul extends nn {
  constructor(t, e, i, s, n) {
    super("binary"), this.op = t, this.arg1 = e, this.arg2 = i, this.min = s, this.max = n;
  }
  visit(t) {
    t.visitBinaryOperation(this);
  }
}
class F8 extends nn {
  constructor(t, e) {
    super("max"), this.arg = t, this.min = t.min, this.max = e;
  }
  visit(t) {
    t.visitMin(this);
  }
}
class I1 extends nn {
  constructor(t, e, i) {
    super("var"), this.index = t, this.min = e, this.max = i;
  }
  visit(t) {
    t.visitVariable(this);
  }
}
class C1 extends nn {
  constructor(t, e) {
    super("definition"), this.variable = t, this.arg = e;
  }
  visit(t) {
    t.visitVariableDefinition(this);
  }
}
class u1 {
  constructor() {
    this.parts = [];
  }
  visitArgument(t) {
    this.parts.push("Math.max(", t.min, ", Math.min(", t.max, ", src[srcOffset + ", t.index, "]))");
  }
  visitVariable(t) {
    this.parts.push("v", t.index);
  }
  visitLiteral(t) {
    this.parts.push(t.number);
  }
  visitBinaryOperation(t) {
    this.parts.push("("), t.arg1.visit(this), this.parts.push(" ", t.op, " "), t.arg2.visit(this), this.parts.push(")");
  }
  visitVariableDefinition(t) {
    this.parts.push("var "), t.variable.visit(this), this.parts.push(" = "), t.arg.visit(this), this.parts.push(";");
  }
  visitMin(t) {
    this.parts.push("Math.min("), t.arg.visit(this), this.parts.push(", ", t.max, ")");
  }
  toString() {
    return this.parts.join("");
  }
}
function R8(A, t) {
  return t.type === "literal" && t.number === 0 ? A : A.type === "literal" && A.number === 0 ? t : t.type === "literal" && A.type === "literal" ? new ra(A.number + t.number) : new Ul("+", A, t, A.min + t.min, A.max + t.max);
}
function x8(A, t) {
  if (t.type === "literal") {
    if (t.number === 0) return new ra(0);
    if (t.number === 1) return A;
    if (A.type === "literal") return new ra(A.number * t.number);
  }
  if (A.type === "literal") {
    if (A.number === 0) return new ra(0);
    if (A.number === 1) return t;
  }
  const e = Math.min(A.min * t.min, A.min * t.max, A.max * t.min, A.max * t.max), i = Math.max(A.min * t.min, A.min * t.max, A.max * t.min, A.max * t.max);
  return new Ul("*", A, t, e, i);
}
function N8(A, t) {
  if (t.type === "literal") {
    if (t.number === 0) return A;
    if (A.type === "literal") return new ra(A.number - t.number);
  }
  return t.type === "binary" && t.op === "-" && A.type === "literal" && A.number === 1 && t.arg1.type === "literal" && t.arg1.number === 1 ? t.arg2 : new Ul("-", A, t, A.min - t.max, A.max - t.min);
}
function G8(A, t) {
  return A.min >= t ? new ra(t) : A.max <= t ? A : new F8(A, t);
}
class v8 {
  compile(t, e, i) {
    const s = [], n = [], o = e.length >> 1, r = i.length >> 1;
    let c, h, I, C, d, u, E, p, y = 0;
    for (let D = 0; D < o; D++) s.push(new S8(D, e[2 * D], e[2 * D + 1]));
    for (let D = 0, S = t.length; D < S; D++) if (p = t[D], typeof p != "number") switch (p) {
      case "add":
        if (s.length < 2) return null;
        C = s.pop(), I = s.pop(), s.push(R8(I, C));
        break;
      case "cvr":
        if (s.length < 1) return null;
        break;
      case "mul":
        if (s.length < 2) return null;
        C = s.pop(), I = s.pop(), s.push(x8(I, C));
        break;
      case "sub":
        if (s.length < 2) return null;
        C = s.pop(), I = s.pop(), s.push(N8(I, C));
        break;
      case "exch":
        if (s.length < 2) return null;
        d = s.pop(), u = s.pop(), s.push(d, u);
        break;
      case "pop":
        if (s.length < 1) return null;
        s.pop();
        break;
      case "index":
        if (s.length < 1 || (I = s.pop(), I.type !== "literal") || (c = I.number, c < 0 || !Number.isInteger(c) || s.length < c)) return null;
        if (d = s[s.length - c - 1], d.type === "literal" || d.type === "var") {
          s.push(d);
          break;
        }
        E = new I1(y++, d.min, d.max), s[s.length - c - 1] = E, s.push(E), n.push(new C1(E, d));
        break;
      case "dup":
        if (s.length < 1) return null;
        if (typeof t[D + 1] == "number" && t[D + 2] === "gt" && t[D + 3] === D + 7 && t[D + 4] === "jz" && t[D + 5] === "pop" && t[D + 6] === t[D + 1]) {
          I = s.pop(), s.push(G8(I, t[D + 1])), D += 6;
          break;
        }
        if (d = s.at(-1), d.type === "literal" || d.type === "var") {
          s.push(d);
          break;
        }
        E = new I1(y++, d.min, d.max), s[s.length - 1] = E, s.push(E), n.push(new C1(E, d));
        break;
      case "roll":
        if (s.length < 2 || (C = s.pop(), I = s.pop(), C.type !== "literal" || I.type !== "literal") || (h = C.number, c = I.number, c <= 0 || !Number.isInteger(c) || !Number.isInteger(h) || s.length < c)) return null;
        if (h = (h % c + c) % c, h === 0) break;
        s.push(...s.splice(s.length - c, c - h));
        break;
      default:
        return null;
    }
    else s.push(new ra(p));
    if (s.length !== r) return null;
    const b = [];
    for (const D of n) {
      const S = new u1();
      D.visit(S), b.push(S.toString());
    }
    for (let D = 0, S = s.length; D < S; D++) {
      const R = s[D], x = new u1();
      R.visit(x);
      const N = i[2 * D], U = i[2 * D + 1], T = [x.toString()];
      N > R.min && (T.unshift("Math.max(", N, ", "), T.push(")")), U < R.max && (T.unshift("Math.min(", U, ", "), T.push(")")), T.unshift("dest[destOffset + ", D, "] = "), T.push(";"), b.push(T.join(""));
    }
    return b.join(`
`);
  }
}
const M8 = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"], L8 = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
function B1(A) {
  return !!(1 & A);
}
function U8(A) {
  return !(1 & A);
}
function H8(A, t, e) {
  let i, s;
  for (i = t, s = A.length; i < s; ++i) if (A[i] !== e) return i;
  return i;
}
function J8(A, t, e, i) {
  for (let s = t; s < e; ++s) A[s] = i;
}
function d1(A, t, e) {
  for (let i = t, s = e - 1; i < s; ++i, --s) {
    const n = A[i];
    A[i] = A[s], A[s] = n;
  }
}
function nh(A, t, e = !1) {
  let i = "ltr";
  return e ? i = "ttb" : t || (i = "rtl"), { str: A, dir: i };
}
const Is = [], lA = [];
function xE(A, t = -1, e = !1) {
  let i = !0;
  const s = A.length;
  if (s === 0 || e) return nh(A, i, e);
  Is.length = s, lA.length = s;
  let n, o, r = 0;
  for (n = 0; n < s; ++n) {
    Is[n] = A.charAt(n);
    const b = A.charCodeAt(n);
    let D = "L";
    b <= 255 ? D = M8[b] : 1424 <= b && b <= 1524 ? D = "R" : 1536 <= b && b <= 1791 ? (D = L8[255 & b], D || O("Bidi: invalid Unicode character " + b.toString(16))) : (1792 <= b && b <= 2220 || 64336 <= b && b <= 65023 || 65136 <= b && b <= 65279) && (D = "AL"), D !== "R" && D !== "AL" && D !== "AN" || r++, lA[n] = D;
  }
  if (r === 0) return i = !0, nh(A, i);
  t === -1 && (r / s < 0.3 && s > 4 ? (i = !0, t = 0) : (i = !1, t = 1));
  const c = [];
  for (n = 0; n < s; ++n) c[n] = t;
  const h = B1(t) ? "R" : "L", I = h, C = I;
  let d, u = I;
  for (n = 0; n < s; ++n) lA[n] === "NSM" ? lA[n] = u : u = lA[n];
  for (u = I, n = 0; n < s; ++n) d = lA[n], d === "EN" ? lA[n] = u === "AL" ? "AN" : "EN" : d !== "R" && d !== "L" && d !== "AL" || (u = d);
  for (n = 0; n < s; ++n) d = lA[n], d === "AL" && (lA[n] = "R");
  for (n = 1; n < s - 1; ++n) lA[n] === "ES" && lA[n - 1] === "EN" && lA[n + 1] === "EN" && (lA[n] = "EN"), lA[n] !== "CS" || lA[n - 1] !== "EN" && lA[n - 1] !== "AN" || lA[n + 1] !== lA[n - 1] || (lA[n] = lA[n - 1]);
  for (n = 0; n < s; ++n) if (lA[n] === "EN") {
    for (let b = n - 1; b >= 0 && lA[b] === "ET"; --b) lA[b] = "EN";
    for (let b = n + 1; b < s && lA[b] === "ET"; ++b) lA[b] = "EN";
  }
  for (n = 0; n < s; ++n) d = lA[n], d !== "WS" && d !== "ES" && d !== "ET" && d !== "CS" || (lA[n] = "ON");
  for (u = I, n = 0; n < s; ++n) d = lA[n], d === "EN" ? lA[n] = u === "L" ? "L" : "EN" : d !== "R" && d !== "L" || (u = d);
  for (n = 0; n < s; ++n) if (lA[n] === "ON") {
    const b = H8(lA, n + 1, "ON");
    let D = I;
    n > 0 && (D = lA[n - 1]);
    let S = C;
    b + 1 < s && (S = lA[b + 1]), D !== "L" && (D = "R"), S !== "L" && (S = "R"), D === S && J8(lA, n, b, D), n = b - 1;
  }
  for (n = 0; n < s; ++n) lA[n] === "ON" && (lA[n] = h);
  for (n = 0; n < s; ++n) d = lA[n], U8(c[n]) ? d === "R" ? c[n] += 1 : d !== "AN" && d !== "EN" || (c[n] += 2) : d !== "L" && d !== "AN" && d !== "EN" || (c[n] += 1);
  let E, p = -1, y = 99;
  for (n = 0, o = c.length; n < o; ++n) E = c[n], p < E && (p = E), y > E && B1(E) && (y = E);
  for (E = p; E >= y; --E) {
    let b = -1;
    for (n = 0, o = c.length; n < o; ++n) c[n] < E ? b >= 0 && (d1(Is, b, n), b = -1) : b < 0 && (b = n);
    b >= 0 && d1(Is, b, c.length);
  }
  for (n = 0, o = Is.length; n < o; ++n) {
    const b = Is[n];
    b !== "<" && b !== ">" || (Is[n] = "");
  }
  return nh(Is.join(""), i);
}
const $s = { style: "normal", weight: "normal" }, ea = { style: "normal", weight: "bold" }, ia = { style: "italic", weight: "normal" }, sa = { style: "italic", weight: "bold" }, Zn = /* @__PURE__ */ new Map([["Times-Roman", { local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "Linux Libertine O", "Libertinus Serif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"], style: $s, ultimate: "serif" }], ["Times-Bold", { alias: "Times-Roman", style: ea, ultimate: "serif" }], ["Times-Italic", { alias: "Times-Roman", style: ia, ultimate: "serif" }], ["Times-BoldItalic", { alias: "Times-Roman", style: sa, ultimate: "serif" }], ["Helvetica", { local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"], path: "LiberationSans-Regular.ttf", style: $s, ultimate: "sans-serif" }], ["Helvetica-Bold", { alias: "Helvetica", path: "LiberationSans-Bold.ttf", style: ea, ultimate: "sans-serif" }], ["Helvetica-Oblique", { alias: "Helvetica", path: "LiberationSans-Italic.ttf", style: ia, ultimate: "sans-serif" }], ["Helvetica-BoldOblique", { alias: "Helvetica", path: "LiberationSans-BoldItalic.ttf", style: sa, ultimate: "sans-serif" }], ["Courier", { local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono", "Linux Libertine Mono O", "Libertinus Mono"], style: $s, ultimate: "monospace" }], ["Courier-Bold", { alias: "Courier", style: ea, ultimate: "monospace" }], ["Courier-Oblique", { alias: "Courier", style: ia, ultimate: "monospace" }], ["Courier-BoldOblique", { alias: "Courier", style: sa, ultimate: "monospace" }], ["ArialBlack", { local: ["Arial Black"], style: { style: "normal", weight: "900" }, fallback: "Helvetica-Bold" }], ["ArialBlack-Bold", { alias: "ArialBlack" }], ["ArialBlack-Italic", { alias: "ArialBlack", style: { style: "italic", weight: "900" }, fallback: "Helvetica-BoldOblique" }], ["ArialBlack-BoldItalic", { alias: "ArialBlack-Italic" }], ["ArialNarrow", { local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"], style: $s, fallback: "Helvetica" }], ["ArialNarrow-Bold", { alias: "ArialNarrow", style: ea, fallback: "Helvetica-Bold" }], ["ArialNarrow-Italic", { alias: "ArialNarrow", style: ia, fallback: "Helvetica-Oblique" }], ["ArialNarrow-BoldItalic", { alias: "ArialNarrow", style: sa, fallback: "Helvetica-BoldOblique" }], ["Calibri", { local: ["Calibri", "Carlito"], style: $s, fallback: "Helvetica" }], ["Calibri-Bold", { alias: "Calibri", style: ea, fallback: "Helvetica-Bold" }], ["Calibri-Italic", { alias: "Calibri", style: ia, fallback: "Helvetica-Oblique" }], ["Calibri-BoldItalic", { alias: "Calibri", style: sa, fallback: "Helvetica-BoldOblique" }], ["Wingdings", { local: ["Wingdings", "URW Dingbats"], style: $s }], ["Wingdings-Regular", { alias: "Wingdings" }], ["Wingdings-Bold", { alias: "Wingdings" }]]), Y8 = /* @__PURE__ */ new Map([["Arial-Black", "ArialBlack"]]);
function Q1(A) {
  const t = /* @__PURE__ */ new Set(["thin", "extralight", "ultralight", "demilight", "semilight", "light", "book", "regular", "normal", "medium", "demibold", "semibold", "bold", "extrabold", "ultrabold", "black", "heavy", "extrablack", "ultrablack", "roman", "italic", "oblique", "ultracondensed", "extracondensed", "condensed", "semicondensed", "normal", "semiexpanded", "expanded", "extraexpanded", "ultraexpanded", "bolditalic"]);
  return A.split(/[- ,+]+/g).filter(((e) => !t.has(e.toLowerCase()))).join(" ");
}
function Oh({ alias: A, local: t, path: e, fallback: i, style: s, ultimate: n }, o, r, c = !0, h = !0, I = "") {
  const C = { style: null, ultimate: null };
  if (t) {
    const d = I ? ` ${I}` : "";
    for (const u of t) o.push(`local(${u}${d})`);
  }
  if (A) {
    const d = Zn.get(A), u = I || (function(E) {
      switch (E) {
        case ea:
          return "Bold";
        case ia:
          return "Italic";
        case sa:
          return "Bold Italic";
        default:
          if (E?.weight === "bold") return "Bold";
          if (E?.style === "italic") return "Italic";
      }
      return "";
    })(s);
    Object.assign(C, Oh(d, o, r, c && !i, h && !e, u));
  }
  if (s && (C.style = s), n && (C.ultimate = n), c && i) {
    const d = Zn.get(i), { ultimate: u } = Oh(d, o, r, c, h && !e, I);
    C.ultimate ||= u;
  }
  return h && e && r && o.push(`url(${r}${e})`), C;
}
function E1(A, t, e, i, s, n) {
  if (i.startsWith("InvalidPDFjsFont_")) return null;
  n !== "TrueType" && n !== "Type1" || !/^[A-Z]{6}\+/.test(i) || (i = i.slice(7));
  const o = i = Dr(i);
  let r = A.get(o);
  if (r) return r;
  let c = Zn.get(i);
  if (!c) {
    for (const [y, b] of Y8) if (i.startsWith(y)) {
      i = `${b}${i.substring(y.length)}`, c = Zn.get(i);
      break;
    }
  }
  let h = !1;
  c || (c = Zn.get(s), h = !0);
  const I = `${t.getDocId()}_s${t.createFontId()}`;
  if (!c) {
    if (!vh(i)) return O(`Cannot substitute the font because of its name: ${i}`), A.set(o, null), null;
    const y = /bold/gi.test(i), b = /oblique|italic/gi.test(i), D = y && b && sa || y && ea || b && ia || $s;
    return r = { css: `"${Q1(i)}",${I}`, guessFallback: !0, loadedName: I, baseFontName: i, src: `local(${i})`, style: D }, A.set(o, r), r;
  }
  const C = [];
  h && vh(i) && C.push(`local(${i})`);
  const { style: d, ultimate: u } = Oh(c, C, e), E = u === null, p = E ? "" : `,${u}`;
  return r = { css: `"${Q1(i)}",${I}${p}`, guessFallback: E, loadedName: I, baseFontName: i, src: C.join(","), style: d }, A.set(o, r), r;
}
class Ye {
  constructor(t, e) {
    this._imgData = t, this._isMask = e;
  }
  static needsToBeResized(t, e) {
    if (t <= this._goodSquareLength && e <= this._goodSquareLength) return !1;
    const { MAX_DIM: i } = this;
    if (t > i || e > i) return !0;
    const s = t * e;
    return this._hasMaxArea ? s > this.MAX_AREA : s < this._goodSquareLength ** 2 ? !1 : this._areGoodDims(t, e) ? (this._goodSquareLength = Math.max(this._goodSquareLength, Math.floor(Math.sqrt(t * e))), !1) : (this._goodSquareLength = this._guessMax(this._goodSquareLength, i, 128, 0), s > (this.MAX_AREA = this._goodSquareLength ** 2));
  }
  static get MAX_DIM() {
    return bt(this, "MAX_DIM", this._guessMax(2048, 65537, 0, 1));
  }
  static get MAX_AREA() {
    return this._hasMaxArea = !0, bt(this, "MAX_AREA", this._guessMax(Ye._goodSquareLength, this.MAX_DIM, 128, 0) ** 2);
  }
  static set MAX_AREA(t) {
    t >= 0 && (this._hasMaxArea = !0, bt(this, "MAX_AREA", t));
  }
  static setMaxArea(t) {
    this._hasMaxArea || (this.MAX_AREA = t >> 2);
  }
  static _areGoodDims(t, e) {
    try {
      const i = new OffscreenCanvas(t, e), s = i.getContext("2d");
      s.fillRect(0, 0, 1, 1);
      const n = s.getImageData(0, 0, 1, 1).data[3];
      return i.width = i.height = 1, n !== 0;
    } catch {
      return !1;
    }
  }
  static _guessMax(t, e, i, s) {
    for (; t + i + 1 < e; ) {
      const n = Math.floor((t + e) / 2), o = s || n;
      this._areGoodDims(n, o) ? t = n : e = n;
    }
    return t;
  }
  static async createImage(t, e = !1) {
    return new Ye(t, e)._createImage();
  }
  async _createImage() {
    const t = this._encodeBMP(), e = new Blob([t.buffer], { type: "image/bmp" }), i = createImageBitmap(e), { MAX_AREA: s, MAX_DIM: n } = Ye, { _imgData: o } = this, { width: r, height: c } = o, h = Math.max(r / n, c / n, Math.sqrt(r * c / s)), I = Math.max(h, 2), C = Math.round(10 * (h + 1.25)) / 10 / I, d = Math.floor(Math.log2(C)), u = new Array(d + 2).fill(2);
    u[0] = I, u.splice(-1, 1, C / (1 << d));
    let E = r, p = c, y = await i;
    for (const b of u) {
      const D = E, S = p;
      E = Math.floor(E / b) - 1, p = Math.floor(p / b) - 1;
      const R = new OffscreenCanvas(E, p);
      R.getContext("2d").drawImage(y, 0, 0, D, S, 0, 0, E, p), y = R.transferToImageBitmap();
    }
    return o.data = null, o.bitmap = y, o.width = E, o.height = p, o;
  }
  _encodeBMP() {
    const { width: t, height: e, kind: i } = this._imgData;
    let s, n = this._imgData.data, o = new Uint8Array(0), r = o, c = 0;
    switch (i) {
      case xo: {
        s = 1, o = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
        const p = t + 7 >> 3, y = p + 3 & -4;
        if (p !== y) {
          const b = new Uint8Array(y * e);
          let D = 0;
          for (let S = 0, R = e * p; S < R; S += p, D += y) b.set(n.subarray(S, S + p), D);
          n = b;
        }
        break;
      }
      case _n:
        if (s = 24, 3 & t) {
          const p = 3 * t, y = p + 3 & -4, b = y - p, D = new Uint8Array(y * e);
          let S = 0;
          for (let R = 0, x = e * p; R < x; R += p) {
            const N = n.subarray(R, R + p);
            for (let U = 0; U < p; U += 3) D[S++] = N[U + 2], D[S++] = N[U + 1], D[S++] = N[U];
            S += b;
          }
          n = D;
        } else for (let p = 0, y = n.length; p < y; p += 3) {
          const b = n[p];
          n[p] = n[p + 2], n[p + 2] = b;
        }
        break;
      case ds:
        s = 32, c = 3, r = new Uint8Array(68);
        const E = new DataView(r.buffer);
        es.isLittleEndian ? (E.setUint32(0, 255, !0), E.setUint32(4, 65280, !0), E.setUint32(8, 16711680, !0), E.setUint32(12, 4278190080, !0)) : (E.setUint32(0, 4278190080, !0), E.setUint32(4, 16711680, !0), E.setUint32(8, 65280, !0), E.setUint32(12, 255, !0));
        break;
      default:
        throw new Error("invalid format");
    }
    let h = 0;
    const I = 40 + r.length, C = 14 + I + o.length + n.length, d = new Uint8Array(C), u = new DataView(d.buffer);
    return u.setUint16(h, 19778, !0), h += 2, u.setUint32(h, C, !0), h += 4, u.setUint32(h, 0, !0), h += 4, u.setUint32(h, 14 + I + o.length, !0), h += 4, u.setUint32(h, I, !0), h += 4, u.setInt32(h, t, !0), h += 4, u.setInt32(h, -e, !0), h += 4, u.setUint16(h, 1, !0), h += 2, u.setUint16(h, s, !0), h += 2, u.setUint32(h, c, !0), h += 4, u.setUint32(h, 0, !0), h += 4, u.setInt32(h, 0, !0), h += 4, u.setInt32(h, 0, !0), h += 4, u.setUint32(h, o.length / 4, !0), h += 4, u.setUint32(h, 0, !0), h += 4, d.set(r, h), h += r.length, d.set(o, h), h += o.length, d.set(n, h), d;
  }
}
Ye._goodSquareLength = 2048;
const f1 = 3285377520, ze = 4294901760, Cs = 65535;
class T8 {
  constructor(t) {
    this.h1 = t ? 4294967295 & t : f1, this.h2 = t ? 4294967295 & t : f1;
  }
  update(t) {
    let e, i;
    if (typeof t == "string") {
      e = new Uint8Array(2 * t.length), i = 0;
      for (let p = 0, y = t.length; p < y; p++) {
        const b = t.charCodeAt(p);
        b <= 255 ? e[i++] = b : (e[i++] = b >>> 8, e[i++] = 255 & b);
      }
    } else {
      if (!ArrayBuffer.isView(t)) throw new Error("Invalid data format, must be a string or TypedArray.");
      e = t.slice(), i = e.byteLength;
    }
    const s = i >> 2, n = i - 4 * s, o = new Uint32Array(e.buffer, 0, s);
    let r = 0, c = 0, h = this.h1, I = this.h2;
    const C = 3432918353, d = 461845907, u = 11601, E = 13715;
    for (let p = 0; p < s; p++) 1 & p ? (r = o[p], r = r * C & ze | r * u & Cs, r = r << 15 | r >>> 17, r = r * d & ze | r * E & Cs, h ^= r, h = h << 13 | h >>> 19, h = 5 * h + 3864292196) : (c = o[p], c = c * C & ze | c * u & Cs, c = c << 15 | c >>> 17, c = c * d & ze | c * E & Cs, I ^= c, I = I << 13 | I >>> 19, I = 5 * I + 3864292196);
    switch (r = 0, n) {
      case 3:
        r ^= e[4 * s + 2] << 16;
      case 2:
        r ^= e[4 * s + 1] << 8;
      case 1:
        r ^= e[4 * s], r = r * C & ze | r * u & Cs, r = r << 15 | r >>> 17, r = r * d & ze | r * E & Cs, 1 & s ? h ^= r : I ^= r;
    }
    this.h1 = h, this.h2 = I;
  }
  hexdigest() {
    let t = this.h1, e = this.h2;
    return t ^= e >>> 1, t = 3981806797 * t & ze | 36045 * t & Cs, e = 4283543511 * e & ze | (2950163797 * (e << 16 | t >>> 16) & ze) >>> 16, t ^= e >>> 1, t = 444984403 * t & ze | 60499 * t & Cs, e = 3301882366 * e & ze | (3120437893 * (e << 16 | t >>> 16) & ze) >>> 16, t ^= e >>> 1, (t >>> 0).toString(16).padStart(8, "0") + (e >>> 0).toString(16).padStart(8, "0");
  }
}
function ao(A, t, e, i, s) {
  let n = A;
  for (let o = 0, r = t.length - 1; o < r; o++) {
    const c = t[o];
    n = n[c] ||= [];
  }
  n[t.at(-1)] = { checkFn: e, iterateFn: i, processFn: s };
}
const Ua = [];
ao(Ua, [yi, Qs, Jo, Te], null, (function(A, t) {
  const e = A.fnArray, i = (t - (A.iCurr - 3)) % 4;
  switch (i) {
    case 0:
      return e[t] === yi;
    case 1:
      return e[t] === Qs;
    case 2:
      return e[t] === Jo;
    case 3:
      return e[t] === Te;
  }
  throw new Error(`iterateInlineImageGroup - invalid pos: ${i}`);
}), (function(A, t) {
  const e = A.fnArray, i = A.argsArray, s = A.iCurr, n = s - 3, o = s - 2, r = s - 1, c = Math.min(Math.floor((t - n) / 4), 200);
  if (c < 10) return t - (t - n) % 4;
  let h = 0;
  const I = [];
  let C = 0, d = 1, u = 1;
  for (let S = 0; S < c; S++) {
    const R = i[o + (S << 2)], x = i[r + (S << 2)][0];
    d + x.width > 1e3 && (h = Math.max(h, d), u += C + 2, d = 0, C = 0), I.push({ transform: R, x: d, y: u, w: x.width, h: x.height }), d += x.width + 2, C = Math.max(C, x.height);
  }
  const E = Math.max(h, d) + 1, p = u + C + 1, y = new Uint8Array(E * p * 4), b = E << 2;
  for (let S = 0; S < c; S++) {
    const R = i[r + (S << 2)][0].data, x = I[S].w << 2;
    let N = 0, U = I[S].x + I[S].y * E << 2;
    y.set(R.subarray(0, x), U - b);
    for (let T = 0, q = I[S].h; T < q; T++) y.set(R.subarray(N, N + x), U), N += x, U += b;
    for (y.set(R.subarray(N - x, N), U); U >= 0; ) R[U - 4] = R[U], R[U - 3] = R[U + 1], R[U - 2] = R[U + 2], R[U - 1] = R[U + 3], R[U + x] = R[U + x - 4], R[U + x + 1] = R[U + x - 3], R[U + x + 2] = R[U + x - 2], R[U + x + 3] = R[U + x - 1], U -= b;
  }
  const D = { width: E, height: p };
  if (A.isOffscreenCanvasSupported) {
    const S = new OffscreenCanvas(E, p);
    S.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(y.buffer), E, p), 0, 0), D.bitmap = S.transferToImageBitmap(), D.data = null;
  } else D.kind = ds, D.data = y;
  return e.splice(n, 4 * c, KQ), i.splice(n, 4 * c, [D, I]), n + 1;
})), ao(Ua, [yi, Qs, bs, Te], null, (function(A, t) {
  const e = A.fnArray, i = (t - (A.iCurr - 3)) % 4;
  switch (i) {
    case 0:
      return e[t] === yi;
    case 1:
      return e[t] === Qs;
    case 2:
      return e[t] === bs;
    case 3:
      return e[t] === Te;
  }
  throw new Error(`iterateImageMaskGroup - invalid pos: ${i}`);
}), (function(A, t) {
  const e = A.fnArray, i = A.argsArray, s = A.iCurr, n = s - 3, o = s - 2, r = s - 1;
  let c = Math.floor((t - n) / 4);
  if (c < 10) return t - (t - n) % 4;
  let h, I, C = !1;
  const d = i[r][0], u = i[o][0], E = i[o][1], p = i[o][2], y = i[o][3];
  if (E === p) {
    C = !0, h = o + 4;
    let b = r + 4;
    for (let D = 1; D < c; D++, h += 4, b += 4) if (I = i[h], i[b][0] !== d || I[0] !== u || I[1] !== E || I[2] !== p || I[3] !== y) {
      D < 10 ? C = !1 : c = D;
      break;
    }
  }
  if (C) {
    c = Math.min(c, 1e3);
    const b = new Float32Array(2 * c);
    h = o;
    for (let D = 0; D < c; D++, h += 4) I = i[h], b[D << 1] = I[4], b[1 + (D << 1)] = I[5];
    e.splice(n, 4 * c, vm), i.splice(n, 4 * c, [d, u, E, p, y, b]);
  } else {
    c = Math.min(c, 100);
    const b = [];
    for (let D = 0; D < c; D++) {
      I = i[o + (D << 2)];
      const S = i[r + (D << 2)][0];
      b.push({ data: S.data, width: S.width, height: S.height, interpolate: S.interpolate, count: S.count, transform: I });
    }
    e.splice(n, 4 * c, Nm), i.splice(n, 4 * c, [b]);
  }
  return n + 1;
})), ao(Ua, [yi, Qs, Aa, Te], (function(A) {
  const t = A.argsArray, e = A.iCurr - 2;
  return t[e][1] === 0 && t[e][2] === 0;
}), (function(A, t) {
  const e = A.fnArray, i = A.argsArray, s = (t - (A.iCurr - 3)) % 4;
  switch (s) {
    case 0:
      return e[t] === yi;
    case 1:
      if (e[t] !== Qs) return !1;
      const n = A.iCurr - 2, o = i[n][0], r = i[n][3];
      return i[t][0] === o && i[t][1] === 0 && i[t][2] === 0 && i[t][3] === r;
    case 2:
      if (e[t] !== Aa) return !1;
      const c = i[A.iCurr - 1][0];
      return i[t][0] === c;
    case 3:
      return e[t] === Te;
  }
  throw new Error(`iterateImageGroup - invalid pos: ${s}`);
}), (function(A, t) {
  const e = A.fnArray, i = A.argsArray, s = A.iCurr, n = s - 3, o = s - 2, r = i[s - 1][0], c = i[o][0], h = i[o][3], I = Math.min(Math.floor((t - n) / 4), 1e3);
  if (I < 3) return t - (t - n) % 4;
  const C = new Float32Array(2 * I);
  let d = o;
  for (let E = 0; E < I; E++, d += 4) {
    const p = i[d];
    C[E << 1] = p[4], C[1 + (E << 1)] = p[5];
  }
  const u = [r, c, h, C];
  return e.splice(n, 4 * I, Gm), i.splice(n, 4 * I, u), n + 1;
})), ao(Ua, [er, xs, sr, Pi, ir], null, (function(A, t) {
  const e = A.fnArray, i = A.argsArray, s = (t - (A.iCurr - 4)) % 5;
  switch (s) {
    case 0:
      return e[t] === er;
    case 1:
      return e[t] === xs;
    case 2:
      return e[t] === sr;
    case 3:
      if (e[t] !== Pi) return !1;
      const n = A.iCurr - 3, o = i[n][0], r = i[n][1];
      return i[t][0] === o && i[t][1] === r;
    case 4:
      return e[t] === ir;
  }
  throw new Error(`iterateShowTextGroup - invalid pos: ${s}`);
}), (function(A, t) {
  const e = A.fnArray, i = A.argsArray, s = A.iCurr, n = s - 4, o = s - 3, r = s - 2, c = s - 1, h = s, I = i[o][0], C = i[o][1];
  let d = Math.min(Math.floor((t - n) / 5), 1e3);
  if (d < 3) return t - (t - n) % 5;
  let u = n;
  n >= 4 && e[n - 4] === e[o] && e[n - 3] === e[r] && e[n - 2] === e[c] && e[n - 1] === e[h] && i[n - 4][0] === I && i[n - 4][1] === C && (d++, u -= 5);
  let E = u + 4;
  for (let p = 1; p < d; p++) e.splice(E, 3), i.splice(E, 3), E += 2;
  return E + 1;
}));
class NE {
  constructor(t) {
    this.queue = t;
  }
  _optimize() {
  }
  push(t, e) {
    this.queue.fnArray.push(t), this.queue.argsArray.push(e), this._optimize();
  }
  flush() {
  }
  reset() {
  }
}
class K8 extends NE {
  constructor(t) {
    super(t), this.state = null, this.context = { iCurr: 0, fnArray: t.fnArray, argsArray: t.argsArray, isOffscreenCanvasSupported: !1 }, this.match = null, this.lastProcessed = 0;
  }
  set isOffscreenCanvasSupported(t) {
    this.context.isOffscreenCanvasSupported = t;
  }
  _optimize() {
    const t = this.queue.fnArray;
    let e = this.lastProcessed, i = t.length, s = this.state, n = this.match;
    if (!s && !n && e + 1 === i && !Ua[t[e]]) return void (this.lastProcessed = i);
    const o = this.context;
    for (; e < i; ) {
      if (n) {
        if ((0, n.iterateFn)(o, e)) {
          e++;
          continue;
        }
        if (e = (0, n.processFn)(o, e + 1), i = t.length, n = null, s = null, e >= i) break;
      }
      s = (s || Ua)[t[e]], s && !Array.isArray(s) ? (o.iCurr = e, e++, (!s.checkFn || (0, s.checkFn)(o)) && (n = s), s = null) : e++;
    }
    this.state = s, this.match = n, this.lastProcessed = e;
  }
  flush() {
    for (; this.match; ) {
      const t = this.queue.fnArray.length;
      this.lastProcessed = (0, this.match.processFn)(this.context, t), this.match = null, this.state = null, this._optimize();
    }
  }
  reset() {
    this.state = null, this.match = null, this.lastProcessed = 0;
  }
}
class ue {
  static CHUNK_SIZE = 1e3;
  static CHUNK_SIZE_ABOUT = this.CHUNK_SIZE - 5;
  constructor(t = 0, e) {
    this._streamSink = e, this.fnArray = [], this.argsArray = [], this.optimizer = !e || t & w9 ? new NE(this) : new K8(this), this.dependencies = /* @__PURE__ */ new Set(), this._totalLength = 0, this.weight = 0, this._resolved = e ? null : Promise.resolve();
  }
  set isOffscreenCanvasSupported(t) {
    this.optimizer.isOffscreenCanvasSupported = t;
  }
  get length() {
    return this.argsArray.length;
  }
  get ready() {
    return this._resolved || this._streamSink.ready;
  }
  get totalLength() {
    return this._totalLength + this.length;
  }
  addOp(t, e) {
    this.optimizer.push(t, e), this.weight++, this._streamSink && (this.weight >= ue.CHUNK_SIZE || this.weight >= ue.CHUNK_SIZE_ABOUT && (t === Te || t === ir)) && this.flush();
  }
  addImageOps(t, e, i) {
    i !== void 0 && this.addOp(wi, ["OC", i]), this.addOp(t, e), i !== void 0 && this.addOp(Wa, []);
  }
  addDependency(t) {
    this.dependencies.has(t) || (this.dependencies.add(t), this.addOp(gm, [t]));
  }
  addDependencies(t) {
    for (const e of t) this.addDependency(e);
  }
  addOpList(t) {
    if (t instanceof ue) {
      for (const e of t.dependencies) this.dependencies.add(e);
      for (let e = 0, i = t.length; e < i; e++) this.addOp(t.fnArray[e], t.argsArray[e]);
    } else O('addOpList - ignoring invalid "opList" parameter.');
  }
  getIR() {
    return { fnArray: this.fnArray, argsArray: this.argsArray, length: this.length };
  }
  get _transfers() {
    const t = [], { fnArray: e, argsArray: i, length: s } = this;
    for (let n = 0; n < s; n++) switch (e[n]) {
      case Jo:
      case KQ:
      case bs:
        const o = i[n][0];
        !o.cached && o.data?.buffer instanceof ArrayBuffer && t.push(o.data.buffer);
    }
    return t;
  }
  flush(t = !1, e = null) {
    this.optimizer.flush();
    const i = this.length;
    this._totalLength += i, this._streamSink.enqueue({ fnArray: this.fnArray, argsArray: this.argsArray, lastChunk: t, separateAnnots: e, length: i }, 1, this._transfers), this.dependencies.clear(), this.fnArray.length = 0, this.argsArray.length = 0, this.weight = 0, this.optimizer.reset();
  }
}
function q8(A, t, e, i) {
  return (A = t + A * e) < 0 ? A = 0 : A > i && (A = i), A;
}
function p1(A, t, e, i, s, n) {
  const o = s * n;
  let r;
  r = t <= 8 ? new Uint8Array(o) : t <= 16 ? new Uint16Array(o) : new Uint32Array(o);
  const c = e / s, h = i / n;
  let I, C, d, u, E = 0;
  const p = new Uint16Array(s), y = e;
  for (I = 0; I < s; I++) p[I] = Math.floor(I * c);
  for (I = 0; I < n; I++) for (d = Math.floor(I * h) * y, C = 0; C < s; C++) u = d + p[C], r[E++] = A[u];
  return r;
}
class Wi {
  constructor({ xref: t, res: e, image: i, isInline: s = !1, smask: n = null, mask: o = null, isMask: r = !1, pdfFunctionFactory: c, localColorSpaceCache: h }) {
    this.image = i;
    const I = i.dict, C = I.get("F", "Filter");
    let d;
    if (C instanceof at) d = C.name;
    else if (Array.isArray(C)) {
      const y = t.fetchIfRef(C[0]);
      y instanceof at && (d = y.name);
    }
    switch (d) {
      case "JPXDecode":
        ({ width: i.width, height: i.height, componentsCount: i.numComps, bitsPerComponent: i.bitsPerComponent } = bl.parseImageProperties(i.stream)), i.stream.reset(), this.jpxDecoderOptions = { numComponents: 0, isIndexedColormap: !1, smaskInData: I.has("SMaskInData") };
        break;
      case "JBIG2Decode":
        i.bitsPerComponent = 1, i.numComps = 1;
    }
    let u = I.get("W", "Width"), E = I.get("H", "Height");
    if (Number.isInteger(i.width) && i.width > 0 && Number.isInteger(i.height) && i.height > 0 && (i.width !== u || i.height !== E) && (O("PDFImage - using the Width/Height of the image data, rather than the image dictionary."), u = i.width, E = i.height), u < 1 || E < 1) throw new Ct(`Invalid image width: ${u} or height: ${E}`);
    this.width = u, this.height = E, this.interpolate = I.get("I", "Interpolate"), this.imageMask = I.get("IM", "ImageMask") || !1, this.matte = I.get("Matte") || !1;
    let p = i.bitsPerComponent;
    if (!p && (p = I.get("BPC", "BitsPerComponent"), !p)) {
      if (!this.imageMask) throw new Ct(`Bits per component missing in image: ${this.imageMask}`);
      p = 1;
    }
    if (this.bpc = p, !this.imageMask) {
      let y = I.getRaw("CS") || I.getRaw("ColorSpace");
      const b = !!y;
      if (b) this.jpxDecoderOptions?.smaskInData && (y = at.get("DeviceRGBA"));
      else if (this.jpxDecoderOptions) y = at.get("DeviceRGBA");
      else switch (i.numComps) {
        case 1:
          y = at.get("DeviceGray");
          break;
        case 3:
          y = at.get("DeviceRGB");
          break;
        case 4:
          y = at.get("DeviceCMYK");
          break;
        default:
          throw new Error(`Images with ${i.numComps} color components not supported.`);
      }
      this.colorSpace = Vt.parse({ cs: y, xref: t, resources: s ? e : null, pdfFunctionFactory: c, localColorSpaceCache: h }), this.numComps = this.colorSpace.numComps, this.jpxDecoderOptions && (this.jpxDecoderOptions.numComponents = b ? this.numComp : 0, this.jpxDecoderOptions.isIndexedColormap = this.colorSpace.name === "Indexed");
    }
    if (this.decode = I.getArray("D", "Decode"), this.needsDecode = !1, this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, p) || r && !Vt.isDefaultDecode(this.decode, 1))) {
      this.needsDecode = !0;
      const y = (1 << p) - 1;
      this.decodeCoefficients = [], this.decodeAddends = [];
      const b = this.colorSpace?.name === "Indexed";
      for (let D = 0, S = 0; D < this.decode.length; D += 2, ++S) {
        const R = this.decode[D], x = this.decode[D + 1];
        this.decodeCoefficients[S] = b ? (x - R) / y : x - R, this.decodeAddends[S] = b ? R : y * R;
      }
    }
    n ? this.smask = new Wi({ xref: t, res: e, image: n, isInline: s, pdfFunctionFactory: c, localColorSpaceCache: h }) : o && (o instanceof AA ? o.dict.get("IM", "ImageMask") ? this.mask = new Wi({ xref: t, res: e, image: o, isInline: s, isMask: !0, pdfFunctionFactory: c, localColorSpaceCache: h }) : O("Ignoring /Mask in image without /ImageMask.") : this.mask = o);
  }
  static async buildImage({ xref: t, res: e, image: i, isInline: s = !1, pdfFunctionFactory: n, localColorSpaceCache: o }) {
    const r = i;
    let c = null, h = null;
    const I = i.dict.get("SMask"), C = i.dict.get("Mask");
    return I ? I instanceof AA ? c = I : O("Unsupported /SMask format.") : C && (C instanceof AA || Array.isArray(C) ? h = C : O("Unsupported /Mask format.")), new Wi({ xref: t, res: e, image: r, isInline: s, smask: c, mask: h, pdfFunctionFactory: n, localColorSpaceCache: o });
  }
  static createRawMask({ imgArray: t, width: e, height: i, imageIsFromDecodeStream: s, inverseDecode: n, interpolate: o }) {
    const r = (e + 7 >> 3) * i, c = t.byteLength;
    let h, I;
    if (!s || n && r !== c ? n ? (h = new Uint8Array(r), h.set(t), h.fill(255, c)) : h = new Uint8Array(t) : h = t, n) for (I = 0; I < c; I++) h[I] ^= 255;
    return { data: h, width: e, height: i, interpolate: o };
  }
  static async createMask({ imgArray: t, width: e, height: i, imageIsFromDecodeStream: s, inverseDecode: n, interpolate: o, isOffscreenCanvasSupported: r = !1 }) {
    const c = e === 1 && i === 1 && n === (t.length === 0 || !!(128 & t[0]));
    if (c) return { isSingleOpaquePixel: c };
    if (r) {
      if (Ye.needsToBeResized(e, i)) {
        const d = new Uint8ClampedArray(e * i * 4);
        return Lh({ src: t, dest: d, width: e, height: i, nonBlackColor: 0, inverseDecode: n }), Ye.createImage({ kind: ds, data: d, width: e, height: i, interpolate: o });
      }
      const h = new OffscreenCanvas(e, i), I = h.getContext("2d"), C = I.createImageData(e, i);
      return Lh({ src: t, dest: C.data, width: e, height: i, nonBlackColor: 0, inverseDecode: n }), I.putImageData(C, 0, 0), { data: null, width: e, height: i, interpolate: o, bitmap: h.transferToImageBitmap() };
    }
    return this.createRawMask({ imgArray: t, width: e, height: i, inverseDecode: n, imageIsFromDecodeStream: s, interpolate: o });
  }
  get drawWidth() {
    return Math.max(this.width, this.smask?.width || 0, this.mask?.width || 0);
  }
  get drawHeight() {
    return Math.max(this.height, this.smask?.height || 0, this.mask?.height || 0);
  }
  decodeBuffer(t) {
    const e = this.bpc, i = this.numComps, s = this.decodeAddends, n = this.decodeCoefficients, o = (1 << e) - 1;
    let r, c;
    if (e === 1) {
      for (r = 0, c = t.length; r < c; r++) t[r] = +!t[r];
      return;
    }
    let h = 0;
    for (r = 0, c = this.width * this.height; r < c; r++) for (let I = 0; I < i; I++) t[h] = q8(t[h], s[I], n[I], o), h++;
  }
  getComponents(t) {
    const e = this.bpc;
    if (e === 8) return t;
    const i = this.width, s = this.height, n = this.numComps, o = i * s * n;
    let r, c = 0;
    r = e <= 8 ? new Uint8Array(o) : e <= 16 ? new Uint16Array(o) : new Uint32Array(o);
    const h = i * n, I = (1 << e) - 1;
    let C, d, u = 0;
    if (e === 1) {
      let E, p, y;
      for (let b = 0; b < s; b++) {
        for (p = u + (-8 & h), y = u + h; u < p; ) d = t[c++], r[u] = d >> 7 & 1, r[u + 1] = d >> 6 & 1, r[u + 2] = d >> 5 & 1, r[u + 3] = d >> 4 & 1, r[u + 4] = d >> 3 & 1, r[u + 5] = d >> 2 & 1, r[u + 6] = d >> 1 & 1, r[u + 7] = 1 & d, u += 8;
        if (u < y) for (d = t[c++], E = 128; u < y; ) r[u++] = +!!(d & E), E >>= 1;
      }
    } else {
      let E = 0;
      for (d = 0, u = 0, C = o; u < C; ++u) {
        for (u % h == 0 && (d = 0, E = 0); E < e; ) d = d << 8 | t[c++], E += 8;
        const p = E - e;
        let y = d >> p;
        y < 0 ? y = 0 : y > I && (y = I), r[u] = y, d &= (1 << p) - 1, E = p;
      }
    }
    return r;
  }
  async fillOpacity(t, e, i, s, n) {
    const o = this.smask, r = this.mask;
    let c, h, I, C, d, u;
    if (o) h = o.width, I = o.height, c = new Uint8ClampedArray(h * I), await o.fillGrayBuffer(c), h === e && I === i || (c = p1(c, o.bpc, h, I, e, i));
    else if (r) if (r instanceof Wi) {
      for (h = r.width, I = r.height, c = new Uint8ClampedArray(h * I), r.numComps = 1, await r.fillGrayBuffer(c), C = 0, d = h * I; C < d; ++C) c[C] = 255 - c[C];
      h === e && I === i || (c = p1(c, r.bpc, h, I, e, i));
    } else {
      if (!Array.isArray(r)) throw new Ct("Unknown mask format.");
      {
        c = new Uint8ClampedArray(e * i);
        const E = this.numComps;
        for (C = 0, d = e * i; C < d; ++C) {
          let p = 0;
          const y = C * E;
          for (u = 0; u < E; ++u) {
            const b = n[y + u], D = 2 * u;
            if (b < r[D] || b > r[D + 1]) {
              p = 255;
              break;
            }
          }
          c[C] = p;
        }
      }
    }
    if (c) for (C = 0, u = 3, d = e * s; C < d; ++C, u += 4) t[u] = c[C];
    else for (C = 0, u = 3, d = e * s; C < d; ++C, u += 4) t[u] = 255;
  }
  undoPreblend(t, e, i) {
    const s = this.smask?.matte;
    if (!s) return;
    const n = this.colorSpace.getRgb(s, 0), o = n[0], r = n[1], c = n[2], h = e * i * 4;
    for (let I = 0; I < h; I += 4) {
      const C = t[I + 3];
      if (C === 0) {
        t[I] = 255, t[I + 1] = 255, t[I + 2] = 255;
        continue;
      }
      const d = 255 / C;
      t[I] = (t[I] - o) * d + o, t[I + 1] = (t[I + 1] - r) * d + r, t[I + 2] = (t[I + 2] - c) * d + c;
    }
  }
  async createImageData(t = !1, e = !1) {
    const i = this.drawWidth, s = this.drawHeight, n = { width: i, height: s, interpolate: this.interpolate, kind: 0, data: null }, o = this.numComps, r = this.width, c = this.height, h = this.bpc, I = r * o * h + 7 >> 3, C = e && Ye.needsToBeResized(i, s);
    if (this.colorSpace.name === "DeviceRGBA") {
      n.kind = ds;
      const x = n.data = await this.getImageBytes(c * r * 4, {});
      return e ? C ? Ye.createImage(n, !1) : this.createBitmap(ds, i, s, x) : n;
    }
    if (!t) {
      let x;
      if (this.colorSpace.name === "DeviceGray" && h === 1 ? x = xo : this.colorSpace.name !== "DeviceRGB" || h !== 8 || this.needsDecode || (x = _n), x && !this.smask && !this.mask && i === r && s === c) {
        const N = await this.getImageBytes(c * I, {});
        if (e) return C ? Ye.createImage({ data: N, kind: x, width: i, height: s, interpolate: this.interpolate }, this.needsDecode) : this.createBitmap(x, r, c, N);
        if (n.kind = x, n.data = N, this.needsDecode) {
          pe(x === xo, "PDFImage.createImageData: The image must be grayscale.");
          const U = n.data;
          for (let T = 0, q = U.length; T < q; T++) U[T] ^= 255;
        }
        return n;
      }
      if (this.image instanceof wl && !this.smask && !this.mask && !this.needsDecode) {
        let N = c * I;
        if (e && !C) {
          let U = !1;
          switch (this.colorSpace.name) {
            case "DeviceGray":
              N *= 4, U = !0;
              break;
            case "DeviceRGB":
              N = N / 3 * 4, U = !0;
              break;
            case "DeviceCMYK":
              U = !0;
          }
          if (U) {
            const T = await this.getImageBytes(N, { drawWidth: i, drawHeight: s, forceRGBA: !0 });
            return this.createBitmap(ds, i, s, T);
          }
        } else switch (this.colorSpace.name) {
          case "DeviceGray":
            N *= 3;
          case "DeviceRGB":
          case "DeviceCMYK":
            return n.kind = _n, n.data = await this.getImageBytes(N, { drawWidth: i, drawHeight: s, forceRGB: !0 }), C ? Ye.createImage(n) : n;
        }
      }
    }
    const d = await this.getImageBytes(c * I, { internal: !0 }), u = 0 | d.length / I * s / c, E = this.getComponents(d);
    let p, y, b, D, S, R;
    return e && !C && (b = new OffscreenCanvas(i, s), D = b.getContext("2d"), S = D.createImageData(i, s), R = S.data), n.kind = ds, t || this.smask || this.mask ? (e && !C || (R = new Uint8ClampedArray(i * s * 4)), p = 1, y = !0, await this.fillOpacity(R, i, s, u, E)) : (!e || C ? (n.kind = _n, R = new Uint8ClampedArray(i * s * 3), p = 0) : (new Uint32Array(R.buffer).fill(es.isLittleEndian ? 4278190080 : 255), p = 1), y = !1), this.needsDecode && this.decodeBuffer(E), this.colorSpace.fillRgb(R, r, c, i, s, u, h, E, p), y && this.undoPreblend(R, i, u), e && !C ? (D.putImageData(S, 0, 0), { data: null, width: i, height: s, bitmap: b.transferToImageBitmap(), interpolate: this.interpolate }) : (n.data = R, C ? Ye.createImage(n) : n);
  }
  async fillGrayBuffer(t) {
    const e = this.numComps;
    if (e !== 1) throw new Ct(`Reading gray scale from a color image: ${e}`);
    const i = this.width, s = this.height, n = this.bpc, o = i * e * n + 7 >> 3, r = await this.getImageBytes(s * o, { internal: !0 }), c = this.getComponents(r);
    let h, I;
    if (n === 1) {
      if (I = i * s, this.needsDecode) for (h = 0; h < I; ++h) t[h] = c[h] - 1 & 255;
      else for (h = 0; h < I; ++h) t[h] = 255 & -c[h];
      return;
    }
    this.needsDecode && this.decodeBuffer(c), I = i * s;
    const C = 255 / ((1 << n) - 1);
    for (h = 0; h < I; ++h) t[h] = C * c[h];
  }
  createBitmap(t, e, i, s) {
    const n = new OffscreenCanvas(e, i), o = n.getContext("2d");
    let r;
    return t === ds ? r = new ImageData(s, e, i) : (r = o.createImageData(e, i), x3({ kind: t, src: s, dest: new Uint32Array(r.data.buffer), width: e, height: i, inverseDecode: this.needsDecode })), o.putImageData(r, 0, 0), { data: null, width: e, height: i, bitmap: n.transferToImageBitmap(), interpolate: this.interpolate };
  }
  async getImageBytes(t, { drawWidth: e, drawHeight: i, forceRGBA: s = !1, forceRGB: n = !1, internal: o = !1 }) {
    this.image.reset(), this.image.drawWidth = e || this.width, this.image.drawHeight = i || this.height, this.image.forceRGBA = !!s, this.image.forceRGB = !!n;
    const r = await this.image.getImageData(t, this.jpxDecoderOptions);
    return o || this.image instanceof Be ? r : (pe(r instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.'), new Uint8Array(r));
  }
}
const GE = Object.freeze({ maxImageSize: -1, disableFontFace: !1, ignoreErrors: !1, isEvalSupported: !0, isOffscreenCanvasSupported: !1, canvasMaxAreaInBytes: -1, fontExtraProperties: !1, useSystemFonts: !0, cMapUrl: null, standardFontDataUrl: null }), P8 = 1, _8 = 2, m1 = Promise.resolve();
function vE(A, t = !1) {
  if (Array.isArray(A)) {
    for (const e of A) {
      const i = vE(e, !0);
      if (i) return i;
    }
    return O(`Unsupported blend mode Array: ${A}`), "source-over";
  }
  if (!(A instanceof at)) return t ? null : "source-over";
  switch (A.name) {
    case "Normal":
    case "Compatible":
      return "source-over";
    case "Multiply":
      return "multiply";
    case "Screen":
      return "screen";
    case "Overlay":
      return "overlay";
    case "Darken":
      return "darken";
    case "Lighten":
      return "lighten";
    case "ColorDodge":
      return "color-dodge";
    case "ColorBurn":
      return "color-burn";
    case "HardLight":
      return "hard-light";
    case "SoftLight":
      return "soft-light";
    case "Difference":
      return "difference";
    case "Exclusion":
      return "exclusion";
    case "Hue":
      return "hue";
    case "Saturation":
      return "saturation";
    case "Color":
      return "color";
    case "Luminosity":
      return "luminosity";
  }
  return t ? null : (O(`Unsupported blend mode: ${A.name}`), "source-over");
}
function rh(A, t) {
  t.objId && A.addDependency(t.objId), A.addImageOps(t.fn, t.args, t.optionalContent), t.fn === bs && t.args[0]?.count > 0 && t.args[0].count++;
}
class Ir {
  static TIME_SLOT_DURATION_MS = 20;
  static CHECK_TIME_EVERY = 100;
  constructor() {
    this.reset();
  }
  check() {
    return !(++this.checked < Ir.CHECK_TIME_EVERY) && (this.checked = 0, this.endTime <= Date.now());
  }
  reset() {
    this.endTime = Date.now() + Ir.TIME_SLOT_DURATION_MS, this.checked = 0;
  }
}
class Ri {
  constructor({ xref: t, handler: e, pageIndex: i, idFactory: s, fontCache: n, builtInCMapCache: o, standardFontDataCache: r, globalImageCache: c, systemFontCache: h, options: I = null }) {
    this.xref = t, this.handler = e, this.pageIndex = i, this.idFactory = s, this.fontCache = n, this.builtInCMapCache = o, this.standardFontDataCache = r, this.globalImageCache = c, this.systemFontCache = h, this.options = I || GE, this.type3FontRefs = null, this._regionalImageCache = new D8(), this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this), Ye.setMaxArea(this.options.canvasMaxAreaInBytes);
  }
  get _pdfFunctionFactory() {
    return bt(this, "_pdfFunctionFactory", new RE({ xref: this.xref, isEvalSupported: this.options.isEvalSupported }));
  }
  get parsingType3Font() {
    return !!this.type3FontRefs;
  }
  clone(t = null) {
    const e = Object.create(this);
    return e.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, t), e;
  }
  hasBlendModes(t, e) {
    if (!(t instanceof z) || t.objId && e.has(t.objId)) return !1;
    const i = new XA(e);
    t.objId && i.put(t.objId);
    const s = [t], n = this.xref;
    for (; s.length; ) {
      const o = s.shift(), r = o.get("ExtGState");
      if (r instanceof z) for (let h of r.getRawValues()) {
        if (h instanceof St) {
          if (i.has(h)) continue;
          try {
            h = n.fetch(h);
          } catch (C) {
            i.put(h), tA(`hasBlendModes - ignoring ExtGState: "${C}".`);
            continue;
          }
        }
        if (!(h instanceof z)) continue;
        h.objId && i.put(h.objId);
        const I = h.get("BM");
        if (I instanceof at) {
          if (I.name !== "Normal") return !0;
        } else if (I !== void 0 && Array.isArray(I)) {
          for (const C of I) if (C instanceof at && C.name !== "Normal") return !0;
        }
      }
      const c = o.get("XObject");
      if (c instanceof z) for (let h of c.getRawValues()) {
        if (h instanceof St) {
          if (i.has(h)) continue;
          try {
            h = n.fetch(h);
          } catch (C) {
            i.put(h), tA(`hasBlendModes - ignoring XObject: "${C}".`);
            continue;
          }
        }
        if (!(h instanceof AA)) continue;
        h.dict.objId && i.put(h.dict.objId);
        const I = h.dict.get("Resources");
        I instanceof z && (I.objId && i.has(I.objId) || (s.push(I), I.objId && i.put(I.objId)));
      }
    }
    for (const o of i) e.put(o);
    return !1;
  }
  async fetchBuiltInCMap(t) {
    const e = this.builtInCMapCache.get(t);
    if (e) return e;
    let i;
    if (this.options.cMapUrl !== null) {
      const s = `${this.options.cMapUrl}${t}.bcmap`, n = await fetch(s);
      if (!n.ok) throw new Error(`fetchBuiltInCMap: failed to fetch file "${s}" with "${n.statusText}".`);
      i = { cMapData: new Uint8Array(await n.arrayBuffer()), compressionType: mQ };
    } else i = await this.handler.sendWithPromise("FetchBuiltInCMap", { name: t });
    return i.compressionType !== pQ && this.builtInCMapCache.set(t, i), i;
  }
  async fetchStandardFontData(t) {
    const e = this.standardFontDataCache.get(t);
    if (e) return new RA(e);
    if (this.options.useSystemFonts && t !== "Symbol" && t !== "ZapfDingbats") return null;
    const i = c5()[t];
    let s;
    if (this.options.standardFontDataUrl !== null) {
      const n = `${this.options.standardFontDataUrl}${i}`, o = await fetch(n);
      o.ok ? s = new Uint8Array(await o.arrayBuffer()) : O(`fetchStandardFontData: failed to fetch file "${n}" with "${o.statusText}".`);
    } else try {
      s = await this.handler.sendWithPromise("FetchStandardFontData", { filename: i });
    } catch (n) {
      O(`fetchStandardFontData: failed to fetch file "${i}" with "${n}".`);
    }
    return s ? (this.standardFontDataCache.set(t, s), new RA(s)) : null;
  }
  async buildFormXObject(t, e, i, s, n, o, r) {
    const c = e.dict, h = ks(c.getArray("Matrix"), null), I = Zi(c.getArray("BBox"), null);
    let C, d;
    c.has("OC") && (C = await this.parseMarkedContentProps(c.get("OC"), t)), C !== void 0 && s.addOp(wi, ["OC", C]);
    const u = c.get("Group");
    if (u) {
      d = { matrix: h, bbox: I, smask: i, isolated: !1, knockout: !1 };
      let p = null;
      if (qA(u.get("S"), "Transparency") && (d.isolated = u.get("I") || !1, d.knockout = u.get("K") || !1, u.has("CS"))) {
        const y = u.getRaw("CS");
        p = Vt.getCached(y, this.xref, r) || await this.parseColorSpace({ cs: y, resources: t, localColorSpaceCache: r });
      }
      i?.backdrop && (p ||= Vt.singletons.rgb, i.backdrop = p.getRgb(i.backdrop, 0)), s.addOp(Rm, [d]);
    }
    const E = u ? [h, null] : [h, I];
    s.addOp(Sm, E), await this.getOperatorList({ stream: e, task: n, resources: c.get("Resources") || t, operatorList: s, initialState: o }), s.addOp(Fm, []), u && s.addOp(xm, [d]), C !== void 0 && s.addOp(Wa, []);
  }
  _sendImgData(t, e, i = !1) {
    const s = e ? [e.bitmap || e.data.buffer] : null;
    return this.parsingType3Font || i ? this.handler.send("commonobj", [t, "Image", e], s) : this.handler.send("obj", [t, this.pageIndex, "Image", e], s);
  }
  async buildPaintImageXObject({ resources: t, image: e, isInline: i = !1, operatorList: s, cacheKey: n, localImageCache: o, localColorSpaceCache: r }) {
    const c = e.dict, h = c.objId, I = c.get("W", "Width"), C = c.get("H", "Height");
    if (!I || typeof I != "number" || !C || typeof C != "number") return void O("Image dimensions are missing, or not numbers.");
    const d = this.options.maxImageSize;
    if (d !== -1 && I * C > d) {
      const D = "Image exceeded maximum allowed size and was removed.";
      if (this.options.ignoreErrors) return void O(D);
      throw new Error(D);
    }
    let u;
    c.has("OC") && (u = await this.parseMarkedContentProps(c.get("OC"), t));
    let E, p;
    if (c.get("IM", "ImageMask")) {
      const D = c.get("I", "Interpolate"), S = I + 7 >> 3, R = e.getBytes(S * C), x = c.getArray("D", "Decode");
      if (this.parsingType3Font) {
        if (E = Wi.createRawMask({ imgArray: R, width: I, height: C, imageIsFromDecodeStream: e instanceof Be, inverseDecode: x?.[0] > 0, interpolate: D }), E.cached = !!n, p = [E], s.addImageOps(bs, p, u), n) {
          const U = { fn: bs, args: p, optionalContent: u };
          o.set(n, h, U), h && this._regionalImageCache.set(null, h, U);
        }
        return;
      }
      if (E = await Wi.createMask({ imgArray: R, width: I, height: C, imageIsFromDecodeStream: e instanceof Be, inverseDecode: x?.[0] > 0, interpolate: D, isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported }), E.isSingleOpaquePixel) {
        if (s.addImageOps(fC, [], u), n) {
          const U = { fn: fC, args: [], optionalContent: u };
          o.set(n, h, U), h && this._regionalImageCache.set(null, h, U);
        }
        return;
      }
      const N = `mask_${this.idFactory.createObjId()}`;
      if (s.addDependency(N), E.dataLen = E.bitmap ? E.width * E.height * 4 : E.data.length, this._sendImgData(N, E), p = [{ data: N, width: E.width, height: E.height, interpolate: E.interpolate, count: 1 }], s.addImageOps(bs, p, u), n) {
        const U = { objId: N, fn: bs, args: p, optionalContent: u };
        o.set(n, h, U), h && this._regionalImageCache.set(null, h, U);
      }
      return;
    }
    if (i && I + C < 200 && !c.has("SMask") && !c.has("Mask")) {
      try {
        E = await new Wi({ xref: this.xref, res: t, image: e, isInline: i, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: r }).createImageData(!0, !1), s.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported, s.addImageOps(Jo, [E], u);
      } catch (D) {
        const S = `Unable to decode inline image: "${D}".`;
        if (!this.options.ignoreErrors) throw new Error(S);
        O(S);
      }
      return;
    }
    let y = `img_${this.idFactory.createObjId()}`, b = !1;
    if (this.parsingType3Font ? y = `${this.idFactory.getDocId()}_type3_${y}` : n && h && (b = this.globalImageCache.shouldCache(h, this.pageIndex), b && (pe(!i, "Cannot cache an inline image globally."), y = `${this.idFactory.getDocId()}_${y}`)), s.addDependency(y), p = [y, I, C], s.addImageOps(Aa, p, u), b) {
      if (this.globalImageCache.hasDecodeFailed(h)) return this.globalImageCache.setData(h, { objId: y, fn: Aa, args: p, optionalContent: u, byteSize: 0 }), void this._sendImgData(y, null, b);
      if (I * C > 25e4 || c.has("SMask") || c.has("Mask")) {
        const D = await this.handler.sendWithPromise("commonobj", [y, "CopyLocalImage", { imageRef: h }]);
        if (D) return this.globalImageCache.setData(h, { objId: y, fn: Aa, args: p, optionalContent: u, byteSize: 0 }), void this.globalImageCache.addByteSize(h, D);
      }
    }
    if (Wi.buildImage({ xref: this.xref, res: t, image: e, isInline: i, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: r }).then((async (D) => (E = await D.createImageData(!1, this.options.isOffscreenCanvasSupported), E.dataLen = E.bitmap ? E.width * E.height * 4 : E.data.length, E.ref = h, b && this.globalImageCache.addByteSize(h, E.dataLen), this._sendImgData(y, E, b)))).catch(((D) => (O(`Unable to decode image "${y}": "${D}".`), h && this.globalImageCache.addDecodeFailed(h), this._sendImgData(y, null, b)))), n) {
      const D = { objId: y, fn: Aa, args: p, optionalContent: u };
      o.set(n, h, D), h && (this._regionalImageCache.set(null, h, D), b && this.globalImageCache.setData(h, { objId: y, fn: Aa, args: p, optionalContent: u, byteSize: 0 }));
    }
  }
  handleSMask(t, e, i, s, n, o) {
    const r = t.get("G"), c = { subtype: t.get("S").name, backdrop: t.get("BC") }, h = t.get("TR");
    if (ah(h)) {
      const I = this._pdfFunctionFactory.create(h), C = new Uint8Array(256), d = new Float32Array(1);
      for (let u = 0; u < 256; u++) d[0] = u / 255, I(d, 0, d, 0), C[u] = 255 * d[0] | 0;
      c.transferMap = C;
    }
    return this.buildFormXObject(e, r, c, i, s, n.state.clone(), o);
  }
  handleTransferFunction(t) {
    let e;
    if (Array.isArray(t)) e = t;
    else {
      if (!ah(t)) return null;
      e = [t];
    }
    const i = [];
    let s = 0, n = 0;
    for (const o of e) {
      const r = this.xref.fetchIfRef(o);
      if (s++, qA(r, "Identity")) {
        i.push(null);
        continue;
      }
      if (!ah(r)) return null;
      const c = this._pdfFunctionFactory.create(r), h = new Uint8Array(256), I = new Float32Array(1);
      for (let C = 0; C < 256; C++) I[0] = C / 255, c(I, 0, I, 0), h[C] = 255 * I[0] | 0;
      i.push(h), n++;
    }
    return s !== 1 && s !== 4 || n === 0 ? null : i;
  }
  handleTilingType(t, e, i, s, n, o, r, c) {
    const h = new ue(), I = z.merge({ xref: this.xref, dictArray: [n.get("Resources"), i] });
    return this.getOperatorList({ stream: s, task: r, resources: I, operatorList: h }).then((function() {
      const C = h.getIR(), d = g1(C, n, e);
      o.addDependencies(h.dependencies), o.addOp(t, d), n.objId && c.set(null, n.objId, { operatorListIR: C, dict: n });
    })).catch(((C) => {
      if (!(C instanceof fe)) {
        if (!this.options.ignoreErrors) throw C;
        O(`handleTilingType - ignoring pattern: "${C}".`);
      }
    }));
  }
  async handleSetFont(t, e, i, s, n, o, r = null, c = null) {
    const h = e?.[0] instanceof at ? e[0].name : null;
    let I = await this.loadFont(h, i, t, r, c);
    if (I.font.isType3Font) try {
      await I.loadType3Data(this, t, n), s.addDependencies(I.type3Dependencies);
    } catch (C) {
      I = new no({ loadedName: "g_font_error", font: new sh(`Type3 font load error: ${C}`), dict: I.font, evaluatorOptions: this.options });
    }
    return o.font = I.font, I.send(this.handler), I.loadedName;
  }
  handleText(t, e) {
    const i = e.font, s = i.charsToGlyphs(t);
    return i.data && (e.textRenderingMode & D9 || e.fillColorSpace.name === "Pattern" || i.disableFontFace || this.options.disableFontFace) && Ri.buildFontPaths(i, s, this.handler, this.options), s;
  }
  ensureStateFont(t) {
    if (t.font) return;
    const e = new Ct("Missing setFont (Tf) operator before text rendering operator.");
    if (!this.options.ignoreErrors) throw e;
    O(`ensureStateFont: "${e}".`);
  }
  async setGState({ resources: t, gState: e, operatorList: i, cacheKey: s, task: n, stateManager: o, localGStateCache: r, localColorSpaceCache: c }) {
    const h = e.objId;
    let I = !0;
    const C = [];
    let d = Promise.resolve();
    for (const u of e.getKeys()) {
      const E = e.get(u);
      switch (u) {
        case "Type":
          break;
        case "LW":
        case "LC":
        case "LJ":
        case "ML":
        case "D":
        case "RI":
        case "FL":
        case "CA":
        case "ca":
          C.push([u, E]);
          break;
        case "Font":
          I = !1, d = d.then((() => this.handleSetFont(t, null, E[0], i, n, o.state).then((function(y) {
            i.addDependency(y), C.push([u, [y, E[1]]]);
          }))));
          break;
        case "BM":
          C.push([u, vE(E)]);
          break;
        case "SMask":
          if (qA(E, "None")) {
            C.push([u, !1]);
            break;
          }
          E instanceof z ? (I = !1, d = d.then((() => this.handleSMask(E, t, i, n, o, c))), C.push([u, !0])) : O("Unsupported SMask type");
          break;
        case "TR":
          const p = this.handleTransferFunction(E);
          C.push([u, p]);
          break;
        case "OP":
        case "op":
        case "OPM":
        case "BG":
        case "BG2":
        case "UCR":
        case "UCR2":
        case "TR2":
        case "HT":
        case "SM":
        case "SA":
        case "AIS":
        case "TK":
          tA("graphic state operator " + u);
          break;
        default:
          tA("Unknown graphic state operator " + u);
      }
    }
    await d, C.length > 0 && i.addOp(Ma, [C]), I && r.set(s, h, C);
  }
  loadFont(t, e, i, s = null, n = null) {
    const o = async () => new no({ loadedName: "g_font_error", font: new sh(`Font "${t}" is not available.`), dict: e, evaluatorOptions: this.options });
    let r;
    if (e) e instanceof St && (r = e);
    else {
      const p = i.get("Font");
      p && (r = p.getRaw(t));
    }
    if (r) {
      if (this.type3FontRefs?.has(r)) return o();
      if (this.fontCache.has(r)) return this.fontCache.get(r);
      try {
        e = this.xref.fetchIfRef(r);
      } catch (p) {
        O(`loadFont - lookup failed: "${p}".`);
      }
    }
    if (!(e instanceof z)) {
      if (!this.options.ignoreErrors && !this.parsingType3Font) return O(`Font "${t}" is not available.`), o();
      O(`Font "${t}" is not available -- attempting to fallback to a default font.`), e = s || Ri.fallbackFontDict;
    }
    if (e.cacheKey && this.fontCache.has(e.cacheKey)) return this.fontCache.get(e.cacheKey);
    const { promise: c, resolve: h } = Promise.withResolvers();
    let I;
    try {
      I = this.preEvaluateFont(e), I.cssFontInfo = n;
    } catch (p) {
      return O(`loadFont - preEvaluateFont failed: "${p}".`), o();
    }
    const { descriptor: C, hash: d } = I, u = r instanceof St;
    let E;
    if (d && C instanceof z) {
      const p = C.fontAliases ||= /* @__PURE__ */ Object.create(null);
      if (p[d]) {
        const y = p[d].aliasRef;
        if (u && y && this.fontCache.has(y)) return this.fontCache.putAlias(r, y), this.fontCache.get(r);
      } else p[d] = { fontID: this.idFactory.createFontId() };
      u && (p[d].aliasRef = r), E = p[d].fontID;
    } else E = this.idFactory.createFontId();
    return pe(E?.startsWith("f"), 'The "fontID" must be (correctly) defined.'), u ? this.fontCache.put(r, c) : (e.cacheKey = `cacheKey_${E}`, this.fontCache.put(e.cacheKey, c)), e.loadedName = `${this.idFactory.getDocId()}_${E}`, this.translateFont(I).then(((p) => {
      h(new no({ loadedName: e.loadedName, font: p, dict: e, evaluatorOptions: this.options }));
    })).catch(((p) => {
      O(`loadFont - translateFont failed: "${p}".`), h(new no({ loadedName: e.loadedName, font: new sh(p instanceof Error ? p.message : p), dict: e, evaluatorOptions: this.options }));
    })), c;
  }
  buildPath(t, e, i, s = !1) {
    const n = t.length - 1;
    if (i || (i = []), n < 0 || t.fnArray[n] !== pC) {
      let o;
      switch (s && (O(`Encountered path operator "${e}" inside of a text object.`), t.addOp(yi, null)), e) {
        case Qo:
          const r = i[0] + i[2], c = i[1] + i[3];
          o = [Math.min(i[0], r), Math.min(i[1], c), Math.max(i[0], r), Math.max(i[1], c)];
          break;
        case On:
        case Bo:
          o = [i[0], i[1], i[0], i[1]];
          break;
        default:
          o = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      }
      t.addOp(pC, [[e], i, o]), s && t.addOp(Te, null);
    } else {
      const o = t.argsArray[n];
      o[0].push(e), o[1].push(...i);
      const r = o[2];
      switch (e) {
        case Qo:
          const c = i[0] + i[2], h = i[1] + i[3];
          r[0] = Math.min(r[0], i[0], c), r[1] = Math.min(r[1], i[1], h), r[2] = Math.max(r[2], i[0], c), r[3] = Math.max(r[3], i[1], h);
          break;
        case On:
        case Bo:
          r[0] = Math.min(r[0], i[0]), r[1] = Math.min(r[1], i[1]), r[2] = Math.max(r[2], i[0]), r[3] = Math.max(r[3], i[1]);
      }
    }
  }
  parseColorSpace({ cs: t, resources: e, localColorSpaceCache: i }) {
    return Vt.parseAsync({ cs: t, xref: this.xref, resources: e, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: i }).catch(((s) => {
      if (s instanceof fe) return null;
      if (this.options.ignoreErrors) return O(`parseColorSpace - ignoring ColorSpace: "${s}".`), null;
      throw s;
    }));
  }
  parseShading({ shading: t, resources: e, localColorSpaceCache: i, localShadingPatternCache: s }) {
    let n, o = s.get(t);
    if (o) return o;
    try {
      n = J5.parseShading(t, this.xref, e, this._pdfFunctionFactory, i).getIR();
    } catch (r) {
      if (r instanceof fe) return null;
      if (this.options.ignoreErrors) return O(`parseShading - ignoring shading: "${r}".`), s.set(t, null), null;
      throw r;
    }
    return o = `pattern_${this.idFactory.createObjId()}`, this.parsingType3Font && (o = `${this.idFactory.getDocId()}_type3_${o}`), s.set(t, o), this.parsingType3Font ? this.handler.send("commonobj", [o, "Pattern", n]) : this.handler.send("obj", [o, this.pageIndex, "Pattern", n]), o;
  }
  handleColorN(t, e, i, s, n, o, r, c, h, I) {
    const C = i.pop();
    if (C instanceof at) {
      const d = n.getRaw(C.name), u = d instanceof St && h.getByRef(d);
      if (u) try {
        const p = s.base ? s.base.getRgb(i, 0) : null, y = g1(u.operatorListIR, u.dict, p);
        return void t.addOp(e, y);
      } catch {
      }
      const E = this.xref.fetchIfRef(d);
      if (E) {
        const p = E instanceof AA ? E.dict : E, y = p.get("PatternType");
        if (y === P8) {
          const b = s.base ? s.base.getRgb(i, 0) : null;
          return this.handleTilingType(e, b, o, E, p, t, r, h);
        }
        if (y === _8) {
          const b = p.get("Shading"), D = this.parseShading({ shading: b, resources: o, localColorSpaceCache: c, localShadingPatternCache: I });
          if (D) {
            const S = ks(p.getArray("Matrix"), null);
            t.addOp(e, ["Shading", D, S]);
          }
          return;
        }
        throw new Ct(`Unknown PatternType: ${y}`);
      }
    }
    throw new Ct(`Unknown PatternName: ${C}`);
  }
  _parseVisibilityExpression(t, e, i) {
    if (++e > 10) return void O("Visibility expression is too deeply nested");
    const s = t.length, n = this.xref.fetchIfRef(t[0]);
    if (!(s < 2) && n instanceof at) {
      switch (n.name) {
        case "And":
        case "Or":
        case "Not":
          i.push(n.name);
          break;
        default:
          return void O(`Invalid operator ${n.name} in visibility expression`);
      }
      for (let o = 1; o < s; o++) {
        const r = t[o], c = this.xref.fetchIfRef(r);
        if (Array.isArray(c)) {
          const h = [];
          i.push(h), this._parseVisibilityExpression(c, e, h);
        } else r instanceof St && i.push(r.toString());
      }
    } else O("Invalid visibility expression");
  }
  async parseMarkedContentProps(t, e) {
    let i;
    if (t instanceof at)
      i = e.get("Properties").get(t.name);
    else {
      if (!(t instanceof z)) throw new Ct("Optional content properties malformed.");
      i = t;
    }
    const s = i.get("Type")?.name;
    if (s === "OCG") return { type: s, id: i.objId };
    if (s === "OCMD") {
      const n = i.get("VE");
      if (Array.isArray(n)) {
        const r = [];
        if (this._parseVisibilityExpression(n, 0, r), r.length > 0) return { type: "OCMD", expression: r };
      }
      const o = i.get("OCGs");
      if (Array.isArray(o) || o instanceof z) {
        const r = [];
        if (Array.isArray(o)) for (const c of o) r.push(c.toString());
        else r.push(o.objId);
        return { type: s, ids: r, policy: i.get("P") instanceof at ? i.get("P").name : null, expression: null };
      }
      if (o instanceof St) return { type: s, id: o.toString() };
    }
    return null;
  }
  getOperatorList({ stream: t, task: e, resources: i, operatorList: s, initialState: n = null, fallbackFontDict: o = null }) {
    if (i ||= z.empty, n ||= new ME(), !s) throw new Error('getOperatorList: missing "operatorList" parameter');
    const r = this, c = this.xref;
    let h = !1;
    const I = new c1(), C = new FE(), d = new h1(), u = new b8(), E = /* @__PURE__ */ new Map(), p = i.get("XObject") || z.empty, y = i.get("Pattern") || z.empty, b = new ko(n), D = new Ns(t, c, b), S = new Ir();
    function R(x) {
      for (let N = 0, U = D.savedStatesDepth; N < U; N++) s.addOp(Te, []);
    }
    return new Promise((function x(N, U) {
      const T = function(H) {
        Promise.all([H, s.ready]).then((function() {
          try {
            x(N, U);
          } catch (W) {
            U(W);
          }
        }), U);
      };
      e.ensureNotTerminated(), S.reset();
      const q = {};
      let _, Y, ht, ut, j, it;
      for (; !(_ = S.check()) && (q.args = null, D.read(q)); ) {
        let H = q.args, W = q.fn;
        switch (0 | W) {
          case Rh:
            if (it = H[0] instanceof at, j = H[0].name, it) {
              const $ = I.getByName(j);
              if ($) {
                rh(s, $), H = null;
                continue;
              }
            }
            return void T(new Promise((function($, ot) {
              if (!it) throw new Ct("XObject must be referred to by name.");
              let V = p.getRaw(j);
              if (V instanceof St) {
                const Bt = I.getByRef(V) || r._regionalImageCache.getByRef(V);
                if (Bt) return rh(s, Bt), void $();
                const Rt = r.globalImageCache.getData(V, r.pageIndex);
                if (Rt) return s.addDependency(Rt.objId), s.addImageOps(Rt.fn, Rt.args, Rt.optionalContent), void $();
                V = c.fetch(V);
              }
              if (!(V instanceof AA)) throw new Ct("XObject should be a stream");
              const rt = V.dict.get("Subtype");
              if (!(rt instanceof at)) throw new Ct("XObject should have a Name subtype");
              if (rt.name === "Form") return b.save(), void r.buildFormXObject(i, V, null, s, e, b.state.clone(), C).then((function() {
                b.restore(), $();
              }), ot);
              if (rt.name !== "Image") {
                if (rt.name !== "PS") throw new Ct(`Unhandled XObject subtype ${rt.name}`);
                tA("Ignored XObject subtype PS"), $();
              } else r.buildPaintImageXObject({ resources: i, image: V, operatorList: s, cacheKey: j, localImageCache: I, localColorSpaceCache: C }).then($, ot);
            })).catch((function($) {
              if (!($ instanceof fe)) {
                if (!r.options.ignoreErrors) throw $;
                O(`getOperatorList - ignoring XObject: "${$}".`);
              }
            })));
          case xs:
            var tt = H[1];
            return void T(r.handleSetFont(i, H, null, s, e, b.state, o).then((function($) {
              s.addDependency($), s.addOp(xs, [$, tt]);
            })));
          case er:
            h = !0;
            break;
          case ir:
            h = !1;
            break;
          case vQ:
            var Z = H[0].cacheKey;
            if (Z) {
              const $ = I.getByName(Z);
              if ($) {
                rh(s, $), H = null;
                continue;
              }
            }
            return void T(r.buildPaintImageXObject({ resources: i, image: H[0], isInline: !0, operatorList: s, cacheKey: Z, localImageCache: I, localColorSpaceCache: C }));
          case Pi:
            if (!b.state.font) {
              r.ensureStateFont(b.state);
              continue;
            }
            H[0] = r.handleText(H[0], b.state);
            break;
          case Go:
            if (!b.state.font) {
              r.ensureStateFont(b.state);
              continue;
            }
            var st = [], dt = b.state;
            for (const $ of H[0]) typeof $ == "string" ? st.push(...r.handleText($, dt)) : typeof $ == "number" && st.push($);
            H[0] = st, W = Pi;
            break;
          case vo:
            if (!b.state.font) {
              r.ensureStateFont(b.state);
              continue;
            }
            s.addOp(Eo), H[0] = r.handleText(H[0], b.state), W = Pi;
            break;
          case Mo:
            if (!b.state.font) {
              r.ensureStateFont(b.state);
              continue;
            }
            s.addOp(Eo), s.addOp(Sh, [H.shift()]), s.addOp(kh, [H.shift()]), H[0] = r.handleText(H[0], b.state), W = Pi;
            break;
          case RQ:
            b.state.textRenderingMode = H[0];
            break;
          case Ig: {
            const $ = Vt.getCached(H[0], c, C);
            if ($) {
              b.state.fillColorSpace = $;
              continue;
            }
            return void T(r.parseColorSpace({ cs: H[0], resources: i, localColorSpaceCache: C }).then((function(ot) {
              b.state.fillColorSpace = ot || Vt.singletons.gray;
            })));
          }
          case dl: {
            const $ = Vt.getCached(H[0], c, C);
            if ($) {
              b.state.strokeColorSpace = $;
              continue;
            }
            return void T(r.parseColorSpace({ cs: H[0], resources: i, localColorSpaceCache: C }).then((function(ot) {
              b.state.strokeColorSpace = ot || Vt.singletons.gray;
            })));
          }
          case Cg:
            ut = b.state.fillColorSpace, H = ut.getRgb(H, 0), W = _i;
            break;
          case Ql:
            ut = b.state.strokeColorSpace, H = ut.getRgb(H, 0), W = ta;
            break;
          case yr:
            b.state.fillColorSpace = Vt.singletons.gray, H = Vt.singletons.gray.getRgb(H, 0), W = _i;
            break;
          case El:
            b.state.strokeColorSpace = Vt.singletons.gray, H = Vt.singletons.gray.getRgb(H, 0), W = ta;
            break;
          case wr:
            b.state.fillColorSpace = Vt.singletons.cmyk, H = Vt.singletons.cmyk.getRgb(H, 0), W = _i;
            break;
          case fl:
            b.state.strokeColorSpace = Vt.singletons.cmyk, H = Vt.singletons.cmyk.getRgb(H, 0), W = ta;
            break;
          case _i:
            b.state.fillColorSpace = Vt.singletons.rgb, H = Vt.singletons.rgb.getRgb(H, 0);
            break;
          case ta:
            b.state.strokeColorSpace = Vt.singletons.rgb, H = Vt.singletons.rgb.getRgb(H, 0);
            break;
          case Uo:
            if (ut = b.state.patternFillColorSpace, !ut) {
              H = [], W = Lm;
              break;
            }
            if (ut.name === "Pattern") return void T(r.handleColorN(s, Uo, H, ut, y, i, e, C, u, E));
            H = ut.getRgb(H, 0), W = _i;
            break;
          case Lo:
            if (ut = b.state.patternStrokeColorSpace, !ut) {
              H = [], W = Mm;
              break;
            }
            if (ut.name === "Pattern") return void T(r.handleColorN(s, Lo, H, ut, y, i, e, C, u, E));
            H = ut.getRgb(H, 0), W = ta;
            break;
          case Ho:
            var ct = i.get("Shading");
            if (!ct) throw new Ct("No shading resource found");
            var M = ct.get(H[0].name);
            if (!M) throw new Ct("No shading object found");
            const lt = r.parseShading({ shading: M, resources: i, localColorSpaceCache: C, localShadingPatternCache: E });
            if (!lt) continue;
            H = [lt], W = Ho;
            break;
          case Ma:
            if (it = H[0] instanceof at, j = H[0].name, it) {
              const $ = d.getByName(j);
              if ($) {
                $.length > 0 && s.addOp(Ma, [$]), H = null;
                continue;
              }
            }
            return void T(new Promise((function($, ot) {
              if (!it) throw new Ct("GState must be referred to by name.");
              const V = i.get("ExtGState");
              if (!(V instanceof z)) throw new Ct("ExtGState should be a dictionary.");
              const rt = V.get(j);
              if (!(rt instanceof z)) throw new Ct("GState should be a dictionary.");
              r.setGState({ resources: i, gState: rt, operatorList: s, cacheKey: j, task: e, stateManager: b, localGStateCache: d, localColorSpaceCache: C }).then($, ot);
            })).catch((function($) {
              if (!($ instanceof fe)) {
                if (!r.options.ignoreErrors) throw $;
                O(`getOperatorList - ignoring ExtGState: "${$}".`);
              }
            })));
          case On:
          case Bo:
          case wQ:
          case bQ:
          case DQ:
          case kQ:
          case Qo:
            r.buildPath(s, W, H, h);
            continue;
          case MQ:
          case LQ:
          case HQ:
          case JQ:
            continue;
          case wi:
            if (!(H[0] instanceof at)) {
              O(`Expected name for beginMarkedContentProps arg0=${H[0]}`), s.addOp(wi, ["OC", null]);
              continue;
            }
            if (H[0].name === "OC") return void T(r.parseMarkedContentProps(H[1], i).then((($) => {
              s.addOp(wi, ["OC", $]);
            })).catch((($) => {
              if (!($ instanceof fe)) {
                if (r.options.ignoreErrors) return O(`getOperatorList - ignoring beginMarkedContentProps: "${$}".`), void s.addOp(wi, ["OC", null]);
                throw $;
              }
            })));
            H = [H[0].name, H[1] instanceof z ? H[1].get("MCID") : null];
            break;
          default:
            if (H !== null) {
              for (Y = 0, ht = H.length; Y < ht && !(H[Y] instanceof z); Y++) ;
              if (Y < ht) {
                O("getOperatorList - ignoring operator: " + W);
                continue;
              }
            }
        }
        s.addOp(W, H);
      }
      _ ? T(m1) : (R(), N());
    })).catch(((x) => {
      if (!(x instanceof fe)) {
        if (this.options.ignoreErrors) return O(`getOperatorList - ignoring errors during "${e.name}" task: "${x}".`), void R();
        throw x;
      }
    }));
  }
  getTextContent({ stream: t, task: e, resources: i, stateManager: s = null, includeMarkedContent: n = !1, sink: o, seenStyles: r = /* @__PURE__ */ new Set(), viewBox: c, lang: h = null, markedContentData: I = null, disableNormalization: C = !1, keepWhiteSpace: d = !1 }) {
    i ||= z.empty, s ||= new ko(new O8()), n && (I ||= { level: 0 });
    const u = { items: [], styles: /* @__PURE__ */ Object.create(null), lang: h }, E = { initialized: !1, str: [], totalWidth: 0, totalHeight: 0, width: 0, height: 0, vertical: !1, prevTransform: null, textAdvanceScale: 0, spaceInFlowMin: 0, spaceInFlowMax: 0, trackingSpaceMin: 1 / 0, negativeSpaceMax: -1 / 0, notASpace: -1 / 0, transform: null, fontName: null, hasEOL: !1 }, p = [" ", " "];
    let y = 0;
    function b(ot) {
      const V = (y + 1) % 2, rt = p[y] !== " " && p[V] === " ";
      return p[y] = ot, y = V, !d && rt;
    }
    function D() {
      return !d && p[y] !== " " && p[(y + 1) % 2] === " ";
    }
    function S() {
      p[0] = p[1] = " ", y = 0;
    }
    const R = this, x = this.xref, N = [];
    let U = null;
    const T = new c1(), q = new h1(), _ = new Ns(t, x, s);
    let Y;
    function ht({ width: ot = 0, height: V = 0, transform: rt = E.prevTransform, fontName: Bt = E.fontName }) {
      u.items.push({ str: " ", dir: "ltr", width: ot, height: V, transform: rt, fontName: Bt, hasEOL: !1 });
    }
    function ut() {
      const ot = Y.font, V = [Y.fontSize * Y.textHScale, 0, 0, Y.fontSize, 0, Y.textRise];
      if (ot.isType3Font && (Y.fontSize <= 1 || ot.isCharBBox) && !ja(Y.fontMatrix, aa)) {
        const rt = ot.bbox[3] - ot.bbox[1];
        rt > 0 && (V[3] *= rt * Y.fontMatrix[3]);
      }
      return PA.transform(Y.ctm, PA.transform(Y.textMatrix, V));
    }
    function j() {
      if (E.initialized) return E;
      const { font: ot, loadedName: V } = Y;
      if (!r.has(V) && (r.add(V), u.styles[V] = { fontFamily: ot.fallbackName, ascent: ot.ascent, descent: ot.descent, vertical: ot.vertical }, R.options.fontExtraProperties && ot.systemFontInfo)) {
        const ft = u.styles[V];
        ft.fontSubstitution = ot.systemFontInfo.css, ft.fontSubstitutionLoadedName = ot.systemFontInfo.loadedName;
      }
      E.fontName = V;
      const rt = E.transform = ut();
      ot.vertical ? (E.width = E.totalWidth = Math.hypot(rt[0], rt[1]), E.height = E.totalHeight = 0, E.vertical = !0) : (E.width = E.totalWidth = 0, E.height = E.totalHeight = Math.hypot(rt[2], rt[3]), E.vertical = !1);
      const Bt = Math.hypot(Y.textLineMatrix[0], Y.textLineMatrix[1]), Rt = Math.hypot(Y.ctm[0], Y.ctm[1]);
      E.textAdvanceScale = Rt * Bt;
      const { fontSize: Ft } = Y;
      return E.trackingSpaceMin = 0.102 * Ft, E.notASpace = 0.03 * Ft, E.negativeSpaceMax = -0.2 * Ft, E.spaceInFlowMin = 0.102 * Ft, E.spaceInFlowMax = 0.6 * Ft, E.hasEOL = !1, E.initialized = !0, E;
    }
    function it() {
      if (!E.initialized) return;
      const ot = Math.hypot(Y.textLineMatrix[0], Y.textLineMatrix[1]), V = Math.hypot(Y.ctm[0], Y.ctm[1]) * ot;
      V !== E.textAdvanceScale && (E.vertical ? (E.totalHeight += E.height * E.textAdvanceScale, E.height = 0) : (E.totalWidth += E.width * E.textAdvanceScale, E.width = 0), E.textAdvanceScale = V);
    }
    function tt(ot) {
      let V = ot.str.join("");
      var rt;
      C || (rt = V, Kc || (Kc = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, mC = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), V = rt.replaceAll(Kc, ((Rt, Ft, ft) => Ft ? Ft.normalize("NFKC") : mC.get(ft))));
      const Bt = xE(V, -1, ot.vertical);
      return { str: Bt.str, dir: Bt.dir, width: Math.abs(ot.totalWidth), height: Math.abs(ot.totalHeight), transform: ot.transform, fontName: ot.fontName, hasEOL: ot.hasEOL };
    }
    async function Z(ot, V) {
      const rt = await R.loadFont(ot, V, i);
      if (rt.font.isType3Font) try {
        await rt.loadType3Data(R, i, e);
      } catch {
      }
      Y.loadedName = rt.loadedName, Y.font = rt.font, Y.fontMatrix = rt.font.fontMatrix || aa;
    }
    function st(ot, V, rt) {
      const Bt = Math.hypot(rt[0], rt[1]);
      return [(rt[0] * ot + rt[1] * V) / Bt, (rt[2] * ot + rt[3] * V) / Bt];
    }
    function dt(ot) {
      const V = ut();
      let rt = V[4], Bt = V[5];
      if (Y.font?.vertical) {
        if (rt < c[0] || rt > c[2] || Bt + ot < c[1] || Bt > c[3]) return !1;
      } else if (rt + ot < c[0] || rt > c[2] || Bt < c[1] || Bt > c[3]) return !1;
      if (!Y.font || !E.prevTransform) return !0;
      let Rt = E.prevTransform[4], Ft = E.prevTransform[5];
      if (Rt === rt && Ft === Bt) return !0;
      let ft = -1;
      switch (V[0] && V[1] === 0 && V[2] === 0 ? ft = V[0] > 0 ? 0 : 180 : V[1] && V[0] === 0 && V[3] === 0 && (ft = V[1] > 0 ? 90 : 270), ft) {
        case 0:
          break;
        case 90:
          [rt, Bt] = [Bt, rt], [Rt, Ft] = [Ft, Rt];
          break;
        case 180:
          [rt, Bt, Rt, Ft] = [-rt, -Bt, -Rt, -Ft];
          break;
        case 270:
          [rt, Bt] = [-Bt, -rt], [Rt, Ft] = [-Ft, -Rt];
          break;
        default:
          [rt, Bt] = st(rt, Bt, V), [Rt, Ft] = st(Rt, Ft, E.prevTransform);
      }
      if (Y.font.vertical) {
        const Ht = (Ft - Bt) / E.textAdvanceScale, Jt = rt - Rt, Gt = Math.sign(E.height);
        return Ht < Gt * E.negativeSpaceMax ? Math.abs(Jt) > 0.5 * E.width ? (M(), !0) : (S(), W(), !0) : Math.abs(Jt) > E.width ? (M(), !0) : (Ht <= Gt * E.notASpace && S(), Ht <= Gt * E.trackingSpaceMin ? D() ? (S(), W(), ht({ height: Math.abs(Ht) })) : E.height += Ht : H(Ht, E.prevTransform, Gt) || (E.str.length === 0 ? (S(), ht({ height: Math.abs(Ht) })) : E.height += Ht), Math.abs(Jt) > 0.25 * E.width && W(), !0);
      }
      const Kt = (rt - Rt) / E.textAdvanceScale, yt = Bt - Ft, vt = Math.sign(E.width);
      return Kt < vt * E.negativeSpaceMax ? Math.abs(yt) > 0.5 * E.height ? (M(), !0) : (S(), W(), !0) : Math.abs(yt) > E.height ? (M(), !0) : (Kt <= vt * E.notASpace && S(), Kt <= vt * E.trackingSpaceMin ? D() ? (S(), W(), ht({ width: Math.abs(Kt) })) : E.width += Kt : H(Kt, E.prevTransform, vt) || (E.str.length === 0 ? (S(), ht({ width: Math.abs(Kt) })) : E.width += Kt), Math.abs(yt) > 0.25 * E.height && W(), !0);
    }
    function ct({ chars: ot, extraSpacing: V }) {
      const rt = Y.font;
      if (!ot) {
        const Ft = Y.charSpacing + V;
        return Ft && (rt.vertical ? Y.translateTextMatrix(0, -Ft) : Y.translateTextMatrix(Ft * Y.textHScale, 0)), void (d && dt(0));
      }
      const Bt = rt.charsToGlyphs(ot), Rt = Y.fontMatrix[0] * Y.fontSize;
      for (let Ft = 0, ft = Bt.length; Ft < ft; Ft++) {
        const Kt = Bt[Ft], { category: yt } = Kt;
        if (yt.isInvisibleFormatMark) continue;
        let vt = Y.charSpacing + (Ft + 1 === ft ? V : 0), Ht = Kt.width;
        rt.vertical && (Ht = Kt.vmetric ? Kt.vmetric[0] : -Ht);
        let Jt = Ht * Rt;
        if (!d && yt.isWhitespace) {
          rt.vertical ? (vt += -Jt + Y.wordSpacing, Y.translateTextMatrix(0, -vt)) : (vt += Jt + Y.wordSpacing, Y.translateTextMatrix(vt * Y.textHScale, 0)), b(" ");
          continue;
        }
        if (!yt.isZeroWidthDiacritic && !dt(Jt)) {
          rt.vertical ? Y.translateTextMatrix(0, Jt) : Y.translateTextMatrix(Jt * Y.textHScale, 0);
          continue;
        }
        const Gt = j();
        yt.isZeroWidthDiacritic && (Jt = 0), rt.vertical ? (Y.translateTextMatrix(0, Jt), Jt = Math.abs(Jt), Gt.height += Jt) : (Jt *= Y.textHScale, Y.translateTextMatrix(Jt, 0), Gt.width += Jt), Jt && (Gt.prevTransform = ut());
        const Zt = Kt.unicode;
        b(Zt) && Gt.str.push(" "), Gt.str.push(Zt), vt && (rt.vertical ? Y.translateTextMatrix(0, -vt) : Y.translateTextMatrix(vt * Y.textHScale, 0));
      }
    }
    function M() {
      S(), E.initialized ? (E.hasEOL = !0, W()) : u.items.push({ str: "", dir: "ltr", width: 0, height: 0, transform: ut(), fontName: Y.loadedName, hasEOL: !0 });
    }
    function H(ot, V, rt) {
      if (rt * E.spaceInFlowMin <= ot && ot <= rt * E.spaceInFlowMax) return E.initialized && (S(), E.str.push(" ")), !1;
      const Bt = E.fontName;
      let Rt = 0;
      return E.vertical && (Rt = ot, ot = 0), W(), S(), ht({ width: Math.abs(ot), height: Math.abs(Rt), transform: V || ut(), fontName: Bt }), !0;
    }
    function W() {
      E.initialized && E.str && (E.vertical ? E.totalHeight += E.height * E.textAdvanceScale : E.totalWidth += E.width * E.textAdvanceScale, u.items.push(tt(E)), E.initialized = !1, E.str.length = 0);
    }
    function lt(ot = !1) {
      const V = u.items.length;
      V !== 0 && (ot && V < 10 || (o.enqueue(u, V), u.items = [], u.styles = /* @__PURE__ */ Object.create(null)));
    }
    const $ = new Ir();
    return new Promise((function ot(V, rt) {
      const Bt = function(Jt) {
        lt(!0), Promise.all([Jt, o.ready]).then((function() {
          try {
            ot(V, rt);
          } catch (Gt) {
            rt(Gt);
          }
        }), rt);
      };
      e.ensureNotTerminated(), $.reset();
      const Rt = {};
      let Ft, ft = [];
      for (; !(Ft = $.check()) && (ft.length = 0, Rt.args = ft, _.read(Rt)); ) {
        const Jt = Y;
        Y = s.state;
        const Gt = Rt.fn;
        switch (ft = Rt.args, 0 | Gt) {
          case xs:
            var Kt = ft[0].name, yt = ft[1];
            if (Y.font && Kt === Y.fontName && yt === Y.fontSize) break;
            return W(), Y.fontName = Kt, Y.fontSize = yt, void Bt(Z(Kt, null));
          case xQ:
            Y.textRise = ft[0];
            break;
          case SQ:
            Y.textHScale = ft[0] / 100;
            break;
          case FQ:
            Y.leading = ft[0];
            break;
          case NQ:
            Y.translateTextLineMatrix(ft[0], ft[1]), Y.textMatrix = Y.textLineMatrix.slice();
            break;
          case GQ:
            Y.leading = -ft[1], Y.translateTextLineMatrix(ft[0], ft[1]), Y.textMatrix = Y.textLineMatrix.slice();
            break;
          case Eo:
            Y.carriageReturn();
            break;
          case sr:
            Y.setTextMatrix(ft[0], ft[1], ft[2], ft[3], ft[4], ft[5]), Y.setTextLineMatrix(ft[0], ft[1], ft[2], ft[3], ft[4], ft[5]), it();
            break;
          case kh:
            Y.charSpacing = ft[0];
            break;
          case Sh:
            Y.wordSpacing = ft[0];
            break;
          case er:
            Y.textMatrix = Ci.slice(), Y.textLineMatrix = Ci.slice();
            break;
          case Go:
            if (!s.state.font) {
              R.ensureStateFont(s.state);
              continue;
            }
            const Zt = (Y.font.vertical ? 1 : -1) * Y.fontSize / 1e3, qt = ft[0];
            for (let Xt = 0, wA = qt.length; Xt < wA; Xt++) {
              const GA = qt[Xt];
              if (typeof GA == "string") N.push(GA);
              else if (typeof GA == "number" && GA !== 0) {
                const aA = N.join("");
                N.length = 0, ct({ chars: aA, extraSpacing: GA * Zt });
              }
            }
            if (N.length > 0) {
              const Xt = N.join("");
              N.length = 0, ct({ chars: Xt, extraSpacing: 0 });
            }
            break;
          case Pi:
            if (!s.state.font) {
              R.ensureStateFont(s.state);
              continue;
            }
            ct({ chars: ft[0], extraSpacing: 0 });
            break;
          case vo:
            if (!s.state.font) {
              R.ensureStateFont(s.state);
              continue;
            }
            Y.carriageReturn(), ct({ chars: ft[0], extraSpacing: 0 });
            break;
          case Mo:
            if (!s.state.font) {
              R.ensureStateFont(s.state);
              continue;
            }
            Y.wordSpacing = ft[0], Y.charSpacing = ft[1], Y.carriageReturn(), ct({ chars: ft[2], extraSpacing: 0 });
            break;
          case Rh:
            W(), U || (U = i.get("XObject") || z.empty);
            var vt = ft[0] instanceof at, Ht = ft[0].name;
            if (vt && T.getByName(Ht)) break;
            return void Bt(new Promise((function(Xt, wA) {
              if (!vt) throw new Ct("XObject must be referred to by name.");
              let GA = U.getRaw(Ht);
              if (GA instanceof St) {
                if (T.getByRef(GA) || R.globalImageCache.getData(GA, R.pageIndex)) return void Xt();
                GA = x.fetch(GA);
              }
              if (!(GA instanceof AA)) throw new Ct("XObject should be a stream");
              const aA = GA.dict.get("Subtype");
              if (!(aA instanceof at)) throw new Ct("XObject should have a Name subtype");
              if (aA.name !== "Form") return T.set(Ht, GA.dict.objId, !0), void Xt();
              const we = s.state.clone(), da = new ko(we), Qa = ks(GA.dict.getArray("Matrix"), null);
              Qa && da.transform(Qa), lt();
              const gn = { enqueueInvoked: !1, enqueue(Mi, Ea) {
                this.enqueueInvoked = !0, o.enqueue(Mi, Ea);
              }, get desiredSize() {
                return o.desiredSize;
              }, get ready() {
                return o.ready;
              } };
              R.getTextContent({ stream: GA, task: e, resources: GA.dict.get("Resources") || i, stateManager: da, includeMarkedContent: n, sink: gn, seenStyles: r, viewBox: c, lang: h, markedContentData: I, disableNormalization: C, keepWhiteSpace: d }).then((function() {
                gn.enqueueInvoked || T.set(Ht, GA.dict.objId, !0), Xt();
              }), wA);
            })).catch((function(Xt) {
              if (!(Xt instanceof fe)) {
                if (!R.options.ignoreErrors) throw Xt;
                O(`getTextContent - ignoring XObject: "${Xt}".`);
              }
            })));
          case Ma:
            if (vt = ft[0] instanceof at, Ht = ft[0].name, vt && q.getByName(Ht)) break;
            return void Bt(new Promise((function(Xt, wA) {
              if (!vt) throw new Ct("GState must be referred to by name.");
              const GA = i.get("ExtGState");
              if (!(GA instanceof z)) throw new Ct("ExtGState should be a dictionary.");
              const aA = GA.get(Ht);
              if (!(aA instanceof z)) throw new Ct("GState should be a dictionary.");
              const we = aA.get("Font");
              if (!we) return q.set(Ht, aA.objId, !0), void Xt();
              W(), Y.fontName = null, Y.fontSize = we[1], Z(null, we[0]).then(Xt, wA);
            })).catch((function(Xt) {
              if (!(Xt instanceof fe)) {
                if (!R.options.ignoreErrors) throw Xt;
                O(`getTextContent - ignoring ExtGState: "${Xt}".`);
              }
            })));
          case UQ:
            W(), n && (I.level++, u.items.push({ type: "beginMarkedContent", tag: ft[0] instanceof at ? ft[0].name : null }));
            break;
          case wi:
            if (W(), n) {
              I.level++;
              let Xt = null;
              ft[1] instanceof z && (Xt = ft[1].get("MCID")), u.items.push({ type: "beginMarkedContentProps", id: Number.isInteger(Xt) ? `${R.idFactory.getPageObjId()}_mc${Xt}` : null, tag: ft[0] instanceof at ? ft[0].name : null });
            }
            break;
          case Wa:
            if (W(), n) {
              if (I.level === 0) break;
              I.level--, u.items.push({ type: "endMarkedContent" });
            }
            break;
          case Te:
            !Jt || Jt.font === Y.font && Jt.fontSize === Y.fontSize && Jt.fontName === Y.fontName || W();
        }
        if (u.items.length >= o.desiredSize) {
          Ft = !0;
          break;
        }
      }
      Ft ? Bt(m1) : (W(), lt(), V());
    })).catch(((ot) => {
      if (!(ot instanceof fe)) {
        if (this.options.ignoreErrors) return O(`getTextContent - ignoring errors during "${e.name}" task: "${ot}".`), W(), void lt();
        throw ot;
      }
    }));
  }
  async extractDataStructures(t, e) {
    const i = this.xref;
    let s;
    const n = this.readToUnicode(e.toUnicode);
    if (e.composite) {
      const d = t.get("CIDSystemInfo");
      d instanceof z && (e.cidSystemInfo = { registry: cA(d.get("Registry")), ordering: cA(d.get("Ordering")), supplement: d.get("Supplement") });
      try {
        const u = t.get("CIDToGIDMap");
        u instanceof AA && (s = u.getBytes());
      } catch (u) {
        if (!this.options.ignoreErrors) throw u;
        O(`extractDataStructures - ignoring CIDToGIDMap data: "${u}".`);
      }
    }
    const o = [];
    let r, c = null;
    if (t.has("Encoding")) {
      if (r = t.get("Encoding"), r instanceof z) {
        if (c = r.get("BaseEncoding"), c = c instanceof at ? c.name : null, r.has("Differences")) {
          const d = r.get("Differences");
          let u = 0;
          for (const E of d) {
            const p = i.fetchIfRef(E);
            if (typeof p == "number") u = p;
            else {
              if (!(p instanceof at)) throw new Ct(`Invalid entry in 'Differences' array: ${p}`);
              o[u++] = p.name;
            }
          }
        }
      } else if (r instanceof at) c = r.name;
      else {
        const d = "Encoding is not a Name nor a Dict";
        if (!this.options.ignoreErrors) throw new Ct(d);
        O(d);
      }
      c !== "MacRomanEncoding" && c !== "MacExpertEncoding" && c !== "WinAnsiEncoding" && (c = null);
    }
    const h = !e.file || e.isInternalFont, I = Kh()[e.name];
    if (c && h && I && (c = null), c) e.defaultEncoding = rr(c);
    else {
      const d = !!(e.flags & Zo), u = !!(e.flags & TC);
      r = Vi, e.type !== "TrueType" || u || (r = nr), (d || I) && (r = kl, h && (/Symbol/i.test(e.name) ? r = Sl : /Dingbats/i.test(e.name) ? r = Fl : /Wingdings/i.test(e.name) && (r = nr))), e.defaultEncoding = r;
    }
    e.differences = o, e.baseEncodingName = c, e.hasEncoding = !!c || o.length > 0, e.dict = t, e.toUnicode = await n;
    const C = await this.buildToUnicode(e);
    return e.toUnicode = C, s && (e.cidToGidMap = this.readCidToGidMap(s, C)), e;
  }
  _simpleFontToUnicode(t, e = !1) {
    pe(!t.composite, "Must be a simple font.");
    const i = [], s = t.defaultEncoding.slice(), n = t.baseEncodingName, o = t.differences;
    for (const c in o) {
      const h = o[c];
      h !== ".notdef" && (s[c] = h);
    }
    const r = mi();
    for (const c in s) {
      let h = s[c];
      if (h === "") continue;
      let I = r[h];
      if (I !== void 0) {
        i[c] = String.fromCharCode(I);
        continue;
      }
      let C = 0;
      switch (h[0]) {
        case "G":
          h.length === 3 && (C = parseInt(h.substring(1), 16));
          break;
        case "g":
          h.length === 5 && (C = parseInt(h.substring(1), 16));
          break;
        case "C":
        case "c":
          if (h.length >= 3 && h.length <= 4) {
            const d = h.substring(1);
            if (e) {
              C = parseInt(d, 16);
              break;
            }
            if (C = +d, Number.isNaN(C) && Number.isInteger(parseInt(d, 16))) return this._simpleFontToUnicode(t, !0);
          }
          break;
        case "u":
          I = Va(h, r), I !== -1 && (C = I);
          break;
        default:
          switch (h) {
            case "f_h":
            case "f_t":
            case "T_h":
              i[c] = h.replaceAll("_", "");
              continue;
          }
      }
      if (C > 0 && C <= 1114111 && Number.isInteger(C)) {
        if (n && C === +c) {
          const d = rr(n);
          if (d && (h = d[c])) {
            i[c] = String.fromCharCode(r[h]);
            continue;
          }
        }
        i[c] = String.fromCodePoint(C);
      }
    }
    return i;
  }
  async buildToUnicode(t) {
    if (t.hasIncludedToUnicodeMap = t.toUnicode?.length > 0, t.hasIncludedToUnicodeMap) return !t.composite && t.hasEncoding && (t.fallbackToUnicode = this._simpleFontToUnicode(t)), t.toUnicode;
    if (!t.composite) return new Tn(this._simpleFontToUnicode(t));
    if (t.composite && (t.cMap.builtInCMap && !(t.cMap instanceof _a) || t.cidSystemInfo?.registry === "Adobe" && (t.cidSystemInfo.ordering === "GB1" || t.cidSystemInfo.ordering === "CNS1" || t.cidSystemInfo.ordering === "Japan1" || t.cidSystemInfo.ordering === "Korea1"))) {
      const { registry: e, ordering: i } = t.cidSystemInfo, s = at.get(`${e}-${i}-UCS2`), n = await eo.create({ encoding: s, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null }), o = [], r = [];
      return t.cMap.forEach((function(c, h) {
        if (h > 65535) throw new Ct("Max size of CID is 65,535");
        const I = n.lookup(h);
        if (I) {
          r.length = 0;
          for (let C = 0, d = I.length; C < d; C += 2) r.push((I.charCodeAt(C) << 8) + I.charCodeAt(C + 1));
          o[c] = String.fromCharCode(...r);
        }
      })), new Tn(o);
    }
    return new ti(t.firstChar, t.lastChar);
  }
  async readToUnicode(t) {
    if (!t) return null;
    if (t instanceof at) {
      const e = await eo.create({ encoding: t, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
      return e instanceof _a ? new ti(0, 65535) : new Tn(e.getMap());
    }
    if (t instanceof AA) try {
      const e = await eo.create({ encoding: t, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
      if (e instanceof _a) return new ti(0, 65535);
      const i = new Array(e.length);
      return e.forEach((function(s, n) {
        if (typeof n == "number") return void (i[s] = String.fromCodePoint(n));
        n.length % 2 != 0 && (n = "\0" + n);
        const o = [];
        for (let r = 0; r < n.length; r += 2) {
          const c = n.charCodeAt(r) << 8 | n.charCodeAt(r + 1);
          if ((63488 & c) != 55296) {
            o.push(c);
            continue;
          }
          r += 2;
          const h = n.charCodeAt(r) << 8 | n.charCodeAt(r + 1);
          o.push(((1023 & c) << 10) + (1023 & h) + 65536);
        }
        i[s] = String.fromCodePoint(...o);
      })), new Tn(i);
    } catch (e) {
      if (e instanceof fe) return null;
      if (this.options.ignoreErrors) return O(`readToUnicode - ignoring ToUnicode data: "${e}".`), null;
      throw e;
    }
    return null;
  }
  readCidToGidMap(t, e) {
    const i = [];
    for (let s = 0, n = t.length; s < n; s++) {
      const o = t[s++] << 8 | t[s], r = s >> 1;
      (o !== 0 || e.has(r)) && (i[r] = o);
    }
    return i;
  }
  extractWidths(t, e, i) {
    const s = this.xref;
    let n = [], o = 0;
    const r = [];
    let c;
    if (i.composite) {
      const C = t.get("DW");
      o = typeof C == "number" ? Math.ceil(C) : 1e3;
      const d = t.get("W");
      if (Array.isArray(d)) for (let u = 0, E = d.length; u < E; u++) {
        let p = s.fetchIfRef(d[u++]);
        if (!Number.isInteger(p)) break;
        const y = s.fetchIfRef(d[u]);
        if (Array.isArray(y)) for (const b of y) {
          const D = s.fetchIfRef(b);
          typeof D == "number" && (n[p] = D), p++;
        }
        else {
          if (!Number.isInteger(y)) break;
          {
            const b = s.fetchIfRef(d[++u]);
            if (typeof b != "number") continue;
            for (let D = p; D <= y; D++) n[D] = b;
          }
        }
      }
      if (i.vertical) {
        const u = t.getArray("DW2");
        let E = Pe(u, 2) ? u : [880, -1e3];
        if (c = [E[1], 0.5 * o, E[0]], E = t.get("W2"), Array.isArray(E)) for (let p = 0, y = E.length; p < y; p++) {
          let b = s.fetchIfRef(E[p++]);
          if (!Number.isInteger(b)) break;
          const D = s.fetchIfRef(E[p]);
          if (Array.isArray(D)) for (let S = 0, R = D.length; S < R; S++) {
            const x = [s.fetchIfRef(D[S++]), s.fetchIfRef(D[S++]), s.fetchIfRef(D[S])];
            Pe(x, null) && (r[b] = x), b++;
          }
          else {
            if (!Number.isInteger(D)) break;
            {
              const S = [s.fetchIfRef(E[++p]), s.fetchIfRef(E[++p]), s.fetchIfRef(E[++p])];
              if (!Pe(S, null)) continue;
              for (let R = b; R <= D; R++) r[R] = S;
            }
          }
        }
      }
    } else {
      const C = t.get("Widths");
      if (Array.isArray(C)) {
        let d = i.firstChar;
        for (const E of C) {
          const p = s.fetchIfRef(E);
          typeof p == "number" && (n[d] = p), d++;
        }
        const u = e.get("MissingWidth");
        o = typeof u == "number" ? u : 0;
      } else {
        const d = t.get("BaseFont");
        if (d instanceof at) {
          const u = this.getBaseFontMetrics(d.name);
          n = this.buildCharCodeToWidth(u.widths, i), o = u.defaultWidth;
        }
      }
    }
    let h = !0, I = o;
    for (const C in n) {
      const d = n[C];
      if (d) if (I) {
        if (I !== d) {
          h = !1;
          break;
        }
      } else I = d;
    }
    h ? i.flags |= bo : i.flags &= ~bo, i.defaultWidth = o, i.widths = n, i.defaultVMetrics = c, i.vmetrics = r;
  }
  isSerifFont(t) {
    const e = t.split("-", 1)[0];
    return e in Nl() || /serif/gi.test(e);
  }
  getBaseFontMetrics(t) {
    let e = 0, i = /* @__PURE__ */ Object.create(null), s = !1, n = dg()[t] || t;
    const o = E5();
    n in o || (n = this.isSerifFont(t) ? "Times-Roman" : "Helvetica");
    const r = o[n];
    return typeof r == "number" ? (e = r, s = !0) : i = r(), { defaultWidth: e, monospace: s, widths: i };
  }
  buildCharCodeToWidth(t, e) {
    const i = /* @__PURE__ */ Object.create(null), s = e.differences, n = e.defaultEncoding;
    for (let o = 0; o < 256; o++) o in s && t[s[o]] ? i[o] = t[s[o]] : o in n && t[n[o]] && (i[o] = t[n[o]]);
    return i;
  }
  preEvaluateFont(t) {
    const e = t;
    let i = t.get("Subtype");
    if (!(i instanceof at)) throw new Ct("invalid font Subtype");
    let s, n = !1;
    if (i.name === "Type0") {
      const I = t.get("DescendantFonts");
      if (!I) throw new Ct("Descendant fonts are not specified");
      if (!((t = Array.isArray(I) ? this.xref.fetchIfRef(I[0]) : I) instanceof z)) throw new Ct("Descendant font is not a dictionary.");
      if (i = t.get("Subtype"), !(i instanceof at)) throw new Ct("invalid font Subtype");
      n = !0;
    }
    let o = t.get("FirstChar");
    Number.isInteger(o) || (o = 0);
    let r = t.get("LastChar");
    Number.isInteger(r) || (r = n ? 65535 : 255);
    const c = t.get("FontDescriptor"), h = t.get("ToUnicode") || e.get("ToUnicode");
    if (c) {
      s = new T8();
      const I = e.getRaw("Encoding");
      if (I instanceof at) s.update(I.name);
      else if (I instanceof St) s.update(I.toString());
      else if (I instanceof z) {
        for (const d of I.getRawValues()) if (d instanceof at) s.update(d.name);
        else if (d instanceof St) s.update(d.toString());
        else if (Array.isArray(d)) {
          const u = d.length, E = new Array(u);
          for (let p = 0; p < u; p++) {
            const y = d[p];
            y instanceof at ? E[p] = y.name : (typeof y == "number" || y instanceof St) && (E[p] = y.toString());
          }
          s.update(E.join());
        }
      }
      if (s.update(`${o}-${r}`), h instanceof AA) {
        const d = h.str || h, u = d.buffer ? new Uint8Array(d.buffer.buffer, 0, d.bufferLength) : new Uint8Array(d.bytes.buffer, d.start, d.end - d.start);
        s.update(u);
      } else h instanceof at && s.update(h.name);
      const C = t.get("Widths") || e.get("Widths");
      if (Array.isArray(C)) {
        const d = [];
        for (const u of C) (typeof u == "number" || u instanceof St) && d.push(u.toString());
        s.update(d.join());
      }
      if (n) {
        s.update("compositeFont");
        const d = t.get("W") || e.get("W");
        if (Array.isArray(d)) {
          const E = [];
          for (const p of d) if (typeof p == "number" || p instanceof St) E.push(p.toString());
          else if (Array.isArray(p)) {
            const y = [];
            for (const b of p) (typeof b == "number" || b instanceof St) && y.push(b.toString());
            E.push(`[${y.join()}]`);
          }
          s.update(E.join());
        }
        const u = t.getRaw("CIDToGIDMap") || e.getRaw("CIDToGIDMap");
        u instanceof at ? s.update(u.name) : u instanceof St ? s.update(u.toString()) : u instanceof AA && s.update(u.peekBytes());
      }
    }
    return { descriptor: c, dict: t, baseDict: e, composite: n, type: i.name, firstChar: o, lastChar: r, toUnicode: h, hash: s ? s.hexdigest() : "" };
  }
  async translateFont({ descriptor: t, dict: e, baseDict: i, composite: s, type: n, firstChar: o, lastChar: r, toUnicode: c, cssFontInfo: h }) {
    const I = n === "Type3";
    if (!t) {
      if (!I) {
        let Z = e.get("BaseFont");
        if (!(Z instanceof at)) throw new Ct("Base font is not specified");
        Z = Z.name.replaceAll(/[,_]/g, "-");
        const st = this.getBaseFontMetrics(Z), dt = Z.split("-", 1)[0], ct = (this.isSerifFont(dt) ? BE : 0) | (st.monospace ? bo : 0) | (Kh()[dt] ? Zo : TC), M = { type: n, name: Z, loadedName: i.loadedName, systemFontInfo: null, widths: st.widths, defaultWidth: st.defaultWidth, isSimulatedFlags: !0, flags: ct, firstChar: o, lastChar: r, toUnicode: c, xHeight: 0, capHeight: 0, italicAngle: 0, isType3Font: I }, H = e.get("Widths"), W = PC(Z);
        let lt = null;
        W && (lt = await this.fetchStandardFontData(W), M.isInternalFont = !!lt), !M.isInternalFont && this.options.useSystemFonts && (M.systemFontInfo = E1(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, Z, W, n));
        const $ = await this.extractDataStructures(e, M);
        if (Array.isArray(H)) {
          const ot = [];
          let V = o;
          for (const rt of H) {
            const Bt = this.xref.fetchIfRef(rt);
            typeof Bt == "number" && (ot[V] = Bt), V++;
          }
          $.widths = ot;
        } else $.widths = this.buildCharCodeToWidth(st.widths, $);
        return new r1(Z, lt, $);
      }
      {
        const Z = Zi(e.getArray("FontBBox"), [0, 0, 0, 0]);
        (t = new z(null)).set("FontName", at.get(n)), t.set("FontBBox", Z);
      }
    }
    let C = t.get("FontName"), d = e.get("BaseFont");
    typeof C == "string" && (C = at.get(C)), typeof d == "string" && (d = at.get(d));
    const u = C?.name, E = d?.name;
    if (I || u === E || (tA(`The FontDescriptor's FontName is "${u}" but should be the same as the Font's BaseFont "${E}".`), u && E && (E.startsWith(u) || !_C(u) && _C(E)) && (C = null)), C ||= d, !(C instanceof at)) throw new Ct("invalid font name");
    let p, y, b, D, S;
    try {
      p = t.get("FontFile", "FontFile2", "FontFile3");
    } catch (Z) {
      if (!this.options.ignoreErrors) throw Z;
      O(`translateFont - fetching "${C.name}" font file: "${Z}".`), p = new Wo();
    }
    let R = !1, x = null, N = null;
    if (p) {
      if (p.dict) {
        const Z = p.dict.get("Subtype");
        Z instanceof at && (y = Z.name), b = p.dict.get("Length1"), D = p.dict.get("Length2"), S = p.dict.get("Length3");
      }
    } else if (h) {
      const Z = Ll(C.name);
      Z && (h.fontFamily = `${h.fontFamily}-PdfJS-XFA`, h.metrics = Z.metrics || null, x = Z.factors || null, p = await this.fetchStandardFontData(Z.name), R = !!p, i = e = SE(C.name), s = !0);
    } else if (!I) {
      const Z = PC(C.name);
      Z && (p = await this.fetchStandardFontData(Z), R = !!p), !R && this.options.useSystemFonts && (N = E1(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, C.name, Z, n));
    }
    const U = ks(e.getArray("FontMatrix"), aa), T = Zi(t.getArray("FontBBox") || e.getArray("FontBBox"), void 0);
    let q = t.get("Ascent");
    typeof q != "number" && (q = void 0);
    let _ = t.get("Descent");
    typeof _ != "number" && (_ = void 0);
    let Y = t.get("XHeight");
    typeof Y != "number" && (Y = 0);
    let ht = t.get("CapHeight");
    typeof ht != "number" && (ht = 0);
    let ut = t.get("Flags");
    Number.isInteger(ut) || (ut = 0);
    let j = t.get("ItalicAngle");
    typeof j != "number" && (j = 0);
    const it = { type: n, name: C.name, subtype: y, file: p, length1: b, length2: D, length3: S, isInternalFont: R, loadedName: i.loadedName, composite: s, fixedPitch: !1, fontMatrix: U, firstChar: o, lastChar: r, toUnicode: c, bbox: T, ascent: q, descent: _, xHeight: Y, capHeight: ht, flags: ut, italicAngle: j, isType3Font: I, cssFontInfo: h, scaleFactors: x, systemFontInfo: N };
    if (s) {
      const Z = i.get("Encoding");
      Z instanceof at && (it.cidEncoding = Z.name);
      const st = await eo.create({ encoding: Z, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
      it.cMap = st, it.vertical = it.cMap.vertical;
    }
    const tt = await this.extractDataStructures(e, it);
    return this.extractWidths(e, t, tt), new r1(C.name, p, tt);
  }
  static buildFontPaths(t, e, i, s) {
    function n(o) {
      const r = `${t.loadedName}_path_${o}`;
      try {
        if (t.renderer.hasBuiltPath(o)) return;
        i.send("commonobj", [r, "FontPath", t.renderer.getPathJs(o)]);
      } catch (c) {
        if (s.ignoreErrors) return void O(`buildFontPaths - ignoring ${r} glyph: "${c}".`);
        throw c;
      }
    }
    for (const o of e) {
      n(o.fontChar);
      const r = o.accent;
      r?.fontChar && n(r.fontChar);
    }
  }
  static get fallbackFontDict() {
    const t = new z();
    return t.set("BaseFont", at.get("Helvetica")), t.set("Type", at.get("FallbackType")), t.set("Subtype", at.get("FallbackType")), t.set("Encoding", at.get("WinAnsiEncoding")), bt(this, "fallbackFontDict", t);
  }
}
class no {
  constructor({ loadedName: t, font: e, dict: i, evaluatorOptions: s }) {
    this.loadedName = t, this.font = e, this.dict = i, this._evaluatorOptions = s || GE, this.type3Loaded = null, this.type3Dependencies = e.isType3Font ? /* @__PURE__ */ new Set() : null, this.sent = !1;
  }
  send(t) {
    this.sent || (this.sent = !0, t.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]));
  }
  fallback(t) {
    this.font.data && (this.font.disableFontFace = !0, Ri.buildFontPaths(this.font, this.font.glyphCacheValues, t, this._evaluatorOptions));
  }
  loadType3Data(t, e, i) {
    if (this.type3Loaded) return this.type3Loaded;
    if (!this.font.isType3Font) throw new Error("Must be a Type3 font.");
    const s = t.clone({ ignoreErrors: !1 }), n = new XA(t.type3FontRefs);
    this.dict.objId && !n.has(this.dict.objId) && n.put(this.dict.objId), s.type3FontRefs = n;
    const o = this.font, r = this.type3Dependencies;
    let c = Promise.resolve();
    const h = this.dict.get("CharProcs"), I = this.dict.get("Resources") || e, C = /* @__PURE__ */ Object.create(null), d = PA.normalizeRect(o.bbox || [0, 0, 0, 0]), u = d[2] - d[0], E = d[3] - d[1], p = Math.hypot(u, E);
    for (const y of h.getKeys()) c = c.then((() => {
      const b = h.get(y), D = new ue();
      return s.getOperatorList({ stream: b, task: i, resources: I, operatorList: D }).then((() => {
        D.fnArray[0] === Fh && this._removeType3ColorOperators(D, p), C[y] = D.getIR();
        for (const S of D.dependencies) r.add(S);
      })).catch((function(S) {
        O(`Type3 font resource "${y}" is not available.`);
        const R = new ue();
        C[y] = R.getIR();
      }));
    }));
    return this.type3Loaded = c.then((() => {
      o.charProcOperatorList = C, this._bbox && (o.isCharBBox = !0, o.bbox = this._bbox);
    })), this.type3Loaded;
  }
  _removeType3ColorOperators(t, e = NaN) {
    const i = PA.normalizeRect(t.argsArray[0].slice(2)), s = i[2] - i[0], n = i[3] - i[1], o = Math.hypot(s, n);
    s === 0 || n === 0 ? (t.fnArray.splice(0, 1), t.argsArray.splice(0, 1)) : (e === 0 || Math.round(o / e) >= 10) && (this._bbox || (this._bbox = [1 / 0, 1 / 0, -1 / 0, -1 / 0]), this._bbox[0] = Math.min(this._bbox[0], i[0]), this._bbox[1] = Math.min(this._bbox[1], i[1]), this._bbox[2] = Math.max(this._bbox[2], i[2]), this._bbox[3] = Math.max(this._bbox[3], i[3]));
    let r = 0, c = t.length;
    for (; r < c; ) {
      switch (t.fnArray[r]) {
        case Fh:
          break;
        case dl:
        case Ig:
        case Ql:
        case Lo:
        case Cg:
        case Uo:
        case El:
        case yr:
        case ta:
        case _i:
        case fl:
        case wr:
        case Ho:
        case yQ:
          t.fnArray.splice(r, 1), t.argsArray.splice(r, 1), c--;
          continue;
        case Ma:
          const [h] = t.argsArray[r];
          let I = 0, C = h.length;
          for (; I < C; ) {
            const [d] = h[I];
            switch (d) {
              case "TR":
              case "TR2":
              case "HT":
              case "BG":
              case "BG2":
              case "UCR":
              case "UCR2":
                h.splice(I, 1), C--;
                continue;
            }
            I++;
          }
      }
      r++;
    }
  }
}
class ko {
  constructor(t = new ME()) {
    this.state = t, this.stateStack = [];
  }
  save() {
    const t = this.state;
    this.stateStack.push(this.state), this.state = t.clone();
  }
  restore() {
    const t = this.stateStack.pop();
    t && (this.state = t);
  }
  transform(t) {
    this.state.ctm = PA.transform(this.state.ctm, t);
  }
}
class O8 {
  constructor() {
    this.ctm = new Float32Array(Ci), this.fontName = null, this.fontSize = 0, this.loadedName = null, this.font = null, this.fontMatrix = aa, this.textMatrix = Ci.slice(), this.textLineMatrix = Ci.slice(), this.charSpacing = 0, this.wordSpacing = 0, this.leading = 0, this.textHScale = 1, this.textRise = 0;
  }
  setTextMatrix(t, e, i, s, n, o) {
    const r = this.textMatrix;
    r[0] = t, r[1] = e, r[2] = i, r[3] = s, r[4] = n, r[5] = o;
  }
  setTextLineMatrix(t, e, i, s, n, o) {
    const r = this.textLineMatrix;
    r[0] = t, r[1] = e, r[2] = i, r[3] = s, r[4] = n, r[5] = o;
  }
  translateTextMatrix(t, e) {
    const i = this.textMatrix;
    i[4] = i[0] * t + i[2] * e + i[4], i[5] = i[1] * t + i[3] * e + i[5];
  }
  translateTextLineMatrix(t, e) {
    const i = this.textLineMatrix;
    i[4] = i[0] * t + i[2] * e + i[4], i[5] = i[1] * t + i[3] * e + i[5];
  }
  carriageReturn() {
    this.translateTextLineMatrix(0, -this.leading), this.textMatrix = this.textLineMatrix.slice();
  }
  clone() {
    const t = Object.create(this);
    return t.textMatrix = this.textMatrix.slice(), t.textLineMatrix = this.textLineMatrix.slice(), t.fontMatrix = this.fontMatrix.slice(), t;
  }
}
class ME {
  constructor() {
    this.ctm = new Float32Array(Ci), this.font = null, this.textRenderingMode = b9, this._fillColorSpace = Vt.singletons.gray, this._strokeColorSpace = Vt.singletons.gray, this.patternFillColorSpace = null, this.patternStrokeColorSpace = null;
  }
  get fillColorSpace() {
    return this._fillColorSpace;
  }
  set fillColorSpace(t) {
    this._fillColorSpace = this.patternFillColorSpace = t;
  }
  get strokeColorSpace() {
    return this._strokeColorSpace;
  }
  set strokeColorSpace(t) {
    this._strokeColorSpace = this.patternStrokeColorSpace = t;
  }
  clone() {
    return Object.create(this);
  }
}
class Ns {
  static get opMap() {
    return bt(this, "opMap", Object.assign(/* @__PURE__ */ Object.create(null), { w: { id: cm, numArgs: 1, variableArgs: !1 }, J: { id: hm, numArgs: 1, variableArgs: !1 }, j: { id: lm, numArgs: 1, variableArgs: !1 }, M: { id: Im, numArgs: 1, variableArgs: !1 }, d: { id: Cm, numArgs: 2, variableArgs: !1 }, ri: { id: yQ, numArgs: 1, variableArgs: !1 }, i: { id: um, numArgs: 1, variableArgs: !1 }, gs: { id: Ma, numArgs: 1, variableArgs: !1 }, q: { id: yi, numArgs: 0, variableArgs: !1 }, Q: { id: Te, numArgs: 0, variableArgs: !1 }, cm: { id: Qs, numArgs: 6, variableArgs: !1 }, m: { id: On, numArgs: 2, variableArgs: !1 }, l: { id: Bo, numArgs: 2, variableArgs: !1 }, c: { id: wQ, numArgs: 6, variableArgs: !1 }, v: { id: bQ, numArgs: 4, variableArgs: !1 }, y: { id: DQ, numArgs: 4, variableArgs: !1 }, h: { id: kQ, numArgs: 0, variableArgs: !1 }, re: { id: Qo, numArgs: 4, variableArgs: !1 }, S: { id: Bm, numArgs: 0, variableArgs: !1 }, s: { id: dm, numArgs: 0, variableArgs: !1 }, f: { id: QC, numArgs: 0, variableArgs: !1 }, F: { id: QC, numArgs: 0, variableArgs: !1 }, "f*": { id: Qm, numArgs: 0, variableArgs: !1 }, B: { id: Em, numArgs: 0, variableArgs: !1 }, "B*": { id: fm, numArgs: 0, variableArgs: !1 }, b: { id: pm, numArgs: 0, variableArgs: !1 }, "b*": { id: mm, numArgs: 0, variableArgs: !1 }, n: { id: EC, numArgs: 0, variableArgs: !1 }, W: { id: ym, numArgs: 0, variableArgs: !1 }, "W*": { id: wm, numArgs: 0, variableArgs: !1 }, BT: { id: er, numArgs: 0, variableArgs: !1 }, ET: { id: ir, numArgs: 0, variableArgs: !1 }, Tc: { id: kh, numArgs: 1, variableArgs: !1 }, Tw: { id: Sh, numArgs: 1, variableArgs: !1 }, Tz: { id: SQ, numArgs: 1, variableArgs: !1 }, TL: { id: FQ, numArgs: 1, variableArgs: !1 }, Tf: { id: xs, numArgs: 2, variableArgs: !1 }, Tr: { id: RQ, numArgs: 1, variableArgs: !1 }, Ts: { id: xQ, numArgs: 1, variableArgs: !1 }, Td: { id: NQ, numArgs: 2, variableArgs: !1 }, TD: { id: GQ, numArgs: 2, variableArgs: !1 }, Tm: { id: sr, numArgs: 6, variableArgs: !1 }, "T*": { id: Eo, numArgs: 0, variableArgs: !1 }, Tj: { id: Pi, numArgs: 1, variableArgs: !1 }, TJ: { id: Go, numArgs: 1, variableArgs: !1 }, "'": { id: vo, numArgs: 1, variableArgs: !1 }, '"': { id: Mo, numArgs: 3, variableArgs: !1 }, d0: { id: bm, numArgs: 2, variableArgs: !1 }, d1: { id: Fh, numArgs: 6, variableArgs: !1 }, CS: { id: dl, numArgs: 1, variableArgs: !1 }, cs: { id: Ig, numArgs: 1, variableArgs: !1 }, SC: { id: Ql, numArgs: 4, variableArgs: !0 }, SCN: { id: Lo, numArgs: 33, variableArgs: !0 }, sc: { id: Cg, numArgs: 4, variableArgs: !0 }, scn: { id: Uo, numArgs: 33, variableArgs: !0 }, G: { id: El, numArgs: 1, variableArgs: !1 }, g: { id: yr, numArgs: 1, variableArgs: !1 }, RG: { id: ta, numArgs: 3, variableArgs: !1 }, rg: { id: _i, numArgs: 3, variableArgs: !1 }, K: { id: fl, numArgs: 4, variableArgs: !1 }, k: { id: wr, numArgs: 4, variableArgs: !1 }, sh: { id: Ho, numArgs: 1, variableArgs: !1 }, BI: { id: Dm, numArgs: 0, variableArgs: !1 }, ID: { id: km, numArgs: 0, variableArgs: !1 }, EI: { id: vQ, numArgs: 1, variableArgs: !1 }, Do: { id: Rh, numArgs: 1, variableArgs: !1 }, MP: { id: MQ, numArgs: 1, variableArgs: !1 }, DP: { id: LQ, numArgs: 2, variableArgs: !1 }, BMC: { id: UQ, numArgs: 1, variableArgs: !1 }, BDC: { id: wi, numArgs: 2, variableArgs: !1 }, EMC: { id: Wa, numArgs: 0, variableArgs: !1 }, BX: { id: HQ, numArgs: 0, variableArgs: !1 }, EX: { id: JQ, numArgs: 0, variableArgs: !1 }, BM: null, BD: null, true: null, fa: null, fal: null, fals: null, false: null, nu: null, nul: null, null: null }));
  }
  static MAX_INVALID_PATH_OPS = 10;
  constructor(t, e, i = new ko()) {
    this.parser = new Es({ lexer: new hi(t, Ns.opMap), xref: e }), this.stateManager = i, this.nonProcessedArgs = [], this._isPathOp = !1, this._numInvalidPathOPS = 0;
  }
  get savedStatesDepth() {
    return this.stateManager.stateStack.length;
  }
  read(t) {
    let e = t.args;
    for (; ; ) {
      const i = this.parser.getObj();
      if (i instanceof KA) {
        const s = i.cmd, n = Ns.opMap[s];
        if (!n) {
          O(`Unknown command "${s}".`);
          continue;
        }
        const o = n.id, r = n.numArgs;
        let c = e !== null ? e.length : 0;
        if (this._isPathOp || (this._numInvalidPathOPS = 0), this._isPathOp = o >= On && o <= EC, n.variableArgs) c > r && tA(`Command ${s}: expected [0, ${r}] args, but received ${c} args.`);
        else {
          if (c !== r) {
            const h = this.nonProcessedArgs;
            for (; c > r; ) h.push(e.shift()), c--;
            for (; c < r && h.length !== 0; ) e === null && (e = []), e.unshift(h.pop()), c++;
          }
          if (c < r) {
            const h = `command ${s}: expected ${r} args, but received ${c} args.`;
            if (this._isPathOp && ++this._numInvalidPathOPS > Ns.MAX_INVALID_PATH_OPS) throw new Ct(`Invalid ${h}`);
            O(`Skipping ${h}`), e !== null && (e.length = 0);
            continue;
          }
        }
        return this.preprocessCommand(o, e), t.fn = o, t.args = e, !0;
      }
      if (i === Ae) return !1;
      if (i !== null && (e === null && (e = []), e.push(i), e.length > 33)) throw new Ct("Too many arguments");
    }
  }
  preprocessCommand(t, e) {
    switch (0 | t) {
      case yi:
        this.stateManager.save();
        break;
      case Te:
        this.stateManager.restore();
        break;
      case Qs:
        this.stateManager.transform(e);
    }
  }
}
class W8 extends Ns {
  constructor(t) {
    super(new _e(t));
  }
  parse() {
    const t = { fn: 0, args: [] }, e = { fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3) };
    try {
      for (; t.args.length = 0, this.read(t); ) {
        if (this.savedStatesDepth !== 0) continue;
        const { fn: i, args: s } = t;
        switch (0 | i) {
          case xs:
            const [n, o] = s;
            n instanceof at && (e.fontName = n.name), typeof o == "number" && o > 0 && (e.fontSize = o);
            break;
          case _i:
            Vt.singletons.rgb.getRgbItem(s, 0, e.fontColor, 0);
            break;
          case yr:
            Vt.singletons.gray.getRgbItem(s, 0, e.fontColor, 0);
            break;
          case wr:
            Vt.singletons.cmyk.getRgbItem(s, 0, e.fontColor, 0);
        }
      }
    } catch (i) {
      O(`parseDefaultAppearance - ignoring errors: "${i}".`);
    }
    return e;
  }
}
function Hl(A) {
  return new W8(A).parse();
}
class j8 extends Ns {
  constructor(t, e, i) {
    super(t), this.stream = t, this.evaluatorOptions = e, this.xref = i, this.resources = t.dict?.get("Resources");
  }
  parse() {
    const t = { fn: 0, args: [] };
    let e = { scaleFactor: 1, fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3), fillColorSpace: Vt.singletons.gray }, i = !1;
    const s = [];
    try {
      for (; t.args.length = 0, !i && this.read(t); ) {
        const { fn: n, args: o } = t;
        switch (0 | n) {
          case yi:
            s.push({ scaleFactor: e.scaleFactor, fontSize: e.fontSize, fontName: e.fontName, fontColor: e.fontColor.slice(), fillColorSpace: e.fillColorSpace });
            break;
          case Te:
            e = s.pop() || e;
            break;
          case sr:
            e.scaleFactor *= Math.hypot(o[0], o[1]);
            break;
          case xs:
            const [r, c] = o;
            r instanceof at && (e.fontName = r.name), typeof c == "number" && c > 0 && (e.fontSize = c * e.scaleFactor);
            break;
          case Ig:
            e.fillColorSpace = Vt.parse({ cs: o[0], xref: this.xref, resources: this.resources, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: this._localColorSpaceCache });
            break;
          case Cg:
            e.fillColorSpace.getRgbItem(o, 0, e.fontColor, 0);
            break;
          case _i:
            Vt.singletons.rgb.getRgbItem(o, 0, e.fontColor, 0);
            break;
          case yr:
            Vt.singletons.gray.getRgbItem(o, 0, e.fontColor, 0);
            break;
          case wr:
            Vt.singletons.cmyk.getRgbItem(o, 0, e.fontColor, 0);
            break;
          case Pi:
          case Go:
          case vo:
          case Mo:
            i = !0;
        }
      }
    } catch (n) {
      O(`parseAppearanceStream - ignoring errors: "${n}".`);
    }
    return this.stream.reset(), delete e.scaleFactor, delete e.fillColorSpace, e;
  }
  get _localColorSpaceCache() {
    return bt(this, "_localColorSpaceCache", new FE());
  }
  get _pdfFunctionFactory() {
    return bt(this, "_pdfFunctionFactory", new RE({ xref: this.xref, isEvalSupported: this.evaluatorOptions.isEvalSupported }));
  }
}
function Xi(A, t) {
  return A[0] === A[1] && A[1] === A[2] ? `${BA(A[0] / 255)} ${t ? "g" : "G"}` : Array.from(A, ((e) => BA(e / 255))).join(" ") + " " + (t ? "rg" : "RG");
}
class Di {
  constructor(t, e) {
    this.xref = t, this.widths = null, this.firstChar = 1 / 0, this.lastChar = -1 / 0, this.fontFamily = e;
    const i = new OffscreenCanvas(1, 1);
    this.ctxMeasure = i.getContext("2d", { willReadFrequently: !0 }), Di._fontNameId || (Di._fontNameId = 1), this.fontName = at.get(`InvalidPDFjsFont_${e}_${Di._fontNameId++}`);
  }
  get fontDescriptorRef() {
    if (!Di._fontDescriptorRef) {
      const t = new z(this.xref);
      t.set("Type", at.get("FontDescriptor")), t.set("FontName", this.fontName), t.set("FontFamily", "MyriadPro Regular"), t.set("FontBBox", [0, 0, 0, 0]), t.set("FontStretch", at.get("Normal")), t.set("FontWeight", 400), t.set("ItalicAngle", 0), Di._fontDescriptorRef = this.xref.getNewPersistentRef(t);
    }
    return Di._fontDescriptorRef;
  }
  get descendantFontRef() {
    const t = new z(this.xref);
    t.set("BaseFont", this.fontName), t.set("Type", at.get("Font")), t.set("Subtype", at.get("CIDFontType0")), t.set("CIDToGIDMap", at.get("Identity")), t.set("FirstChar", this.firstChar), t.set("LastChar", this.lastChar), t.set("FontDescriptor", this.fontDescriptorRef), t.set("DW", 1e3);
    const e = [], i = [...this.widths.entries()].sort();
    let s = null, n = null;
    for (const [r, c] of i) s ? r === s + n.length ? n.push(c) : (e.push(s, n), s = r, n = [c]) : (s = r, n = [c]);
    s && e.push(s, n), t.set("W", e);
    const o = new z(this.xref);
    return o.set("Ordering", "Identity"), o.set("Registry", "Adobe"), o.set("Supplement", 0), t.set("CIDSystemInfo", o), this.xref.getNewPersistentRef(t);
  }
  get baseFontRef() {
    const t = new z(this.xref);
    return t.set("BaseFont", this.fontName), t.set("Type", at.get("Font")), t.set("Subtype", at.get("Type0")), t.set("Encoding", at.get("Identity-H")), t.set("DescendantFonts", [this.descendantFontRef]), t.set("ToUnicode", at.get("Identity-H")), this.xref.getNewPersistentRef(t);
  }
  get resources() {
    const t = new z(this.xref), e = new z(this.xref);
    return e.set(this.fontName.name, this.baseFontRef), t.set("Font", e), t;
  }
  _createContext() {
    return this.widths = /* @__PURE__ */ new Map(), this.ctxMeasure.font = `1000px ${this.fontFamily}`, this.ctxMeasure;
  }
  createFontResources(t) {
    const e = this._createContext();
    for (const i of t.split(/\r\n?|\n/)) for (const s of i.split("")) {
      const n = s.charCodeAt(0);
      if (this.widths.has(n)) continue;
      const o = e.measureText(s), r = Math.ceil(o.width);
      this.widths.set(n, r), this.firstChar = Math.min(n, this.firstChar), this.lastChar = Math.max(n, this.lastChar);
    }
    return this.resources;
  }
  static getFirstPositionInfo(t, e, i) {
    const [s, n, o, r] = t;
    let c = o - s, h = r - n;
    e % 180 != 0 && ([c, h] = [h, c]);
    const I = na * i;
    return { coords: [0, h + aC * i - I], bbox: [0, 0, c, h], matrix: e !== 0 ? Oo(e, h, I) : void 0 };
  }
  createAppearance(t, e, i, s, n, o) {
    const r = this._createContext(), c = [];
    let h = -1 / 0;
    for (const ht of t.split(/\r\n?|\n/)) {
      c.push(ht);
      const ut = r.measureText(ht).width;
      h = Math.max(h, ut);
      for (const j of jm(ht)) {
        const it = String.fromCodePoint(j);
        let tt = this.widths.get(j);
        if (tt === void 0) {
          const Z = r.measureText(it);
          tt = Math.ceil(Z.width), this.widths.set(j, tt), this.firstChar = Math.min(j, this.firstChar), this.lastChar = Math.max(j, this.lastChar);
        }
      }
    }
    h *= s / 1e3;
    const [I, C, d, u] = e;
    let E = d - I, p = u - C;
    i % 180 != 0 && ([E, p] = [p, E]);
    let y = 1;
    h > E && (y = E / h);
    let b = 1;
    const D = na * s, S = aC * s, R = D * c.length;
    R > p && (b = p / R);
    const x = s * Math.min(y, b), N = ["q", `0 0 ${BA(E)} ${BA(p)} re W n`, "BT", `1 0 0 1 0 ${BA(p + S)} Tm 0 Tc ${Xi(n, !0)}`, `/${this.fontName.name} ${BA(x)} Tf`], { resources: U } = this;
    if ((o = typeof o == "number" && o >= 0 && o <= 1 ? o : 1) !== 1) {
      N.push("/R0 gs");
      const ht = new z(this.xref), ut = new z(this.xref);
      ut.set("ca", o), ut.set("CA", o), ut.set("Type", at.get("ExtGState")), ht.set("R0", ut), U.set("ExtGState", ht);
    }
    const T = BA(D);
    for (const ht of c) N.push(`0 -${T} Td <${Vm(ht)}> Tj`);
    N.push("ET", "Q");
    const q = N.join(`
`), _ = new z(this.xref);
    if (_.set("Subtype", at.get("Form")), _.set("Type", at.get("XObject")), _.set("BBox", [0, 0, E, p]), _.set("Length", q.length), _.set("Resources", U), i) {
      const ht = Oo(i, E, p);
      _.set("Matrix", ht);
    }
    const Y = new _e(q);
    return Y.dict = _, Y;
  }
}
class LE {
  constructor(t, e, i) {
    this.root = t, this.xref = e, this._type = i;
  }
  getAll() {
    const t = /* @__PURE__ */ new Map();
    if (!this.root) return t;
    const e = this.xref, i = new XA();
    i.put(this.root);
    const s = [this.root];
    for (; s.length > 0; ) {
      const n = e.fetchIfRef(s.shift());
      if (!(n instanceof z)) continue;
      if (n.has("Kids")) {
        const r = n.get("Kids");
        if (!Array.isArray(r)) continue;
        for (const c of r) {
          if (i.has(c)) throw new Ct(`Duplicate entry in "${this._type}" tree.`);
          s.push(c), i.put(c);
        }
        continue;
      }
      const o = n.get(this._type);
      if (Array.isArray(o)) for (let r = 0, c = o.length; r < c; r += 2) t.set(e.fetchIfRef(o[r]), e.fetchIfRef(o[r + 1]));
    }
    return t;
  }
  get(t) {
    if (!this.root) return null;
    const e = this.xref;
    let i = e.fetchIfRef(this.root), s = 0;
    for (; i.has("Kids"); ) {
      if (++s > 10) return O(`Search depth limit reached for "${this._type}" tree.`), null;
      const o = i.get("Kids");
      if (!Array.isArray(o)) return null;
      let r = 0, c = o.length - 1;
      for (; r <= c; ) {
        const h = r + c >> 1, I = e.fetchIfRef(o[h]), C = I.get("Limits");
        if (t < e.fetchIfRef(C[0])) c = h - 1;
        else {
          if (!(t > e.fetchIfRef(C[1]))) {
            i = I;
            break;
          }
          r = h + 1;
        }
      }
      if (r > c) return null;
    }
    const n = i.get(this._type);
    if (Array.isArray(n)) {
      let o = 0, r = n.length - 2;
      for (; o <= r; ) {
        const c = o + r >> 1, h = c + (1 & c), I = e.fetchIfRef(n[h]);
        if (t < I) r = h - 2;
        else {
          if (!(t > I)) return e.fetchIfRef(n[h + 1]);
          o = h + 2;
        }
      }
    }
    return null;
  }
}
class Fa extends LE {
  constructor(t, e) {
    super(t, e, "Names");
  }
}
class Jl extends LE {
  constructor(t, e) {
    super(t, e, "Nums");
  }
}
function Yl() {
  kE = /* @__PURE__ */ Object.create(null), ZQ = /* @__PURE__ */ Object.create(null), VQ = /* @__PURE__ */ Object.create(null), fo = /* @__PURE__ */ Object.create(null), Th.clear(), bl.cleanup();
}
function y1(A) {
  return A instanceof z ? A.has("UF") ? A.get("UF") : A.has("F") ? A.get("F") : A.has("Unix") ? A.get("Unix") : A.has("Mac") ? A.get("Mac") : A.has("DOS") ? A.get("DOS") : null : null;
}
class Wh {
  #t = !1;
  constructor(t, e, i = !1) {
    t instanceof z && (this.xref = e, this.root = t, t.has("FS") && (this.fs = t.get("FS")), t.has("RF") && O("Related file specifications are not supported"), i || (t.has("EF") ? this.#t = !0 : O("Non-embedded file specifications are not supported")));
  }
  get filename() {
    let t = "";
    const e = y1(this.root);
    return e && typeof e == "string" && (t = cA(e).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/")), bt(this, "filename", t || "unnamed");
  }
  get content() {
    if (!this.#t) return null;
    this._contentRef ||= y1(this.root?.get("EF"));
    let t = null;
    if (this._contentRef) {
      const e = this.xref.fetchIfRef(this._contentRef);
      e instanceof AA ? t = e.getBytes() : O("Embedded file specification points to non-existing/invalid content");
    } else O("Embedded file specification does not have any content");
    return t;
  }
  get description() {
    let t = "";
    const e = this.root?.get("Desc");
    return e && typeof e == "string" && (t = cA(e)), bt(this, "description", t);
  }
  get serializable() {
    return { rawFilename: this.filename, filename: (t = this.filename, t.substring(t.lastIndexOf("/") + 1)), content: this.content, description: this.description };
    var t;
  }
}
const Vn = 0, Z8 = -2, V8 = -3, w1 = -4, X8 = -5, b1 = -6, D1 = -9;
function Na(A, t) {
  const e = A[t];
  return e === " " || e === `
` || e === "\r" || e === "	";
}
class UE {
  _resolveEntities(t) {
    return t.replaceAll(/&([^;]+);/g, ((e, i) => {
      if (i.substring(0, 2) === "#x") return String.fromCodePoint(parseInt(i.substring(2), 16));
      if (i.substring(0, 1) === "#") return String.fromCodePoint(parseInt(i.substring(1), 10));
      switch (i) {
        case "lt":
          return "<";
        case "gt":
          return ">";
        case "amp":
          return "&";
        case "quot":
          return '"';
        case "apos":
          return "'";
      }
      return this.onResolveEntity(i);
    }));
  }
  _parseContent(t, e) {
    const i = [];
    let s = e;
    function n() {
      for (; s < t.length && Na(t, s); ) ++s;
    }
    for (; s < t.length && !Na(t, s) && t[s] !== ">" && t[s] !== "/"; ) ++s;
    const o = t.substring(e, s);
    for (n(); s < t.length && t[s] !== ">" && t[s] !== "/" && t[s] !== "?"; ) {
      n();
      let r = "", c = "";
      for (; s < t.length && !Na(t, s) && t[s] !== "="; ) r += t[s], ++s;
      if (n(), t[s] !== "=") return null;
      ++s, n();
      const h = t[s];
      if (h !== '"' && h !== "'") return null;
      const I = t.indexOf(h, ++s);
      if (I < 0) return null;
      c = t.substring(s, I), i.push({ name: r, value: this._resolveEntities(c) }), s = I + 1, n();
    }
    return { name: o, attributes: i, parsed: s - e };
  }
  _parseProcessingInstruction(t, e) {
    let i = e;
    for (; i < t.length && !Na(t, i) && t[i] !== ">" && t[i] !== "?" && t[i] !== "/"; ) ++i;
    const s = t.substring(e, i);
    (function() {
      for (; i < t.length && Na(t, i); ) ++i;
    })();
    const n = i;
    for (; i < t.length && (t[i] !== "?" || t[i + 1] !== ">"); ) ++i;
    return { name: s, value: t.substring(n, i), parsed: i - e };
  }
  parseXml(t) {
    let e = 0;
    for (; e < t.length; ) {
      let i = e;
      if (t[e] === "<") {
        ++i;
        let s;
        switch (t[i]) {
          case "/":
            if (++i, s = t.indexOf(">", i), s < 0) return void this.onError(D1);
            this.onEndElement(t.substring(i, s)), i = s + 1;
            break;
          case "?":
            ++i;
            const n = this._parseProcessingInstruction(t, i);
            if (t.substring(i + n.parsed, i + n.parsed + 2) !== "?>") return void this.onError(V8);
            this.onPi(n.name, n.value), i += n.parsed + 2;
            break;
          case "!":
            if (t.substring(i + 1, i + 3) === "--") {
              if (s = t.indexOf("-->", i + 3), s < 0) return void this.onError(X8);
              this.onComment(t.substring(i + 3, s)), i = s + 3;
            } else if (t.substring(i + 1, i + 8) === "[CDATA[") {
              if (s = t.indexOf("]]>", i + 8), s < 0) return void this.onError(Z8);
              this.onCdata(t.substring(i + 8, s)), i = s + 3;
            } else {
              if (t.substring(i + 1, i + 8) !== "DOCTYPE") return void this.onError(b1);
              {
                const c = t.indexOf("[", i + 8);
                let h = !1;
                if (s = t.indexOf(">", i + 8), s < 0) return void this.onError(w1);
                if (c > 0 && s > c) {
                  if (s = t.indexOf("]>", i + 8), s < 0) return void this.onError(w1);
                  h = !0;
                }
                const I = t.substring(i + 8, s + (h ? 1 : 0));
                this.onDoctype(I), i = s + (h ? 2 : 1);
              }
            }
            break;
          default:
            const o = this._parseContent(t, i);
            if (o === null) return void this.onError(b1);
            let r = !1;
            if (t.substring(i + o.parsed, i + o.parsed + 2) === "/>") r = !0;
            else if (t.substring(i + o.parsed, i + o.parsed + 1) !== ">") return void this.onError(D1);
            this.onBeginElement(o.name, o.attributes, r), i += o.parsed + (r ? 2 : 1);
        }
      } else {
        for (; i < t.length && t[i] !== "<"; ) i++;
        const s = t.substring(e, i);
        this.onText(this._resolveEntities(s));
      }
      e = i;
    }
  }
  onResolveEntity(t) {
    return `&${t};`;
  }
  onPi(t, e) {
  }
  onComment(t) {
  }
  onCdata(t) {
  }
  onDoctype(t) {
  }
  onText(t) {
  }
  onBeginElement(t, e, i) {
  }
  onEndElement(t) {
  }
  onError(t) {
  }
}
class Xn {
  constructor(t, e) {
    this.nodeName = t, this.nodeValue = e, Object.defineProperty(this, "parentNode", { value: null, writable: !0 });
  }
  get firstChild() {
    return this.childNodes?.[0];
  }
  get nextSibling() {
    const t = this.parentNode.childNodes;
    if (!t) return;
    const e = t.indexOf(this);
    return e !== -1 ? t[e + 1] : void 0;
  }
  get textContent() {
    return this.childNodes ? this.childNodes.map((function(t) {
      return t.textContent;
    })).join("") : this.nodeValue || "";
  }
  get children() {
    return this.childNodes || [];
  }
  hasChildNodes() {
    return this.childNodes?.length > 0;
  }
  searchNode(t, e) {
    if (e >= t.length) return this;
    const i = t[e];
    if (i.name.startsWith("#") && e < t.length - 1) return this.searchNode(t, e + 1);
    const s = [];
    let n = this;
    for (; ; ) {
      if (i.name === n.nodeName) {
        if (i.pos !== 0) {
          if (s.length === 0) return null;
          {
            const [o] = s.pop();
            let r = 0;
            for (const c of o.childNodes) if (i.name === c.nodeName) {
              if (r === i.pos) return c.searchNode(t, e + 1);
              r++;
            }
            return n.searchNode(t, e + 1);
          }
        }
        {
          const o = n.searchNode(t, e + 1);
          if (o !== null) return o;
        }
      }
      if (n.childNodes?.length > 0) s.push([n, 0]), n = n.childNodes[0];
      else {
        if (s.length === 0) return null;
        for (; s.length !== 0; ) {
          const [o, r] = s.pop(), c = r + 1;
          if (c < o.childNodes.length) {
            s.push([o, c]), n = o.childNodes[c];
            break;
          }
        }
        if (s.length === 0) return null;
      }
    }
  }
  dump(t) {
    if (this.nodeName !== "#text") {
      if (t.push(`<${this.nodeName}`), this.attributes) for (const e of this.attributes) t.push(` ${e.name}="${Pa(e.value)}"`);
      if (this.hasChildNodes()) {
        t.push(">");
        for (const e of this.childNodes) e.dump(t);
        t.push(`</${this.nodeName}>`);
      } else this.nodeValue ? t.push(`>${Pa(this.nodeValue)}</${this.nodeName}>`) : t.push("/>");
    } else t.push(Pa(this.nodeValue));
  }
}
class Qg extends UE {
  constructor({ hasAttributes: t = !1, lowerCaseName: e = !1 }) {
    super(), this._currentFragment = null, this._stack = null, this._errorCode = Vn, this._hasAttributes = t, this._lowerCaseName = e;
  }
  parseFromString(t) {
    if (this._currentFragment = [], this._stack = [], this._errorCode = Vn, this.parseXml(t), this._errorCode !== Vn) return;
    const [e] = this._currentFragment;
    return e ? { documentElement: e } : void 0;
  }
  onText(t) {
    if ((function(i) {
      for (let s = 0, n = i.length; s < n; s++) if (!Na(i, s)) return !1;
      return !0;
    })(t)) return;
    const e = new Xn("#text", t);
    this._currentFragment.push(e);
  }
  onCdata(t) {
    const e = new Xn("#text", t);
    this._currentFragment.push(e);
  }
  onBeginElement(t, e, i) {
    this._lowerCaseName && (t = t.toLowerCase());
    const s = new Xn(t);
    s.childNodes = [], this._hasAttributes && (s.attributes = e), this._currentFragment.push(s), i || (this._stack.push(this._currentFragment), this._currentFragment = s.childNodes);
  }
  onEndElement(t) {
    this._currentFragment = this._stack.pop() || [];
    const e = this._currentFragment.at(-1);
    if (!e) return null;
    for (const i of e.childNodes) i.parentNode = e;
    return e;
  }
  onError(t) {
    this._errorCode = t;
  }
}
class z8 {
  constructor(t) {
    t = this._repair(t);
    const e = new Qg({ lowerCaseName: !0 }).parseFromString(t);
    this._metadataMap = /* @__PURE__ */ new Map(), this._data = t, e && this._parse(e);
  }
  _repair(t) {
    return t.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, (function(e, i) {
      const s = i.replaceAll(/\\([0-3])([0-7])([0-7])/g, (function(o, r, c, h) {
        return String.fromCharCode(64 * r + 8 * c + 1 * h);
      })).replaceAll(/&(amp|apos|gt|lt|quot);/g, (function(o, r) {
        switch (r) {
          case "amp":
            return "&";
          case "apos":
            return "'";
          case "gt":
            return ">";
          case "lt":
            return "<";
          case "quot":
            return '"';
        }
        throw new Error(`_repair: ${r} isn't defined.`);
      })), n = [">"];
      for (let o = 0, r = s.length; o < r; o += 2) {
        const c = 256 * s.charCodeAt(o) + s.charCodeAt(o + 1);
        c >= 32 && c < 127 && c !== 60 && c !== 62 && c !== 38 ? n.push(String.fromCharCode(c)) : n.push("&#x" + (65536 + c).toString(16).substring(1) + ";");
      }
      return n.join("");
    }));
  }
  _getSequence(t) {
    const e = t.nodeName;
    return e !== "rdf:bag" && e !== "rdf:seq" && e !== "rdf:alt" ? null : t.childNodes.filter(((i) => i.nodeName === "rdf:li"));
  }
  _parseArray(t) {
    if (!t.hasChildNodes()) return;
    const [e] = t.childNodes, i = this._getSequence(e) || [];
    this._metadataMap.set(t.nodeName, i.map(((s) => s.textContent.trim())));
  }
  _parse(t) {
    let e = t.documentElement;
    if (e.nodeName !== "rdf:rdf") for (e = e.firstChild; e && e.nodeName !== "rdf:rdf"; ) e = e.nextSibling;
    if (e && e.nodeName === "rdf:rdf" && e.hasChildNodes()) {
      for (const i of e.childNodes) if (i.nodeName === "rdf:description") for (const s of i.childNodes) {
        const n = s.nodeName;
        switch (n) {
          case "#text":
            continue;
          case "dc:creator":
          case "dc:subject":
            this._parseArray(s);
            continue;
        }
        this._metadataMap.set(n, s.textContent.trim());
      }
    }
  }
  get serializable() {
    return { parsedData: this._metadataMap, rawData: this._data };
  }
}
class $8 extends Be {
  constructor(t, e, i) {
    super(e), this.str = t, this.dict = t.dict, this.decrypt = i, this.nextChunk = null, this.initialized = !1;
  }
  readBlock() {
    let t;
    if (this.initialized ? t = this.nextChunk : (t = this.str.getBytes(512), this.initialized = !0), !t || t.length === 0) return void (this.eof = !0);
    this.nextChunk = this.str.getBytes(512);
    const e = this.nextChunk?.length > 0;
    t = (0, this.decrypt)(t, !e);
    const i = this.bufferLength, s = i + t.length;
    this.ensureBuffer(s).set(t, i), this.bufferLength = s;
  }
}
class Zs {
  constructor(t) {
    this.a = 0, this.b = 0;
    const e = new Uint8Array(256), i = t.length;
    for (let s = 0; s < 256; ++s) e[s] = s;
    for (let s = 0, n = 0; s < 256; ++s) {
      const o = e[s];
      n = n + o + t[s % i] & 255, e[s] = e[n], e[n] = o;
    }
    this.s = e;
  }
  encryptBlock(t) {
    let e = this.a, i = this.b;
    const s = this.s, n = t.length, o = new Uint8Array(n);
    for (let r = 0; r < n; ++r) {
      e = e + 1 & 255;
      const c = s[e];
      i = i + c & 255;
      const h = s[i];
      s[e] = h, s[i] = c, o[r] = t[r] ^ s[c + h & 255];
    }
    return this.a = e, this.b = i, o;
  }
  decryptBlock(t) {
    return this.encryptBlock(t);
  }
  encrypt(t) {
    return this.encryptBlock(t);
  }
}
const ps = (function() {
  const A = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]), t = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
  return function(e, i, s) {
    let n = 1732584193, o = -271733879, r = -1732584194, c = 271733878;
    const h = s + 72 & -64, I = new Uint8Array(h);
    let C, d;
    for (C = 0; C < s; ++C) I[C] = e[i++];
    I[C++] = 128;
    const u = h - 8;
    for (; C < u; ) I[C++] = 0;
    I[C++] = s << 3 & 255, I[C++] = s >> 5 & 255, I[C++] = s >> 13 & 255, I[C++] = s >> 21 & 255, I[C++] = s >>> 29 & 255, I[C++] = 0, I[C++] = 0, I[C++] = 0;
    const E = new Int32Array(16);
    for (C = 0; C < h; ) {
      for (d = 0; d < 16; ++d, C += 4) E[d] = I[C] | I[C + 1] << 8 | I[C + 2] << 16 | I[C + 3] << 24;
      let p, y, b = n, D = o, S = r, R = c;
      for (d = 0; d < 64; ++d) {
        d < 16 ? (p = D & S | ~D & R, y = d) : d < 32 ? (p = R & D | ~R & S, y = 5 * d + 1 & 15) : d < 48 ? (p = D ^ S ^ R, y = 3 * d + 5 & 15) : (p = S ^ (D | ~R), y = 7 * d & 15);
        const x = R, N = b + p + t[d] + E[y] | 0, U = A[d];
        R = S, S = D, D = D + (N << U | N >>> 32 - U) | 0, b = x;
      }
      n = n + b | 0, o = o + D | 0, r = r + S | 0, c = c + R | 0;
    }
    return new Uint8Array([255 & n, n >> 8 & 255, n >> 16 & 255, n >>> 24 & 255, 255 & o, o >> 8 & 255, o >> 16 & 255, o >>> 24 & 255, 255 & r, r >> 8 & 255, r >> 16 & 255, r >>> 24 & 255, 255 & c, c >> 8 & 255, c >> 16 & 255, c >>> 24 & 255]);
  };
})();
class Dt {
  constructor(t, e) {
    this.high = 0 | t, this.low = 0 | e;
  }
  and(t) {
    this.high &= t.high, this.low &= t.low;
  }
  xor(t) {
    this.high ^= t.high, this.low ^= t.low;
  }
  or(t) {
    this.high |= t.high, this.low |= t.low;
  }
  shiftRight(t) {
    t >= 32 ? (this.low = this.high >>> t - 32 | 0, this.high = 0) : (this.low = this.low >>> t | this.high << 32 - t, this.high = this.high >>> t | 0);
  }
  shiftLeft(t) {
    t >= 32 ? (this.high = this.low << t - 32, this.low = 0) : (this.high = this.high << t | this.low >>> 32 - t, this.low <<= t);
  }
  rotateRight(t) {
    let e, i;
    32 & t ? (i = this.low, e = this.high) : (e = this.low, i = this.high), t &= 31, this.low = e >>> t | i << 32 - t, this.high = i >>> t | e << 32 - t;
  }
  not() {
    this.high = ~this.high, this.low = ~this.low;
  }
  add(t) {
    const e = (this.low >>> 0) + (t.low >>> 0);
    let i = (this.high >>> 0) + (t.high >>> 0);
    e > 4294967295 && (i += 1), this.low = 0 | e, this.high = 0 | i;
  }
  copyTo(t, e) {
    t[e] = this.high >>> 24 & 255, t[e + 1] = this.high >> 16 & 255, t[e + 2] = this.high >> 8 & 255, t[e + 3] = 255 & this.high, t[e + 4] = this.low >>> 24 & 255, t[e + 5] = this.low >> 16 & 255, t[e + 6] = this.low >> 8 & 255, t[e + 7] = 255 & this.low;
  }
  assign(t) {
    this.high = t.high, this.low = t.low;
  }
}
const Ha = /* @__PURE__ */ (function() {
  function A(r, c) {
    return r >>> c | r << 32 - c;
  }
  function t(r, c, h) {
    return r & c ^ ~r & h;
  }
  function e(r, c, h) {
    return r & c ^ r & h ^ c & h;
  }
  function i(r) {
    return A(r, 2) ^ A(r, 13) ^ A(r, 22);
  }
  function s(r) {
    return A(r, 6) ^ A(r, 11) ^ A(r, 25);
  }
  function n(r) {
    return A(r, 7) ^ A(r, 18) ^ r >>> 3;
  }
  const o = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  return function(r, c, h) {
    let I = 1779033703, C = 3144134277, d = 1013904242, u = 2773480762, E = 1359893119, p = 2600822924, y = 528734635, b = 1541459225;
    const D = 64 * Math.ceil((h + 9) / 64), S = new Uint8Array(D);
    let R, x;
    for (R = 0; R < h; ++R) S[R] = r[c++];
    S[R++] = 128;
    const N = D - 8;
    for (; R < N; ) S[R++] = 0;
    S[R++] = 0, S[R++] = 0, S[R++] = 0, S[R++] = h >>> 29 & 255, S[R++] = h >> 21 & 255, S[R++] = h >> 13 & 255, S[R++] = h >> 5 & 255, S[R++] = h << 3 & 255;
    const U = new Uint32Array(64);
    for (R = 0; R < D; ) {
      for (x = 0; x < 16; ++x) U[x] = S[R] << 24 | S[R + 1] << 16 | S[R + 2] << 8 | S[R + 3], R += 4;
      for (x = 16; x < 64; ++x) U[x] = 0 | (A(T = U[x - 2], 17) ^ A(T, 19) ^ T >>> 10) + U[x - 7] + n(U[x - 15]) + U[x - 16];
      let q, _, Y = I, ht = C, ut = d, j = u, it = E, tt = p, Z = y, st = b;
      for (x = 0; x < 64; ++x) q = st + s(it) + t(it, tt, Z) + o[x] + U[x], _ = i(Y) + e(Y, ht, ut), st = Z, Z = tt, tt = it, it = j + q | 0, j = ut, ut = ht, ht = Y, Y = q + _ | 0;
      I = I + Y | 0, C = C + ht | 0, d = d + ut | 0, u = u + j | 0, E = E + it | 0, p = p + tt | 0, y = y + Z | 0, b = b + st | 0;
    }
    var T;
    return new Uint8Array([I >> 24 & 255, I >> 16 & 255, I >> 8 & 255, 255 & I, C >> 24 & 255, C >> 16 & 255, C >> 8 & 255, 255 & C, d >> 24 & 255, d >> 16 & 255, d >> 8 & 255, 255 & d, u >> 24 & 255, u >> 16 & 255, u >> 8 & 255, 255 & u, E >> 24 & 255, E >> 16 & 255, E >> 8 & 255, 255 & E, p >> 24 & 255, p >> 16 & 255, p >> 8 & 255, 255 & p, y >> 24 & 255, y >> 16 & 255, y >> 8 & 255, 255 & y, b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, 255 & b]);
  };
})(), k1 = (function() {
  function A(r, c, h, I, C) {
    r.assign(c), r.and(h), C.assign(c), C.not(), C.and(I), r.xor(C);
  }
  function t(r, c, h, I, C) {
    r.assign(c), r.and(h), C.assign(c), C.and(I), r.xor(C), C.assign(h), C.and(I), r.xor(C);
  }
  function e(r, c, h) {
    r.assign(c), r.rotateRight(28), h.assign(c), h.rotateRight(34), r.xor(h), h.assign(c), h.rotateRight(39), r.xor(h);
  }
  function i(r, c, h) {
    r.assign(c), r.rotateRight(14), h.assign(c), h.rotateRight(18), r.xor(h), h.assign(c), h.rotateRight(41), r.xor(h);
  }
  function s(r, c, h) {
    r.assign(c), r.rotateRight(1), h.assign(c), h.rotateRight(8), r.xor(h), h.assign(c), h.shiftRight(7), r.xor(h);
  }
  function n(r, c, h) {
    r.assign(c), r.rotateRight(19), h.assign(c), h.rotateRight(61), r.xor(h), h.assign(c), h.shiftRight(6), r.xor(h);
  }
  const o = [new Dt(1116352408, 3609767458), new Dt(1899447441, 602891725), new Dt(3049323471, 3964484399), new Dt(3921009573, 2173295548), new Dt(961987163, 4081628472), new Dt(1508970993, 3053834265), new Dt(2453635748, 2937671579), new Dt(2870763221, 3664609560), new Dt(3624381080, 2734883394), new Dt(310598401, 1164996542), new Dt(607225278, 1323610764), new Dt(1426881987, 3590304994), new Dt(1925078388, 4068182383), new Dt(2162078206, 991336113), new Dt(2614888103, 633803317), new Dt(3248222580, 3479774868), new Dt(3835390401, 2666613458), new Dt(4022224774, 944711139), new Dt(264347078, 2341262773), new Dt(604807628, 2007800933), new Dt(770255983, 1495990901), new Dt(1249150122, 1856431235), new Dt(1555081692, 3175218132), new Dt(1996064986, 2198950837), new Dt(2554220882, 3999719339), new Dt(2821834349, 766784016), new Dt(2952996808, 2566594879), new Dt(3210313671, 3203337956), new Dt(3336571891, 1034457026), new Dt(3584528711, 2466948901), new Dt(113926993, 3758326383), new Dt(338241895, 168717936), new Dt(666307205, 1188179964), new Dt(773529912, 1546045734), new Dt(1294757372, 1522805485), new Dt(1396182291, 2643833823), new Dt(1695183700, 2343527390), new Dt(1986661051, 1014477480), new Dt(2177026350, 1206759142), new Dt(2456956037, 344077627), new Dt(2730485921, 1290863460), new Dt(2820302411, 3158454273), new Dt(3259730800, 3505952657), new Dt(3345764771, 106217008), new Dt(3516065817, 3606008344), new Dt(3600352804, 1432725776), new Dt(4094571909, 1467031594), new Dt(275423344, 851169720), new Dt(430227734, 3100823752), new Dt(506948616, 1363258195), new Dt(659060556, 3750685593), new Dt(883997877, 3785050280), new Dt(958139571, 3318307427), new Dt(1322822218, 3812723403), new Dt(1537002063, 2003034995), new Dt(1747873779, 3602036899), new Dt(1955562222, 1575990012), new Dt(2024104815, 1125592928), new Dt(2227730452, 2716904306), new Dt(2361852424, 442776044), new Dt(2428436474, 593698344), new Dt(2756734187, 3733110249), new Dt(3204031479, 2999351573), new Dt(3329325298, 3815920427), new Dt(3391569614, 3928383900), new Dt(3515267271, 566280711), new Dt(3940187606, 3454069534), new Dt(4118630271, 4000239992), new Dt(116418474, 1914138554), new Dt(174292421, 2731055270), new Dt(289380356, 3203993006), new Dt(460393269, 320620315), new Dt(685471733, 587496836), new Dt(852142971, 1086792851), new Dt(1017036298, 365543100), new Dt(1126000580, 2618297676), new Dt(1288033470, 3409855158), new Dt(1501505948, 4234509866), new Dt(1607167915, 987167468), new Dt(1816402316, 1246189591)];
  return function(r, c, h, I = !1) {
    let C, d, u, E, p, y, b, D;
    I ? (C = new Dt(3418070365, 3238371032), d = new Dt(1654270250, 914150663), u = new Dt(2438529370, 812702999), E = new Dt(355462360, 4144912697), p = new Dt(1731405415, 4290775857), y = new Dt(2394180231, 1750603025), b = new Dt(3675008525, 1694076839), D = new Dt(1203062813, 3204075428)) : (C = new Dt(1779033703, 4089235720), d = new Dt(3144134277, 2227873595), u = new Dt(1013904242, 4271175723), E = new Dt(2773480762, 1595750129), p = new Dt(1359893119, 2917565137), y = new Dt(2600822924, 725511199), b = new Dt(528734635, 4215389547), D = new Dt(1541459225, 327033209));
    const S = 128 * Math.ceil((h + 17) / 128), R = new Uint8Array(S);
    let x, N;
    for (x = 0; x < h; ++x) R[x] = r[c++];
    R[x++] = 128;
    const U = S - 16;
    for (; x < U; ) R[x++] = 0;
    R[x++] = 0, R[x++] = 0, R[x++] = 0, R[x++] = 0, R[x++] = 0, R[x++] = 0, R[x++] = 0, R[x++] = 0, R[x++] = 0, R[x++] = 0, R[x++] = 0, R[x++] = h >>> 29 & 255, R[x++] = h >> 21 & 255, R[x++] = h >> 13 & 255, R[x++] = h >> 5 & 255, R[x++] = h << 3 & 255;
    const T = new Array(80);
    for (x = 0; x < 80; x++) T[x] = new Dt(0, 0);
    let q = new Dt(0, 0), _ = new Dt(0, 0), Y = new Dt(0, 0), ht = new Dt(0, 0), ut = new Dt(0, 0), j = new Dt(0, 0), it = new Dt(0, 0), tt = new Dt(0, 0);
    const Z = new Dt(0, 0), st = new Dt(0, 0), dt = new Dt(0, 0), ct = new Dt(0, 0);
    let M, H;
    for (x = 0; x < S; ) {
      for (N = 0; N < 16; ++N) T[N].high = R[x] << 24 | R[x + 1] << 16 | R[x + 2] << 8 | R[x + 3], T[N].low = R[x + 4] << 24 | R[x + 5] << 16 | R[x + 6] << 8 | R[x + 7], x += 8;
      for (N = 16; N < 80; ++N) M = T[N], n(M, T[N - 2], ct), M.add(T[N - 7]), s(dt, T[N - 15], ct), M.add(dt), M.add(T[N - 16]);
      for (q.assign(C), _.assign(d), Y.assign(u), ht.assign(E), ut.assign(p), j.assign(y), it.assign(b), tt.assign(D), N = 0; N < 80; ++N) Z.assign(tt), i(dt, ut, ct), Z.add(dt), A(dt, ut, j, it, ct), Z.add(dt), Z.add(o[N]), Z.add(T[N]), e(st, q, ct), t(dt, q, _, Y, ct), st.add(dt), M = tt, tt = it, it = j, j = ut, ht.add(Z), ut = ht, ht = Y, Y = _, _ = q, M.assign(Z), M.add(st), q = M;
      C.add(q), d.add(_), u.add(Y), E.add(ht), p.add(ut), y.add(j), b.add(it), D.add(tt);
    }
    return I ? (H = new Uint8Array(48), C.copyTo(H, 0), d.copyTo(H, 8), u.copyTo(H, 16), E.copyTo(H, 24), p.copyTo(H, 32), y.copyTo(H, 40)) : (H = new Uint8Array(64), C.copyTo(H, 0), d.copyTo(H, 8), u.copyTo(H, 16), E.copyTo(H, 24), p.copyTo(H, 32), y.copyTo(H, 40), b.copyTo(H, 48), D.copyTo(H, 56)), H;
  };
})();
class ty {
  decryptBlock(t) {
    return t;
  }
  encrypt(t) {
    return t;
  }
}
class Tl {
  constructor() {
    this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]), this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]), this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]), this._mixCol = new Uint8Array(256);
    for (let t = 0; t < 256; t++) this._mixCol[t] = t < 128 ? t << 1 : t << 1 ^ 27;
    this.buffer = new Uint8Array(16), this.bufferPosition = 0;
  }
  _expandKey(t) {
    oA("Cannot call `_expandKey` on the base class");
  }
  _decrypt(t, e) {
    let i, s, n;
    const o = new Uint8Array(16);
    o.set(t);
    for (let r = 0, c = this._keySize; r < 16; ++r, ++c) o[r] ^= e[c];
    for (let r = this._cyclesOfRepetition - 1; r >= 1; --r) {
      i = o[13], o[13] = o[9], o[9] = o[5], o[5] = o[1], o[1] = i, i = o[14], s = o[10], o[14] = o[6], o[10] = o[2], o[6] = i, o[2] = s, i = o[15], s = o[11], n = o[7], o[15] = o[3], o[11] = i, o[7] = s, o[3] = n;
      for (let c = 0; c < 16; ++c) o[c] = this._inv_s[o[c]];
      for (let c = 0, h = 16 * r; c < 16; ++c, ++h) o[c] ^= e[h];
      for (let c = 0; c < 16; c += 4) {
        const h = this._mix[o[c]], I = this._mix[o[c + 1]], C = this._mix[o[c + 2]], d = this._mix[o[c + 3]];
        i = h ^ I >>> 8 ^ I << 24 ^ C >>> 16 ^ C << 16 ^ d >>> 24 ^ d << 8, o[c] = i >>> 24 & 255, o[c + 1] = i >> 16 & 255, o[c + 2] = i >> 8 & 255, o[c + 3] = 255 & i;
      }
    }
    i = o[13], o[13] = o[9], o[9] = o[5], o[5] = o[1], o[1] = i, i = o[14], s = o[10], o[14] = o[6], o[10] = o[2], o[6] = i, o[2] = s, i = o[15], s = o[11], n = o[7], o[15] = o[3], o[11] = i, o[7] = s, o[3] = n;
    for (let r = 0; r < 16; ++r) o[r] = this._inv_s[o[r]], o[r] ^= e[r];
    return o;
  }
  _encrypt(t, e) {
    const i = this._s;
    let s, n, o;
    const r = new Uint8Array(16);
    r.set(t);
    for (let c = 0; c < 16; ++c) r[c] ^= e[c];
    for (let c = 1; c < this._cyclesOfRepetition; c++) {
      for (let h = 0; h < 16; ++h) r[h] = i[r[h]];
      o = r[1], r[1] = r[5], r[5] = r[9], r[9] = r[13], r[13] = o, o = r[2], n = r[6], r[2] = r[10], r[6] = r[14], r[10] = o, r[14] = n, o = r[3], n = r[7], s = r[11], r[3] = r[15], r[7] = o, r[11] = n, r[15] = s;
      for (let h = 0; h < 16; h += 4) {
        const I = r[h + 0], C = r[h + 1], d = r[h + 2], u = r[h + 3];
        s = I ^ C ^ d ^ u, r[h + 0] ^= s ^ this._mixCol[I ^ C], r[h + 1] ^= s ^ this._mixCol[C ^ d], r[h + 2] ^= s ^ this._mixCol[d ^ u], r[h + 3] ^= s ^ this._mixCol[u ^ I];
      }
      for (let h = 0, I = 16 * c; h < 16; ++h, ++I) r[h] ^= e[I];
    }
    for (let c = 0; c < 16; ++c) r[c] = i[r[c]];
    o = r[1], r[1] = r[5], r[5] = r[9], r[9] = r[13], r[13] = o, o = r[2], n = r[6], r[2] = r[10], r[6] = r[14], r[10] = o, r[14] = n, o = r[3], n = r[7], s = r[11], r[3] = r[15], r[7] = o, r[11] = n, r[15] = s;
    for (let c = 0, h = this._keySize; c < 16; ++c, ++h) r[c] ^= e[h];
    return r;
  }
  _decryptBlock2(t, e) {
    const i = t.length;
    let s = this.buffer, n = this.bufferPosition;
    const o = [];
    let r = this.iv;
    for (let I = 0; I < i; ++I) {
      if (s[n] = t[I], ++n, n < 16) continue;
      const C = this._decrypt(s, this._key);
      for (let d = 0; d < 16; ++d) C[d] ^= r[d];
      r = s, o.push(C), s = new Uint8Array(16), n = 0;
    }
    if (this.buffer = s, this.bufferLength = n, this.iv = r, o.length === 0) return new Uint8Array(0);
    let c = 16 * o.length;
    if (e) {
      const I = o.at(-1);
      let C = I[15];
      if (C <= 16) {
        for (let d = 15, u = 16 - C; d >= u; --d) if (I[d] !== C) {
          C = 0;
          break;
        }
        c -= C, o[o.length - 1] = I.subarray(0, 16 - C);
      }
    }
    const h = new Uint8Array(c);
    for (let I = 0, C = 0, d = o.length; I < d; ++I, C += 16) h.set(o[I], C);
    return h;
  }
  decryptBlock(t, e, i = null) {
    const s = t.length, n = this.buffer;
    let o = this.bufferPosition;
    if (i) this.iv = i;
    else {
      for (let r = 0; o < 16 && r < s; ++r, ++o) n[o] = t[r];
      if (o < 16) return this.bufferLength = o, new Uint8Array(0);
      this.iv = n, t = t.subarray(16);
    }
    return this.buffer = new Uint8Array(16), this.bufferLength = 0, this.decryptBlock = this._decryptBlock2, this.decryptBlock(t, e);
  }
  encrypt(t, e) {
    const i = t.length;
    let s = this.buffer, n = this.bufferPosition;
    const o = [];
    e || (e = new Uint8Array(16));
    for (let h = 0; h < i; ++h) {
      if (s[n] = t[h], ++n, n < 16) continue;
      for (let C = 0; C < 16; ++C) s[C] ^= e[C];
      const I = this._encrypt(s, this._key);
      e = I, o.push(I), s = new Uint8Array(16), n = 0;
    }
    if (this.buffer = s, this.bufferLength = n, this.iv = e, o.length === 0) return new Uint8Array(0);
    const r = 16 * o.length, c = new Uint8Array(r);
    for (let h = 0, I = 0, C = o.length; h < C; ++h, I += 16) c.set(o[h], I);
    return c;
  }
}
class HE extends Tl {
  constructor(t) {
    super(), this._cyclesOfRepetition = 10, this._keySize = 160, this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]), this._key = this._expandKey(t);
  }
  _expandKey(t) {
    const e = this._s, i = this._rcon, s = new Uint8Array(176);
    s.set(t);
    for (let n = 16, o = 1; n < 176; ++o) {
      let r = s[n - 3], c = s[n - 2], h = s[n - 1], I = s[n - 4];
      r = e[r], c = e[c], h = e[h], I = e[I], r ^= i[o];
      for (let C = 0; C < 4; ++C) s[n] = r ^= s[n - 16], n++, s[n] = c ^= s[n - 16], n++, s[n] = h ^= s[n - 16], n++, s[n] = I ^= s[n - 16], n++;
    }
    return s;
  }
}
class Cr extends Tl {
  constructor(t) {
    super(), this._cyclesOfRepetition = 14, this._keySize = 224, this._key = this._expandKey(t);
  }
  _expandKey(t) {
    const e = this._s, i = new Uint8Array(240);
    i.set(t);
    let s, n, o, r, c = 1;
    for (let h = 32, I = 1; h < 240; ++I) {
      h % 32 == 16 ? (s = e[s], n = e[n], o = e[o], r = e[r]) : h % 32 == 0 && (s = i[h - 3], n = i[h - 2], o = i[h - 1], r = i[h - 4], s = e[s], n = e[n], o = e[o], r = e[r], s ^= c, (c <<= 1) >= 256 && (c = 255 & (27 ^ c)));
      for (let C = 0; C < 4; ++C) i[h] = s ^= i[h - 32], h++, i[h] = n ^= i[h - 32], h++, i[h] = o ^= i[h - 32], h++, i[h] = r ^= i[h - 32], h++;
    }
    return i;
  }
}
class Ay {
  checkOwnerPassword(t, e, i, s) {
    const n = new Uint8Array(t.length + 56);
    return n.set(t, 0), n.set(e, t.length), n.set(i, t.length + e.length), ja(Ha(n, 0, n.length), s);
  }
  checkUserPassword(t, e, i) {
    const s = new Uint8Array(t.length + 8);
    return s.set(t, 0), s.set(e, t.length), ja(Ha(s, 0, s.length), i);
  }
  getOwnerKey(t, e, i, s) {
    const n = new Uint8Array(t.length + 56);
    n.set(t, 0), n.set(e, t.length), n.set(i, t.length + e.length);
    const o = Ha(n, 0, n.length);
    return new Cr(o).decryptBlock(s, !1, new Uint8Array(16));
  }
  getUserKey(t, e, i) {
    const s = new Uint8Array(t.length + 8);
    s.set(t, 0), s.set(e, t.length);
    const n = Ha(s, 0, s.length);
    return new Cr(n).decryptBlock(i, !1, new Uint8Array(16));
  }
}
class ey {
  _hash(t, e, i) {
    let s = Ha(e, 0, e.length).subarray(0, 32), n = [0], o = 0;
    for (; o < 64 || n.at(-1) > o - 32; ) {
      const I = t.length + s.length + i.length, C = new Uint8Array(I);
      let d = 0;
      C.set(t, d), d += t.length, C.set(s, d), d += s.length, C.set(i, d);
      const u = new Uint8Array(64 * I);
      for (let p = 0, y = 0; p < 64; p++, y += I) u.set(C, y);
      n = new HE(s.subarray(0, 16)).encrypt(u, s.subarray(16, 32));
      const E = n.slice(0, 16).reduce(((p, y) => p + y), 0) % 3;
      E === 0 ? s = Ha(n, 0, n.length) : E === 1 ? (r = n, c = 0, h = n.length, s = k1(r, c, h, !0)) : E === 2 && (s = k1(n, 0, n.length)), o++;
    }
    var r, c, h;
    return s.subarray(0, 32);
  }
  checkOwnerPassword(t, e, i, s) {
    const n = new Uint8Array(t.length + 56);
    return n.set(t, 0), n.set(e, t.length), n.set(i, t.length + e.length), ja(this._hash(t, n, i), s);
  }
  checkUserPassword(t, e, i) {
    const s = new Uint8Array(t.length + 8);
    return s.set(t, 0), s.set(e, t.length), ja(this._hash(t, s, []), i);
  }
  getOwnerKey(t, e, i, s) {
    const n = new Uint8Array(t.length + 56);
    n.set(t, 0), n.set(e, t.length), n.set(i, t.length + e.length);
    const o = this._hash(t, n, i);
    return new Cr(o).decryptBlock(s, !1, new Uint8Array(16));
  }
  getUserKey(t, e, i) {
    const s = new Uint8Array(t.length + 8);
    s.set(t, 0), s.set(e, t.length);
    const n = this._hash(t, s, []);
    return new Cr(n).decryptBlock(i, !1, new Uint8Array(16));
  }
}
class S1 {
  constructor(t, e) {
    this.StringCipherConstructor = t, this.StreamCipherConstructor = e;
  }
  createStream(t, e) {
    const i = new this.StreamCipherConstructor();
    return new $8(t, e, (function(s, n) {
      return i.decryptBlock(s, n);
    }));
  }
  decryptString(t) {
    const e = new this.StringCipherConstructor();
    let i = re(t);
    return i = e.decryptBlock(i, !0), Re(i);
  }
  encryptString(t) {
    const e = new this.StringCipherConstructor();
    if (e instanceof Tl) {
      const s = 16 - t.length % 16;
      t += String.fromCharCode(s).repeat(s);
      const n = new Uint8Array(16);
      if (typeof crypto < "u") crypto.getRandomValues(n);
      else for (let c = 0; c < 16; c++) n[c] = Math.floor(256 * Math.random());
      let o = re(t);
      o = e.encrypt(o, n);
      const r = new Uint8Array(16 + o.length);
      return r.set(n), r.set(o, 16), Re(r);
    }
    let i = re(t);
    return i = e.encrypt(i), Re(i);
  }
}
class Ja {
  static #t = new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]);
  #A(t, e, i, s, n, o, r, c, h, I, C, d) {
    if (e) {
      const E = Math.min(127, e.length);
      e = e.subarray(0, E);
    } else e = [];
    const u = t === 6 ? new ey() : new Ay();
    return u.checkUserPassword(e, c, r) ? u.getUserKey(e, h, C) : e.length && u.checkOwnerPassword(e, s, o, i) ? u.getOwnerKey(e, n, o, I) : null;
  }
  #e(t, e, i, s, n, o, r, c) {
    const h = 40 + i.length + t.length, I = new Uint8Array(h);
    let C, d, u = 0;
    if (e) for (d = Math.min(32, e.length); u < d; ++u) I[u] = e[u];
    for (C = 0; u < 32; ) I[u++] = Ja.#t[C++];
    for (C = 0, d = i.length; C < d; ++C) I[u++] = i[C];
    for (I[u++] = 255 & n, I[u++] = n >> 8 & 255, I[u++] = n >> 16 & 255, I[u++] = n >>> 24 & 255, C = 0, d = t.length; C < d; ++C) I[u++] = t[C];
    o >= 4 && !c && (I[u++] = 255, I[u++] = 255, I[u++] = 255, I[u++] = 255);
    let E = ps(I, 0, u);
    const p = r >> 3;
    if (o >= 3) for (C = 0; C < 50; ++C) E = ps(E, 0, p);
    const y = E.subarray(0, p);
    let b, D;
    if (o >= 3) {
      for (u = 0; u < 32; ++u) I[u] = Ja.#t[u];
      for (C = 0, d = t.length; C < d; ++C) I[u++] = t[C];
      b = new Zs(y), D = b.encryptBlock(ps(I, 0, u)), d = y.length;
      const S = new Uint8Array(d);
      for (C = 1; C <= 19; ++C) {
        for (let R = 0; R < d; ++R) S[R] = y[R] ^ C;
        b = new Zs(S), D = b.encryptBlock(D);
      }
      for (C = 0, d = D.length; C < d; ++C) if (s[C] !== D[C]) return null;
    } else for (b = new Zs(y), D = b.encryptBlock(Ja.#t), C = 0, d = D.length; C < d; ++C) if (s[C] !== D[C]) return null;
    return y;
  }
  #s(t, e, i, s) {
    const n = new Uint8Array(32);
    let o = 0;
    const r = Math.min(32, t.length);
    for (; o < r; ++o) n[o] = t[o];
    let c = 0;
    for (; o < 32; ) n[o++] = Ja.#t[c++];
    let h = ps(n, 0, o);
    const I = s >> 3;
    if (i >= 3) for (c = 0; c < 50; ++c) h = ps(h, 0, h.length);
    let C, d;
    if (i >= 3) {
      d = e;
      const u = new Uint8Array(I);
      for (c = 19; c >= 0; c--) {
        for (let E = 0; E < I; ++E) u[E] = h[E] ^ c;
        C = new Zs(u), d = C.encryptBlock(d);
      }
    } else C = new Zs(h.subarray(0, I)), d = C.encryptBlock(e);
    return d;
  }
  #a(t, e, i, s = !1) {
    const n = new Uint8Array(i.length + 9), o = i.length;
    let r;
    for (r = 0; r < o; ++r) n[r] = i[r];
    return n[r++] = 255 & t, n[r++] = t >> 8 & 255, n[r++] = t >> 16 & 255, n[r++] = 255 & e, n[r++] = e >> 8 & 255, s && (n[r++] = 115, n[r++] = 65, n[r++] = 108, n[r++] = 84), ps(n, 0, r).subarray(0, Math.min(i.length + 5, 16));
  }
  #i(t, e, i, s, n) {
    if (!(e instanceof at)) throw new Ct("Invalid crypt filter name.");
    const o = this, r = t.get(e.name), c = r?.get("CFM");
    if (!c || c.name === "None") return function() {
      return new ty();
    };
    if (c.name === "V2") return function() {
      return new Zs(o.#a(i, s, n, !1));
    };
    if (c.name === "AESV2") return function() {
      return new HE(o.#a(i, s, n, !0));
    };
    if (c.name === "AESV3") return function() {
      return new Cr(n);
    };
    throw new Ct("Unknown crypto method");
  }
  constructor(t, e, i) {
    const s = t.get("Filter");
    if (!qA(s, "Standard")) throw new Ct("unknown encryption method");
    this.filterName = s.name, this.dict = t;
    const n = t.get("V");
    if (!Number.isInteger(n) || n !== 1 && n !== 2 && n !== 4 && n !== 5) throw new Ct("unsupported encryption algorithm");
    this.algorithm = n;
    let o = t.get("Length");
    if (!o) if (n <= 3) o = 40;
    else {
      const b = t.get("CF"), D = t.get("StmF");
      b instanceof z && D instanceof at && (b.suppressEncryption = !0, o = b.get(D.name)?.get("Length") || 128, o < 40 && (o <<= 3));
    }
    if (!Number.isInteger(o) || o < 40 || o % 8 != 0) throw new Ct("invalid key length");
    const r = re(t.get("O")), c = re(t.get("U")), h = r.subarray(0, 32), I = c.subarray(0, 32), C = t.get("P"), d = t.get("R"), u = (n === 4 || n === 5) && t.get("EncryptMetadata") !== !1;
    this.encryptMetadata = u;
    const E = re(e);
    let p, y;
    if (i) {
      if (d === 6) try {
        i = xh(i);
      } catch {
        O("CipherTransformFactory: Unable to convert UTF8 encoded password.");
      }
      p = re(i);
    }
    if (n !== 5) y = this.#e(E, p, h, I, C, d, o, u);
    else {
      const b = r.subarray(32, 40), D = r.subarray(40, 48), S = c.subarray(0, 48), R = c.subarray(32, 40), x = c.subarray(40, 48), N = re(t.get("OE")), U = re(t.get("UE")), T = re(t.get("Perms"));
      y = this.#A(d, p, h, b, D, S, I, R, x, N, U, T);
    }
    if (!y && !i) throw new To("No password given", Um);
    if (!y && i) {
      const b = this.#s(p, h, d, o);
      y = this.#e(E, b, h, I, C, d, o, u);
    }
    if (!y) throw new To("Incorrect Password", Hm);
    if (this.encryptionKey = y, n >= 4) {
      const b = t.get("CF");
      b instanceof z && (b.suppressEncryption = !0), this.cf = b, this.stmf = t.get("StmF") || at.get("Identity"), this.strf = t.get("StrF") || at.get("Identity"), this.eff = t.get("EFF") || this.stmf;
    }
  }
  createCipherTransform(t, e) {
    if (this.algorithm === 4 || this.algorithm === 5) return new S1(this.#i(this.cf, this.strf, t, e, this.encryptionKey), this.#i(this.cf, this.stmf, t, e, this.encryptionKey));
    const i = this.#a(t, e, this.encryptionKey, !1), s = function() {
      return new Zs(i);
    };
    return new S1(s, s);
  }
}
async function me(A, t, e, { encrypt: i = null }) {
  const s = i?.createCipherTransform(A.num, A.gen);
  e.push(`${A.num} ${A.gen} obj
`), t instanceof z ? await Eg(t, e, s) : t instanceof AA ? await JE(t, e, s) : (Array.isArray(t) || ArrayBuffer.isView(t)) && await YE(t, e, s), e.push(`
endobj
`);
}
async function Eg(A, t, e) {
  t.push("<<");
  for (const i of A.getKeys()) t.push(` /${yl(i)} `), await TE(A.getRaw(i), t, e);
  t.push(">>");
}
async function JE(A, t, e) {
  let i = A.getBytes();
  const { dict: s } = A, [n, o] = await Promise.all([s.getAsync("Filter"), s.getAsync("DecodeParms")]), r = qA(Array.isArray(n) ? await s.xref.fetchIfRefAsync(n[0]) : n, "FlateDecode");
  if (i.length >= 256 || r) try {
    const h = new CompressionStream("deflate"), I = h.writable.getWriter();
    I.write(i), I.close();
    const C = await new Response(h.readable).arrayBuffer();
    let d, u;
    i = new Uint8Array(C), n ? r || (d = Array.isArray(n) ? [at.get("FlateDecode"), ...n] : [at.get("FlateDecode"), n], o && (u = Array.isArray(o) ? [null, ...o] : [null, o])) : d = at.get("FlateDecode"), d && s.set("Filter", d), u && s.set("DecodeParms", u);
  } catch (h) {
    tA(`writeStream - cannot compress data: "${h}".`);
  }
  let c = Re(i);
  e && (c = e.encryptString(c)), s.set("Length", c.length), await Eg(s, t, e), t.push(` stream
`, c, `
endstream`);
}
async function YE(A, t, e) {
  t.push("[");
  let i = !0;
  for (const s of A) i ? i = !1 : t.push(" "), await TE(s, t, e);
  t.push("]");
}
async function TE(A, t, e) {
  A instanceof at ? t.push(`/${yl(A.name)}`) : A instanceof St ? t.push(`${A.num} ${A.gen} R`) : Array.isArray(A) || ArrayBuffer.isView(A) ? await YE(A, t, e) : typeof A == "string" ? (e && (A = e.encryptString(A)), t.push(`(${Za(A)})`)) : typeof A == "number" ? t.push(BA(A)) : typeof A == "boolean" ? t.push(A.toString()) : A instanceof z ? await Eg(A, t, e) : A instanceof AA ? await JE(A, t, e) : A === null ? t.push("null") : O(`Unhandled value in writer: ${typeof A}, please file a bug.`);
}
function oh(A, t, e, i) {
  for (let s = t + e - 1; s > e - 1; s--) i[s] = 255 & A, A >>= 8;
  return e + t;
}
function KE(A, t, e) {
  for (let i = 0, s = A.length; i < s; i++) e[t + i] = 255 & A.charCodeAt(i);
}
function iy({ xfaData: A, xfaDatasetsRef: t, newRefs: e, xref: i }) {
  A === null && (A = (function(o, r) {
    const c = new Qg({ hasAttributes: !0 }).parseFromString(o);
    for (const { xfa: I } of r) {
      if (!I) continue;
      const { path: C, value: d } = I;
      if (!C) continue;
      const u = AE(C);
      let E = c.documentElement.searchNode(u, 0);
      !E && u.length > 1 && (E = c.documentElement.searchNode([u.at(-1)], 0)), E ? E.childNodes = Array.isArray(d) ? d.map(((p) => new Xn("value", p))) : [new Xn("#text", d)] : O(`Node not found for path: ${C}`);
    }
    const h = [];
    return c.documentElement.dump(h), h.join("");
  })(i.fetchIfRef(t).getString(), e));
  const s = i.encrypt;
  s && (A = s.createCipherTransform(t.num, t.gen).encryptString(A));
  const n = `${t.num} ${t.gen} obj
<< /Type /EmbeddedFile /Length ${A.length}>>
stream
` + A + `
endstream
endobj
`;
  e.push({ ref: t, data: n });
}
function F1(A) {
  const t = [];
  for (const { ref: e } of A) e.num === t.at(-2) + t.at(-1) ? t[t.length - 1] += 1 : t.push(e.num, 1);
  return t;
}
function R1(A, t, e) {
  if (Array.isArray(t.fileIds) && t.fileIds.length > 0) {
    const i = (function(s, n) {
      const o = Math.floor(Date.now() / 1e3), r = n.filename || "", c = [o.toString(), r, s.toString()];
      let h = c.reduce(((d, u) => d + u.length), 0);
      for (const d of Object.values(n.info)) c.push(d), h += d.length;
      const I = new Uint8Array(h);
      let C = 0;
      for (const d of c) KE(d, C, I), C += d.length;
      return Re(ps(I));
    })(A, t);
    e.set("ID", [t.fileIds[0], i]);
  }
}
async function sy({ originalData: A, xrefInfo: t, newRefs: e, xref: i = null, hasXfa: s = !1, xfaDatasetsRef: n = null, hasXfaDatasetsEntry: o = !1, needAppearances: r, acroFormRef: c = null, acroForm: h = null, xfaData: I = null, useXrefStream: C = !1 }) {
  await (async function({ xref: S, acroForm: R, acroFormRef: x, hasXfa: N, hasXfaDatasetsEntry: U, xfaDatasetsRef: T, needAppearances: q, newRefs: _ }) {
    if (!N || U || T || O("XFA - Cannot save it"), !q && (!N || !T || U)) return;
    const Y = R.clone();
    if (N && !U) {
      const ut = R.get("XFA").slice();
      ut.splice(2, 0, "datasets"), ut.splice(3, 0, T), Y.set("XFA", ut);
    }
    q && Y.set("NeedAppearances", !0);
    const ht = [];
    await me(x, Y, ht, S), _.push({ ref: x, data: ht.join("") });
  })({ xref: i, acroForm: h, acroFormRef: c, hasXfa: s, hasXfaDatasetsEntry: o, xfaDatasetsRef: n, needAppearances: r, newRefs: e }), s && iy({ xfaData: I, xfaDatasetsRef: n, newRefs: e, xref: i });
  const d = [];
  let u = A.length;
  const E = A.at(-1);
  E !== 10 && E !== 13 && (d.push(`
`), u += 1);
  const p = (function(S, R, x) {
    const N = new z(null);
    N.set("Prev", S.startXRef);
    const U = S.newRef;
    return x ? (R.push({ ref: U, data: "" }), N.set("Size", U.num + 1), N.set("Type", at.get("XRef"))) : N.set("Size", U.num), S.rootRef !== null && N.set("Root", S.rootRef), S.infoRef !== null && N.set("Info", S.infoRef), S.encryptRef !== null && N.set("Encrypt", S.encryptRef), N;
  })(t, e, C);
  e = e.sort(((S, R) => S.ref.num - R.ref.num));
  for (const { data: S } of e) S !== null && d.push(S);
  await (C ? (async function(S, R, x, N, U) {
    const T = [];
    let q = 0, _ = 0;
    for (const { ref: tt, data: Z } of x) {
      let st;
      q = Math.max(q, R), Z !== null ? (st = Math.min(tt.gen, 65535), T.push([1, R, st]), R += Z.length) : (st = Math.min(tt.gen + 1, 65535), T.push([0, 0, st])), _ = Math.max(_, st);
    }
    N.set("Index", F1(x));
    const Y = [1, yC(q), yC(_)];
    N.set("W", Y), R1(R, S, N);
    const ht = Y.reduce(((tt, Z) => tt + Z), 0), ut = new Uint8Array(ht * T.length), j = new RA(ut);
    j.dict = N;
    let it = 0;
    for (const [tt, Z, st] of T) it = oh(tt, Y[0], it, ut), it = oh(Z, Y[1], it, ut), it = oh(st, Y[2], it, ut);
    await me(S.newRef, j, U, {}), U.push(`startxref
`, R.toString(), `
%%EOF
`);
  })(t, u, e, p, d) : (async function(S, R, x, N, U) {
    U.push(`xref
`);
    const T = F1(x);
    let q = 0;
    for (const { ref: _, data: Y } of x) _.num === T[q] && (U.push(`${T[q]} ${T[q + 1]}
`), q += 2), Y !== null ? (U.push(`${R.toString().padStart(10, "0")} ${Math.min(_.gen, 65535).toString().padStart(5, "0")} n\r
`), R += Y.length) : U.push(`0000000000 ${Math.min(_.gen + 1, 65535).toString().padStart(5, "0")} f\r
`);
    R1(R, S, N), U.push(`trailer
`), await Eg(N, U), U.push(`
startxref
`, R.toString(), `
%%EOF
`);
  })(t, u, e, p, d));
  const y = d.reduce(((S, R) => S + R.length), A.length), b = new Uint8Array(y);
  b.set(A);
  let D = A.length;
  for (const S of d) KE(S, D, b), D += S.length;
  return b;
}
const qE = 1, PE = 2, jh = 3, _E = 4, Zh = 5;
class Xa {
  constructor(t, e) {
    this.dict = t, this.ref = e instanceof St ? e : null, this.roleMap = /* @__PURE__ */ new Map(), this.structParentIds = null;
  }
  init() {
    this.readRoleMap();
  }
  #t(t, e, i) {
    if (!(t instanceof St) || e < 0) return;
    this.structParentIds ||= new Ii();
    let s = this.structParentIds.get(t);
    s || (s = [], this.structParentIds.put(t, s)), s.push([e, i]);
  }
  addAnnotationIdToPage(t, e) {
    this.#t(t, e, _E);
  }
  readRoleMap() {
    const t = this.dict.get("RoleMap");
    t instanceof z && t.forEach(((e, i) => {
      i instanceof at && this.roleMap.set(e, i.name);
    }));
  }
  static async canCreateStructureTree({ catalogRef: t, pdfManager: e, newAnnotationsByPage: i }) {
    if (!(t instanceof St)) return O("Cannot save the struct tree: no catalog reference."), !1;
    let s = 0, n = !0;
    for (const [o, r] of i) {
      const { ref: c } = await e.getPage(o);
      if (!(c instanceof St)) {
        O(`Cannot save the struct tree: page ${o} has no ref.`), n = !0;
        break;
      }
      for (const h of r) h.accessibilityData?.type && (h.parentTreeId = s++, n = !1);
    }
    if (n) {
      for (const o of i.values()) for (const r of o) delete r.parentTreeId;
      return !1;
    }
    return !0;
  }
  static async createStructureTree({ newAnnotationsByPage: t, xref: e, catalogRef: i, pdfManager: s, newRefs: n }) {
    const o = s.catalog.cloneDict(), r = new Ii();
    r.put(i, o);
    const c = e.getNewTemporaryRef();
    o.set("StructTreeRoot", c);
    const h = new z(e);
    h.set("Type", at.get("StructTreeRoot"));
    const I = e.getNewTemporaryRef();
    h.set("ParentTree", I);
    const C = [];
    h.set("K", C), r.put(c, h);
    const d = new z(e), u = [];
    d.set("Nums", u);
    const E = await this.#A({ newAnnotationsByPage: t, structTreeRootRef: c, kids: C, nums: u, xref: e, pdfManager: s, cache: r });
    h.set("ParentTreeNextKey", E), r.put(I, d);
    const p = [];
    for (const [y, b] of r.items()) p.length = 0, await me(y, b, p, e), n.push({ ref: y, data: p.join("") });
  }
  async canUpdateStructTree({ pdfManager: t, xref: e, newAnnotationsByPage: i }) {
    if (!this.ref) return O("Cannot update the struct tree: no root reference."), !1;
    let s = this.dict.get("ParentTreeNextKey");
    if (!Number.isInteger(s) || s < 0) return O("Cannot update the struct tree: invalid next key."), !1;
    const n = this.dict.get("ParentTree");
    if (!(n instanceof z)) return O("Cannot update the struct tree: ParentTree isn't a dict."), !1;
    const o = n.get("Nums");
    if (!Array.isArray(o)) return O("Cannot update the struct tree: nums isn't an array."), !1;
    const r = new Jl(n, e);
    for (const h of i.keys()) {
      const { pageDict: I } = await t.getPage(h);
      if (!I.has("StructParents")) continue;
      const C = I.get("StructParents");
      if (!Number.isInteger(C) || !Array.isArray(r.get(C))) return O(`Cannot save the struct tree: page ${h} has a wrong id.`), !1;
    }
    let c = !0;
    for (const [h, I] of i) {
      const { pageDict: C } = await t.getPage(h);
      Xa.#e({ elements: I, xref: this.dict.xref, pageDict: C, numberTree: r });
      for (const d of I) d.accessibilityData?.type && (d.parentTreeId = s++, c = !1);
    }
    if (c) {
      for (const h of i.values()) for (const I of h) delete I.parentTreeId, delete I.structTreeParent;
      return !1;
    }
    return !0;
  }
  async updateStructureTree({ newAnnotationsByPage: t, pdfManager: e, newRefs: i }) {
    const s = this.dict.xref, n = this.dict.clone(), o = this.ref, r = new Ii();
    r.put(o, n);
    let c, h = n.getRaw("ParentTree");
    h instanceof St ? c = s.fetch(h) : (c = h, h = s.getNewTemporaryRef(), n.set("ParentTree", h)), c = c.clone(), r.put(h, c);
    let I = c.getRaw("Nums"), C = null;
    I instanceof St && (C = I, I = s.fetch(C)), I = I.slice(), C || c.set("Nums", I);
    const d = await Xa.#A({ newAnnotationsByPage: t, structTreeRootRef: o, kids: null, nums: I, xref: s, pdfManager: e, cache: r });
    n.set("ParentTreeNextKey", d), C && r.put(C, I);
    const u = [];
    for (const [E, p] of r.items()) u.length = 0, await me(E, p, u, s), i.push({ ref: E, data: u.join("") });
  }
  static async #A({ newAnnotationsByPage: t, structTreeRootRef: e, kids: i, nums: s, xref: n, pdfManager: o, cache: r }) {
    const c = at.get("OBJR");
    let h = -1 / 0;
    for (const [I, C] of t) {
      const { ref: d } = await o.getPage(I), u = d instanceof St;
      for (const { accessibilityData: E, ref: p, parentTreeId: y, structTreeParent: b } of C) {
        if (!E?.type) continue;
        const { type: D, title: S, lang: R, alt: x, expanded: N, actualText: U } = E;
        h = Math.max(h, y);
        const T = n.getNewTemporaryRef(), q = new z(n);
        q.set("S", at.get(D)), S && q.set("T", xi(S)), R && q.set("Lang", R), x && q.set("Alt", xi(x)), N && q.set("E", xi(N)), U && q.set("ActualText", xi(U)), await this.#s({ structTreeParent: b, tagDict: q, newTagRef: T, structTreeRootRef: e, fallbackKids: i, xref: n, cache: r });
        const _ = new z(n);
        q.set("K", _), _.set("Type", c), u && _.set("Pg", d), _.set("Obj", p), r.put(T, q), s.push(y, T);
      }
    }
    return h + 1;
  }
  static #e({ elements: t, xref: e, pageDict: i, numberTree: s }) {
    const n = /* @__PURE__ */ new Map();
    for (const h of t) if (h.structTreeParentId) {
      const I = parseInt(h.structTreeParentId.split("_mc")[1], 10);
      let C = n.get(I);
      C || (C = [], n.set(I, C)), C.push(h);
    }
    const o = i.get("StructParents");
    if (!Number.isInteger(o)) return;
    const r = s.get(o), c = (h, I, C) => {
      const d = n.get(h);
      if (d) {
        const u = I.getRaw("P"), E = e.fetchIfRef(u);
        if (u instanceof St && E instanceof z) {
          const p = { ref: C, dict: I };
          for (const y of d) y.structTreeParent = p;
        }
        return !0;
      }
      return !1;
    };
    for (const h of r) {
      if (!(h instanceof St)) continue;
      const I = e.fetch(h), C = I.get("K");
      if (Number.isInteger(C)) c(C, I, h);
      else if (Array.isArray(C)) for (let d of C) {
        if (d = e.fetchIfRef(d), Number.isInteger(d) && c(d, I, h)) break;
        if (!(d instanceof z)) continue;
        if (!qA(d.get("Type"), "MCR")) break;
        const u = d.get("MCID");
        if (Number.isInteger(u) && c(u, I, h)) break;
      }
    }
  }
  static async #s({ structTreeParent: t, tagDict: e, newTagRef: i, structTreeRootRef: s, fallbackKids: n, xref: o, cache: r }) {
    let c, h = null;
    t ? ({ ref: h } = t, c = t.dict.getRaw("P") || s) : c = s, e.set("P", c);
    const I = o.fetchIfRef(c);
    if (!I) return void n.push(i);
    let C = r.get(c);
    C || (C = I.clone(), r.put(c, C));
    const d = C.getRaw("K");
    let u = d instanceof St ? r.get(d) : null;
    if (!u) {
      u = o.fetchIfRef(d), u = Array.isArray(u) ? u.slice() : [d];
      const p = o.getNewTemporaryRef();
      C.set("K", p), r.put(p, u);
    }
    const E = u.indexOf(h);
    u.splice(E >= 0 ? E + 1 : u.length, 0, i);
  }
}
class ay {
  constructor(t, e) {
    this.tree = t, this.dict = e, this.kids = [], this.parseKids();
  }
  get role() {
    const t = this.dict.get("S"), e = t instanceof at ? t.name : "", { root: i } = this.tree;
    return i.roleMap.has(e) ? i.roleMap.get(e) : e;
  }
  parseKids() {
    let t = null;
    const e = this.dict.getRaw("Pg");
    e instanceof St && (t = e.toString());
    const i = this.dict.get("K");
    if (Array.isArray(i)) for (const s of i) {
      const n = this.parseKid(t, s);
      n && this.kids.push(n);
    }
    else {
      const s = this.parseKid(t, i);
      s && this.kids.push(s);
    }
  }
  parseKid(t, e) {
    if (Number.isInteger(e)) return this.tree.pageDict.objId !== t ? null : new ro({ type: qE, mcid: e, pageObjId: t });
    let i = null;
    if (e instanceof St ? i = this.dict.xref.fetch(e) : e instanceof z && (i = e), !i) return null;
    const s = i.getRaw("Pg");
    s instanceof St && (t = s.toString());
    const n = i.get("Type") instanceof at ? i.get("Type").name : null;
    if (n === "MCR") {
      if (this.tree.pageDict.objId !== t) return null;
      const o = i.getRaw("Stm");
      return new ro({ type: PE, refObjId: o instanceof St ? o.toString() : null, pageObjId: t, mcid: i.get("MCID") });
    }
    if (n === "OBJR") {
      if (this.tree.pageDict.objId !== t) return null;
      const o = i.getRaw("Obj");
      return new ro({ type: jh, refObjId: o instanceof St ? o.toString() : null, pageObjId: t });
    }
    return new ro({ type: Zh, dict: i });
  }
}
class ro {
  constructor({ type: t, dict: e = null, mcid: i = null, pageObjId: s = null, refObjId: n = null }) {
    this.type = t, this.dict = e, this.mcid = i, this.pageObjId = s, this.refObjId = n, this.parentNode = null;
  }
}
class ny {
  constructor(t, e) {
    this.root = t, this.rootDict = t ? t.dict : null, this.pageDict = e, this.nodes = [];
  }
  parse(t) {
    if (!this.root || !this.rootDict) return;
    const e = this.rootDict.get("ParentTree");
    if (!e) return;
    const i = this.pageDict.get("StructParents"), s = t instanceof St && this.root.structParentIds?.get(t);
    if (!Number.isInteger(i) && !s) return;
    const n = /* @__PURE__ */ new Map(), o = new Jl(e, this.rootDict.xref);
    if (Number.isInteger(i)) {
      const r = o.get(i);
      if (Array.isArray(r)) for (const c of r) c instanceof St && this.addNode(this.rootDict.xref.fetch(c), n);
    }
    if (s) for (const [r, c] of s) {
      const h = o.get(r);
      if (h) {
        const I = this.addNode(this.rootDict.xref.fetchIfRef(h), n);
        I?.kids?.length === 1 && I.kids[0].type === jh && (I.kids[0].type = c);
      }
    }
  }
  addNode(t, e, i = 0) {
    if (i > 40) return O("StructTree MAX_DEPTH reached."), null;
    if (!(t instanceof z)) return null;
    if (e.has(t)) return e.get(t);
    const s = new ay(this, t);
    e.set(t, s);
    const n = t.get("P");
    if (!n || qA(n.get("Type"), "StructTreeRoot")) return this.addTopLevelNode(t, s) || e.delete(t), s;
    const o = this.addNode(n, e, i + 1);
    if (!o) return s;
    let r = !1;
    for (const c of o.kids) c.type === Zh && c.dict === t && (c.parentNode = s, r = !0);
    return r || e.delete(t), s;
  }
  addTopLevelNode(t, e) {
    const i = this.rootDict.get("K");
    if (!i) return !1;
    if (i instanceof z) return i.objId === t.objId && (this.nodes[0] = e, !0);
    if (!Array.isArray(i)) return !0;
    let s = !1;
    for (let n = 0; n < i.length; n++)
      i[n]?.toString() === t.objId && (this.nodes[n] = e, s = !0);
    return s;
  }
  get serializable() {
    function t(i, s, n = 0) {
      if (n > 40) return void O("StructTree too deep to be fully serialized.");
      const o = /* @__PURE__ */ Object.create(null);
      o.role = i.role, o.children = [], s.children.push(o);
      const r = i.dict.get("Alt");
      typeof r == "string" && (o.alt = cA(r));
      const c = i.dict.get("Lang");
      typeof c == "string" && (o.lang = cA(c));
      for (const h of i.kids) {
        const I = h.type === Zh ? h.parentNode : null;
        I ? t(I, o, n + 1) : h.type === qE || h.type === PE ? o.children.push({ type: "content", id: `p${h.pageObjId}_mc${h.mcid}` }) : h.type === jh ? o.children.push({ type: "object", id: h.refObjId }) : h.type === _E && o.children.push({ type: "annotation", id: `pdfjs_internal_id_${h.refObjId}` });
      }
    }
    const e = /* @__PURE__ */ Object.create(null);
    e.children = [], e.role = "Root";
    for (const i of this.nodes) i && t(i, e);
    return e;
  }
}
function Kl(A) {
  if (!Array.isArray(A) || A.length < 2) return !1;
  const [t, e, ...i] = A;
  if (!(t instanceof St || Number.isInteger(t)) || !(e instanceof at)) return !1;
  const s = i.length;
  let n = !0;
  switch (e.name) {
    case "XYZ":
      if (s < 2 || s > 3) return !1;
      break;
    case "Fit":
    case "FitB":
      return s === 0;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (s > 1) return !1;
      break;
    case "FitR":
      if (s !== 4) return !1;
      n = !1;
      break;
    default:
      return !1;
  }
  for (const o of i) if (!(typeof o == "number" || n && o === null)) return !1;
  return !0;
}
function oo(A) {
  return A instanceof z && (A = A.get("D")), Kl(A) ? A : null;
}
function x1(A) {
  let t = A.get("D");
  if (t) {
    if (t instanceof at && (t = t.name), typeof t == "string") return cA(t);
    if (Kl(t)) return JSON.stringify(t);
  }
  return null;
}
class za {
  constructor(t, e) {
    if (this.pdfManager = t, this.xref = e, this._catDict = e.getCatalogObj(), !(this._catDict instanceof z)) throw new Ct("Catalog object is not a dictionary.");
    this.toplevelPagesDict, this._actualNumPages = null, this.fontCache = new Ii(), this.builtInCMapCache = /* @__PURE__ */ new Map(), this.standardFontDataCache = /* @__PURE__ */ new Map(), this.globalImageCache = new La(), this.pageKidsCountCache = new Ii(), this.pageIndexCache = new Ii(), this.pageDictCache = new Ii(), this.nonBlendModesSet = new XA(), this.systemFontCache = /* @__PURE__ */ new Map();
  }
  cloneDict() {
    return this._catDict.clone();
  }
  get version() {
    const t = this._catDict.get("Version");
    if (t instanceof at) {
      if ($Q.test(t.name)) return bt(this, "version", t.name);
      O(`Invalid PDF catalog version: ${t.name}`);
    }
    return bt(this, "version", null);
  }
  get lang() {
    const t = this._catDict.get("Lang");
    return bt(this, "lang", t && typeof t == "string" ? cA(t) : null);
  }
  get needsRendering() {
    const t = this._catDict.get("NeedsRendering");
    return bt(this, "needsRendering", typeof t == "boolean" && t);
  }
  get collection() {
    let t = null;
    try {
      const e = this._catDict.get("Collection");
      e instanceof z && e.size > 0 && (t = e);
    } catch (e) {
      if (e instanceof yA) throw e;
      tA("Cannot fetch Collection entry; assuming no collection is present.");
    }
    return bt(this, "collection", t);
  }
  get acroForm() {
    let t = null;
    try {
      const e = this._catDict.get("AcroForm");
      e instanceof z && e.size > 0 && (t = e);
    } catch (e) {
      if (e instanceof yA) throw e;
      tA("Cannot fetch AcroForm entry; assuming no forms are present.");
    }
    return bt(this, "acroForm", t);
  }
  get acroFormRef() {
    const t = this._catDict.getRaw("AcroForm");
    return bt(this, "acroFormRef", t instanceof St ? t : null);
  }
  get metadata() {
    const t = this._catDict.getRaw("Metadata");
    if (!(t instanceof St)) return bt(this, "metadata", null);
    let e = null;
    try {
      const i = this.xref.fetch(t, !this.xref.encrypt?.encryptMetadata);
      if (i instanceof AA && i.dict instanceof z) {
        const s = i.dict.get("Type"), n = i.dict.get("Subtype");
        if (qA(s, "Metadata") && qA(n, "XML")) {
          const o = ar(i.getString());
          o && (e = new z8(o).serializable);
        }
      }
    } catch (i) {
      if (i instanceof yA) throw i;
      tA(`Skipping invalid Metadata: "${i}".`);
    }
    return bt(this, "metadata", e);
  }
  get markInfo() {
    let t = null;
    try {
      t = this._readMarkInfo();
    } catch (e) {
      if (e instanceof yA) throw e;
      O("Unable to read mark info.");
    }
    return bt(this, "markInfo", t);
  }
  _readMarkInfo() {
    const t = this._catDict.get("MarkInfo");
    if (!(t instanceof z)) return null;
    const e = { Marked: !1, UserProperties: !1, Suspects: !1 };
    for (const i in e) {
      const s = t.get(i);
      typeof s == "boolean" && (e[i] = s);
    }
    return e;
  }
  get structTreeRoot() {
    let t = null;
    try {
      t = this._readStructTreeRoot();
    } catch (e) {
      if (e instanceof yA) throw e;
      O("Unable read to structTreeRoot info.");
    }
    return bt(this, "structTreeRoot", t);
  }
  _readStructTreeRoot() {
    const t = this._catDict.getRaw("StructTreeRoot"), e = this.xref.fetchIfRef(t);
    if (!(e instanceof z)) return null;
    const i = new Xa(e, t);
    return i.init(), i;
  }
  get toplevelPagesDict() {
    const t = this._catDict.get("Pages");
    if (!(t instanceof z)) throw new Ct("Invalid top-level pages dictionary.");
    return bt(this, "toplevelPagesDict", t);
  }
  get documentOutline() {
    let t = null;
    try {
      t = this._readDocumentOutline();
    } catch (e) {
      if (e instanceof yA) throw e;
      O("Unable to read document outline.");
    }
    return bt(this, "documentOutline", t);
  }
  _readDocumentOutline() {
    let t = this._catDict.get("Outlines");
    if (!(t instanceof z) || (t = t.getRaw("First"), !(t instanceof St))) return null;
    const e = { items: [] }, i = [{ obj: t, parent: e }], s = new XA();
    s.put(t);
    const n = this.xref, o = new Uint8ClampedArray(3);
    for (; i.length > 0; ) {
      const r = i.shift(), c = n.fetchIfRef(r.obj);
      if (c === null) continue;
      c.has("Title") || O("Invalid outline item encountered.");
      const h = { url: null, dest: null, action: null };
      za.parseDestDictionary({ destDict: c, resultObj: h, docBaseUrl: this.baseUrl, docAttachments: this.attachments });
      const I = c.get("Title"), C = c.get("F") || 0, d = c.getArray("C"), u = c.get("Count");
      let E = o;
      !Pe(d, 3) || d[0] === 0 && d[1] === 0 && d[2] === 0 || (E = Vt.singletons.rgb.getRgb(d, 0));
      const p = { action: h.action, attachment: h.attachment, dest: h.dest, url: h.url, unsafeUrl: h.unsafeUrl, newWindow: h.newWindow, setOCGState: h.setOCGState, title: typeof I == "string" ? cA(I) : "", color: E, count: Number.isInteger(u) ? u : void 0, bold: !!(2 & C), italic: !!(1 & C), items: [] };
      r.parent.items.push(p), t = c.getRaw("First"), t instanceof St && !s.has(t) && (i.push({ obj: t, parent: p }), s.put(t)), t = c.getRaw("Next"), t instanceof St && !s.has(t) && (i.push({ obj: t, parent: r.parent }), s.put(t));
    }
    return e.items.length > 0 ? e.items : null;
  }
  get permissions() {
    let t = null;
    try {
      t = this._readPermissions();
    } catch (e) {
      if (e instanceof yA) throw e;
      O("Unable to read permissions.");
    }
    return bt(this, "permissions", t);
  }
  _readPermissions() {
    const t = this.xref.trailer.get("Encrypt");
    if (!(t instanceof z)) return null;
    let e = t.get("P");
    if (typeof e != "number") return null;
    e += 2 ** 32;
    const i = [];
    for (const s in CC) {
      const n = CC[s];
      e & n && i.push(n);
    }
    return i;
  }
  get optionalContentConfig() {
    let t = null;
    try {
      const e = this._catDict.get("OCProperties");
      if (!e) return bt(this, "optionalContentConfig", null);
      const i = e.get("D");
      if (!i) return bt(this, "optionalContentConfig", null);
      const s = e.get("OCGs");
      if (!Array.isArray(s)) return bt(this, "optionalContentConfig", null);
      const n = [], o = new XA();
      for (const r of s) r instanceof St && !o.has(r) && (o.put(r), n.push(this.#t(r)));
      t = this.#A(i, o), t.groups = n;
    } catch (e) {
      if (e instanceof yA) throw e;
      O(`Unable to read optional content config: ${e}`);
    }
    return bt(this, "optionalContentConfig", t);
  }
  #t(t) {
    const e = this.xref.fetch(t), i = { id: t.toString(), name: null, intent: null, usage: { print: null, view: null } }, s = e.get("Name");
    typeof s == "string" && (i.name = cA(s));
    let n = e.getArray("Intent");
    Array.isArray(n) || (n = [n]), n.every(((I) => I instanceof at)) && (i.intent = n.map(((I) => I.name)));
    const o = e.get("Usage");
    if (!(o instanceof z)) return i;
    const r = i.usage, c = o.get("Print");
    if (c instanceof z) {
      const I = c.get("PrintState");
      if (I instanceof at) switch (I.name) {
        case "ON":
        case "OFF":
          r.print = { printState: I.name };
      }
    }
    const h = o.get("View");
    if (h instanceof z) {
      const I = h.get("ViewState");
      if (I instanceof at) switch (I.name) {
        case "ON":
        case "OFF":
          r.view = { viewState: I.name };
      }
    }
    return i;
  }
  #A(t, e) {
    function i(h) {
      const I = [];
      if (Array.isArray(h)) for (const C of h) C instanceof St && e.has(C) && I.push(C.toString());
      return I;
    }
    function s(h, I = 0) {
      if (!Array.isArray(h)) return null;
      const C = [];
      for (const u of h) {
        if (u instanceof St && e.has(u)) {
          r.put(u), C.push(u.toString());
          continue;
        }
        const E = n(u, I);
        E && C.push(E);
      }
      if (I > 0) return C;
      const d = [];
      for (const u of e) r.has(u) || d.push(u.toString());
      return d.length && C.push({ name: null, order: d }), C;
    }
    function n(h, I) {
      if (++I > c) return O("parseNestedOrder - reached MAX_NESTED_LEVELS."), null;
      const C = o.fetchIfRef(h);
      if (!Array.isArray(C)) return null;
      const d = o.fetchIfRef(C[0]);
      if (typeof d != "string") return null;
      const u = s(C.slice(1), I);
      return u && u.length ? { name: cA(d), order: u } : null;
    }
    const o = this.xref, r = new XA(), c = 10;
    return { name: typeof t.get("Name") == "string" ? cA(t.get("Name")) : null, creator: typeof t.get("Creator") == "string" ? cA(t.get("Creator")) : null, baseState: t.get("BaseState") instanceof at ? t.get("BaseState").name : null, on: i(t.get("ON")), off: i(t.get("OFF")), order: s(t.get("Order")), groups: null };
  }
  setActualNumPages(t = null) {
    this._actualNumPages = t;
  }
  get hasActualNumPages() {
    return this._actualNumPages !== null;
  }
  get _pagesCount() {
    const t = this.toplevelPagesDict.get("Count");
    if (!Number.isInteger(t)) throw new Ct("Page count in top-level pages dictionary is not an integer.");
    return bt(this, "_pagesCount", t);
  }
  get numPages() {
    return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
  }
  get destinations() {
    const t = this._readDests(), e = /* @__PURE__ */ Object.create(null);
    if (t instanceof Fa) for (const [i, s] of t.getAll()) {
      const n = oo(s);
      n && (e[cA(i)] = n);
    }
    else t instanceof z && t.forEach((function(i, s) {
      const n = oo(s);
      n && (e[i] = n);
    }));
    return bt(this, "destinations", e);
  }
  getDestination(t) {
    const e = this._readDests();
    if (e instanceof Fa) {
      const i = oo(e.get(t));
      if (i) return i;
      const s = this.destinations[t];
      if (s) return O(`Found "${t}" at an incorrect position in the NameTree.`), s;
    } else if (e instanceof z) {
      const i = oo(e.get(t));
      if (i) return i;
    }
    return null;
  }
  _readDests() {
    const t = this._catDict.get("Names");
    return t?.has("Dests") ? new Fa(t.getRaw("Dests"), this.xref) : this._catDict.has("Dests") ? this._catDict.get("Dests") : void 0;
  }
  get pageLabels() {
    let t = null;
    try {
      t = this._readPageLabels();
    } catch (e) {
      if (e instanceof yA) throw e;
      O("Unable to read page labels.");
    }
    return bt(this, "pageLabels", t);
  }
  _readPageLabels() {
    const t = this._catDict.getRaw("PageLabels");
    if (!t) return null;
    const e = new Array(this.numPages);
    let i = null, s = "";
    const n = new Jl(t, this.xref).getAll();
    let o = "", r = 1;
    for (let c = 0, h = this.numPages; c < h; c++) {
      const I = n.get(c);
      if (I !== void 0) {
        if (!(I instanceof z)) throw new Ct("PageLabel is not a dictionary.");
        if (I.has("Type") && !qA(I.get("Type"), "PageLabel")) throw new Ct("Invalid type in PageLabel dictionary.");
        if (I.has("S")) {
          const C = I.get("S");
          if (!(C instanceof at)) throw new Ct("Invalid style in PageLabel dictionary.");
          i = C.name;
        } else i = null;
        if (I.has("P")) {
          const C = I.get("P");
          if (typeof C != "string") throw new Ct("Invalid prefix in PageLabel dictionary.");
          s = cA(C);
        } else s = "";
        if (I.has("St")) {
          const C = I.get("St");
          if (!(Number.isInteger(C) && C >= 1)) throw new Ct("Invalid start in PageLabel dictionary.");
          r = C;
        } else r = 1;
      }
      switch (i) {
        case "D":
          o = r;
          break;
        case "R":
        case "r":
          o = Om(r, i === "r");
          break;
        case "A":
        case "a":
          const C = 26, d = i === "a" ? 97 : 65, u = r - 1;
          o = String.fromCharCode(d + u % C).repeat(Math.floor(u / C) + 1);
          break;
        default:
          if (i) throw new Ct(`Invalid style "${i}" in PageLabel dictionary.`);
          o = "";
      }
      e[c] = s + o, r++;
    }
    return e;
  }
  get pageLayout() {
    const t = this._catDict.get("PageLayout");
    let e = "";
    if (t instanceof at) switch (t.name) {
      case "SinglePage":
      case "OneColumn":
      case "TwoColumnLeft":
      case "TwoColumnRight":
      case "TwoPageLeft":
      case "TwoPageRight":
        e = t.name;
    }
    return bt(this, "pageLayout", e);
  }
  get pageMode() {
    const t = this._catDict.get("PageMode");
    let e = "UseNone";
    if (t instanceof at) switch (t.name) {
      case "UseNone":
      case "UseOutlines":
      case "UseThumbs":
      case "FullScreen":
      case "UseOC":
      case "UseAttachments":
        e = t.name;
    }
    return bt(this, "pageMode", e);
  }
  get viewerPreferences() {
    const t = this._catDict.get("ViewerPreferences");
    if (!(t instanceof z)) return bt(this, "viewerPreferences", null);
    let e = null;
    for (const i of t.getKeys()) {
      const s = t.get(i);
      let n;
      switch (i) {
        case "HideToolbar":
        case "HideMenubar":
        case "HideWindowUI":
        case "FitWindow":
        case "CenterWindow":
        case "DisplayDocTitle":
        case "PickTrayByPDFSize":
          typeof s == "boolean" && (n = s);
          break;
        case "NonFullScreenPageMode":
          if (s instanceof at) switch (s.name) {
            case "UseNone":
            case "UseOutlines":
            case "UseThumbs":
            case "UseOC":
              n = s.name;
              break;
            default:
              n = "UseNone";
          }
          break;
        case "Direction":
          if (s instanceof at) switch (s.name) {
            case "L2R":
            case "R2L":
              n = s.name;
              break;
            default:
              n = "L2R";
          }
          break;
        case "ViewArea":
        case "ViewClip":
        case "PrintArea":
        case "PrintClip":
          if (s instanceof at) switch (s.name) {
            case "MediaBox":
            case "CropBox":
            case "BleedBox":
            case "TrimBox":
            case "ArtBox":
              n = s.name;
              break;
            default:
              n = "CropBox";
          }
          break;
        case "PrintScaling":
          if (s instanceof at) switch (s.name) {
            case "None":
            case "AppDefault":
              n = s.name;
              break;
            default:
              n = "AppDefault";
          }
          break;
        case "Duplex":
          if (s instanceof at) switch (s.name) {
            case "Simplex":
            case "DuplexFlipShortEdge":
            case "DuplexFlipLongEdge":
              n = s.name;
              break;
            default:
              n = "None";
          }
          break;
        case "PrintPageRange":
          Array.isArray(s) && s.length % 2 == 0 && s.every(((o, r, c) => Number.isInteger(o) && o > 0 && (r === 0 || o >= c[r - 1]) && o <= this.numPages)) && (n = s);
          break;
        case "NumCopies":
          Number.isInteger(s) && s > 0 && (n = s);
          break;
        default:
          O(`Ignoring non-standard key in ViewerPreferences: ${i}.`);
          continue;
      }
      n !== void 0 ? (e || (e = /* @__PURE__ */ Object.create(null)), e[i] = n) : O(`Bad value, for key "${i}", in ViewerPreferences: ${s}.`);
    }
    return bt(this, "viewerPreferences", e);
  }
  get openAction() {
    const t = this._catDict.get("OpenAction"), e = /* @__PURE__ */ Object.create(null);
    if (t instanceof z) {
      const i = new z(this.xref);
      i.set("A", t);
      const s = { url: null, dest: null, action: null };
      za.parseDestDictionary({ destDict: i, resultObj: s }), Array.isArray(s.dest) ? e.dest = s.dest : s.action && (e.action = s.action);
    } else Array.isArray(t) && (e.dest = t);
    return bt(this, "openAction", _Q(e) > 0 ? e : null);
  }
  get attachments() {
    const t = this._catDict.get("Names");
    let e = null;
    if (t instanceof z && t.has("EmbeddedFiles")) {
      const i = new Fa(t.getRaw("EmbeddedFiles"), this.xref);
      for (const [s, n] of i.getAll()) {
        const o = new Wh(n, this.xref);
        e || (e = /* @__PURE__ */ Object.create(null)), e[cA(s)] = o.serializable;
      }
    }
    return bt(this, "attachments", e);
  }
  get xfaImages() {
    const t = this._catDict.get("Names");
    let e = null;
    if (t instanceof z && t.has("XFAImages")) {
      const i = new Fa(t.getRaw("XFAImages"), this.xref);
      for (const [s, n] of i.getAll()) e || (e = new z(this.xref)), e.set(cA(s), n);
    }
    return bt(this, "xfaImages", e);
  }
  _collectJavaScript() {
    const t = this._catDict.get("Names");
    let e = null;
    function i(n, o) {
      if (!(o instanceof z) || !qA(o.get("S"), "JavaScript")) return;
      let r = o.get("JS");
      if (r instanceof AA) r = r.getString();
      else if (typeof r != "string") return;
      r = cA(r).replaceAll("\0", ""), r && (e ||= /* @__PURE__ */ new Map()).set(n, r);
    }
    if (t instanceof z && t.has("JavaScript")) {
      const n = new Fa(t.getRaw("JavaScript"), this.xref);
      for (const [o, r] of n.getAll()) i(cA(o), r);
    }
    const s = this._catDict.get("OpenAction");
    return s && i("OpenAction", s), e;
  }
  get jsActions() {
    const t = this._collectJavaScript();
    let e = Bg(this.xref, this._catDict, rm);
    if (t) {
      e ||= /* @__PURE__ */ Object.create(null);
      for (const [i, s] of t) i in e ? e[i].push(s) : e[i] = [s];
    }
    return bt(this, "jsActions", e);
  }
  async fontFallback(t, e) {
    const i = await Promise.all(this.fontCache);
    for (const s of i) if (s.loadedName === t) return void s.fallback(e);
  }
  async cleanup(t = !1) {
    Yl(), this.globalImageCache.clear(t), this.pageKidsCountCache.clear(), this.pageIndexCache.clear(), this.pageDictCache.clear(), this.nonBlendModesSet.clear();
    const e = await Promise.all(this.fontCache);
    for (const { dict: i } of e) delete i.cacheKey;
    this.fontCache.clear(), this.builtInCMapCache.clear(), this.standardFontDataCache.clear(), this.systemFontCache.clear();
  }
  async getPageDict(t) {
    const e = [this.toplevelPagesDict], i = new XA(), s = this._catDict.getRaw("Pages");
    s instanceof St && i.put(s);
    const n = this.xref, o = this.pageKidsCountCache, r = this.pageIndexCache, c = this.pageDictCache;
    let h = 0;
    for (; e.length; ) {
      const I = e.pop();
      if (I instanceof St) {
        const E = o.get(I);
        if (E >= 0 && h + E <= t) {
          h += E;
          continue;
        }
        if (i.has(I)) throw new Ct("Pages tree contains circular reference.");
        i.put(I);
        const p = await (c.get(I) || n.fetchAsync(I));
        if (p instanceof z) {
          let y = p.getRaw("Type");
          if (y instanceof St && (y = await n.fetchAsync(y)), qA(y, "Page") || !p.has("Kids")) {
            if (o.has(I) || o.put(I, 1), r.has(I) || r.put(I, h), h === t) return [p, I];
            h++;
            continue;
          }
        }
        e.push(p);
        continue;
      }
      if (!(I instanceof z)) throw new Ct("Page dictionary kid reference points to wrong type of object.");
      const { objId: C } = I;
      let d = I.getRaw("Count");
      if (d instanceof St && (d = await n.fetchAsync(d)), Number.isInteger(d) && d >= 0 && (C && !o.has(C) && o.put(C, d), h + d <= t)) {
        h += d;
        continue;
      }
      let u = I.getRaw("Kids");
      if (u instanceof St && (u = await n.fetchAsync(u)), !Array.isArray(u)) {
        let E = I.getRaw("Type");
        if (E instanceof St && (E = await n.fetchAsync(E)), qA(E, "Page") || !I.has("Kids")) {
          if (h === t) return [I, null];
          h++;
          continue;
        }
        throw new Ct("Page dictionary kids object is not an array.");
      }
      for (let E = u.length - 1; E >= 0; E--) {
        const p = u[E];
        e.push(p), I === this.toplevelPagesDict && p instanceof St && !c.has(p) && c.put(p, n.fetchAsync(p));
      }
    }
    throw new Error(`Page index ${t} not found.`);
  }
  async getAllPageDicts(t = !1) {
    const { ignoreErrors: e } = this.pdfManager.evaluatorOptions, i = [{ currentNode: this.toplevelPagesDict, posInKids: 0 }], s = new XA(), n = this._catDict.getRaw("Pages");
    n instanceof St && s.put(n);
    const o = /* @__PURE__ */ new Map(), r = this.xref, c = this.pageIndexCache;
    let h = 0;
    function I(u) {
      if (u instanceof Ds && !t) throw u;
      t && e && h === 0 && (O(`getAllPageDicts - Skipping invalid first page: "${u}".`), u = z.empty), o.set(h++, [u, null]);
    }
    for (; i.length > 0; ) {
      const u = i.at(-1), { currentNode: E, posInKids: p } = u;
      let y = E.getRaw("Kids");
      if (y instanceof St) try {
        y = await r.fetchAsync(y);
      } catch (R) {
        I(R);
        break;
      }
      if (!Array.isArray(y)) {
        I(new Ct("Page dictionary kids object is not an array."));
        break;
      }
      if (p >= y.length) {
        i.pop();
        continue;
      }
      const b = y[p];
      let D;
      if (b instanceof St) {
        if (s.has(b)) {
          I(new Ct("Pages tree contains circular reference."));
          break;
        }
        s.put(b);
        try {
          D = await r.fetchAsync(b);
        } catch (R) {
          I(R);
          break;
        }
      } else D = b;
      if (!(D instanceof z)) {
        I(new Ct("Page dictionary kid reference points to wrong type of object."));
        break;
      }
      let S = D.getRaw("Type");
      if (S instanceof St) try {
        S = await r.fetchAsync(S);
      } catch (R) {
        I(R);
        break;
      }
      qA(S, "Page") || !D.has("Kids") ? (C = D, (d = b instanceof St ? b : null) && !c.has(d) && c.put(d, h), o.set(h++, [C, d])) : i.push({ currentNode: D, posInKids: 0 }), u.posInKids++;
    }
    var C, d;
    return o;
  }
  getPageIndex(t) {
    const e = this.pageIndexCache.get(t);
    if (e !== void 0) return Promise.resolve(e);
    const i = this.xref;
    let s = 0;
    const n = (o) => (function(r) {
      let c, h = 0;
      return i.fetchAsync(r).then((function(I) {
        if (Po(r, t) && !zQ(I, "Page") && !(I instanceof z && !I.has("Type") && I.has("Contents"))) throw new Ct("The reference does not point to a /Page dictionary.");
        if (!I) return null;
        if (!(I instanceof z)) throw new Ct("Node must be a dictionary.");
        return c = I.getRaw("Parent"), I.getAsync("Parent");
      })).then((function(I) {
        if (!I) return null;
        if (!(I instanceof z)) throw new Ct("Parent must be a dictionary.");
        return I.getAsync("Kids");
      })).then((function(I) {
        if (!I) return null;
        const C = [];
        let d = !1;
        for (const u of I) {
          if (!(u instanceof St)) throw new Ct("Kid must be a reference.");
          if (Po(u, r)) {
            d = !0;
            break;
          }
          C.push(i.fetchAsync(u).then((function(E) {
            if (!(E instanceof z)) throw new Ct("Kid node must be a dictionary.");
            E.has("Count") ? h += E.get("Count") : h++;
          })));
        }
        if (!d) throw new Ct("Kid reference not found in parent's kids.");
        return Promise.all(C).then((function() {
          return [h, c];
        }));
      }));
    })(o).then(((r) => {
      if (!r) return this.pageIndexCache.put(t, s), s;
      const [c, h] = r;
      return s += c, n(h);
    }));
    return n(t);
  }
  get baseUrl() {
    const t = this._catDict.get("URI");
    if (t instanceof z) {
      const e = t.get("Base");
      if (typeof e == "string") {
        const i = Yo(e, null, { tryConvertEncoding: !0 });
        if (i) return bt(this, "baseUrl", i.href);
      }
    }
    return bt(this, "baseUrl", this.pdfManager.docBaseUrl);
  }
  static parseDestDictionary({ destDict: t, resultObj: e, docBaseUrl: i = null, docAttachments: s = null }) {
    if (!(t instanceof z)) return void O("parseDestDictionary: `destDict` must be a dictionary.");
    let n, o, r = t.get("A");
    if (r instanceof z || (t.has("Dest") ? r = t.get("Dest") : (r = t.get("AA"), r instanceof z && (r.has("D") ? r = r.get("D") : r.has("U") && (r = r.get("U"))))), r instanceof z) {
      const c = r.get("S");
      if (!(c instanceof at)) return void O("parseDestDictionary: Invalid type in Action dictionary.");
      const h = c.name;
      switch (h) {
        case "ResetForm":
          const I = r.get("Flags"), C = !(1 & (typeof I == "number" ? I : 0)), d = [], u = [];
          for (const _ of r.get("Fields") || []) _ instanceof St ? u.push(_.toString()) : typeof _ == "string" && d.push(cA(_));
          e.resetForm = { fields: d, refs: u, include: C };
          break;
        case "URI":
          n = r.get("URI"), n instanceof at && (n = "/" + n.name);
          break;
        case "GoTo":
          o = r.get("D");
          break;
        case "Launch":
        case "GoToR":
          const E = r.get("F");
          if (E instanceof z) {
            const _ = new Wh(E, null, !0), { rawFilename: Y } = _.serializable;
            n = Y;
          } else typeof E == "string" && (n = E);
          const p = x1(r);
          p && typeof n == "string" && (n = n.split("#", 1)[0] + "#" + p);
          const y = r.get("NewWindow");
          typeof y == "boolean" && (e.newWindow = y);
          break;
        case "GoToE":
          const b = r.get("T");
          let D;
          if (s && b instanceof z) {
            const _ = b.get("R"), Y = b.get("N");
            qA(_, "C") && typeof Y == "string" && (D = s[cA(Y)]);
          }
          if (D) {
            e.attachment = D;
            const _ = x1(r);
            _ && (e.attachmentDest = _);
          } else O('parseDestDictionary - unimplemented "GoToE" action.');
          break;
        case "Named":
          const S = r.get("N");
          S instanceof at && (e.action = S.name);
          break;
        case "SetOCGState":
          const R = r.get("State"), x = r.get("PreserveRB");
          if (!Array.isArray(R) || R.length === 0) break;
          const N = [];
          for (const _ of R) if (_ instanceof at) switch (_.name) {
            case "ON":
            case "OFF":
            case "Toggle":
              N.push(_.name);
          }
          else _ instanceof St && N.push(_.toString());
          if (N.length !== R.length) break;
          e.setOCGState = { state: N, preserveRB: typeof x != "boolean" || x };
          break;
        case "JavaScript":
          const U = r.get("JS");
          let T;
          U instanceof AA ? T = U.getString() : typeof U == "string" && (T = U);
          const q = T && eE(cA(T));
          if (q) {
            n = q.url, e.newWindow = q.newWindow;
            break;
          }
        default:
          if (h === "JavaScript" || h === "SubmitForm") break;
          O(`parseDestDictionary - unsupported action: "${h}".`);
      }
    } else t.has("Dest") && (o = t.get("Dest"));
    if (typeof n == "string") {
      const c = Yo(n, i, { addDefaultProtocol: !0, tryConvertEncoding: !0 });
      c && (e.url = c.href), e.unsafeUrl = n;
    }
    o && (o instanceof at && (o = o.name), typeof o == "string" ? e.dest = cA(o) : Kl(o) && (e.dest = o));
  }
}
function ry(A, t) {
  if (A instanceof z) A = A.getRawValues();
  else if (A instanceof AA) A = A.dict.getRawValues();
  else if (!Array.isArray(A)) return;
  for (const i of A) ((e = i) instanceof St || e instanceof z || e instanceof AA || Array.isArray(e)) && t.push(i);
  var e;
}
class zo {
  constructor(t, e, i) {
    this.dict = t, this.keys = e, this.xref = i, this.refSet = null;
  }
  async load() {
    if (this.xref.stream.isDataLoaded) return;
    const { keys: t, dict: e } = this;
    this.refSet = new XA();
    const i = [];
    for (const s of t) {
      const n = e.getRaw(s);
      n !== void 0 && i.push(n);
    }
    return this._walk(i);
  }
  async _walk(t) {
    const e = [], i = [];
    for (; t.length; ) {
      let s = t.pop();
      if (s instanceof St) {
        if (this.refSet.has(s)) continue;
        try {
          this.refSet.put(s), s = this.xref.fetch(s);
        } catch (n) {
          if (!(n instanceof yA)) {
            O(`ObjectLoader._walk - requesting all data: "${n}".`), this.refSet = null;
            const { manager: o } = this.xref.stream;
            return o.requestAllChunks();
          }
          e.push(s), i.push({ begin: n.begin, end: n.end });
        }
      }
      if (s instanceof AA) {
        const n = s.getBaseStreams();
        if (n) {
          let o = !1;
          for (const r of n) r.isDataLoaded || (o = !0, i.push({ begin: r.start, end: r.end }));
          o && e.push(s);
        }
      }
      ry(s, t);
    }
    if (i.length) {
      await this.xref.stream.manager.requestRanges(i);
      for (const s of e) s instanceof St && this.refSet.remove(s);
      return this._walk(e);
    }
    this.refSet = null;
  }
}
const fg = Symbol(), oa = Symbol(), FA = Symbol(), Ms = Symbol(), si = Symbol(), Ya = Symbol(), So = Symbol(), li = Symbol(), ki = Symbol(), Qt = Symbol("content"), ii = Symbol("data"), $a = Symbol(), nt = Symbol("extra"), fA = Symbol(), kr = Symbol(), Vh = Symbol(), OE = Symbol(), ga = Symbol(), pg = Symbol(), ur = Symbol(), zn = Symbol(), ql = Symbol(), oe = Symbol(), $n = Symbol(), ee = Symbol(), tn = Symbol(), qi = Symbol(), HA = Symbol(), jt = Symbol(), LA = Symbol(), QA = Symbol(), Br = Symbol(), Ga = Symbol(), Xh = Symbol(), Fo = Symbol(), Pl = Symbol(), Ba = Symbol(), Ta = Symbol(), ys = Symbol(), tr = Symbol(), zi = Symbol(), is = Symbol(), dr = Symbol(), Qr = Symbol(), oy = Symbol(), UA = Symbol("namespaceId"), hA = Symbol("nodeName"), Fs = Symbol(), Ni = Symbol(), zh = Symbol(), $i = Symbol(), vi = Symbol(), Fe = Symbol(), rn = Symbol(), Rs = Symbol(), WE = Symbol("root"), Kn = Symbol(), ji = Symbol(), $h = Symbol(), jE = Symbol(), xe = Symbol(), ci = Symbol(), OA = Symbol(), ZE = Symbol(), Tt = Symbol(), Ar = Symbol(), gA = Symbol(), CA = Symbol("uid"), Bi = Symbol(), JA = { config: { id: 0, check: (A) => A.startsWith("http://www.xfa.org/schema/xci/") }, connectionSet: { id: 1, check: (A) => A.startsWith("http://www.xfa.org/schema/xfa-connection-set/") }, datasets: { id: 2, check: (A) => A.startsWith("http://www.xfa.org/schema/xfa-data/") }, form: { id: 3, check: (A) => A.startsWith("http://www.xfa.org/schema/xfa-form/") }, localeSet: { id: 4, check: (A) => A.startsWith("http://www.xfa.org/schema/xfa-locale-set/") }, pdf: { id: 5, check: (A) => A === "http://ns.adobe.com/xdp/pdf/" }, signature: { id: 6, check: (A) => A === "http://www.w3.org/2000/09/xmldsig#" }, sourceSet: { id: 7, check: (A) => A.startsWith("http://www.xfa.org/schema/xfa-source-set/") }, stylesheet: { id: 8, check: (A) => A === "http://www.w3.org/1999/XSL/Transform" }, template: { id: 9, check: (A) => A.startsWith("http://www.xfa.org/schema/xfa-template/") }, xdc: { id: 10, check: (A) => A.startsWith("http://www.xfa.org/schema/xdc/") }, xdp: { id: 11, check: (A) => A === "http://ns.adobe.com/xdp/" }, xfdf: { id: 12, check: (A) => A === "http://ns.adobe.com/xfdf/" }, xhtml: { id: 13, check: (A) => A === "http://www.w3.org/1999/xhtml" }, xmpmeta: { id: 14, check: (A) => A === "http://ns.adobe.com/xmpmeta/" } }, gy = { pt: (A) => A, cm: (A) => A / 2.54 * 72, mm: (A) => A / 25.4 * 72, in: (A) => 72 * A, px: (A) => A }, cy = /([+-]?\d+\.?\d*)(.*)/;
function mg(A) {
  return A.startsWith("'") || A.startsWith('"') ? A.slice(1, -1) : A;
}
function Ot({ data: A, defaultValue: t, validate: e }) {
  if (!A) return t;
  A = A.trim();
  const i = parseInt(A, 10);
  return !isNaN(i) && e(i) ? i : t;
}
function $o({ data: A, defaultValue: t, validate: e }) {
  if (!A) return t;
  A = A.trim();
  const i = parseFloat(A);
  return !isNaN(i) && e(i) ? i : t;
}
function yg({ data: A, defaultValue: t, validate: e }) {
  return A && e(A = A.trim()) ? A : t;
}
function Et(A, t) {
  return yg({ data: A, defaultValue: t[0], validate: (e) => t.includes(e) });
}
function Nt(A, t = "0") {
  if (t ||= "0", !A) return Nt(t);
  const e = A.trim().match(cy);
  if (!e) return Nt(t);
  const [, i, s] = e, n = parseFloat(i);
  if (isNaN(n)) return Nt(t);
  if (n === 0) return 0;
  const o = gy[s];
  return o ? o(n) : n;
}
function N1(A) {
  if (!A) return { num: 1, den: 1 };
  const t = A.trim().split(/\s*:\s*/).map(((s) => parseFloat(s))).filter(((s) => !isNaN(s)));
  if (t.length === 1 && t.push(1), t.length === 0) return { num: 1, den: 1 };
  const [e, i] = t;
  return { num: e, den: i };
}
function di(A) {
  return A ? A.trim().split(/\s+/).map(((t) => ({ excluded: t[0] === "-", viewname: t.substring(1) }))) : [];
}
class Yt {
  static get FAILURE() {
    return bt(this, "FAILURE", new Yt(!1, null, null, null));
  }
  static get EMPTY() {
    return bt(this, "EMPTY", new Yt(!0, null, null, null));
  }
  constructor(t, e, i, s) {
    this.success = t, this.html = e, this.bbox = i, this.breakNode = s;
  }
  isBreak() {
    return !!this.breakNode;
  }
  static breakNode(t) {
    return new Yt(!1, null, null, t);
  }
  static success(t, e = null) {
    return new Yt(!0, t, e, null);
  }
}
class hy {
  constructor(t) {
    this.fonts = /* @__PURE__ */ new Map(), this.cache = /* @__PURE__ */ new Map(), this.warned = /* @__PURE__ */ new Set(), this.defaultFont = null, this.add(t);
  }
  add(t, e = null) {
    for (const s of t) this.addPdfFont(s);
    for (const s of this.fonts.values()) s.regular || (s.regular = s.italic || s.bold || s.bolditalic);
    if (!e || e.size === 0) return;
    const i = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
    for (const s of e) this.fonts.set(s, i);
  }
  addPdfFont(t) {
    const e = t.cssFontInfo, i = e.fontFamily;
    let s = this.fonts.get(i);
    s || (s = /* @__PURE__ */ Object.create(null), this.fonts.set(i, s), this.defaultFont || (this.defaultFont = s));
    let n = "";
    const o = parseFloat(e.fontWeight);
    parseFloat(e.italicAngle) !== 0 ? n = o >= 700 ? "bolditalic" : "italic" : o >= 700 && (n = "bold"), n || ((t.name.includes("Bold") || t.psName?.includes("Bold")) && (n = "bold"), (t.name.includes("Italic") || t.name.endsWith("It") || t.psName?.includes("Italic") || t.psName?.endsWith("It")) && (n += "italic")), n || (n = "regular"), s[n] = t;
  }
  getDefault() {
    return this.defaultFont;
  }
  find(t, e = !0) {
    let i = this.fonts.get(t) || this.cache.get(t);
    if (i) return i;
    const s = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
    let n = t.replaceAll(s, "");
    if (i = this.fonts.get(n), i) return this.cache.set(t, i), i;
    n = n.toLowerCase();
    const o = [];
    for (const [r, c] of this.fonts.entries()) r.replaceAll(s, "").toLowerCase().startsWith(n) && o.push(c);
    if (o.length === 0) for (const [, r] of this.fonts.entries()) r.regular.name?.replaceAll(s, "").toLowerCase().startsWith(n) && o.push(r);
    if (o.length === 0) {
      n = n.replaceAll(/psmt|mt/gi, "");
      for (const [r, c] of this.fonts.entries()) r.replaceAll(s, "").toLowerCase().startsWith(n) && o.push(c);
    }
    if (o.length === 0) for (const r of this.fonts.values()) r.regular.name?.replaceAll(s, "").toLowerCase().startsWith(n) && o.push(r);
    return o.length >= 1 ? (o.length !== 1 && e && O(`XFA - Too many choices to guess the correct font: ${t}`), this.cache.set(t, o[0]), o[0]) : (e && !this.warned.has(t) && (this.warned.add(t), O(`XFA - Cannot find the font: ${t}`)), null);
  }
}
function _l(A, t) {
  return A.posture === "italic" ? A.weight === "bold" ? t.bolditalic : t.italic : A.weight === "bold" ? t.bold : t.regular;
}
class G1 {
  constructor(t, e, i, s) {
    if (this.lineHeight = i, this.paraMargin = e || { top: 0, bottom: 0, left: 0, right: 0 }, !t) return void ([this.pdfFont, this.xfaFont] = this.defaultFont(s));
    this.xfaFont = { typeface: t.typeface, posture: t.posture, weight: t.weight, size: t.size, letterSpacing: t.letterSpacing };
    const n = s.find(t.typeface);
    n ? (this.pdfFont = _l(t, n), this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(s))) : [this.pdfFont, this.xfaFont] = this.defaultFont(s);
  }
  defaultFont(t) {
    const e = t.find("Helvetica", !1) || t.find("Myriad Pro", !1) || t.find("Arial", !1) || t.getDefault();
    if (e?.regular) {
      const i = e.regular;
      return [i, { typeface: i.cssFontInfo.fontFamily, posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
    }
    return [null, { typeface: "Courier", posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
  }
}
class ly {
  constructor(t, e, i, s) {
    this.fontFinder = s, this.stack = [new G1(t, e, i, s)];
  }
  pushData(t, e, i) {
    const s = this.stack.at(-1);
    for (const o of ["typeface", "posture", "weight", "size", "letterSpacing"]) t[o] || (t[o] = s.xfaFont[o]);
    for (const o of ["top", "bottom", "left", "right"]) isNaN(e[o]) && (e[o] = s.paraMargin[o]);
    const n = new G1(t, e, i || s.lineHeight, this.fontFinder);
    n.pdfFont || (n.pdfFont = s.pdfFont), this.stack.push(n);
  }
  popFont() {
    this.stack.pop();
  }
  topFont() {
    return this.stack.at(-1);
  }
}
class Iy {
  constructor(t, e, i, s) {
    this.glyphs = [], this.fontSelector = new ly(t, e, i, s), this.extraHeight = 0;
  }
  pushData(t, e, i) {
    this.fontSelector.pushData(t, e, i);
  }
  popFont(t) {
    return this.fontSelector.popFont();
  }
  addPara() {
    const t = this.fontSelector.topFont();
    this.extraHeight += t.paraMargin.top + t.paraMargin.bottom;
  }
  addString(t) {
    if (!t) return;
    const e = this.fontSelector.topFont(), i = e.xfaFont.size;
    if (e.pdfFont) {
      const s = e.xfaFont.letterSpacing, n = e.pdfFont, o = n.lineHeight || 1.2, r = e.lineHeight || Math.max(1.2, o) * i, c = o - (n.lineGap === void 0 ? 0.2 : n.lineGap), h = Math.max(1, c) * i, I = i / 1e3, C = n.defaultWidth || n.charsToGlyphs(" ")[0].width;
      for (const d of t.split(/[\u2029\n]/)) {
        const u = n.encodeString(d).join(""), E = n.charsToGlyphs(u);
        for (const p of E) {
          const y = p.width || C;
          this.glyphs.push([y * I + s, r, h, p.unicode, !1]);
        }
        this.glyphs.push([0, 0, 0, `
`, !0]);
      }
      this.glyphs.pop();
    } else {
      for (const s of t.split(/[\u2029\n]/)) {
        for (const n of s.split("")) this.glyphs.push([i, 1.2 * i, i, n, !1]);
        this.glyphs.push([0, 0, 0, `
`, !0]);
      }
      this.glyphs.pop();
    }
  }
  compute(t) {
    let e = -1, i = 0, s = 0, n = 0, o = 0, r = 0, c = !1, h = !0;
    for (let I = 0, C = this.glyphs.length; I < C; I++) {
      const [d, u, E, p, y] = this.glyphs[I], b = p === " ", D = h ? E : u;
      y ? (s = Math.max(s, o), o = 0, n += r, r = D, e = -1, i = 0, h = !1) : b ? o + d > t ? (s = Math.max(s, o), o = 0, n += r, r = D, e = -1, i = 0, c = !0, h = !1) : (r = Math.max(D, r), i = o, o += d, e = I) : o + d > t ? (n += r, r = D, e !== -1 ? (I = e, s = Math.max(s, i), o = 0, e = -1, i = 0) : (s = Math.max(s, o), o = d), c = !0, h = !1) : (o += d, r = Math.max(D, r));
    }
    return s = Math.max(s, o), n += r + this.extraHeight, { width: 1.02 * s, height: n, isBroken: c };
  }
}
const v1 = /^[^.[]+/, Cy = /^[^\]]+/, tg = 0, Ag = 1, Ol = 2, uy = 3, By = 4, VE = /* @__PURE__ */ new Map([["$data", (A, t) => A.datasets ? A.datasets.data : A], ["$record", (A, t) => (A.datasets ? A.datasets.data : A)[ee]()[0]], ["$template", (A, t) => A.template], ["$connectionSet", (A, t) => A.connectionSet], ["$form", (A, t) => A.form], ["$layout", (A, t) => A.layout], ["$host", (A, t) => A.host], ["$dataWindow", (A, t) => A.dataWindow], ["$event", (A, t) => A.event], ["!", (A, t) => A.datasets], ["$xfa", (A, t) => A], ["xfa", (A, t) => A], ["$", (A, t) => t]]), M1 = /* @__PURE__ */ new WeakMap();
function dy(A) {
  return (A = A.trim()) === "*" ? 1 / 0 : parseInt(A, 10) || 0;
}
function XE(A, t, e = !0) {
  let i = A.match(v1);
  if (!i) return null;
  let [s] = i;
  const n = [{ name: s, cacheName: "." + s, index: 0, js: null, formCalc: null, operator: tg }];
  let o = s.length;
  for (; o < A.length; ) {
    const r = o;
    if (A.charAt(o++) === "[") {
      if (i = A.slice(o).match(Cy), !i) return O("XFA - Invalid index in SOM expression"), null;
      n.at(-1).index = dy(i[0]), o += i[0].length + 1;
      continue;
    }
    let c;
    switch (A.charAt(o)) {
      case ".":
        if (!t) return null;
        o++, c = Ag;
        break;
      case "#":
        o++, c = Ol;
        break;
      case "[":
        if (e) return O("XFA - SOM expression contains a FormCalc subexpression which is not supported for now."), null;
        c = uy;
        break;
      case "(":
        if (e) return O("XFA - SOM expression contains a JavaScript subexpression which is not supported for now."), null;
        c = By;
        break;
      default:
        c = tg;
    }
    if (i = A.slice(o).match(v1), !i) break;
    [s] = i, o += s.length, n.push({ name: s, cacheName: A.slice(r, o), operator: c, index: 0, js: null, formCalc: null });
  }
  return n;
}
function ms(A, t, e, i = !0, s = !0) {
  const n = XE(e, i);
  if (!n) return null;
  const o = VE.get(n[0].name);
  let r, c = 0;
  o ? (r = !0, A = [o(A, t)], c = 1) : (r = t === null, A = [t || A]);
  for (let h = n.length; c < h; c++) {
    const { name: I, cacheName: C, operator: d, index: u } = n[c], E = [];
    for (const p of A) {
      if (!p.isXFAObject) continue;
      let y, b;
      if (s && (b = M1.get(p), b || (b = /* @__PURE__ */ new Map(), M1.set(p, b)), y = b.get(C)), !y) {
        switch (d) {
          case tg:
            y = p[ur](I, !1);
            break;
          case Ag:
            y = p[ur](I, !0);
            break;
          case Ol:
            y = p[pg](I), y = y.isXFAObjectArray ? y.children : [y];
        }
        s && b.set(C, y);
      }
      y.length > 0 && E.push(y);
    }
    if (E.length !== 0 || r || c !== 0) A = isFinite(u) ? E.filter(((p) => u < p.length)).map(((p) => p[u])) : E.flat();
    else {
      if (!(t = t[jt]())) return null;
      c = -1, A = [t];
    }
  }
  return A.length === 0 ? null : A;
}
function Qy(A, t, e) {
  const i = XE(e);
  if (!i || i.some(((o) => o.operator === Ag))) return null;
  const s = VE.get(i[0].name);
  let n = 0;
  s ? (A = s(A, t), n = 1) : A = t || A;
  for (let o = i.length; n < o; n++) {
    const { name: r, operator: c, index: h } = i[n];
    if (!isFinite(h)) return i[n].index = 0, A.createNodes(i.slice(n));
    let I;
    switch (c) {
      case tg:
        I = A[ur](r, !1);
        break;
      case Ag:
        I = A[ur](r, !0);
        break;
      case Ol:
        I = A[pg](r), I = I.isXFAObjectArray ? I.children : [I];
    }
    if (I.length === 0) return A.createNodes(i.slice(n));
    if (!(h < I.length)) return i[n].index = h - I.length, A.createNodes(i.slice(n));
    {
      const C = I[h];
      if (!C.isXFAObject) return O("XFA - Cannot create a node."), null;
      A = C;
    }
  }
  return null;
}
const go = Symbol(), Vs = Symbol(), Ra = Symbol(), zt = Symbol("_children"), gh = Symbol(), us = Symbol(), ch = Symbol(), L1 = Symbol(), hh = Symbol(), U1 = Symbol(), lh = Symbol(), qn = Symbol(), co = Symbol(), Ai = Symbol("parent"), Mn = Symbol(), Ln = Symbol(), Ih = Symbol();
let tl = 0;
const zE = JA.datasets.id;
class gt {
  constructor(t, e, i = !1) {
    this[UA] = t, this[hA] = e, this[lh] = i, this[Ai] = null, this[zt] = [], this[CA] = `${e}${tl++}`, this[QA] = null;
  }
  get isXFAObject() {
    return !0;
  }
  get isXFAObjectArray() {
    return !1;
  }
  createNodes(t) {
    let e = this, i = null;
    for (const { name: s, index: n } of t) {
      for (let o = 0, r = isFinite(n) ? n : 0; o <= r; o++) {
        const c = e[UA] === zE ? -1 : e[UA];
        i = new Gi(c, s), e[FA](i);
      }
      e = i;
    }
    return i;
  }
  [Ni](t) {
    if (!this[lh] || !this[zh](t)) return !1;
    const e = t[hA], i = this[e];
    if (!(i instanceof P)) return i !== null && this[Rs](i), this[e] = t, this[FA](t), !0;
    if (i.push(t)) return this[FA](t), !0;
    let s = "";
    return this.id ? s = ` (id: ${this.id})` : this.name && (s = ` (name: ${this.name} ${this.h.value})`), O(`XFA - node "${this[hA]}"${s} has already enough "${e}"!`), !1;
  }
  [zh](t) {
    return this.hasOwnProperty(t[hA]) && t[UA] === this[UA];
  }
  [tr]() {
    return !1;
  }
  [fg]() {
    return !1;
  }
  [Pl]() {
    return !1;
  }
  [Ba]() {
    return !1;
  }
  [Fe]() {
    this.para && this[LA]()[nt].paraStack.pop();
  }
  [rn]() {
    this[LA]()[nt].paraStack.push(this.para);
  }
  [$h](t) {
    this.id && this[UA] === JA.template.id && t.set(this.id, this);
  }
  [LA]() {
    return this[QA].template;
  }
  [zi]() {
    return !1;
  }
  [is]() {
    return !1;
  }
  [FA](t) {
    t[Ai] = this, this[zt].push(t), !t[QA] && this[QA] && (t[QA] = this[QA]);
  }
  [Rs](t) {
    const e = this[zt].indexOf(t);
    this[zt].splice(e, 1);
  }
  [Br]() {
    return this.hasOwnProperty("value");
  }
  [xe](t) {
  }
  [$i](t) {
  }
  [fA]() {
  }
  [si](t) {
    delete this[lh], this[So] && (t.clean(this[So]), delete this[So]);
  }
  [Xh](t) {
    return this[zt].indexOf(t);
  }
  [Fo](t, e) {
    e[Ai] = this, this[zt].splice(t, 0, e), !e[QA] && this[QA] && (e[QA] = this[QA]);
  }
  [dr]() {
    return !this.name;
  }
  [oy]() {
    return "";
  }
  [OA]() {
    return this[zt].length === 0 ? this[Qt] : this[zt].map(((t) => t[OA]())).join("");
  }
  get [Ra]() {
    const t = Object.getPrototypeOf(this);
    if (!t._attributes) {
      const e = t._attributes = /* @__PURE__ */ new Set();
      for (const i of Object.getOwnPropertyNames(this)) {
        if (this[i] === null || this[i] instanceof gt || this[i] instanceof P) break;
        e.add(i);
      }
    }
    return bt(this, Ra, t._attributes);
  }
  [ys](t) {
    let e = this;
    for (; e; ) {
      if (e === t) return !0;
      e = e[jt]();
    }
    return !1;
  }
  [jt]() {
    return this[Ai];
  }
  [HA]() {
    return this[jt]();
  }
  [ee](t = null) {
    return t ? this[t] : this[zt];
  }
  [$a]() {
    const t = /* @__PURE__ */ Object.create(null);
    this[Qt] && (t.$content = this[Qt]);
    for (const e of Object.getOwnPropertyNames(this)) {
      const i = this[e];
      i !== null && (i instanceof gt ? t[e] = i[$a]() : i instanceof P ? i.isEmpty() || (t[e] = i.dump()) : t[e] = i);
    }
    return t;
  }
  [gA]() {
    return null;
  }
  [Tt]() {
    return Yt.EMPTY;
  }
  *[tn]() {
    for (const t of this[ee]()) yield t;
  }
  *[L1](t, e) {
    for (const i of this[tn]()) if (!t || e === t.has(i[hA])) {
      const s = this[ga](), n = i[Tt](s);
      n.success || (this[nt].failingNode = i), yield n;
    }
  }
  [kr]() {
    return null;
  }
  [oa](t, e) {
    this[nt].children.push(t);
  }
  [ga]() {
  }
  [Ms]({ filter: t = null, include: e = !0 }) {
    if (this[nt].generator) {
      const i = this[ga](), s = this[nt].failingNode[Tt](i);
      if (!s.success) return s;
      s.html && this[oa](s.html, s.bbox), delete this[nt].failingNode;
    } else this[nt].generator = this[L1](t, e);
    for (; ; ) {
      const i = this[nt].generator.next();
      if (i.done) break;
      const s = i.value;
      if (!s.success) return s;
      s.html && this[oa](s.html, s.bbox);
    }
    return this[nt].generator = null, Yt.EMPTY;
  }
  [jE](t) {
    this[Ln] = new Set(Object.keys(t));
  }
  [U1](t) {
    const e = this[Ra], i = this[Ln];
    return [...t].filter(((s) => e.has(s) && !i.has(s)));
  }
  [Kn](t, e = /* @__PURE__ */ new Set()) {
    for (const i of this[zt]) i[Mn](t, e);
  }
  [Mn](t, e) {
    const i = this[hh](t, e);
    i ? this[go](i, t, e) : this[Kn](t, e);
  }
  [hh](t, e) {
    const { use: i, usehref: s } = this;
    if (!i && !s) return null;
    let n = null, o = null, r = null, c = i;
    if (s ? (c = s, s.startsWith("#som(") && s.endsWith(")") ? o = s.slice(5, -1) : s.startsWith(".#som(") && s.endsWith(")") ? o = s.slice(6, -1) : s.startsWith("#") ? r = s.slice(1) : s.startsWith(".#") && (r = s.slice(2))) : i.startsWith("#") ? r = i.slice(1) : o = i, this.use = this.usehref = "", r ? n = t.get(r) : (n = ms(t.get(WE), this, o, !0, !1), n && (n = n[0])), !n) return O(`XFA - Invalid prototype reference: ${c}.`), null;
    if (n[hA] !== this[hA]) return O(`XFA - Incompatible prototype: ${n[hA]} !== ${this[hA]}.`), null;
    if (e.has(n)) return O("XFA - Cycle detected in prototypes use."), null;
    e.add(n);
    const h = n[hh](t, e);
    return h && n[go](h, t, e), n[Kn](t, e), e.delete(n), n;
  }
  [go](t, e, i) {
    if (i.has(t)) return void O("XFA - Cycle detected in prototypes use.");
    !this[Qt] && t[Qt] && (this[Qt] = t[Qt]), new Set(i).add(t);
    for (const s of this[U1](t[Ln])) this[s] = t[s], this[Ln] && this[Ln].add(s);
    for (const s of Object.getOwnPropertyNames(this)) {
      if (this[Ra].has(s)) continue;
      const n = this[s], o = t[s];
      if (n instanceof P) {
        for (const r of n[zt]) r[Mn](e, i);
        for (let r = n[zt].length, c = o[zt].length; r < c; r++) {
          const h = t[zt][r][li]();
          if (!n.push(h)) break;
          h[Ai] = this, this[zt].push(h), h[Mn](e, i);
        }
      } else if (n === null) {
        if (o !== null) {
          const r = o[li]();
          r[Ai] = this, this[s] = r, this[zt].push(r), r[Mn](e, i);
        }
      } else n[Kn](e, i), o && n[go](o, e, i);
    }
  }
  static [gh](t) {
    return Array.isArray(t) ? t.map(((e) => gt[gh](e))) : typeof t == "object" && t !== null ? Object.assign({}, t) : t;
  }
  [li]() {
    const t = Object.create(Object.getPrototypeOf(this));
    for (const e of Object.getOwnPropertySymbols(this)) try {
      t[e] = this[e];
    } catch {
      bt(t, e, this[e]);
    }
    t[CA] = `${t[hA]}${tl++}`, t[zt] = [];
    for (const e of Object.getOwnPropertyNames(this)) {
      if (this[Ra].has(e)) {
        t[e] = gt[gh](this[e]);
        continue;
      }
      const i = this[e];
      t[e] = i instanceof P ? new P(i[qn]) : null;
    }
    for (const e of this[zt]) {
      const i = e[hA], s = e[li]();
      t[zt].push(s), s[Ai] = t, t[i] === null ? t[i] = s : t[i][zt].push(s);
    }
    return t;
  }
  [ee](t = null) {
    return t ? this[zt].filter(((e) => e[hA] === t)) : this[zt];
  }
  [pg](t) {
    return this[t];
  }
  [ur](t, e, i = !0) {
    return Array.from(this[zn](t, e, i));
  }
  *[zn](t, e, i = !0) {
    if (t !== "parent") {
      for (const s of this[zt]) s[hA] === t && (yield s), s.name === t && (yield s), (e || s[dr]()) && (yield* s[zn](t, e, !1));
      i && this[Ra].has(t) && (yield new Wl(this, t, this[t]));
    } else yield this[Ai];
  }
}
class P {
  constructor(t = 1 / 0) {
    this[qn] = t, this[zt] = [];
  }
  get isXFAObject() {
    return !1;
  }
  get isXFAObjectArray() {
    return !0;
  }
  push(t) {
    return this[zt].length <= this[qn] ? (this[zt].push(t), !0) : (O(`XFA - node "${t[hA]}" accepts no more than ${this[qn]} children`), !1);
  }
  isEmpty() {
    return this[zt].length === 0;
  }
  dump() {
    return this[zt].length === 1 ? this[zt][0][$a]() : this[zt].map(((t) => t[$a]()));
  }
  [li]() {
    const t = new P(this[qn]);
    return t[zt] = this[zt].map(((e) => e[li]())), t;
  }
  get children() {
    return this[zt];
  }
  clear() {
    this[zt].length = 0;
  }
}
class Wl {
  constructor(t, e, i) {
    this[Ai] = t, this[hA] = e, this[Qt] = i, this[ki] = !1, this[CA] = "attribute" + tl++;
  }
  [jt]() {
    return this[Ai];
  }
  [Ta]() {
    return !0;
  }
  [ql]() {
    return this[Qt].trim();
  }
  [xe](t) {
    t = t.value || "", this[Qt] = t.toString();
  }
  [OA]() {
    return this[Qt];
  }
  [ys](t) {
    return this[Ai] === t || this[Ai][ys](t);
  }
}
class Gi extends gt {
  constructor(t, e, i = {}) {
    if (super(t, e), this[Qt] = "", this[us] = null, e !== "#text") {
      const s = /* @__PURE__ */ new Map();
      this[Vs] = s;
      for (const [n, o] of Object.entries(i)) s.set(n, new Wl(this, n, o));
      if (i.hasOwnProperty(Fs)) {
        const n = i[Fs].xfa.dataNode;
        n !== void 0 && (n === "dataGroup" ? this[us] = !1 : n === "dataValue" && (this[us] = !0));
      }
    }
    this[ki] = !1;
  }
  [Ar](t) {
    const e = this[hA];
    if (e === "#text") return void t.push(Pa(this[Qt]));
    const i = xh(e), s = this[UA] === zE ? "xfa:" : "";
    t.push(`<${s}${i}`);
    for (const [n, o] of this[Vs].entries()) {
      const r = xh(n);
      t.push(` ${r}="${Pa(o[Qt])}"`);
    }
    if (this[us] !== null && (this[us] ? t.push(' xfa:dataNode="dataValue"') : t.push(' xfa:dataNode="dataGroup"')), this[Qt] || this[zt].length !== 0) {
      if (t.push(">"), this[Qt]) typeof this[Qt] == "string" ? t.push(Pa(this[Qt])) : this[Qt][Ar](t);
      else for (const n of this[zt]) n[Ar](t);
      t.push(`</${s}${i}>`);
    } else t.push("/>");
  }
  [Ni](t) {
    if (this[Qt]) {
      const e = new Gi(this[UA], "#text");
      this[FA](e), e[Qt] = this[Qt], this[Qt] = "";
    }
    return this[FA](t), !0;
  }
  [$i](t) {
    this[Qt] += t;
  }
  [fA]() {
    if (this[Qt] && this[zt].length > 0) {
      const t = new Gi(this[UA], "#text");
      this[FA](t), t[Qt] = this[Qt], delete this[Qt];
    }
  }
  [Tt]() {
    return this[hA] === "#text" ? Yt.success({ name: "#text", value: this[Qt] }) : Yt.EMPTY;
  }
  [ee](t = null) {
    return t ? this[zt].filter(((e) => e[hA] === t)) : this[zt];
  }
  [OE]() {
    return this[Vs];
  }
  [pg](t) {
    const e = this[Vs].get(t);
    return e !== void 0 ? e : this[ee](t);
  }
  *[zn](t, e) {
    const i = this[Vs].get(t);
    i && (yield i);
    for (const s of this[zt]) s[hA] === t && (yield s), e && (yield* s[zn](t, e));
  }
  *[Vh](t, e) {
    const i = this[Vs].get(t);
    !i || e && i[ki] || (yield i);
    for (const s of this[zt]) yield* s[Vh](t, e);
  }
  *[$n](t, e, i) {
    for (const s of this[zt]) s[hA] !== t || i && s[ki] || (yield s), e && (yield* s[$n](t, e, i));
  }
  [Ta]() {
    return this[us] === null ? this[zt].length === 0 || this[zt][0][UA] === JA.xhtml.id : this[us];
  }
  [ql]() {
    return this[us] === null ? this[zt].length === 0 ? this[Qt].trim() : this[zt][0][UA] === JA.xhtml.id ? this[zt][0][OA]().trim() : null : this[Qt].trim();
  }
  [xe](t) {
    t = t.value || "", this[Qt] = t.toString();
  }
  [$a](t = !1) {
    const e = /* @__PURE__ */ Object.create(null);
    t && (e.$ns = this[UA]), this[Qt] && (e.$content = this[Qt]), e.$name = this[hA], e.children = [];
    for (const i of this[zt]) e.children.push(i[$a](t));
    e.attributes = /* @__PURE__ */ Object.create(null);
    for (const [i, s] of this[Vs]) e.attributes[i] = s[Qt];
    return e;
  }
}
class xA extends gt {
  constructor(t, e) {
    super(t, e), this[Qt] = "";
  }
  [$i](t) {
    this[Qt] += t;
  }
  [fA]() {
  }
}
class uA extends xA {
  constructor(t, e, i) {
    super(t, e), this[co] = i;
  }
  [fA]() {
    this[Qt] = yg({ data: this[Qt], defaultValue: this[co][0], validate: (t) => this[co].includes(t) });
  }
  [si](t) {
    super[si](t), delete this[co];
  }
}
class iA extends xA {
  [fA]() {
    this[Qt] = this[Qt].trim();
  }
}
class Qi extends xA {
  constructor(t, e, i, s) {
    super(t, e), this[ch] = i, this[Ih] = s;
  }
  [fA]() {
    this[Qt] = Ot({ data: this[Qt], defaultValue: this[ch], validate: this[Ih] });
  }
  [si](t) {
    super[si](t), delete this[ch], delete this[Ih];
  }
}
class WA extends Qi {
  constructor(t, e) {
    super(t, e, 0, ((i) => i === 1));
  }
}
class $E extends Qi {
  constructor(t, e) {
    super(t, e, 1, ((i) => i === 0));
  }
}
function _t(A) {
  return typeof A == "string" ? "0px" : Number.isInteger(A) ? `${A}px` : `${A.toFixed(2)}px`;
}
const H1 = { anchorType(A, t) {
  const e = A[HA]();
  if (e && (!e.layout || e.layout === "position")) switch ("transform" in t || (t.transform = ""), A.anchorType) {
    case "bottomCenter":
      t.transform += "translate(-50%, -100%)";
      break;
    case "bottomLeft":
      t.transform += "translate(0,-100%)";
      break;
    case "bottomRight":
      t.transform += "translate(-100%,-100%)";
      break;
    case "middleCenter":
      t.transform += "translate(-50%,-50%)";
      break;
    case "middleLeft":
      t.transform += "translate(0,-50%)";
      break;
    case "middleRight":
      t.transform += "translate(-100%,-50%)";
      break;
    case "topCenter":
      t.transform += "translate(-50%,0)";
      break;
    case "topRight":
      t.transform += "translate(-100%,0)";
  }
}, dimensions(A, t) {
  const e = A[HA]();
  let i = A.w;
  const s = A.h;
  if (e.layout?.includes("row")) {
    const n = e[nt], o = A.colSpan;
    let r;
    o === -1 ? (r = n.columnWidths.slice(n.currentColumn).reduce(((c, h) => c + h), 0), n.currentColumn = 0) : (r = n.columnWidths.slice(n.currentColumn, n.currentColumn + o).reduce(((c, h) => c + h), 0), n.currentColumn = (n.currentColumn + A.colSpan) % n.columnWidths.length), isNaN(r) || (i = A.w = r);
  }
  t.width = i !== "" ? _t(i) : "auto", t.height = s !== "" ? _t(s) : "auto";
}, position(A, t) {
  const e = A[HA]();
  e?.layout && e.layout !== "position" || (t.position = "absolute", t.left = _t(A.x), t.top = _t(A.y));
}, rotate(A, t) {
  A.rotate && ("transform" in t || (t.transform = ""), t.transform += `rotate(-${A.rotate}deg)`, t.transformOrigin = "top left");
}, presence(A, t) {
  switch (A.presence) {
    case "invisible":
      t.visibility = "hidden";
      break;
    case "hidden":
    case "inactive":
      t.display = "none";
  }
}, hAlign(A, t) {
  if (A[hA] === "para") switch (A.hAlign) {
    case "justifyAll":
      t.textAlign = "justify-all";
      break;
    case "radix":
      t.textAlign = "left";
      break;
    default:
      t.textAlign = A.hAlign;
  }
  else switch (A.hAlign) {
    case "left":
      t.alignSelf = "start";
      break;
    case "center":
      t.alignSelf = "center";
      break;
    case "right":
      t.alignSelf = "end";
  }
}, margin(A, t) {
  A.margin && (t.margin = A.margin[gA]().margin);
} };
function tf(A, t) {
  A[HA]().layout === "position" && (A.minW > 0 && (t.minWidth = _t(A.minW)), A.maxW > 0 && (t.maxWidth = _t(A.maxW)), A.minH > 0 && (t.minHeight = _t(A.minH)), A.maxH > 0 && (t.maxHeight = _t(A.maxH)));
}
function J1(A, t, e, i, s, n) {
  const o = new Iy(t, e, i, s);
  return typeof A == "string" ? o.addString(A) : A[vi](o), o.compute(n);
}
function jl(A, t) {
  let e = null, i = null, s = !1;
  if ((!A.w || !A.h) && A.value) {
    let n = 0, o = 0;
    A.margin && (n = A.margin.leftInset + A.margin.rightInset, o = A.margin.topInset + A.margin.bottomInset);
    let r = null, c = null;
    A.para && (c = /* @__PURE__ */ Object.create(null), r = A.para.lineHeight === "" ? null : A.para.lineHeight, c.top = A.para.spaceAbove === "" ? 0 : A.para.spaceAbove, c.bottom = A.para.spaceBelow === "" ? 0 : A.para.spaceBelow, c.left = A.para.marginLeft === "" ? 0 : A.para.marginLeft, c.right = A.para.marginRight === "" ? 0 : A.para.marginRight);
    let h = A.font;
    if (!h) {
      const d = A[LA]();
      let u = A[jt]();
      for (; u && u !== d; ) {
        if (u.font) {
          h = u.font;
          break;
        }
        u = u[jt]();
      }
    }
    const I = (A.w || t.width) - n, C = A[QA].fontFinder;
    if (A.value.exData && A.value.exData[Qt] && A.value.exData.contentType === "text/html") {
      const d = J1(A.value.exData[Qt], h, c, r, C, I);
      i = d.width, e = d.height, s = d.isBroken;
    } else {
      const d = A.value[OA]();
      if (d) {
        const u = J1(d, h, c, r, C, I);
        i = u.width, e = u.height, s = u.isBroken;
      }
    }
    i === null || A.w || (i += n), e === null || A.h || (e += o);
  }
  return { w: i, h: e, isBroken: s };
}
function Af(A, t, e) {
  let i;
  if (A.w !== "" && A.h !== "") i = [A.x, A.y, A.w, A.h];
  else {
    if (!e) return null;
    let s = A.w;
    if (s === "") {
      if (A.maxW === 0) {
        const o = A[HA]();
        s = o.layout === "position" && o.w !== "" ? 0 : A.minW;
      } else s = Math.min(A.maxW, e.width);
      t.attributes.style.width = _t(s);
    }
    let n = A.h;
    if (n === "") {
      if (A.maxH === 0) {
        const o = A[HA]();
        n = o.layout === "position" && o.h !== "" ? 0 : A.minH;
      } else n = Math.min(A.maxH, e.height);
      t.attributes.style.height = _t(n);
    }
    i = [A.x, A.y, s, n];
  }
  return i;
}
function wg(A) {
  const t = A[HA]();
  if (t.layout?.includes("row")) {
    const e = t[nt], i = A.colSpan;
    let s;
    s = i === -1 ? e.columnWidths.slice(e.currentColumn).reduce(((n, o) => n + o), 0) : e.columnWidths.slice(e.currentColumn, e.currentColumn + i).reduce(((n, o) => n + o), 0), isNaN(s) || (A.w = s);
  }
  t.layout && t.layout !== "position" && (A.x = A.y = 0), A.layout === "table" && A.w === "" && Array.isArray(A.columnWidths) && (A.w = A.columnWidths.reduce(((e, i) => e + i), 0));
}
function ef(A) {
  switch (A.layout) {
    case "position":
    default:
      return "xfaPosition";
    case "lr-tb":
      return "xfaLrTb";
    case "rl-row":
      return "xfaRlRow";
    case "rl-tb":
      return "xfaRlTb";
    case "row":
      return "xfaRow";
    case "table":
      return "xfaTable";
    case "tb":
      return "xfaTb";
  }
}
function ye(A, ...t) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const i of t) {
    const s = A[i];
    if (s !== null) {
      if (H1.hasOwnProperty(i)) H1[i](A, e);
      else if (s instanceof gt) {
        const n = s[gA]();
        n ? Object.assign(e, n) : O(`(DEBUG) - XFA - style for ${i} not implemented yet`);
      }
    }
  }
  return e;
}
function ca(A, t) {
  const { attributes: e } = t, { style: i } = e, s = { name: "div", attributes: { class: ["xfaWrapper"], style: /* @__PURE__ */ Object.create(null) }, children: [] };
  if (e.class.push("xfaWrapped"), A.border) {
    const { widths: n, insets: o } = A.border[nt];
    let r, c, h = o[0], I = o[3];
    const C = o[0] + o[2], d = o[1] + o[3];
    switch (A.border.hand) {
      case "even":
        h -= n[0] / 2, I -= n[3] / 2, r = `calc(100% + ${(n[1] + n[3]) / 2 - d}px)`, c = `calc(100% + ${(n[0] + n[2]) / 2 - C}px)`;
        break;
      case "left":
        h -= n[0], I -= n[3], r = `calc(100% + ${n[1] + n[3] - d}px)`, c = `calc(100% + ${n[0] + n[2] - C}px)`;
        break;
      case "right":
        r = d ? `calc(100% - ${d}px)` : "100%", c = C ? `calc(100% - ${C}px)` : "100%";
    }
    const u = ["xfaBorder"];
    on(A.border) && u.push("xfaPrintOnly");
    const E = { name: "div", attributes: { class: u, style: { top: `${h}px`, left: `${I}px`, width: r, height: c } }, children: [] };
    for (const p of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"]) i[p] !== void 0 && (E.attributes.style[p] = i[p], delete i[p]);
    s.children.push(E, t);
  } else s.children.push(t);
  for (const n of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"]) i[n] !== void 0 && (s.attributes.style[n] = i[n], delete i[n]);
  return s.attributes.style.position = i.position === "absolute" ? "absolute" : "relative", delete i.position, i.alignSelf && (s.attributes.style.alignSelf = i.alignSelf, delete i.alignSelf), s;
}
function sf(A) {
  const t = Nt(A.textIndent, "0px");
  if (t >= 0) return;
  const e = "padding" + ((A.textAlign === "right" ? "right" : "left") == "left" ? "Left" : "Right"), i = Nt(A[e], "0px");
  A[e] = i - t + "px";
}
function Zl(A, t) {
  switch (A.access) {
    case "nonInteractive":
      t.push("xfaNonInteractive");
      break;
    case "readOnly":
      t.push("xfaReadOnly");
      break;
    case "protected":
      t.push("xfaDisabled");
  }
}
function on(A) {
  return A.relevant.length > 0 && !A.relevant[0].excluded && A.relevant[0].viewname === "print";
}
function af(A) {
  const t = A[LA]()[nt].paraStack;
  return t.length ? t.at(-1) : null;
}
function nf(A, t, e) {
  if (e.attributes.class?.includes("xfaRich")) {
    t && (A.h === "" && (t.height = "auto"), A.w === "" && (t.width = "auto"));
    const i = af(A);
    if (i) {
      const s = e.attributes.style;
      switch (s.display = "flex", s.flexDirection = "column", i.vAlign) {
        case "top":
          s.justifyContent = "start";
          break;
        case "bottom":
          s.justifyContent = "end";
          break;
        case "middle":
          s.justifyContent = "center";
      }
      const n = i[gA]();
      for (const [o, r] of Object.entries(n)) o in s || (s[o] = r);
    }
  }
}
function rf(A, t, e, i) {
  if (!e) return void delete i.fontFamily;
  const s = mg(A.typeface);
  i.fontFamily = `"${s}"`;
  const n = e.find(s);
  if (n) {
    const { fontFamily: o } = n.regular.cssFontInfo;
    o !== s && (i.fontFamily = `"${o}"`);
    const r = af(t);
    if (r && r.lineHeight !== "" || i.lineHeight) return;
    const c = _l(A, n);
    c && (i.lineHeight = Math.max(1.2, c.lineHeight));
  }
}
function of(A) {
  const t = Yo(A, null, { addDefaultProtocol: !0, tryConvertEncoding: !0 });
  return t ? t.href : null;
}
function gf(A, t) {
  return { name: "div", attributes: { class: [A.layout === "lr-tb" ? "xfaLr" : "xfaRl"] }, children: t };
}
function cf(A) {
  if (!A[nt]) return null;
  const t = { name: "div", attributes: A[nt].attributes, children: A[nt].children };
  if (A[nt].failingNode) {
    const e = A[nt].failingNode[kr]();
    e && (A.layout.endsWith("-tb") ? t.children.push(gf(A, [e])) : t.children.push(e));
  }
  return t.children.length === 0 ? null : t;
}
function hf(A, t, e) {
  const i = A[nt], s = i.availableSpace, [n, o, r, c] = e;
  switch (A.layout) {
    case "position":
      i.width = Math.max(i.width, n + r), i.height = Math.max(i.height, o + c), i.children.push(t);
      break;
    case "lr-tb":
    case "rl-tb":
      i.line && i.attempt !== 1 || (i.line = gf(A, []), i.children.push(i.line), i.numberInLine = 0), i.numberInLine += 1, i.line.children.push(t), i.attempt === 0 ? (i.currentWidth += r, i.height = Math.max(i.height, i.prevHeight + c)) : (i.currentWidth = r, i.prevHeight = i.height, i.height += c, i.attempt = 0), i.width = Math.max(i.width, i.currentWidth);
      break;
    case "rl-row":
    case "row": {
      i.children.push(t), i.width += r, i.height = Math.max(i.height, c);
      const h = _t(i.height);
      for (const I of i.children) I.attributes.style.height = h;
      break;
    }
    case "table":
    case "tb":
      i.width = Math.min(s.width, Math.max(i.width, r)), i.height += c, i.children.push(t);
  }
}
function lf(A) {
  const t = A[nt].availableSpace, e = A.margin ? A.margin.topInset + A.margin.bottomInset : 0, i = A.margin ? A.margin.leftInset + A.margin.rightInset : 0;
  switch (A.layout) {
    case "lr-tb":
    case "rl-tb":
      return A[nt].attempt === 0 ? { width: t.width - i - A[nt].currentWidth, height: t.height - e - A[nt].prevHeight } : { width: t.width - i, height: t.height - e - A[nt].height };
    case "rl-row":
    case "row":
      return { width: A[nt].columnWidths.slice(A[nt].currentColumn).reduce(((s, n) => s + n)), height: t.height - i };
    case "table":
    case "tb":
      return { width: t.width - i, height: t.height - e - A[nt].height };
    default:
      return t;
  }
}
function bg(A, t) {
  if (A[LA]()[nt].firstUnsplittable === null || A.w === 0 || A.h === 0) return !0;
  const e = A[HA](), i = e[nt]?.attempt || 0, [, s, n, o] = (function(r) {
    let c, h, I = r.w === "" ? NaN : r.w, C = r.h === "" ? NaN : r.h, [d, u] = [0, 0];
    switch (r.anchorType || "") {
      case "bottomCenter":
        [d, u] = [I / 2, C];
        break;
      case "bottomLeft":
        [d, u] = [0, C];
        break;
      case "bottomRight":
        [d, u] = [I, C];
        break;
      case "middleCenter":
        [d, u] = [I / 2, C / 2];
        break;
      case "middleLeft":
        [d, u] = [0, C / 2];
        break;
      case "middleRight":
        [d, u] = [I, C / 2];
        break;
      case "topCenter":
        [d, u] = [I / 2, 0];
        break;
      case "topRight":
        [d, u] = [I, 0];
    }
    switch (r.rotate || 0) {
      case 0:
        [c, h] = [-d, -u];
        break;
      case 90:
        [c, h] = [-u, d], [I, C] = [C, -I];
        break;
      case 180:
        [c, h] = [d, u], [I, C] = [-I, -C];
        break;
      case 270:
        [c, h] = [u, -d], [I, C] = [-C, I];
    }
    return [r.x + c + Math.min(0, I), r.y + h + Math.min(0, C), Math.abs(I), Math.abs(C)];
  })(A);
  switch (e.layout) {
    case "lr-tb":
    case "rl-tb":
      return i === 0 ? A[LA]()[nt].noLayoutFailure ? A.w !== "" ? Math.round(n - t.width) <= 2 : t.width > 2 : !(A.h !== "" && Math.round(o - t.height) > 2) && (A.w !== "" ? Math.round(n - t.width) <= 2 || e[nt].numberInLine === 0 && t.height > 2 : t.width > 2) : !!A[LA]()[nt].noLayoutFailure || !(A.h !== "" && Math.round(o - t.height) > 2) && (A.w === "" || Math.round(n - t.width) <= 2 || !e[is]()) && t.height > 2;
    case "table":
    case "tb":
      return !!A[LA]()[nt].noLayoutFailure || (A.h === "" || A[zi]() ? (A.w === "" || Math.round(n - t.width) <= 2 || !e[is]()) && t.height > 2 : Math.round(o - t.height) <= 2);
    case "position":
      return A[LA]()[nt].noLayoutFailure || A.h === "" || Math.round(o + s - t.height) <= 2 ? !0 : o + s > A[LA]()[nt].currentContentArea.h;
    case "rl-row":
    case "row":
      return !!A[LA]()[nt].noLayoutFailure || A.h === "" || Math.round(o - t.height) <= 2;
    default:
      return !0;
  }
}
const wt = JA.template.id, ha = "http://www.w3.org/2000/svg", Ey = /^H(\d+)$/, fy = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]), py = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
function Y1(A) {
  if (!A || !A.border) return { w: 0, h: 0 };
  const t = A.border[oe]();
  return t ? { w: t.widths[0] + t.widths[2] + t.insets[0] + t.insets[2], h: t.widths[1] + t.widths[3] + t.insets[1] + t.insets[3] } : { w: 0, h: 0 };
}
function Vl(A) {
  return A.margin && (A.margin.topInset || A.margin.rightInset || A.margin.bottomInset || A.margin.leftInset);
}
function Xl(A, t) {
  if (!A.value) {
    const e = new sI({});
    A[FA](e), A.value = e;
  }
  A.value[xe](t);
}
function* zl(A) {
  for (const t of A[ee]()) t instanceof AI ? yield* t[tn]() : yield t;
}
function Sr(A) {
  return A.validate?.nullTest === "error";
}
function Dg(A) {
  for (; A; ) {
    if (!A.traversal) return void (A[ci] = A[jt]()[ci]);
    if (A[ci]) return;
    let t = null;
    for (const s of A.traversal[ee]()) if (s.operation === "next") {
      t = s;
      break;
    }
    if (!t || !t.ref) return void (A[ci] = A[jt]()[ci]);
    const e = A[LA]();
    A[ci] = ++e[ci];
    const i = e[ji](t.ref, A);
    if (!i) return;
    A = i[0];
  }
}
function kg(A, t) {
  const e = A.assist;
  if (e) {
    const i = e[Tt]();
    i && (t.title = i);
    const s = e.role.match(Ey);
    if (s) {
      const n = "heading", o = s[1];
      t.role = n, t["aria-level"] = o;
    }
  }
  if (A.layout === "table") t.role = "table";
  else if (A.layout === "row") t.role = "row";
  else {
    const i = A[jt]();
    i.layout === "row" && (t.role = i.assist?.role === "TH" ? "columnheader" : "cell");
  }
}
function Ia(A) {
  if (!A.assist) return null;
  const t = A.assist;
  return t.speak && t.speak[Qt] !== "" ? t.speak[Qt] : t.toolTip ? t.toolTip[Qt] : null;
}
function Ls(A) {
  return Yt.success({ name: "div", attributes: { class: ["xfaRich"], style: /* @__PURE__ */ Object.create(null) }, children: [{ name: "span", attributes: { style: /* @__PURE__ */ Object.create(null) }, value: A }] });
}
function Sg(A) {
  const t = A[LA]();
  t[nt].firstUnsplittable === null && (t[nt].firstUnsplittable = A, t[nt].noLayoutFailure = !0);
}
function Fg(A) {
  const t = A[LA]();
  t[nt].firstUnsplittable === A && (t[nt].noLayoutFailure = !1);
}
function T1(A) {
  if (A[nt] || (A[nt] = /* @__PURE__ */ Object.create(null), A.targetType === "auto")) return !1;
  const t = A[LA]();
  let e = null;
  if (A.target) {
    if (e = t[ji](A.target, A[jt]()), !e) return !1;
    e = e[0];
  }
  const { currentPageArea: i, currentContentArea: s } = t[nt];
  if (A.targetType === "pageArea") return e instanceof An || (e = null), A.startNew ? (A[nt].target = e || i, !0) : !(!e || e === i) && (A[nt].target = e, !0);
  e instanceof $l || (e = null);
  const n = e && e[jt]();
  let o, r = n;
  if (A.startNew) if (e) {
    const c = n.contentArea.children, h = c.indexOf(s), I = c.indexOf(e);
    h !== -1 && h < I && (r = null), o = I - 1;
  } else o = i.contentArea.children.indexOf(s);
  else {
    if (!e || e === s) return !1;
    o = n.contentArea.children.indexOf(e) - 1, r = n === i ? null : n;
  }
  return A[nt].target = r, A[nt].index = o, !0;
}
function K1(A, t, e) {
  const i = A[LA](), s = i[nt].noLayoutFailure, n = t[HA];
  t[HA] = () => A, i[nt].noLayoutFailure = !0;
  const o = t[Tt](e);
  A[oa](o.html, o.bbox), i[nt].noLayoutFailure = s, t[HA] = n;
}
class my extends iA {
  constructor(t) {
    super(wt, "appearanceFilter"), this.id = t.id || "", this.type = Et(t.type, ["optional", "required"]), this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class If extends gt {
  constructor(t) {
    super(wt, "arc", !0), this.circular = Ot({ data: t.circular, defaultValue: 0, validate: (e) => e === 1 }), this.hand = Et(t.hand, ["even", "left", "right"]), this.id = t.id || "", this.startAngle = $o({ data: t.startAngle, defaultValue: 0, validate: (e) => !0 }), this.sweepAngle = $o({ data: t.sweepAngle, defaultValue: 360, validate: (e) => !0 }), this.use = t.use || "", this.usehref = t.usehref || "", this.edge = null, this.fill = null;
  }
  [Tt]() {
    const t = this.edge || new Fr({}), e = t[gA](), i = /* @__PURE__ */ Object.create(null);
    let s;
    this.fill?.presence === "visible" ? Object.assign(i, this.fill[gA]()) : i.fill = "transparent", i.strokeWidth = _t(t.presence === "visible" ? t.thickness : 0), i.stroke = e.color;
    const n = { xmlns: ha, style: { width: "100%", height: "100%", overflow: "visible" } };
    if (this.sweepAngle === 360) s = { name: "ellipse", attributes: { xmlns: ha, cx: "50%", cy: "50%", rx: "50%", ry: "50%", style: i } };
    else {
      const r = this.startAngle * Math.PI / 180, c = this.sweepAngle * Math.PI / 180, h = this.sweepAngle > 180 ? 1 : 0, [I, C, d, u] = [50 * (1 + Math.cos(r)), 50 * (1 - Math.sin(r)), 50 * (1 + Math.cos(r + c)), 50 * (1 - Math.sin(r + c))];
      s = { name: "path", attributes: { xmlns: ha, d: `M ${I} ${C} A 50 50 0 ${h} 0 ${d} ${u}`, vectorEffect: "non-scaling-stroke", style: i } }, Object.assign(n, { viewBox: "0 0 100 100", preserveAspectRatio: "none" });
    }
    const o = { name: "svg", children: [s], attributes: n };
    return Vl(this[jt]()[jt]()) ? Yt.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [o] }) : (o.attributes.style.position = "absolute", Yt.success(o));
  }
}
class yy extends gt {
  constructor(t) {
    super(wt, "area", !0), this.colSpan = Ot({ data: t.colSpan, defaultValue: 1, validate: (e) => e >= 1 || e === -1 }), this.id = t.id || "", this.name = t.name || "", this.relevant = di(t.relevant), this.use = t.use || "", this.usehref = t.usehref || "", this.x = Nt(t.x, "0pt"), this.y = Nt(t.y, "0pt"), this.desc = null, this.extras = null, this.area = new P(), this.draw = new P(), this.exObject = new P(), this.exclGroup = new P(), this.field = new P(), this.subform = new P(), this.subformSet = new P();
  }
  *[tn]() {
    yield* zl(this);
  }
  [dr]() {
    return !0;
  }
  [Ba]() {
    return !0;
  }
  [oa](t, e) {
    const [i, s, n, o] = e;
    this[nt].width = Math.max(this[nt].width, i + n), this[nt].height = Math.max(this[nt].height, s + o), this[nt].children.push(t);
  }
  [ga]() {
    return this[nt].availableSpace;
  }
  [Tt](t) {
    const e = ye(this, "position"), i = { style: e, id: this[CA], class: ["xfaArea"] };
    on(this) && i.class.push("xfaPrintOnly"), this.name && (i.xfaName = this.name);
    const s = [];
    this[nt] = { children: s, width: 0, height: 0, availableSpace: t };
    const n = this[Ms]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]), include: !0 });
    if (!n.success) return n.isBreak() ? n : (delete this[nt], Yt.FAILURE);
    e.width = _t(this[nt].width), e.height = _t(this[nt].height);
    const o = { name: "div", attributes: i, children: s }, r = [this.x, this.y, this[nt].width, this[nt].height];
    return delete this[nt], Yt.success(o, r);
  }
}
class wy extends gt {
  constructor(t) {
    super(wt, "assist", !0), this.id = t.id || "", this.role = t.role || "", this.use = t.use || "", this.usehref = t.usehref || "", this.speak = null, this.toolTip = null;
  }
  [Tt]() {
    return this.toolTip?.[Qt] || null;
  }
}
class by extends gt {
  constructor(t) {
    super(wt, "barcode", !0), this.charEncoding = yg({ data: t.charEncoding ? t.charEncoding.toLowerCase() : "", defaultValue: "", validate: (e) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e) || e.match(/iso-8859-\d{2}/) }), this.checksum = Et(t.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]), this.dataColumnCount = Ot({ data: t.dataColumnCount, defaultValue: -1, validate: (e) => e >= 0 }), this.dataLength = Ot({ data: t.dataLength, defaultValue: -1, validate: (e) => e >= 0 }), this.dataPrep = Et(t.dataPrep, ["none", "flateCompress"]), this.dataRowCount = Ot({ data: t.dataRowCount, defaultValue: -1, validate: (e) => e >= 0 }), this.endChar = t.endChar || "", this.errorCorrectionLevel = Ot({ data: t.errorCorrectionLevel, defaultValue: -1, validate: (e) => e >= 0 && e <= 8 }), this.id = t.id || "", this.moduleHeight = Nt(t.moduleHeight, "5mm"), this.moduleWidth = Nt(t.moduleWidth, "0.25mm"), this.printCheckDigit = Ot({ data: t.printCheckDigit, defaultValue: 0, validate: (e) => e === 1 }), this.rowColumnRatio = N1(t.rowColumnRatio), this.startChar = t.startChar || "", this.textLocation = Et(t.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]), this.truncate = Ot({ data: t.truncate, defaultValue: 0, validate: (e) => e === 1 }), this.type = Et(t.type ? t.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]), this.upsMode = Et(t.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]), this.use = t.use || "", this.usehref = t.usehref || "", this.wideNarrowRatio = N1(t.wideNarrowRatio), this.encrypt = null, this.extras = null;
  }
}
class Dy extends gt {
  constructor(t) {
    super(wt, "bind", !0), this.match = Et(t.match, ["once", "dataRef", "global", "none"]), this.ref = t.ref || "", this.picture = null;
  }
}
class Al extends gt {
  constructor(t) {
    super(wt, "bindItems"), this.connection = t.connection || "", this.labelRef = t.labelRef || "", this.ref = t.ref || "", this.valueRef = t.valueRef || "";
  }
}
class ky extends gt {
  constructor(t) {
    super(wt, "bookend"), this.id = t.id || "", this.leader = t.leader || "", this.trailer = t.trailer || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class Sy extends WA {
  constructor(t) {
    super(wt, "boolean"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
  [Tt](t) {
    return Ls(this[Qt] === 1 ? "1" : "0");
  }
}
class Cf extends gt {
  constructor(t) {
    super(wt, "border", !0), this.break = Et(t.break, ["close", "open"]), this.hand = Et(t.hand, ["even", "left", "right"]), this.id = t.id || "", this.presence = Et(t.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = di(t.relevant), this.use = t.use || "", this.usehref = t.usehref || "", this.corner = new P(4), this.edge = new P(4), this.extras = null, this.fill = null, this.margin = null;
  }
  [oe]() {
    if (!this[nt]) {
      const t = this.edge.children.slice();
      if (t.length < 4) {
        const s = t.at(-1) || new Fr({});
        for (let n = t.length; n < 4; n++) t.push(s);
      }
      const e = t.map(((s) => s.thickness)), i = [0, 0, 0, 0];
      this.margin && (i[0] = this.margin.topInset, i[1] = this.margin.rightInset, i[2] = this.margin.bottomInset, i[3] = this.margin.leftInset), this[nt] = { widths: e, insets: i, edges: t };
    }
    return this[nt];
  }
  [gA]() {
    const { edges: t } = this[oe](), e = t.map(((s) => {
      const n = s[gA]();
      return n.color ||= "#000000", n;
    })), i = /* @__PURE__ */ Object.create(null);
    if (this.margin && Object.assign(i, this.margin[gA]()), this.fill?.presence === "visible" && Object.assign(i, this.fill[gA]()), this.corner.children.some(((s) => s.radius !== 0))) {
      const s = this.corner.children.map(((n) => n[gA]()));
      if (s.length === 2 || s.length === 3) {
        const n = s.at(-1);
        for (let o = s.length; o < 4; o++) s.push(n);
      }
      i.borderRadius = s.map(((n) => n.radius)).join(" ");
    }
    switch (this.presence) {
      case "invisible":
      case "hidden":
        i.borderStyle = "";
        break;
      case "inactive":
        i.borderStyle = "none";
        break;
      default:
        i.borderStyle = e.map(((s) => s.style)).join(" ");
    }
    return i.borderWidth = e.map(((s) => s.width)).join(" "), i.borderColor = e.map(((s) => s.color)).join(" "), i;
  }
}
class Fy extends gt {
  constructor(t) {
    super(wt, "break", !0), this.after = Et(t.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.afterTarget = t.afterTarget || "", this.before = Et(t.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.beforeTarget = t.beforeTarget || "", this.bookendLeader = t.bookendLeader || "", this.bookendTrailer = t.bookendTrailer || "", this.id = t.id || "", this.overflowLeader = t.overflowLeader || "", this.overflowTarget = t.overflowTarget || "", this.overflowTrailer = t.overflowTrailer || "", this.startNew = Ot({ data: t.startNew, defaultValue: 0, validate: (e) => e === 1 }), this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null;
  }
}
class uf extends gt {
  constructor(t) {
    super(wt, "breakAfter", !0), this.id = t.id || "", this.leader = t.leader || "", this.startNew = Ot({ data: t.startNew, defaultValue: 0, validate: (e) => e === 1 }), this.target = t.target || "", this.targetType = Et(t.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = t.trailer || "", this.use = t.use || "", this.usehref = t.usehref || "", this.script = null;
  }
}
class Bf extends gt {
  constructor(t) {
    super(wt, "breakBefore", !0), this.id = t.id || "", this.leader = t.leader || "", this.startNew = Ot({ data: t.startNew, defaultValue: 0, validate: (e) => e === 1 }), this.target = t.target || "", this.targetType = Et(t.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = t.trailer || "", this.use = t.use || "", this.usehref = t.usehref || "", this.script = null;
  }
  [Tt](t) {
    return this[nt] = {}, Yt.FAILURE;
  }
}
class Ry extends gt {
  constructor(t) {
    super(wt, "button", !0), this.highlight = Et(t.highlight, ["inverted", "none", "outline", "push"]), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null;
  }
  [Tt](t) {
    const e = this[jt]()[jt](), i = { name: "button", attributes: { id: this[CA], class: ["xfaButton"], style: {} }, children: [] };
    for (const s of e.event.children) {
      if (s.activity !== "click" || !s.script) continue;
      const n = eE(s.script[Qt]);
      if (!n) continue;
      const o = of(n.url);
      o && i.children.push({ name: "a", attributes: { id: "link" + this[CA], href: o, newWindow: n.newWindow, class: ["xfaLink"], style: {} }, children: [] });
    }
    return Yt.success(i);
  }
}
class xy extends gt {
  constructor(t) {
    super(wt, "calculate", !0), this.id = t.id || "", this.override = Et(t.override, ["disabled", "error", "ignore", "warning"]), this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null, this.message = null, this.script = null;
  }
}
class Ny extends gt {
  constructor(t) {
    super(wt, "caption", !0), this.id = t.id || "", this.placement = Et(t.placement, ["left", "bottom", "inline", "right", "top"]), this.presence = Et(t.presence, ["visible", "hidden", "inactive", "invisible"]), this.reserve = Math.ceil(Nt(t.reserve)), this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null, this.font = null, this.margin = null, this.para = null, this.value = null;
  }
  [xe](t) {
    Xl(this, t);
  }
  [oe](t) {
    if (!this[nt]) {
      let { width: e, height: i } = t;
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          e = this.reserve <= 0 ? e : this.reserve;
          break;
        case "top":
        case "bottom":
          i = this.reserve <= 0 ? i : this.reserve;
      }
      this[nt] = jl(this, { width: e });
    }
    return this[nt];
  }
  [Tt](t) {
    if (!this.value) return Yt.EMPTY;
    this[rn]();
    const e = this.value[Tt](t).html;
    if (!e) return this[Fe](), Yt.EMPTY;
    const i = this.reserve;
    if (this.reserve <= 0) {
      const { w: o, h: r } = this[oe](t);
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          this.reserve = o;
          break;
        case "top":
        case "bottom":
          this.reserve = r;
      }
    }
    const s = [];
    typeof e == "string" ? s.push({ name: "#text", value: e }) : s.push(e);
    const n = ye(this, "font", "margin", "visibility");
    switch (this.placement) {
      case "left":
      case "right":
        this.reserve > 0 && (n.width = _t(this.reserve));
        break;
      case "top":
      case "bottom":
        this.reserve > 0 && (n.height = _t(this.reserve));
    }
    return nf(this, null, e), this[Fe](), this.reserve = i, Yt.success({ name: "div", attributes: { style: n, class: ["xfaCaption"] }, children: s });
  }
}
class Gy extends iA {
  constructor(t) {
    super(wt, "certificate"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class vy extends gt {
  constructor(t) {
    super(wt, "certificates", !0), this.credentialServerPolicy = Et(t.credentialServerPolicy, ["optional", "required"]), this.id = t.id || "", this.url = t.url || "", this.urlPolicy = t.urlPolicy || "", this.use = t.use || "", this.usehref = t.usehref || "", this.encryption = null, this.issuers = null, this.keyUsage = null, this.oids = null, this.signing = null, this.subjectDNs = null;
  }
}
class df extends gt {
  constructor(t) {
    super(wt, "checkButton", !0), this.id = t.id || "", this.mark = Et(t.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]), this.shape = Et(t.shape, ["square", "round"]), this.size = Nt(t.size, "10pt"), this.use = t.use || "", this.usehref = t.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
  [Tt](t) {
    const e = ye("margin"), i = _t(this.size);
    let s, n, o;
    e.width = e.height = i;
    const r = this[jt]()[jt](), c = r.items.children.length && r.items.children[0][Tt]().html || [], h = { on: (c[0] !== void 0 ? c[0] : "on").toString(), off: (c[1] !== void 0 ? c[1] : "off").toString() }, I = (r.value?.[OA]() || "off") === h.on || void 0, C = r[HA](), d = r[CA];
    let u;
    C instanceof pf ? (o = C[CA], s = "radio", n = "xfaRadio", u = C[ii]?.[CA] || C[CA]) : (s = "checkbox", n = "xfaCheckbox", u = r[ii]?.[CA] || r[CA]);
    const E = { name: "input", attributes: { class: [n], style: e, fieldId: d, dataId: u, type: s, checked: I, xfaOn: h.on, xfaOff: h.off, "aria-label": Ia(r), "aria-required": !1 } };
    return o && (E.attributes.name = o), Sr(r) && (E.attributes["aria-required"] = !0, E.attributes.required = !0), Yt.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [E] });
  }
}
class Qf extends gt {
  constructor(t) {
    super(wt, "choiceList", !0), this.commitOn = Et(t.commitOn, ["select", "exit"]), this.id = t.id || "", this.open = Et(t.open, ["userControl", "always", "multiSelect", "onEntry"]), this.textEntry = Ot({ data: t.textEntry, defaultValue: 0, validate: (e) => e === 1 }), this.use = t.use || "", this.usehref = t.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
  [Tt](t) {
    const e = ye(this, "border", "margin"), i = this[jt]()[jt](), s = { fontSize: `calc(${i.font?.size || 10}px * var(--scale-factor))` }, n = [];
    if (i.items.children.length > 0) {
      const r = i.items;
      let c = 0, h = 0;
      r.children.length === 2 && (c = r.children[0].save, h = 1 - c);
      const I = r.children[c][Tt]().html, C = r.children[h][Tt]().html;
      let d = !1;
      const u = i.value?.[OA]() || "";
      for (let E = 0, p = I.length; E < p; E++) {
        const y = { name: "option", attributes: { value: C[E] || I[E], style: s }, value: I[E] };
        C[E] === u && (y.attributes.selected = d = !0), n.push(y);
      }
      d || n.splice(0, 0, { name: "option", attributes: { hidden: !0, selected: !0 }, value: " " });
    }
    const o = { class: ["xfaSelect"], fieldId: i[CA], dataId: i[ii]?.[CA] || i[CA], style: e, "aria-label": Ia(i), "aria-required": !1 };
    return Sr(i) && (o["aria-required"] = !0, o.required = !0), this.open === "multiSelect" && (o.multiple = !0), Yt.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [{ name: "select", children: n, attributes: o }] });
  }
}
class My extends gt {
  constructor(t) {
    super(wt, "color", !0), this.cSpace = Et(t.cSpace, ["SRGB"]), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "", this.value = t.value ? (function(e, i = [0, 0, 0]) {
      let [s, n, o] = i;
      if (!e) return { r: s, g: n, b: o };
      const r = e.trim().split(/\s*,\s*/).map(((c) => Math.min(Math.max(0, parseInt(c.trim(), 10)), 255))).map(((c) => isNaN(c) ? 0 : c));
      return r.length < 3 || ([s, n, o] = r), { r: s, g: n, b: o };
    })(t.value) : "", this.extras = null;
  }
  [Br]() {
    return !1;
  }
  [gA]() {
    return this.value ? PA.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
  }
}
class Ly extends gt {
  constructor(t) {
    super(wt, "comb"), this.id = t.id || "", this.numberOfCells = Ot({ data: t.numberOfCells, defaultValue: 0, validate: (e) => e >= 0 }), this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class Uy extends gt {
  constructor(t) {
    super(wt, "connect", !0), this.connection = t.connection || "", this.id = t.id || "", this.ref = t.ref || "", this.usage = Et(t.usage, ["exportAndImport", "exportOnly", "importOnly"]), this.use = t.use || "", this.usehref = t.usehref || "", this.picture = null;
  }
}
class $l extends gt {
  constructor(t) {
    super(wt, "contentArea", !0), this.h = Nt(t.h), this.id = t.id || "", this.name = t.name || "", this.relevant = di(t.relevant), this.use = t.use || "", this.usehref = t.usehref || "", this.w = Nt(t.w), this.x = Nt(t.x, "0pt"), this.y = Nt(t.y, "0pt"), this.desc = null, this.extras = null;
  }
  [Tt](t) {
    const e = { left: _t(this.x), top: _t(this.y), width: _t(this.w), height: _t(this.h) }, i = ["xfaContentarea"];
    return on(this) && i.push("xfaPrintOnly"), Yt.success({ name: "div", children: [], attributes: { style: e, class: i, id: this[CA] } });
  }
}
class Ef extends gt {
  constructor(t) {
    super(wt, "corner", !0), this.id = t.id || "", this.inverted = Ot({ data: t.inverted, defaultValue: 0, validate: (e) => e === 1 }), this.join = Et(t.join, ["square", "round"]), this.presence = Et(t.presence, ["visible", "hidden", "inactive", "invisible"]), this.radius = Nt(t.radius), this.stroke = Et(t.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = Nt(t.thickness, "0.5pt"), this.use = t.use || "", this.usehref = t.usehref || "", this.color = null, this.extras = null;
  }
  [gA]() {
    const t = ye(this, "visibility");
    return t.radius = _t(this.join === "square" ? 0 : this.radius), t;
  }
}
class Hy extends xA {
  constructor(t) {
    super(wt, "date"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
  [fA]() {
    const t = this[Qt].trim();
    this[Qt] = t ? new Date(t) : null;
  }
  [Tt](t) {
    return Ls(this[Qt] ? this[Qt].toString() : "");
  }
}
class Jy extends xA {
  constructor(t) {
    super(wt, "dateTime"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
  [fA]() {
    const t = this[Qt].trim();
    this[Qt] = t ? new Date(t) : null;
  }
  [Tt](t) {
    return Ls(this[Qt] ? this[Qt].toString() : "");
  }
}
class Yy extends gt {
  constructor(t) {
    super(wt, "dateTimeEdit", !0), this.hScrollPolicy = Et(t.hScrollPolicy, ["auto", "off", "on"]), this.id = t.id || "", this.picker = Et(t.picker, ["host", "none"]), this.use = t.use || "", this.usehref = t.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
  }
  [Tt](t) {
    const e = ye(this, "border", "font", "margin"), i = this[jt]()[jt](), s = { name: "input", attributes: { type: "text", fieldId: i[CA], dataId: i[ii]?.[CA] || i[CA], class: ["xfaTextfield"], style: e, "aria-label": Ia(i), "aria-required": !1 } };
    return Sr(i) && (s.attributes["aria-required"] = !0, s.attributes.required = !0), Yt.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [s] });
  }
}
class Ty extends xA {
  constructor(t) {
    super(wt, "decimal"), this.fracDigits = Ot({ data: t.fracDigits, defaultValue: 2, validate: (e) => !0 }), this.id = t.id || "", this.leadDigits = Ot({ data: t.leadDigits, defaultValue: -1, validate: (e) => !0 }), this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
  [fA]() {
    const t = parseFloat(this[Qt].trim());
    this[Qt] = isNaN(t) ? null : t;
  }
  [Tt](t) {
    return Ls(this[Qt] !== null ? this[Qt].toString() : "");
  }
}
class Ky extends gt {
  constructor(t) {
    super(wt, "defaultUi", !0), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null;
  }
}
class qy extends gt {
  constructor(t) {
    super(wt, "desc", !0), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "", this.boolean = new P(), this.date = new P(), this.dateTime = new P(), this.decimal = new P(), this.exData = new P(), this.float = new P(), this.image = new P(), this.integer = new P(), this.text = new P(), this.time = new P();
  }
}
class Py extends uA {
  constructor(t) {
    super(wt, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class _y extends gt {
  constructor(t) {
    super(wt, "digestMethods", !0), this.id = t.id || "", this.type = Et(t.type, ["optional", "required"]), this.use = t.use || "", this.usehref = t.usehref || "", this.digestMethod = new P();
  }
}
class ff extends gt {
  constructor(t) {
    super(wt, "draw", !0), this.anchorType = Et(t.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = Ot({ data: t.colSpan, defaultValue: 1, validate: (e) => e >= 1 || e === -1 }), this.h = t.h ? Nt(t.h) : "", this.hAlign = Et(t.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = t.id || "", this.locale = t.locale || "", this.maxH = Nt(t.maxH, "0pt"), this.maxW = Nt(t.maxW, "0pt"), this.minH = Nt(t.minH, "0pt"), this.minW = Nt(t.minW, "0pt"), this.name = t.name || "", this.presence = Et(t.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = di(t.relevant), this.rotate = Ot({ data: t.rotate, defaultValue: 0, validate: (e) => e % 90 == 0 }), this.use = t.use || "", this.usehref = t.usehref || "", this.w = t.w ? Nt(t.w) : "", this.x = Nt(t.x, "0pt"), this.y = Nt(t.y, "0pt"), this.assist = null, this.border = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.value = null, this.setProperty = new P();
  }
  [xe](t) {
    Xl(this, t);
  }
  [Tt](t) {
    if (Dg(this), this.presence === "hidden" || this.presence === "inactive") return Yt.EMPTY;
    wg(this), this[rn]();
    const e = this.w, i = this.h, { w: s, h: n, isBroken: o } = jl(this, t);
    if (s && this.w === "") {
      if (o && this[HA]()[is]()) return this[Fe](), Yt.FAILURE;
      this.w = s;
    }
    if (n && this.h === "" && (this.h = n), Sg(this), !bg(this, t)) return this.w = e, this.h = i, this[Fe](), Yt.FAILURE;
    Fg(this);
    const r = ye(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
    tf(this, r), r.margin && (r.padding = r.margin, delete r.margin);
    const c = ["xfaDraw"];
    this.font && c.push("xfaFont"), on(this) && c.push("xfaPrintOnly");
    const h = { style: r, id: this[CA], class: c };
    this.name && (h.xfaName = this.name);
    const I = { name: "div", attributes: h, children: [] };
    kg(this, h);
    const C = Af(this, I, t), d = this.value ? this.value[Tt](t).html : null;
    return d === null ? (this.w = e, this.h = i, this[Fe](), Yt.success(ca(this, I), C)) : (I.children.push(d), nf(this, r, d), this.w = e, this.h = i, this[Fe](), Yt.success(ca(this, I), C));
  }
}
class Fr extends gt {
  constructor(t) {
    super(wt, "edge", !0), this.cap = Et(t.cap, ["square", "butt", "round"]), this.id = t.id || "", this.presence = Et(t.presence, ["visible", "hidden", "inactive", "invisible"]), this.stroke = Et(t.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = Nt(t.thickness, "0.5pt"), this.use = t.use || "", this.usehref = t.usehref || "", this.color = null, this.extras = null;
  }
  [gA]() {
    const t = ye(this, "visibility");
    if (Object.assign(t, { linecap: this.cap, width: _t(this.thickness), color: this.color ? this.color[gA]() : "#000000", style: "" }), this.presence !== "visible") t.style = "none";
    else switch (this.stroke) {
      case "solid":
        t.style = "solid";
        break;
      case "dashDot":
      case "dashDotDot":
      case "dashed":
        t.style = "dashed";
        break;
      case "dotted":
        t.style = "dotted";
        break;
      case "embossed":
        t.style = "ridge";
        break;
      case "etched":
        t.style = "groove";
        break;
      case "lowered":
        t.style = "inset";
        break;
      case "raised":
        t.style = "outset";
    }
    return t;
  }
}
class Oy extends uA {
  constructor(t) {
    super(wt, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class Wy extends gt {
  constructor(t) {
    super(wt, "encodings", !0), this.id = t.id || "", this.type = Et(t.type, ["optional", "required"]), this.use = t.use || "", this.usehref = t.usehref || "", this.encoding = new P();
  }
}
class jy extends gt {
  constructor(t) {
    super(wt, "encrypt", !0), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "", this.certificate = null;
  }
}
class Zy extends gt {
  constructor(t) {
    super(wt, "encryptData", !0), this.id = t.id || "", this.operation = Et(t.operation, ["encrypt", "decrypt"]), this.target = t.target || "", this.use = t.use || "", this.usehref = t.usehref || "", this.filter = null, this.manifest = null;
  }
}
class Vy extends gt {
  constructor(t) {
    super(wt, "encryption", !0), this.id = t.id || "", this.type = Et(t.type, ["optional", "required"]), this.use = t.use || "", this.usehref = t.usehref || "", this.certificate = new P();
  }
}
class Xy extends uA {
  constructor(t) {
    super(wt, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class zy extends gt {
  constructor(t) {
    super(wt, "encryptionMethods", !0), this.id = t.id || "", this.type = Et(t.type, ["optional", "required"]), this.use = t.use || "", this.usehref = t.usehref || "", this.encryptionMethod = new P();
  }
}
let $y = class extends gt {
  constructor(A) {
    super(wt, "event", !0), this.activity = Et(A.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]), this.id = A.id || "", this.listen = Et(A.listen, ["refOnly", "refAndDescendents"]), this.name = A.name || "", this.ref = A.ref || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.encryptData = null, this.execute = null, this.script = null, this.signData = null, this.submit = null;
  }
};
class t6 extends xA {
  constructor(t) {
    super(wt, "exData"), this.contentType = t.contentType || "", this.href = t.href || "", this.id = t.id || "", this.maxLength = Ot({ data: t.maxLength, defaultValue: -1, validate: (e) => e >= -1 }), this.name = t.name || "", this.rid = t.rid || "", this.transferEncoding = Et(t.transferEncoding, ["none", "base64", "package"]), this.use = t.use || "", this.usehref = t.usehref || "";
  }
  [Pl]() {
    return this.contentType === "text/html";
  }
  [Ni](t) {
    return (this.contentType === "text/html" && t[UA] === JA.xhtml.id || this.contentType === "text/xml") && (this[Qt] = t, !0);
  }
  [Tt](t) {
    return this.contentType === "text/html" && this[Qt] ? this[Qt][Tt](t) : Yt.EMPTY;
  }
}
class A6 extends gt {
  constructor(t) {
    super(wt, "exObject", !0), this.archive = t.archive || "", this.classId = t.classId || "", this.codeBase = t.codeBase || "", this.codeType = t.codeType || "", this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null, this.boolean = new P(), this.date = new P(), this.dateTime = new P(), this.decimal = new P(), this.exData = new P(), this.exObject = new P(), this.float = new P(), this.image = new P(), this.integer = new P(), this.text = new P(), this.time = new P();
  }
}
class pf extends gt {
  constructor(t) {
    super(wt, "exclGroup", !0), this.access = Et(t.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = t.accessKey || "", this.anchorType = Et(t.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = Ot({ data: t.colSpan, defaultValue: 1, validate: (e) => e >= 1 || e === -1 }), this.h = t.h ? Nt(t.h) : "", this.hAlign = Et(t.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = t.id || "", this.layout = Et(t.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.maxH = Nt(t.maxH, "0pt"), this.maxW = Nt(t.maxW, "0pt"), this.minH = Nt(t.minH, "0pt"), this.minW = Nt(t.minW, "0pt"), this.name = t.name || "", this.presence = Et(t.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = di(t.relevant), this.use = t.use || "", this.usehref = t.usehref || "", this.w = t.w ? Nt(t.w) : "", this.x = Nt(t.x, "0pt"), this.y = Nt(t.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.margin = null, this.para = null, this.traversal = null, this.validate = null, this.connect = new P(), this.event = new P(), this.field = new P(), this.setProperty = new P();
  }
  [Ba]() {
    return !0;
  }
  [Br]() {
    return !0;
  }
  [xe](t) {
    for (const e of this.field.children) {
      if (!e.value) {
        const i = new sI({});
        e[FA](i), e.value = i;
      }
      e.value[xe](t);
    }
  }
  [is]() {
    return this.layout.endsWith("-tb") && this[nt].attempt === 0 && this[nt].numberInLine > 0 || this[jt]()[is]();
  }
  [zi]() {
    const t = this[HA]();
    return !!t[zi]() && (this[nt]._isSplittable !== void 0 ? this[nt]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[nt]._isSplittable = !1, !1) : (!t.layout?.endsWith("-tb") || t[nt].numberInLine === 0) && (this[nt]._isSplittable = !0, !0));
  }
  [kr]() {
    return cf(this);
  }
  [oa](t, e) {
    hf(this, t, e);
  }
  [ga]() {
    return lf(this);
  }
  [Tt](t) {
    if (Dg(this), this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0) return Yt.EMPTY;
    wg(this);
    const e = [], i = { id: this[CA], class: [] };
    Zl(this, i.class), this[nt] || (this[nt] = /* @__PURE__ */ Object.create(null)), Object.assign(this[nt], { children: e, attributes: i, attempt: 0, line: null, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, t.width), height: Math.min(this.h || 1 / 0, t.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
    const s = this[zi]();
    if (s || Sg(this), !bg(this, t)) return Yt.FAILURE;
    const n = /* @__PURE__ */ new Set(["field"]);
    if (this.layout.includes("row")) {
      const b = this[HA]().columnWidths;
      Array.isArray(b) && b.length > 0 && (this[nt].columnWidths = b, this[nt].currentColumn = 0);
    }
    const o = ye(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), r = ["xfaExclgroup"], c = ef(this);
    c && r.push(c), on(this) && r.push("xfaPrintOnly"), i.style = o, i.class = r, this.name && (i.xfaName = this.name), this[rn]();
    const h = this.layout === "lr-tb" || this.layout === "rl-tb", I = h ? 2 : 1;
    for (; this[nt].attempt < I; this[nt].attempt++) {
      h && this[nt].attempt === 1 && (this[nt].numberInLine = 0);
      const b = this[Ms]({ filter: n, include: !0 });
      if (b.success) break;
      if (b.isBreak()) return this[Fe](), b;
      if (h && this[nt].attempt === 0 && this[nt].numberInLine === 0 && !this[LA]()[nt].noLayoutFailure) {
        this[nt].attempt = I;
        break;
      }
    }
    if (this[Fe](), s || Fg(this), this[nt].attempt === I) return s || delete this[nt], Yt.FAILURE;
    let C = 0, d = 0;
    this.margin && (C = this.margin.leftInset + this.margin.rightInset, d = this.margin.topInset + this.margin.bottomInset);
    const u = Math.max(this[nt].width + C, this.w || 0), E = Math.max(this[nt].height + d, this.h || 0), p = [this.x, this.y, u, E];
    this.w === "" && (o.width = _t(u)), this.h === "" && (o.height = _t(E));
    const y = { name: "div", attributes: i, children: e };
    return kg(this, i), delete this[nt], Yt.success(ca(this, y), p);
  }
}
class e6 extends gt {
  constructor(t) {
    super(wt, "execute"), this.connection = t.connection || "", this.executeType = Et(t.executeType, ["import", "remerge"]), this.id = t.id || "", this.runAt = Et(t.runAt, ["client", "both", "server"]), this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class i6 extends gt {
  constructor(t) {
    super(wt, "extras", !0), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "", this.boolean = new P(), this.date = new P(), this.dateTime = new P(), this.decimal = new P(), this.exData = new P(), this.extras = new P(), this.float = new P(), this.image = new P(), this.integer = new P(), this.text = new P(), this.time = new P();
  }
}
class tI extends gt {
  constructor(t) {
    super(wt, "field", !0), this.access = Et(t.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = t.accessKey || "", this.anchorType = Et(t.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = Ot({ data: t.colSpan, defaultValue: 1, validate: (e) => e >= 1 || e === -1 }), this.h = t.h ? Nt(t.h) : "", this.hAlign = Et(t.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = t.id || "", this.locale = t.locale || "", this.maxH = Nt(t.maxH, "0pt"), this.maxW = Nt(t.maxW, "0pt"), this.minH = Nt(t.minH, "0pt"), this.minW = Nt(t.minW, "0pt"), this.name = t.name || "", this.presence = Et(t.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = di(t.relevant), this.rotate = Ot({ data: t.rotate, defaultValue: 0, validate: (e) => e % 90 == 0 }), this.use = t.use || "", this.usehref = t.usehref || "", this.w = t.w ? Nt(t.w) : "", this.x = Nt(t.x, "0pt"), this.y = Nt(t.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.format = null, this.items = new P(2), this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.validate = null, this.value = null, this.bindItems = new P(), this.connect = new P(), this.event = new P(), this.setProperty = new P();
  }
  [Ba]() {
    return !0;
  }
  [xe](t) {
    Xl(this, t);
  }
  [Tt](t) {
    if (Dg(this), !this.ui) {
      let b;
      switch (this.ui = new iI({}), this.ui[QA] = this[QA], this[FA](this.ui), this.items.children.length) {
        case 0:
          b = new kf({}), this.ui.textEdit = b;
          break;
        case 1:
          b = new df({}), this.ui.checkButton = b;
          break;
        case 2:
          b = new Qf({}), this.ui.choiceList = b;
      }
      this.ui[FA](b);
    }
    if (!this.ui || this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0) return Yt.EMPTY;
    this.caption && delete this.caption[nt], this[rn]();
    const e = this.caption ? this.caption[Tt](t).html : null, i = this.w, s = this.h;
    let n = 0, o = 0;
    this.margin && (n = this.margin.leftInset + this.margin.rightInset, o = this.margin.topInset + this.margin.bottomInset);
    let r = null;
    if (this.w === "" || this.h === "") {
      let b = null, D = null, S = 0, R = 0;
      if (this.ui.checkButton) S = R = this.ui.checkButton.size;
      else {
        const { w: x, h: N } = jl(this, t);
        x !== null ? (S = x, R = N) : R = (function(U, T = !1) {
          let q = null;
          if (U) {
            const ut = mg(U.typeface), j = U[QA].fontFinder.find(ut);
            q = _l(U, j);
          }
          if (!q) return { lineHeight: 12, lineGap: 2, lineNoGap: 10 };
          const _ = U.size || 10, Y = q.lineHeight ? Math.max(T ? 0 : 1.2, q.lineHeight) : 1.2, ht = q.lineGap === void 0 ? 0.2 : q.lineGap;
          return { lineHeight: Y * _, lineGap: ht * _, lineNoGap: Math.max(1, Y - ht) * _ };
        })(this.font, !0).lineNoGap;
      }
      if (r = Y1(this.ui[oe]()), S += r.w, R += r.h, this.caption) {
        const { w: x, h: N, isBroken: U } = this.caption[oe](t);
        if (U && this[HA]()[is]()) return this[Fe](), Yt.FAILURE;
        switch (b = x, D = N, this.caption.placement) {
          case "left":
          case "right":
          case "inline":
            b += S;
            break;
          case "top":
          case "bottom":
            D += R;
        }
      } else b = S, D = R;
      b && this.w === "" && (b += n, this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < b ? b : this.minW)), D && this.h === "" && (D += o, this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < D ? D : this.minH));
    }
    if (this[Fe](), wg(this), Sg(this), !bg(this, t)) return this.w = i, this.h = s, this[Fe](), Yt.FAILURE;
    Fg(this);
    const c = ye(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
    tf(this, c);
    const h = ["xfaField"];
    this.font && h.push("xfaFont"), on(this) && h.push("xfaPrintOnly");
    const I = { style: c, id: this[CA], class: h };
    c.margin && (c.padding = c.margin, delete c.margin), Zl(this, h), this.name && (I.xfaName = this.name);
    const C = [], d = { name: "div", attributes: I, children: C };
    kg(this, I);
    const u = this.border ? this.border[gA]() : null, E = Af(this, d, t), p = this.ui[Tt]().html;
    if (!p) return Object.assign(c, u), Yt.success(ca(this, d), E);
    this[ci] && (p.children?.[0] ? p.children[0].attributes.tabindex = this[ci] : p.attributes.tabindex = this[ci]), p.attributes.style || (p.attributes.style = /* @__PURE__ */ Object.create(null));
    let y = null;
    if (this.ui.button ? (p.children.length === 1 && ([y] = p.children.splice(0, 1)), Object.assign(p.attributes.style, u)) : Object.assign(c, u), C.push(p), this.value) {
      if (this.ui.imageEdit) p.children.push(this.value[Tt]().html);
      else if (!this.ui.button) {
        let b = "";
        if (this.value.exData) b = this.value.exData[OA]();
        else if (this.value.text) b = this.value.text[oe]();
        else {
          const D = this.value[Tt]().html;
          D !== null && (b = D.children[0].value);
        }
        this.ui.textEdit && this.value.text?.maxChars && (p.children[0].attributes.maxLength = this.value.text.maxChars), b && (this.ui.numericEdit && (b = parseFloat(b), b = isNaN(b) ? "" : b.toString()), p.children[0].name === "textarea" ? p.children[0].attributes.textContent = b : p.children[0].attributes.value = b);
      }
    }
    if (!this.ui.imageEdit && p.children?.[0] && this.h) {
      r = r || Y1(this.ui[oe]());
      let b = 0;
      if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
        b = this.caption.reserve, b <= 0 && (b = this.caption[oe](t).h);
        const D = this.h - b - o - r.h;
        p.children[0].attributes.style.height = _t(D);
      } else p.children[0].attributes.style.height = "100%";
    }
    if (y && p.children.push(y), !e) return p.attributes.class && p.attributes.class.push("xfaLeft"), this.w = i, this.h = s, Yt.success(ca(this, d), E);
    if (this.ui.button) return c.padding && delete c.padding, e.name === "div" && (e.name = "span"), p.children.push(e), Yt.success(d, E);
    switch (this.ui.checkButton && (e.attributes.class[0] = "xfaCaptionForCheckButton"), p.attributes.class || (p.attributes.class = []), p.children.splice(0, 0, e), this.caption.placement) {
      case "left":
      case "inline":
        p.attributes.class.push("xfaLeft");
        break;
      case "right":
        p.attributes.class.push("xfaRight");
        break;
      case "top":
        p.attributes.class.push("xfaTop");
        break;
      case "bottom":
        p.attributes.class.push("xfaBottom");
    }
    return this.w = i, this.h = s, Yt.success(ca(this, d), E);
  }
}
class s6 extends gt {
  constructor(t) {
    super(wt, "fill", !0), this.id = t.id || "", this.presence = Et(t.presence, ["visible", "hidden", "inactive", "invisible"]), this.use = t.use || "", this.usehref = t.usehref || "", this.color = null, this.extras = null, this.linear = null, this.pattern = null, this.radial = null, this.solid = null, this.stipple = null;
  }
  [gA]() {
    const t = this[jt](), e = t[jt]()[jt](), i = /* @__PURE__ */ Object.create(null);
    let s = "color", n = s;
    t instanceof Cf && (s = "background-color", n = "background", e instanceof iI && (i.backgroundColor = "white")), (t instanceof wf || t instanceof If) && (s = n = "fill", i.fill = "white");
    for (const o of Object.getOwnPropertyNames(this)) {
      if (o === "extras" || o === "color") continue;
      const r = this[o];
      if (!(r instanceof gt)) continue;
      const c = r[gA](this.color);
      return c && (i[c.startsWith("#") ? s : n] = c), i;
    }
    if (this.color?.value) {
      const o = this.color[gA]();
      i[o.startsWith("#") ? s : n] = o;
    }
    return i;
  }
}
class a6 extends gt {
  constructor(t) {
    super(wt, "filter", !0), this.addRevocationInfo = Et(t.addRevocationInfo, ["", "required", "optional", "none"]), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "", this.version = Ot({ data: this.version, defaultValue: 5, validate: (e) => e >= 1 && e <= 5 }), this.appearanceFilter = null, this.certificates = null, this.digestMethods = null, this.encodings = null, this.encryptionMethods = null, this.handler = null, this.lockDocument = null, this.mdp = null, this.reasons = null, this.timeStamp = null;
  }
}
class n6 extends xA {
  constructor(t) {
    super(wt, "float"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
  [fA]() {
    const t = parseFloat(this[Qt].trim());
    this[Qt] = isNaN(t) ? null : t;
  }
  [Tt](t) {
    return Ls(this[Qt] !== null ? this[Qt].toString() : "");
  }
}
class r6 extends gt {
  constructor(t) {
    super(wt, "font", !0), this.baselineShift = Nt(t.baselineShift), this.fontHorizontalScale = $o({ data: t.fontHorizontalScale, defaultValue: 100, validate: (e) => e >= 0 }), this.fontVerticalScale = $o({ data: t.fontVerticalScale, defaultValue: 100, validate: (e) => e >= 0 }), this.id = t.id || "", this.kerningMode = Et(t.kerningMode, ["none", "pair"]), this.letterSpacing = Nt(t.letterSpacing, "0"), this.lineThrough = Ot({ data: t.lineThrough, defaultValue: 0, validate: (e) => e === 1 || e === 2 }), this.lineThroughPeriod = Et(t.lineThroughPeriod, ["all", "word"]), this.overline = Ot({ data: t.overline, defaultValue: 0, validate: (e) => e === 1 || e === 2 }), this.overlinePeriod = Et(t.overlinePeriod, ["all", "word"]), this.posture = Et(t.posture, ["normal", "italic"]), this.size = Nt(t.size, "10pt"), this.typeface = t.typeface || "Courier", this.underline = Ot({ data: t.underline, defaultValue: 0, validate: (e) => e === 1 || e === 2 }), this.underlinePeriod = Et(t.underlinePeriod, ["all", "word"]), this.use = t.use || "", this.usehref = t.usehref || "", this.weight = Et(t.weight, ["normal", "bold"]), this.extras = null, this.fill = null;
  }
  [si](t) {
    super[si](t), this[QA].usedTypefaces.add(this.typeface);
  }
  [gA]() {
    const t = ye(this, "fill"), e = t.color;
    return e && (e === "#000000" ? delete t.color : e.startsWith("#") || (t.background = e, t.backgroundClip = "text", t.color = "transparent")), this.baselineShift && (t.verticalAlign = _t(this.baselineShift)), t.fontKerning = this.kerningMode === "none" ? "none" : "normal", t.letterSpacing = _t(this.letterSpacing), this.lineThrough !== 0 && (t.textDecoration = "line-through", this.lineThrough === 2 && (t.textDecorationStyle = "double")), this.overline !== 0 && (t.textDecoration = "overline", this.overline === 2 && (t.textDecorationStyle = "double")), t.fontStyle = this.posture, t.fontSize = _t(0.99 * this.size), rf(this, this, this[QA].fontFinder, t), this.underline !== 0 && (t.textDecoration = "underline", this.underline === 2 && (t.textDecorationStyle = "double")), t.fontWeight = this.weight, t;
  }
}
class o6 extends gt {
  constructor(t) {
    super(wt, "format", !0), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null, this.picture = null;
  }
}
class g6 extends iA {
  constructor(t) {
    super(wt, "handler"), this.id = t.id || "", this.type = Et(t.type, ["optional", "required"]), this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class c6 extends gt {
  constructor(t) {
    super(wt, "hyphenation"), this.excludeAllCaps = Ot({ data: t.excludeAllCaps, defaultValue: 0, validate: (e) => e === 1 }), this.excludeInitialCap = Ot({ data: t.excludeInitialCap, defaultValue: 0, validate: (e) => e === 1 }), this.hyphenate = Ot({ data: t.hyphenate, defaultValue: 0, validate: (e) => e === 1 }), this.id = t.id || "", this.pushCharacterCount = Ot({ data: t.pushCharacterCount, defaultValue: 3, validate: (e) => e >= 0 }), this.remainCharacterCount = Ot({ data: t.remainCharacterCount, defaultValue: 3, validate: (e) => e >= 0 }), this.use = t.use || "", this.usehref = t.usehref || "", this.wordCharacterCount = Ot({ data: t.wordCharacterCount, defaultValue: 7, validate: (e) => e >= 0 });
  }
}
let mf = class extends iA {
  constructor(A) {
    super(wt, "image"), this.aspect = Et(A.aspect, ["fit", "actual", "height", "none", "width"]), this.contentType = A.contentType || "", this.href = A.href || "", this.id = A.id || "", this.name = A.name || "", this.transferEncoding = Et(A.transferEncoding, ["base64", "none", "package"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [Tt]() {
    if (this.contentType && !fy.has(this.contentType.toLowerCase())) return Yt.EMPTY;
    let A = this[QA].images && this[QA].images.get(this.href);
    if (!A && (this.href || !this[Qt]) || (A || this.transferEncoding !== "base64" || (A = re(atob(this[Qt]))), !A)) return Yt.EMPTY;
    if (!this.contentType) {
      for (const [s, n] of py) if (A.length > s.length && s.every(((o, r) => o === A[r]))) {
        this.contentType = n;
        break;
      }
      if (!this.contentType) return Yt.EMPTY;
    }
    const t = new Blob([A], { type: this.contentType });
    let e;
    switch (this.aspect) {
      case "fit":
      case "actual":
        break;
      case "height":
        e = { height: "100%", objectFit: "fill" };
        break;
      case "none":
        e = { width: "100%", height: "100%", objectFit: "fill" };
        break;
      case "width":
        e = { width: "100%", objectFit: "fill" };
    }
    const i = this[jt]();
    return Yt.success({ name: "img", attributes: { class: ["xfaImage"], style: e, src: URL.createObjectURL(t), alt: i ? Ia(i[jt]()) : null } });
  }
};
class h6 extends gt {
  constructor(t) {
    super(wt, "imageEdit", !0), this.data = Et(t.data, ["link", "embed"]), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
  [Tt](t) {
    return this.data === "embed" ? Yt.success({ name: "div", children: [], attributes: {} }) : Yt.EMPTY;
  }
}
class l6 extends xA {
  constructor(t) {
    super(wt, "integer"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
  [fA]() {
    const t = parseInt(this[Qt].trim(), 10);
    this[Qt] = isNaN(t) ? null : t;
  }
  [Tt](t) {
    return Ls(this[Qt] !== null ? this[Qt].toString() : "");
  }
}
class I6 extends gt {
  constructor(t) {
    super(wt, "issuers", !0), this.id = t.id || "", this.type = Et(t.type, ["optional", "required"]), this.use = t.use || "", this.usehref = t.usehref || "", this.certificate = new P();
  }
}
class el extends gt {
  constructor(t) {
    super(wt, "items", !0), this.id = t.id || "", this.name = t.name || "", this.presence = Et(t.presence, ["visible", "hidden", "inactive", "invisible"]), this.ref = t.ref || "", this.save = Ot({ data: t.save, defaultValue: 0, validate: (e) => e === 1 }), this.use = t.use || "", this.usehref = t.usehref || "", this.boolean = new P(), this.date = new P(), this.dateTime = new P(), this.decimal = new P(), this.exData = new P(), this.float = new P(), this.image = new P(), this.integer = new P(), this.text = new P(), this.time = new P();
  }
  [Tt]() {
    const t = [];
    for (const e of this[ee]()) t.push(e[OA]());
    return Yt.success(t);
  }
}
class C6 extends gt {
  constructor(t) {
    super(wt, "keep", !0), this.id = t.id || "";
    const e = ["none", "contentArea", "pageArea"];
    this.intact = Et(t.intact, e), this.next = Et(t.next, e), this.previous = Et(t.previous, e), this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null;
  }
}
class u6 extends gt {
  constructor(t) {
    super(wt, "keyUsage");
    const e = ["", "yes", "no"];
    this.crlSign = Et(t.crlSign, e), this.dataEncipherment = Et(t.dataEncipherment, e), this.decipherOnly = Et(t.decipherOnly, e), this.digitalSignature = Et(t.digitalSignature, e), this.encipherOnly = Et(t.encipherOnly, e), this.id = t.id || "", this.keyAgreement = Et(t.keyAgreement, e), this.keyCertSign = Et(t.keyCertSign, e), this.keyEncipherment = Et(t.keyEncipherment, e), this.nonRepudiation = Et(t.nonRepudiation, e), this.type = Et(t.type, ["optional", "required"]), this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class B6 extends gt {
  constructor(t) {
    super(wt, "line", !0), this.hand = Et(t.hand, ["even", "left", "right"]), this.id = t.id || "", this.slope = Et(t.slope, ["\\", "/"]), this.use = t.use || "", this.usehref = t.usehref || "", this.edge = null;
  }
  [Tt]() {
    const t = this[jt]()[jt](), e = this.edge || new Fr({}), i = e[gA](), s = /* @__PURE__ */ Object.create(null), n = e.presence === "visible" ? e.thickness : 0;
    let o, r, c, h;
    s.strokeWidth = _t(n), s.stroke = i.color;
    let I = "100%", C = "100%";
    t.w <= n ? ([o, r, c, h] = ["50%", 0, "50%", "100%"], I = s.strokeWidth) : t.h <= n ? ([o, r, c, h] = [0, "50%", "100%", "50%"], C = s.strokeWidth) : this.slope === "\\" ? [o, r, c, h] = [0, 0, "100%", "100%"] : [o, r, c, h] = [0, "100%", "100%", 0];
    const d = { name: "svg", children: [{ name: "line", attributes: { xmlns: ha, x1: o, y1: r, x2: c, y2: h, style: s } }], attributes: { xmlns: ha, width: I, height: C, style: { overflow: "visible" } } };
    return Vl(t) ? Yt.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [d] }) : (d.attributes.style.position = "absolute", Yt.success(d));
  }
}
class d6 extends gt {
  constructor(t) {
    super(wt, "linear", !0), this.id = t.id || "", this.type = Et(t.type, ["toRight", "toBottom", "toLeft", "toTop"]), this.use = t.use || "", this.usehref = t.usehref || "", this.color = null, this.extras = null;
  }
  [gA](t) {
    return t = t ? t[gA]() : "#FFFFFF", `linear-gradient(${this.type.replace(/([RBLT])/, " $1").toLowerCase()}, ${t}, ${this.color ? this.color[gA]() : "#000000"})`;
  }
}
class Q6 extends xA {
  constructor(t) {
    super(wt, "lockDocument"), this.id = t.id || "", this.type = Et(t.type, ["optional", "required"]), this.use = t.use || "", this.usehref = t.usehref || "";
  }
  [fA]() {
    this[Qt] = Et(this[Qt], ["auto", "0", "1"]);
  }
}
class E6 extends gt {
  constructor(t) {
    super(wt, "manifest", !0), this.action = Et(t.action, ["include", "all", "exclude"]), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null, this.ref = new P();
  }
}
class f6 extends gt {
  constructor(t) {
    super(wt, "margin", !0), this.bottomInset = Nt(t.bottomInset, "0"), this.id = t.id || "", this.leftInset = Nt(t.leftInset, "0"), this.rightInset = Nt(t.rightInset, "0"), this.topInset = Nt(t.topInset, "0"), this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null;
  }
  [gA]() {
    return { margin: _t(this.topInset) + " " + _t(this.rightInset) + " " + _t(this.bottomInset) + " " + _t(this.leftInset) };
  }
}
class p6 extends gt {
  constructor(t) {
    super(wt, "mdp"), this.id = t.id || "", this.permissions = Ot({ data: t.permissions, defaultValue: 2, validate: (e) => e === 1 || e === 3 }), this.signatureType = Et(t.signatureType, ["filler", "author"]), this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class m6 extends gt {
  constructor(t) {
    super(wt, "medium"), this.id = t.id || "", this.imagingBBox = (function(e) {
      if (!e) return { x: -1, y: -1, width: -1, height: -1 };
      const s = e.trim().split(/\s*,\s*/).map(((h) => Nt(h, "-1")));
      if (s.length < 4 || s[2] < 0 || s[3] < 0) return { x: -1, y: -1, width: -1, height: -1 };
      const [n, o, r, c] = s;
      return { x: n, y: o, width: r, height: c };
    })(t.imagingBBox), this.long = Nt(t.long), this.orientation = Et(t.orientation, ["portrait", "landscape"]), this.short = Nt(t.short), this.stock = t.stock || "", this.trayIn = Et(t.trayIn, ["auto", "delegate", "pageFront"]), this.trayOut = Et(t.trayOut, ["auto", "delegate"]), this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class y6 extends gt {
  constructor(t) {
    super(wt, "message", !0), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "", this.text = new P();
  }
}
class w6 extends gt {
  constructor(t) {
    super(wt, "numericEdit", !0), this.hScrollPolicy = Et(t.hScrollPolicy, ["auto", "off", "on"]), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
  }
  [Tt](t) {
    const e = ye(this, "border", "font", "margin"), i = this[jt]()[jt](), s = { name: "input", attributes: { type: "text", fieldId: i[CA], dataId: i[ii]?.[CA] || i[CA], class: ["xfaTextfield"], style: e, "aria-label": Ia(i), "aria-required": !1 } };
    return Sr(i) && (s.attributes["aria-required"] = !0, s.attributes.required = !0), Yt.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [s] });
  }
}
class b6 extends gt {
  constructor(t) {
    super(wt, "occur", !0), this.id = t.id || "", this.initial = t.initial !== "" ? Ot({ data: t.initial, defaultValue: "", validate: (e) => !0 }) : "", this.max = t.max !== "" ? Ot({ data: t.max, defaultValue: 1, validate: (e) => !0 }) : "", this.min = t.min !== "" ? Ot({ data: t.min, defaultValue: 1, validate: (e) => !0 }) : "", this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null;
  }
  [si]() {
    const t = this[jt](), e = this.min;
    this.min === "" && (this.min = t instanceof An || t instanceof Er ? 0 : 1), this.max === "" && (this.max = e === "" ? t instanceof An || t instanceof Er ? -1 : 1 : this.min), this.max !== -1 && this.max < this.min && (this.max = this.min), this.initial === "" && (this.initial = t instanceof eI ? 1 : this.min);
  }
}
class D6 extends iA {
  constructor(t) {
    super(wt, "oid"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class k6 extends gt {
  constructor(t) {
    super(wt, "oids", !0), this.id = t.id || "", this.type = Et(t.type, ["optional", "required"]), this.use = t.use || "", this.usehref = t.usehref || "", this.oid = new P();
  }
}
class yf extends gt {
  constructor(t) {
    super(wt, "overflow"), this.id = t.id || "", this.leader = t.leader || "", this.target = t.target || "", this.trailer = t.trailer || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
  [oe]() {
    if (!this[nt]) {
      const t = this[jt](), e = this[LA](), i = e[ji](this.target, t), s = e[ji](this.leader, t), n = e[ji](this.trailer, t);
      this[nt] = { target: i?.[0] || null, leader: s?.[0] || null, trailer: n?.[0] || null, addLeader: !1, addTrailer: !1 };
    }
    return this[nt];
  }
}
class An extends gt {
  constructor(t) {
    super(wt, "pageArea", !0), this.blankOrNotBlank = Et(t.blankOrNotBlank, ["any", "blank", "notBlank"]), this.id = t.id || "", this.initialNumber = Ot({ data: t.initialNumber, defaultValue: 1, validate: (e) => !0 }), this.name = t.name || "", this.numbered = Ot({ data: t.numbered, defaultValue: 1, validate: (e) => !0 }), this.oddOrEven = Et(t.oddOrEven, ["any", "even", "odd"]), this.pagePosition = Et(t.pagePosition, ["any", "first", "last", "only", "rest"]), this.relevant = di(t.relevant), this.use = t.use || "", this.usehref = t.usehref || "", this.desc = null, this.extras = null, this.medium = null, this.occur = null, this.area = new P(), this.contentArea = new P(), this.draw = new P(), this.exclGroup = new P(), this.field = new P(), this.subform = new P();
  }
  [Qr]() {
    return this[nt] ? !this.occur || this.occur.max === -1 || this[nt].numberOfUse < this.occur.max : (this[nt] = { numberOfUse: 0 }, !0);
  }
  [Ya]() {
    delete this[nt];
  }
  [qi]() {
    this[nt] || (this[nt] = { numberOfUse: 0 });
    const t = this[jt]();
    return t.relation === "orderedOccurrence" && this[Qr]() ? (this[nt].numberOfUse += 1, this) : t[qi]();
  }
  [ga]() {
    return this[nt].space || { width: 0, height: 0 };
  }
  [Tt]() {
    this[nt] || (this[nt] = { numberOfUse: 1 });
    const t = [];
    this[nt].children = t;
    const e = /* @__PURE__ */ Object.create(null);
    if (this.medium && this.medium.short && this.medium.long) {
      if (e.width = _t(this.medium.short), e.height = _t(this.medium.long), this[nt].space = { width: this.medium.short, height: this.medium.long }, this.medium.orientation === "landscape") {
        const i = e.width;
        e.width = e.height, e.height = i, this[nt].space = { width: this.medium.long, height: this.medium.short };
      }
    } else O("XFA - No medium specified in pageArea: please file a bug.");
    return this[Ms]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]), include: !0 }), this[Ms]({ filter: /* @__PURE__ */ new Set(["contentArea"]), include: !0 }), Yt.success({ name: "div", children: t, attributes: { class: ["xfaPage"], id: this[CA], style: e, xfaName: this.name } });
  }
}
class Er extends gt {
  constructor(t) {
    super(wt, "pageSet", !0), this.duplexImposition = Et(t.duplexImposition, ["longEdge", "shortEdge"]), this.id = t.id || "", this.name = t.name || "", this.relation = Et(t.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]), this.relevant = di(t.relevant), this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null, this.occur = null, this.pageArea = new P(), this.pageSet = new P();
  }
  [Ya]() {
    for (const t of this.pageArea.children) t[Ya]();
    for (const t of this.pageSet.children) t[Ya]();
  }
  [Qr]() {
    return !this.occur || this.occur.max === -1 || this[nt].numberOfUse < this.occur.max;
  }
  [qi]() {
    if (this[nt] || (this[nt] = { numberOfUse: 1, pageIndex: -1, pageSetIndex: -1 }), this.relation === "orderedOccurrence") {
      if (this[nt].pageIndex + 1 < this.pageArea.children.length)
        return this[nt].pageIndex += 1, this.pageArea.children[this[nt].pageIndex][qi]();
      if (this[nt].pageSetIndex + 1 < this.pageSet.children.length) return this[nt].pageSetIndex += 1, this.pageSet.children[this[nt].pageSetIndex][qi]();
      if (this[Qr]()) return this[nt].numberOfUse += 1, this[nt].pageIndex = -1, this[nt].pageSetIndex = -1, this[qi]();
      const n = this[jt]();
      return n instanceof Er ? n[qi]() : (this[Ya](), this[qi]());
    }
    const t = this[LA]()[nt].pageNumber, e = t % 2 == 0 ? "even" : "odd", i = t === 0 ? "first" : "rest";
    let s = this.pageArea.children.find(((n) => n.oddOrEven === e && n.pagePosition === i));
    return s || (s = this.pageArea.children.find(((n) => n.oddOrEven === "any" && n.pagePosition === i)), s || (s = this.pageArea.children.find(((n) => n.oddOrEven === "any" && n.pagePosition === "any")), s || this.pageArea.children[0]));
  }
}
class S6 extends gt {
  constructor(t) {
    super(wt, "para", !0), this.hAlign = Et(t.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = t.id || "", this.lineHeight = t.lineHeight ? Nt(t.lineHeight, "0pt") : "", this.marginLeft = t.marginLeft ? Nt(t.marginLeft, "0pt") : "", this.marginRight = t.marginRight ? Nt(t.marginRight, "0pt") : "", this.orphans = Ot({ data: t.orphans, defaultValue: 0, validate: (e) => e >= 0 }), this.preserve = t.preserve || "", this.radixOffset = t.radixOffset ? Nt(t.radixOffset, "0pt") : "", this.spaceAbove = t.spaceAbove ? Nt(t.spaceAbove, "0pt") : "", this.spaceBelow = t.spaceBelow ? Nt(t.spaceBelow, "0pt") : "", this.tabDefault = t.tabDefault ? Nt(this.tabDefault) : "", this.tabStops = (t.tabStops || "").trim().split(/\s+/).map(((e, i) => i % 2 == 1 ? Nt(e) : e)), this.textIndent = t.textIndent ? Nt(t.textIndent, "0pt") : "", this.use = t.use || "", this.usehref = t.usehref || "", this.vAlign = Et(t.vAlign, ["top", "bottom", "middle"]), this.widows = Ot({ data: t.widows, defaultValue: 0, validate: (e) => e >= 0 }), this.hyphenation = null;
  }
  [gA]() {
    const t = ye(this, "hAlign");
    return this.marginLeft !== "" && (t.paddingLeft = _t(this.marginLeft)), this.marginRight !== "" && (t.paddingight = _t(this.marginRight)), this.spaceAbove !== "" && (t.paddingTop = _t(this.spaceAbove)), this.spaceBelow !== "" && (t.paddingBottom = _t(this.spaceBelow)), this.textIndent !== "" && (t.textIndent = _t(this.textIndent), sf(t)), this.lineHeight > 0 && (t.lineHeight = _t(this.lineHeight)), this.tabDefault !== "" && (t.tabSize = _t(this.tabDefault)), this.tabStops.length, this.hyphenatation && Object.assign(t, this.hyphenatation[gA]()), t;
  }
}
class F6 extends gt {
  constructor(t) {
    super(wt, "passwordEdit", !0), this.hScrollPolicy = Et(t.hScrollPolicy, ["auto", "off", "on"]), this.id = t.id || "", this.passwordChar = t.passwordChar || "*", this.use = t.use || "", this.usehref = t.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
}
class R6 extends gt {
  constructor(t) {
    super(wt, "pattern", !0), this.id = t.id || "", this.type = Et(t.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]), this.use = t.use || "", this.usehref = t.usehref || "", this.color = null, this.extras = null;
  }
  [gA](t) {
    t = t ? t[gA]() : "#FFFFFF";
    const e = this.color ? this.color[gA]() : "#000000", i = "repeating-linear-gradient", s = `${t},${t} 5px,${e} 5px,${e} 10px`;
    switch (this.type) {
      case "crossHatch":
        return `${i}(to top,${s}) ${i}(to right,${s})`;
      case "crossDiagonal":
        return `${i}(45deg,${s}) ${i}(-45deg,${s})`;
      case "diagonalLeft":
        return `${i}(45deg,${s})`;
      case "diagonalRight":
        return `${i}(-45deg,${s})`;
      case "horizontal":
        return `${i}(to top,${s})`;
      case "vertical":
        return `${i}(to right,${s})`;
    }
    return "";
  }
}
class x6 extends iA {
  constructor(t) {
    super(wt, "picture"), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class N6 extends gt {
  constructor(t) {
    super(wt, "proto", !0), this.appearanceFilter = new P(), this.arc = new P(), this.area = new P(), this.assist = new P(), this.barcode = new P(), this.bindItems = new P(), this.bookend = new P(), this.boolean = new P(), this.border = new P(), this.break = new P(), this.breakAfter = new P(), this.breakBefore = new P(), this.button = new P(), this.calculate = new P(), this.caption = new P(), this.certificate = new P(), this.certificates = new P(), this.checkButton = new P(), this.choiceList = new P(), this.color = new P(), this.comb = new P(), this.connect = new P(), this.contentArea = new P(), this.corner = new P(), this.date = new P(), this.dateTime = new P(), this.dateTimeEdit = new P(), this.decimal = new P(), this.defaultUi = new P(), this.desc = new P(), this.digestMethod = new P(), this.digestMethods = new P(), this.draw = new P(), this.edge = new P(), this.encoding = new P(), this.encodings = new P(), this.encrypt = new P(), this.encryptData = new P(), this.encryption = new P(), this.encryptionMethod = new P(), this.encryptionMethods = new P(), this.event = new P(), this.exData = new P(), this.exObject = new P(), this.exclGroup = new P(), this.execute = new P(), this.extras = new P(), this.field = new P(), this.fill = new P(), this.filter = new P(), this.float = new P(), this.font = new P(), this.format = new P(), this.handler = new P(), this.hyphenation = new P(), this.image = new P(), this.imageEdit = new P(), this.integer = new P(), this.issuers = new P(), this.items = new P(), this.keep = new P(), this.keyUsage = new P(), this.line = new P(), this.linear = new P(), this.lockDocument = new P(), this.manifest = new P(), this.margin = new P(), this.mdp = new P(), this.medium = new P(), this.message = new P(), this.numericEdit = new P(), this.occur = new P(), this.oid = new P(), this.oids = new P(), this.overflow = new P(), this.pageArea = new P(), this.pageSet = new P(), this.para = new P(), this.passwordEdit = new P(), this.pattern = new P(), this.picture = new P(), this.radial = new P(), this.reason = new P(), this.reasons = new P(), this.rectangle = new P(), this.ref = new P(), this.script = new P(), this.setProperty = new P(), this.signData = new P(), this.signature = new P(), this.signing = new P(), this.solid = new P(), this.speak = new P(), this.stipple = new P(), this.subform = new P(), this.subformSet = new P(), this.subjectDN = new P(), this.subjectDNs = new P(), this.submit = new P(), this.text = new P(), this.textEdit = new P(), this.time = new P(), this.timeStamp = new P(), this.toolTip = new P(), this.traversal = new P(), this.traverse = new P(), this.ui = new P(), this.validate = new P(), this.value = new P(), this.variables = new P();
  }
}
class G6 extends gt {
  constructor(t) {
    super(wt, "radial", !0), this.id = t.id || "", this.type = Et(t.type, ["toEdge", "toCenter"]), this.use = t.use || "", this.usehref = t.usehref || "", this.color = null, this.extras = null;
  }
  [gA](t) {
    t = t ? t[gA]() : "#FFFFFF";
    const e = this.color ? this.color[gA]() : "#000000";
    return `radial-gradient(circle at center, ${this.type === "toEdge" ? `${t},${e}` : `${e},${t}`})`;
  }
}
class v6 extends iA {
  constructor(t) {
    super(wt, "reason"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class M6 extends gt {
  constructor(t) {
    super(wt, "reasons", !0), this.id = t.id || "", this.type = Et(t.type, ["optional", "required"]), this.use = t.use || "", this.usehref = t.usehref || "", this.reason = new P();
  }
}
class wf extends gt {
  constructor(t) {
    super(wt, "rectangle", !0), this.hand = Et(t.hand, ["even", "left", "right"]), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "", this.corner = new P(4), this.edge = new P(4), this.fill = null;
  }
  [Tt]() {
    const t = this.edge.children.length ? this.edge.children[0] : new Fr({}), e = t[gA](), i = /* @__PURE__ */ Object.create(null);
    this.fill?.presence === "visible" ? Object.assign(i, this.fill[gA]()) : i.fill = "transparent", i.strokeWidth = _t(t.presence === "visible" ? t.thickness : 0), i.stroke = e.color;
    const s = (this.corner.children.length ? this.corner.children[0] : new Ef({}))[gA](), n = { name: "svg", children: [{ name: "rect", attributes: { xmlns: ha, width: "100%", height: "100%", x: 0, y: 0, rx: s.radius, ry: s.radius, style: i } }], attributes: { xmlns: ha, style: { overflow: "visible" }, width: "100%", height: "100%" } };
    return Vl(this[jt]()[jt]()) ? Yt.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [n] }) : (n.attributes.style.position = "absolute", Yt.success(n));
  }
}
class L6 extends iA {
  constructor(t) {
    super(wt, "ref"), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class U6 extends iA {
  constructor(t) {
    super(wt, "script"), this.binding = t.binding || "", this.contentType = t.contentType || "", this.id = t.id || "", this.name = t.name || "", this.runAt = Et(t.runAt, ["client", "both", "server"]), this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class il extends gt {
  constructor(t) {
    super(wt, "setProperty"), this.connection = t.connection || "", this.ref = t.ref || "", this.target = t.target || "";
  }
}
class H6 extends gt {
  constructor(t) {
    super(wt, "signData", !0), this.id = t.id || "", this.operation = Et(t.operation, ["sign", "clear", "verify"]), this.ref = t.ref || "", this.target = t.target || "", this.use = t.use || "", this.usehref = t.usehref || "", this.filter = null, this.manifest = null;
  }
}
class J6 extends gt {
  constructor(t) {
    super(wt, "signature", !0), this.id = t.id || "", this.type = Et(t.type, ["PDF1.3", "PDF1.6"]), this.use = t.use || "", this.usehref = t.usehref || "", this.border = null, this.extras = null, this.filter = null, this.manifest = null, this.margin = null;
  }
}
class Y6 extends gt {
  constructor(t) {
    super(wt, "signing", !0), this.id = t.id || "", this.type = Et(t.type, ["optional", "required"]), this.use = t.use || "", this.usehref = t.usehref || "", this.certificate = new P();
  }
}
class T6 extends gt {
  constructor(t) {
    super(wt, "solid", !0), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null;
  }
  [gA](t) {
    return t ? t[gA]() : "#FFFFFF";
  }
}
class K6 extends iA {
  constructor(t) {
    super(wt, "speak"), this.disable = Ot({ data: t.disable, defaultValue: 0, validate: (e) => e === 1 }), this.id = t.id || "", this.priority = Et(t.priority, ["custom", "caption", "name", "toolTip"]), this.rid = t.rid || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class q6 extends gt {
  constructor(t) {
    super(wt, "stipple", !0), this.id = t.id || "", this.rate = Ot({ data: t.rate, defaultValue: 50, validate: (e) => e >= 0 && e <= 100 }), this.use = t.use || "", this.usehref = t.usehref || "", this.color = null, this.extras = null;
  }
  [gA](t) {
    const e = this.rate / 100;
    return PA.makeHexColor(Math.round(t.value.r * (1 - e) + this.value.r * e), Math.round(t.value.g * (1 - e) + this.value.g * e), Math.round(t.value.b * (1 - e) + this.value.b * e));
  }
}
class bf extends gt {
  constructor(t) {
    super(wt, "subform", !0), this.access = Et(t.access, ["open", "nonInteractive", "protected", "readOnly"]), this.allowMacro = Ot({ data: t.allowMacro, defaultValue: 0, validate: (e) => e === 1 }), this.anchorType = Et(t.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = Ot({ data: t.colSpan, defaultValue: 1, validate: (e) => e >= 1 || e === -1 }), this.columnWidths = (t.columnWidths || "").trim().split(/\s+/).map(((e) => e === "-1" ? -1 : Nt(e))), this.h = t.h ? Nt(t.h) : "", this.hAlign = Et(t.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = t.id || "", this.layout = Et(t.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.locale = t.locale || "", this.maxH = Nt(t.maxH, "0pt"), this.maxW = Nt(t.maxW, "0pt"), this.mergeMode = Et(t.mergeMode, ["consumeData", "matchTemplate"]), this.minH = Nt(t.minH, "0pt"), this.minW = Nt(t.minW, "0pt"), this.name = t.name || "", this.presence = Et(t.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = di(t.relevant), this.restoreState = Et(t.restoreState, ["manual", "auto"]), this.scope = Et(t.scope, ["name", "none"]), this.use = t.use || "", this.usehref = t.usehref || "", this.w = t.w ? Nt(t.w) : "", this.x = Nt(t.x, "0pt"), this.y = Nt(t.y, "0pt"), this.assist = null, this.bind = null, this.bookend = null, this.border = null, this.break = null, this.calculate = null, this.desc = null, this.extras = null, this.keep = null, this.margin = null, this.occur = null, this.overflow = null, this.pageSet = null, this.para = null, this.traversal = null, this.validate = null, this.variables = null, this.area = new P(), this.breakAfter = new P(), this.breakBefore = new P(), this.connect = new P(), this.draw = new P(), this.event = new P(), this.exObject = new P(), this.exclGroup = new P(), this.field = new P(), this.proto = new P(), this.setProperty = new P(), this.subform = new P(), this.subformSet = new P();
  }
  [HA]() {
    const t = this[jt]();
    return t instanceof AI ? t[HA]() : t;
  }
  [Ba]() {
    return !0;
  }
  [is]() {
    return this.layout.endsWith("-tb") && this[nt].attempt === 0 && this[nt].numberInLine > 0 || this[jt]()[is]();
  }
  *[tn]() {
    yield* zl(this);
  }
  [kr]() {
    return cf(this);
  }
  [oa](t, e) {
    hf(this, t, e);
  }
  [ga]() {
    return lf(this);
  }
  [zi]() {
    const t = this[HA]();
    return !!t[zi]() && (this[nt]._isSplittable !== void 0 ? this[nt]._isSplittable : this.layout === "position" || this.layout.includes("row") || this.keep && this.keep.intact !== "none" ? (this[nt]._isSplittable = !1, !1) : (!t.layout?.endsWith("-tb") || t[nt].numberInLine === 0) && (this[nt]._isSplittable = !0, !0));
  }
  [Tt](t) {
    if (Dg(this), this.break) {
      if (this.break.after !== "auto" || this.break.afterTarget !== "") {
        const R = new uf({ targetType: this.break.after, target: this.break.afterTarget, startNew: this.break.startNew.toString() });
        R[QA] = this[QA], this[FA](R), this.breakAfter.push(R);
      }
      if (this.break.before !== "auto" || this.break.beforeTarget !== "") {
        const R = new Bf({ targetType: this.break.before, target: this.break.beforeTarget, startNew: this.break.startNew.toString() });
        R[QA] = this[QA], this[FA](R), this.breakBefore.push(R);
      }
      if (this.break.overflowTarget !== "") {
        const R = new yf({ target: this.break.overflowTarget, leader: this.break.overflowLeader, trailer: this.break.overflowTrailer });
        R[QA] = this[QA], this[FA](R), this.overflow.push(R);
      }
      this[Rs](this.break), this.break = null;
    }
    if (this.presence === "hidden" || this.presence === "inactive") return Yt.EMPTY;
    if ((this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && O("XFA - Several breakBefore or breakAfter in subforms: please file a bug."), this.breakBefore.children.length >= 1) {
      const R = this.breakBefore.children[0];
      if (T1(R)) return Yt.breakNode(R);
    }
    if (this[nt]?.afterBreakAfter) return Yt.EMPTY;
    wg(this);
    const e = [], i = { id: this[CA], class: [] };
    Zl(this, i.class), this[nt] || (this[nt] = /* @__PURE__ */ Object.create(null)), Object.assign(this[nt], { children: e, line: null, attributes: i, attempt: 0, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, t.width), height: Math.min(this.h || 1 / 0, t.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
    const s = this[LA](), n = s[nt].noLayoutFailure, o = this[zi]();
    if (o || Sg(this), !bg(this, t)) return Yt.FAILURE;
    const r = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
    if (this.layout.includes("row")) {
      const R = this[HA]().columnWidths;
      Array.isArray(R) && R.length > 0 && (this[nt].columnWidths = R, this[nt].currentColumn = 0);
    }
    const c = ye(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), h = ["xfaSubform"], I = ef(this);
    if (I && h.push(I), i.style = c, i.class = h, this.name && (i.xfaName = this.name), this.overflow) {
      const R = this.overflow[oe]();
      R.addLeader && (R.addLeader = !1, K1(this, R.leader, t));
    }
    this[rn]();
    const C = this.layout === "lr-tb" || this.layout === "rl-tb", d = C ? 2 : 1;
    for (; this[nt].attempt < d; this[nt].attempt++) {
      C && this[nt].attempt === 1 && (this[nt].numberInLine = 0);
      const R = this[Ms]({ filter: r, include: !0 });
      if (R.success) break;
      if (R.isBreak()) return this[Fe](), R;
      if (C && this[nt].attempt === 0 && this[nt].numberInLine === 0 && !s[nt].noLayoutFailure) {
        this[nt].attempt = d;
        break;
      }
    }
    if (this[Fe](), o || Fg(this), s[nt].noLayoutFailure = n, this[nt].attempt === d) return this.overflow && (this[LA]()[nt].overflowNode = this.overflow), o || delete this[nt], Yt.FAILURE;
    if (this.overflow) {
      const R = this.overflow[oe]();
      R.addTrailer && (R.addTrailer = !1, K1(this, R.trailer, t));
    }
    let u = 0, E = 0;
    this.margin && (u = this.margin.leftInset + this.margin.rightInset, E = this.margin.topInset + this.margin.bottomInset);
    const p = Math.max(this[nt].width + u, this.w || 0), y = Math.max(this[nt].height + E, this.h || 0), b = [this.x, this.y, p, y];
    if (this.w === "" && (c.width = _t(p)), this.h === "" && (c.height = _t(y)), (c.width === "0px" || c.height === "0px") && e.length === 0) return Yt.EMPTY;
    const D = { name: "div", attributes: i, children: e };
    kg(this, i);
    const S = Yt.success(ca(this, D), b);
    if (this.breakAfter.children.length >= 1) {
      const R = this.breakAfter.children[0];
      if (T1(R)) return this[nt].afterBreakAfter = S, Yt.breakNode(R);
    }
    return delete this[nt], S;
  }
}
class AI extends gt {
  constructor(t) {
    super(wt, "subformSet", !0), this.id = t.id || "", this.name = t.name || "", this.relation = Et(t.relation, ["ordered", "choice", "unordered"]), this.relevant = di(t.relevant), this.use = t.use || "", this.usehref = t.usehref || "", this.bookend = null, this.break = null, this.desc = null, this.extras = null, this.occur = null, this.overflow = null, this.breakAfter = new P(), this.breakBefore = new P(), this.subform = new P(), this.subformSet = new P();
  }
  *[tn]() {
    yield* zl(this);
  }
  [HA]() {
    let t = this[jt]();
    for (; !(t instanceof bf); ) t = t[jt]();
    return t;
  }
  [Ba]() {
    return !0;
  }
}
class P6 extends xA {
  constructor(t) {
    super(wt, "subjectDN"), this.delimiter = t.delimiter || ",", this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
  [fA]() {
    this[Qt] = new Map(this[Qt].split(this.delimiter).map(((t) => ((t = t.split("=", 2))[0] = t[0].trim(), t))));
  }
}
class _6 extends gt {
  constructor(t) {
    super(wt, "subjectDNs", !0), this.id = t.id || "", this.type = Et(t.type, ["optional", "required"]), this.use = t.use || "", this.usehref = t.usehref || "", this.subjectDN = new P();
  }
}
class O6 extends gt {
  constructor(t) {
    super(wt, "submit", !0), this.embedPDF = Ot({ data: t.embedPDF, defaultValue: 0, validate: (e) => e === 1 }), this.format = Et(t.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]), this.id = t.id || "", this.target = t.target || "", this.textEncoding = yg({ data: t.textEncoding ? t.textEncoding.toLowerCase() : "", defaultValue: "", validate: (e) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e) || e.match(/iso-8859-\d{2}/) }), this.use = t.use || "", this.usehref = t.usehref || "", this.xdpContent = t.xdpContent || "", this.encrypt = null, this.encryptData = new P(), this.signData = new P();
  }
}
class eI extends gt {
  constructor(t) {
    super(wt, "template", !0), this.baseProfile = Et(t.baseProfile, ["full", "interactiveForms"]), this.extras = null, this.subform = new P();
  }
  [fA]() {
    this.subform.children.length === 0 && O("XFA - No subforms in template node."), this.subform.children.length >= 2 && O("XFA - Several subforms in template node: please file a bug."), this[ci] = 5e3;
  }
  [zi]() {
    return !0;
  }
  [ji](t, e) {
    return t.startsWith("#") ? [this[Ga].get(t.slice(1))] : ms(this, e, t, !0, !0);
  }
  *[ZE]() {
    if (!this.subform.children.length) return Yt.success({ name: "div", children: [] });
    this[nt] = { overflowNode: null, firstUnsplittable: null, currentContentArea: null, currentPageArea: null, noLayoutFailure: !1, pageNumber: 1, pagePosition: "first", oddOrEven: "odd", blankOrNotBlank: "nonBlank", paraStack: [] };
    const t = this.subform.children[0];
    t.pageSet[Ya]();
    const e = t.pageSet.pageArea.children, i = { name: "div", children: [] };
    let s = null, n = null, o = null;
    if (t.breakBefore.children.length >= 1 ? (n = t.breakBefore.children[0], o = n.target) : t.subform.children.length >= 1 && t.subform.children[0].breakBefore.children.length >= 1 ? (n = t.subform.children[0].breakBefore.children[0], o = n.target) : t.break?.beforeTarget ? (n = t.break, o = n.beforeTarget) : t.subform.children.length >= 1 && t.subform.children[0].break?.beforeTarget && (n = t.subform.children[0].break, o = n.beforeTarget), n) {
      const E = this[ji](o, n[jt]());
      E instanceof An && (s = E, n[nt] = {});
    }
    s || (s = e[0]), s[nt] = { numberOfUse: 1 };
    const r = s[jt]();
    let c;
    r[nt] = { numberOfUse: 1, pageIndex: r.pageArea.children.indexOf(s), pageSetIndex: 0 };
    let h = null, I = null, C = !0, d = 0, u = 0;
    for (; ; ) {
      if (C) d = 0;
      else if (i.children.pop(), ++d == 3) return O("XFA - Something goes wrong: please file a bug."), i;
      c = null, this[nt].currentPageArea = s;
      const E = s[Tt]().html;
      i.children.push(E), h && (this[nt].noLayoutFailure = !0, E.children.push(h[Tt](s[nt].space).html), h = null), I && (this[nt].noLayoutFailure = !0, E.children.push(I[Tt](s[nt].space).html), I = null);
      const p = s.contentArea.children, y = E.children.filter(((D) => D.attributes.class.includes("xfaContentarea")));
      C = !1, this[nt].firstUnsplittable = null, this[nt].noLayoutFailure = !1;
      const b = (D) => {
        const S = t[kr]();
        S && (C ||= S.children?.length > 0, y[D].children.push(S));
      };
      for (let D = u, S = p.length; D < S; D++) {
        const R = this[nt].currentContentArea = p[D], x = { width: R.w, height: R.h };
        u = 0, h && (y[D].children.push(h[Tt](x).html), h = null), I && (y[D].children.push(I[Tt](x).html), I = null);
        const N = t[Tt](x);
        if (N.success) return N.html ? (C ||= N.html.children?.length > 0, y[D].children.push(N.html)) : !C && i.children.length > 1 && i.children.pop(), i;
        if (N.isBreak()) {
          const U = N.breakNode;
          if (b(D), U.targetType === "auto") continue;
          U.leader && (h = this[ji](U.leader, U[jt]()), h = h ? h[0] : null), U.trailer && (I = this[ji](U.trailer, U[jt]()), I = I ? I[0] : null), U.targetType === "pageArea" ? (c = U[nt].target, D = 1 / 0) : U[nt].target ? (c = U[nt].target, u = U[nt].index + 1, D = 1 / 0) : D = U[nt].index;
        } else if (this[nt].overflowNode) {
          const U = this[nt].overflowNode;
          this[nt].overflowNode = null;
          const T = U[oe](), q = T.target;
          T.addLeader = T.leader !== null, T.addTrailer = T.trailer !== null, b(D);
          const _ = D;
          if (D = 1 / 0, q instanceof An) c = q;
          else if (q instanceof $l) {
            const Y = p.indexOf(q);
            Y !== -1 ? Y > _ ? D = Y - 1 : u = Y : (c = q[jt](), u = c.contentArea.children.indexOf(q));
          }
        } else b(D);
      }
      this[nt].pageNumber += 1, c && (c[Qr]() ? c[nt].numberOfUse += 1 : c = null), s = c || s[qi](), yield null;
    }
  }
}
class Df extends xA {
  constructor(t) {
    super(wt, "text"), this.id = t.id || "", this.maxChars = Ot({ data: t.maxChars, defaultValue: 0, validate: (e) => e >= 0 }), this.name = t.name || "", this.rid = t.rid || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
  [fg]() {
    return !0;
  }
  [Ni](t) {
    return t[UA] === JA.xhtml.id ? (this[Qt] = t, !0) : (O(`XFA - Invalid content in Text: ${t[hA]}.`), !1);
  }
  [$i](t) {
    this[Qt] instanceof gt || super[$i](t);
  }
  [fA]() {
    typeof this[Qt] == "string" && (this[Qt] = this[Qt].replaceAll(`\r
`, `
`));
  }
  [oe]() {
    return typeof this[Qt] == "string" ? this[Qt].split(/[\u2029\u2028\n]/).reduce(((t, e) => (e && t.push(e), t)), []).join(`
`) : this[Qt][OA]();
  }
  [Tt](t) {
    if (typeof this[Qt] == "string") {
      const e = Ls(this[Qt]).html;
      return this[Qt].includes("\u2029") ? (e.name = "div", e.children = [], this[Qt].split("\u2029").map(((i) => i.split(/[\u2028\n]/).reduce(((s, n) => (s.push({ name: "span", value: n }, { name: "br" }), s)), []))).forEach(((i) => {
        e.children.push({ name: "p", children: i });
      }))) : /[\u2028\n]/.test(this[Qt]) && (e.name = "div", e.children = [], this[Qt].split(/[\u2028\n]/).forEach(((i) => {
        e.children.push({ name: "span", value: i }, { name: "br" });
      }))), Yt.success(e);
    }
    return this[Qt][Tt](t);
  }
}
class kf extends gt {
  constructor(t) {
    super(wt, "textEdit", !0), this.allowRichText = Ot({ data: t.allowRichText, defaultValue: 0, validate: (e) => e === 1 }), this.hScrollPolicy = Et(t.hScrollPolicy, ["auto", "off", "on"]), this.id = t.id || "", this.multiLine = Ot({ data: t.multiLine, defaultValue: "", validate: (e) => e === 0 || e === 1 }), this.use = t.use || "", this.usehref = t.usehref || "", this.vScrollPolicy = Et(t.vScrollPolicy, ["auto", "off", "on"]), this.border = null, this.comb = null, this.extras = null, this.margin = null;
  }
  [Tt](t) {
    const e = ye(this, "border", "font", "margin");
    let i;
    const s = this[jt]()[jt]();
    return this.multiLine === "" && (this.multiLine = s instanceof ff ? 1 : 0), i = this.multiLine === 1 ? { name: "textarea", attributes: { dataId: s[ii]?.[CA] || s[CA], fieldId: s[CA], class: ["xfaTextfield"], style: e, "aria-label": Ia(s), "aria-required": !1 } } : { name: "input", attributes: { type: "text", dataId: s[ii]?.[CA] || s[CA], fieldId: s[CA], class: ["xfaTextfield"], style: e, "aria-label": Ia(s), "aria-required": !1 } }, Sr(s) && (i.attributes["aria-required"] = !0, i.attributes.required = !0), Yt.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [i] });
  }
}
class W6 extends iA {
  constructor(t) {
    super(wt, "time"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
  [fA]() {
    const t = this[Qt].trim();
    this[Qt] = t ? new Date(t) : null;
  }
  [Tt](t) {
    return Ls(this[Qt] ? this[Qt].toString() : "");
  }
}
class j6 extends gt {
  constructor(t) {
    super(wt, "timeStamp"), this.id = t.id || "", this.server = t.server || "", this.type = Et(t.type, ["optional", "required"]), this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class Z6 extends iA {
  constructor(t) {
    super(wt, "toolTip"), this.id = t.id || "", this.rid = t.rid || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class V6 extends gt {
  constructor(t) {
    super(wt, "traversal", !0), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null, this.traverse = new P();
  }
}
class X6 extends gt {
  constructor(t) {
    super(wt, "traverse", !0), this.id = t.id || "", this.operation = Et(t.operation, ["next", "back", "down", "first", "left", "right", "up"]), this.ref = t.ref || "", this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null, this.script = null;
  }
  get name() {
    return this.operation;
  }
  [dr]() {
    return !1;
  }
}
class iI extends gt {
  constructor(t) {
    super(wt, "ui", !0), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null, this.picture = null, this.barcode = null, this.button = null, this.checkButton = null, this.choiceList = null, this.dateTimeEdit = null, this.defaultUi = null, this.imageEdit = null, this.numericEdit = null, this.passwordEdit = null, this.signature = null, this.textEdit = null;
  }
  [oe]() {
    if (this[nt] === void 0) {
      for (const t of Object.getOwnPropertyNames(this)) {
        if (t === "extras" || t === "picture") continue;
        const e = this[t];
        if (e instanceof gt) return this[nt] = e, e;
      }
      this[nt] = null;
    }
    return this[nt];
  }
  [Tt](t) {
    const e = this[oe]();
    return e ? e[Tt](t) : Yt.EMPTY;
  }
}
class z6 extends gt {
  constructor(t) {
    super(wt, "validate", !0), this.formatTest = Et(t.formatTest, ["warning", "disabled", "error"]), this.id = t.id || "", this.nullTest = Et(t.nullTest, ["disabled", "error", "warning"]), this.scriptTest = Et(t.scriptTest, ["error", "disabled", "warning"]), this.use = t.use || "", this.usehref = t.usehref || "", this.extras = null, this.message = null, this.picture = null, this.script = null;
  }
}
class sI extends gt {
  constructor(t) {
    super(wt, "value", !0), this.id = t.id || "", this.override = Ot({ data: t.override, defaultValue: 0, validate: (e) => e === 1 }), this.relevant = di(t.relevant), this.use = t.use || "", this.usehref = t.usehref || "", this.arc = null, this.boolean = null, this.date = null, this.dateTime = null, this.decimal = null, this.exData = null, this.float = null, this.image = null, this.integer = null, this.line = null, this.rectangle = null, this.text = null, this.time = null;
  }
  [xe](t) {
    const e = this[jt]();
    if (e instanceof tI && e.ui?.imageEdit) return this.image || (this.image = new mf({}), this[FA](this.image)), void (this.image[Qt] = t[Qt]);
    const i = t[hA];
    if (this[i] === null) {
      for (const s of Object.getOwnPropertyNames(this)) {
        const n = this[s];
        n instanceof gt && (this[s] = null, this[Rs](n));
      }
      this[t[hA]] = t, this[FA](t);
    } else this[i][Qt] = t[Qt];
  }
  [OA]() {
    if (this.exData) return typeof this.exData[Qt] == "string" ? this.exData[Qt].trim() : this.exData[Qt][OA]().trim();
    for (const t of Object.getOwnPropertyNames(this)) {
      if (t === "image") continue;
      const e = this[t];
      if (e instanceof gt) return (e[Qt] || "").toString().trim();
    }
    return null;
  }
  [Tt](t) {
    for (const e of Object.getOwnPropertyNames(this)) {
      const i = this[e];
      if (i instanceof gt) return i[Tt](t);
    }
    return Yt.EMPTY;
  }
}
class $6 extends gt {
  constructor(t) {
    super(wt, "variables", !0), this.id = t.id || "", this.use = t.use || "", this.usehref = t.usehref || "", this.boolean = new P(), this.date = new P(), this.dateTime = new P(), this.decimal = new P(), this.exData = new P(), this.float = new P(), this.image = new P(), this.integer = new P(), this.manifest = new P(), this.script = new P(), this.text = new P(), this.time = new P();
  }
  [dr]() {
    return !0;
  }
}
class eg {
  static [Bi](t, e) {
    if (eg.hasOwnProperty(t)) {
      const i = eg[t](e);
      return i[jE](e), i;
    }
  }
  static appearanceFilter(t) {
    return new my(t);
  }
  static arc(t) {
    return new If(t);
  }
  static area(t) {
    return new yy(t);
  }
  static assist(t) {
    return new wy(t);
  }
  static barcode(t) {
    return new by(t);
  }
  static bind(t) {
    return new Dy(t);
  }
  static bindItems(t) {
    return new Al(t);
  }
  static bookend(t) {
    return new ky(t);
  }
  static boolean(t) {
    return new Sy(t);
  }
  static border(t) {
    return new Cf(t);
  }
  static break(t) {
    return new Fy(t);
  }
  static breakAfter(t) {
    return new uf(t);
  }
  static breakBefore(t) {
    return new Bf(t);
  }
  static button(t) {
    return new Ry(t);
  }
  static calculate(t) {
    return new xy(t);
  }
  static caption(t) {
    return new Ny(t);
  }
  static certificate(t) {
    return new Gy(t);
  }
  static certificates(t) {
    return new vy(t);
  }
  static checkButton(t) {
    return new df(t);
  }
  static choiceList(t) {
    return new Qf(t);
  }
  static color(t) {
    return new My(t);
  }
  static comb(t) {
    return new Ly(t);
  }
  static connect(t) {
    return new Uy(t);
  }
  static contentArea(t) {
    return new $l(t);
  }
  static corner(t) {
    return new Ef(t);
  }
  static date(t) {
    return new Hy(t);
  }
  static dateTime(t) {
    return new Jy(t);
  }
  static dateTimeEdit(t) {
    return new Yy(t);
  }
  static decimal(t) {
    return new Ty(t);
  }
  static defaultUi(t) {
    return new Ky(t);
  }
  static desc(t) {
    return new qy(t);
  }
  static digestMethod(t) {
    return new Py(t);
  }
  static digestMethods(t) {
    return new _y(t);
  }
  static draw(t) {
    return new ff(t);
  }
  static edge(t) {
    return new Fr(t);
  }
  static encoding(t) {
    return new Oy(t);
  }
  static encodings(t) {
    return new Wy(t);
  }
  static encrypt(t) {
    return new jy(t);
  }
  static encryptData(t) {
    return new Zy(t);
  }
  static encryption(t) {
    return new Vy(t);
  }
  static encryptionMethod(t) {
    return new Xy(t);
  }
  static encryptionMethods(t) {
    return new zy(t);
  }
  static event(t) {
    return new $y(t);
  }
  static exData(t) {
    return new t6(t);
  }
  static exObject(t) {
    return new A6(t);
  }
  static exclGroup(t) {
    return new pf(t);
  }
  static execute(t) {
    return new e6(t);
  }
  static extras(t) {
    return new i6(t);
  }
  static field(t) {
    return new tI(t);
  }
  static fill(t) {
    return new s6(t);
  }
  static filter(t) {
    return new a6(t);
  }
  static float(t) {
    return new n6(t);
  }
  static font(t) {
    return new r6(t);
  }
  static format(t) {
    return new o6(t);
  }
  static handler(t) {
    return new g6(t);
  }
  static hyphenation(t) {
    return new c6(t);
  }
  static image(t) {
    return new mf(t);
  }
  static imageEdit(t) {
    return new h6(t);
  }
  static integer(t) {
    return new l6(t);
  }
  static issuers(t) {
    return new I6(t);
  }
  static items(t) {
    return new el(t);
  }
  static keep(t) {
    return new C6(t);
  }
  static keyUsage(t) {
    return new u6(t);
  }
  static line(t) {
    return new B6(t);
  }
  static linear(t) {
    return new d6(t);
  }
  static lockDocument(t) {
    return new Q6(t);
  }
  static manifest(t) {
    return new E6(t);
  }
  static margin(t) {
    return new f6(t);
  }
  static mdp(t) {
    return new p6(t);
  }
  static medium(t) {
    return new m6(t);
  }
  static message(t) {
    return new y6(t);
  }
  static numericEdit(t) {
    return new w6(t);
  }
  static occur(t) {
    return new b6(t);
  }
  static oid(t) {
    return new D6(t);
  }
  static oids(t) {
    return new k6(t);
  }
  static overflow(t) {
    return new yf(t);
  }
  static pageArea(t) {
    return new An(t);
  }
  static pageSet(t) {
    return new Er(t);
  }
  static para(t) {
    return new S6(t);
  }
  static passwordEdit(t) {
    return new F6(t);
  }
  static pattern(t) {
    return new R6(t);
  }
  static picture(t) {
    return new x6(t);
  }
  static proto(t) {
    return new N6(t);
  }
  static radial(t) {
    return new G6(t);
  }
  static reason(t) {
    return new v6(t);
  }
  static reasons(t) {
    return new M6(t);
  }
  static rectangle(t) {
    return new wf(t);
  }
  static ref(t) {
    return new L6(t);
  }
  static script(t) {
    return new U6(t);
  }
  static setProperty(t) {
    return new il(t);
  }
  static signData(t) {
    return new H6(t);
  }
  static signature(t) {
    return new J6(t);
  }
  static signing(t) {
    return new Y6(t);
  }
  static solid(t) {
    return new T6(t);
  }
  static speak(t) {
    return new K6(t);
  }
  static stipple(t) {
    return new q6(t);
  }
  static subform(t) {
    return new bf(t);
  }
  static subformSet(t) {
    return new AI(t);
  }
  static subjectDN(t) {
    return new P6(t);
  }
  static subjectDNs(t) {
    return new _6(t);
  }
  static submit(t) {
    return new O6(t);
  }
  static template(t) {
    return new eI(t);
  }
  static text(t) {
    return new Df(t);
  }
  static textEdit(t) {
    return new kf(t);
  }
  static time(t) {
    return new W6(t);
  }
  static timeStamp(t) {
    return new j6(t);
  }
  static toolTip(t) {
    return new Z6(t);
  }
  static traversal(t) {
    return new V6(t);
  }
  static traverse(t) {
    return new X6(t);
  }
  static ui(t) {
    return new iI(t);
  }
  static validate(t) {
    return new z6(t);
  }
  static value(t) {
    return new sI(t);
  }
  static variables(t) {
    return new $6(t);
  }
}
const q1 = JA.datasets.id;
function ho(A) {
  const t = new Df({});
  return t[Qt] = A, t;
}
class tw {
  constructor(t) {
    this.root = t, this.datasets = t.datasets, this.data = t.datasets?.data || new Gi(JA.datasets.id, "data"), this.emptyMerge = this.data[ee]().length === 0, this.root.form = this.form = t.template[li]();
  }
  _isConsumeData() {
    return !this.emptyMerge && this._mergeMode;
  }
  _isMatchTemplate() {
    return !this._isConsumeData();
  }
  bind() {
    return this._bindElement(this.form, this.data), this.form;
  }
  getData() {
    return this.data;
  }
  _bindValue(t, e, i) {
    if (t[ii] = e, t[Br]()) if (e[Ta]()) {
      const s = e[ql]();
      t[xe](ho(s));
    } else if (t instanceof tI && t.ui?.choiceList?.open === "multiSelect") {
      const s = e[ee]().map(((n) => n[Qt].trim())).join(`
`);
      t[xe](ho(s));
    } else this._isConsumeData() && O("XFA - Nodes haven't the same type.");
    else !e[Ta]() || this._isMatchTemplate() ? this._bindElement(t, e) : O("XFA - Nodes haven't the same type.");
  }
  _findDataByNameToConsume(t, e, i, s) {
    if (!t) return null;
    let n, o;
    for (let r = 0; r < 3; r++) {
      for (n = i[$n](t, !1, !0); o = n.next().value, o; ) if (e === o[Ta]()) return o;
      if (i[UA] === JA.datasets.id && i[hA] === "data") break;
      i = i[jt]();
    }
    return s ? (n = this.data[$n](t, !0, !1), o = n.next().value, o || (n = this.data[Vh](t, !0), o = n.next().value, o?.[Ta]() ? o : null)) : null;
  }
  _setProperties(t, e) {
    if (t.hasOwnProperty("setProperty")) for (const { ref: i, target: s, connection: n } of t.setProperty.children) {
      if (n || !i) continue;
      const o = ms(this.root, e, i, !1, !1);
      if (!o) {
        O(`XFA - Invalid reference: ${i}.`);
        continue;
      }
      const [r] = o;
      if (!r[ys](this.data)) {
        O("XFA - Invalid node: must be a data node.");
        continue;
      }
      const c = ms(this.root, t, s, !1, !1);
      if (!c) {
        O(`XFA - Invalid target: ${s}.`);
        continue;
      }
      const [h] = c;
      if (!h[ys](t)) {
        O("XFA - Invalid target: must be a property or subproperty.");
        continue;
      }
      const I = h[jt]();
      if (h instanceof il || I instanceof il) {
        O("XFA - Invalid target: cannot be a setProperty or one of its properties.");
        continue;
      }
      if (h instanceof Al || I instanceof Al) {
        O("XFA - Invalid target: cannot be a bindItems or one of its properties.");
        continue;
      }
      const C = r[OA](), d = h[hA];
      if (h instanceof Wl) {
        const u = /* @__PURE__ */ Object.create(null);
        u[d] = C;
        const E = Reflect.construct(Object.getPrototypeOf(I).constructor, [u]);
        I[d] = E[d];
      } else h.hasOwnProperty(Qt) ? (h[ii] = r, h[Qt] = C, h[fA]()) : O("XFA - Invalid node to use in setProperty");
    }
  }
  _bindItems(t, e) {
    if (!t.hasOwnProperty("items") || !t.hasOwnProperty("bindItems") || t.bindItems.isEmpty()) return;
    for (const n of t.items.children) t[Rs](n);
    t.items.clear();
    const i = new el({}), s = new el({});
    t[FA](i), t.items.push(i), t[FA](s), t.items.push(s);
    for (const { ref: n, labelRef: o, valueRef: r, connection: c } of t.bindItems.children) {
      if (c || !n) continue;
      const h = ms(this.root, e, n, !1, !1);
      if (h) for (const I of h) {
        if (!I[ys](this.datasets)) {
          O(`XFA - Invalid ref (${n}): must be a datasets child.`);
          continue;
        }
        const C = ms(this.root, I, o, !0, !1);
        if (!C) {
          O(`XFA - Invalid label: ${o}.`);
          continue;
        }
        const [d] = C;
        if (!d[ys](this.datasets)) {
          O("XFA - Invalid label: must be a datasets child.");
          continue;
        }
        const u = ms(this.root, I, r, !0, !1);
        if (!u) {
          O(`XFA - Invalid value: ${r}.`);
          continue;
        }
        const [E] = u;
        if (!E[ys](this.datasets)) {
          O("XFA - Invalid value: must be a datasets child.");
          continue;
        }
        const p = ho(d[OA]()), y = ho(E[OA]());
        i[FA](p), i.text.push(p), s[FA](y), s.text.push(y);
      }
      else O(`XFA - Invalid reference: ${n}.`);
    }
  }
  _bindOccurrences(t, e, i) {
    let s;
    if (e.length > 1 && (s = t[li](), s[Rs](s.occur), s.occur = null), this._bindValue(t, e[0], i), this._setProperties(t, e[0]), this._bindItems(t, e[0]), e.length === 1) return;
    const n = t[jt](), o = t[hA], r = n[Xh](t);
    for (let c = 1, h = e.length; c < h; c++) {
      const I = e[c], C = s[li]();
      n[o].push(C), n[Fo](r + c, C), this._bindValue(C, I, i), this._setProperties(C, I), this._bindItems(C, I);
    }
  }
  _createOccurrences(t) {
    if (!this.emptyMerge) return;
    const { occur: e } = t;
    if (!e || e.initial <= 1) return;
    const i = t[jt](), s = t[hA];
    if (!(i[s] instanceof P)) return;
    let n;
    n = t.name ? i[s].children.filter(((c) => c.name === t.name)).length : i[s].children.length;
    const o = i[Xh](t) + 1, r = e.initial - n;
    if (r) {
      const c = t[li]();
      c[Rs](c.occur), c.occur = null, i[s].push(c), i[Fo](o, c);
      for (let h = 1; h < r; h++) {
        const I = c[li]();
        i[s].push(I), i[Fo](o + h, I);
      }
    }
  }
  _getOccurInfo(t) {
    const { name: e, occur: i } = t;
    if (!i || !e) return [1, 1];
    const s = i.max === -1 ? 1 / 0 : i.max;
    return [i.min, s];
  }
  _setAndBind(t, e) {
    this._setProperties(t, e), this._bindItems(t, e), this._bindElement(t, e);
  }
  _bindElement(t, e) {
    const i = [];
    this._createOccurrences(t);
    for (const s of t[ee]()) {
      if (s[ii]) continue;
      if (this._mergeMode === void 0 && s[hA] === "subform") {
        this._mergeMode = s.mergeMode === "consumeData";
        const C = e[ee]();
        if (C.length > 0) this._bindOccurrences(s, [C[0]], null);
        else if (this.emptyMerge) {
          const d = e[UA] === q1 ? -1 : e[UA], u = s[ii] = new Gi(d, s.name || "root");
          e[FA](u), this._bindElement(s, u);
        }
        continue;
      }
      if (!s[Ba]()) continue;
      let n = !1, o = null, r = null, c = null;
      if (s.bind) {
        switch (s.bind.match) {
          case "none":
            this._setAndBind(s, e);
            continue;
          case "global":
            n = !0;
            break;
          case "dataRef":
            if (!s.bind.ref) {
              O(`XFA - ref is empty in node ${s[hA]}.`), this._setAndBind(s, e);
              continue;
            }
            r = s.bind.ref;
        }
        s.bind.picture && (o = s.bind.picture[Qt]);
      }
      const [h, I] = this._getOccurInfo(s);
      if (r) {
        if (c = ms(this.root, e, r, !0, !1), c === null) {
          if (c = Qy(this.data, e, r), !c) continue;
          this._isConsumeData() && (c[ki] = !0), this._setAndBind(s, c);
          continue;
        }
        this._isConsumeData() && (c = c.filter(((C) => !C[ki]))), c.length > I ? c = c.slice(0, I) : c.length === 0 && (c = null), c && this._isConsumeData() && c.forEach(((C) => {
          C[ki] = !0;
        }));
      } else {
        if (!s.name) {
          this._setAndBind(s, e);
          continue;
        }
        if (this._isConsumeData()) {
          const C = [];
          for (; C.length < I; ) {
            const d = this._findDataByNameToConsume(s.name, s[Br](), e, n);
            if (!d) break;
            d[ki] = !0, C.push(d);
          }
          c = C.length > 0 ? C : null;
        } else {
          if (c = e[$n](s.name, !1, this.emptyMerge).next().value, !c) {
            if (h === 0) {
              i.push(s);
              continue;
            }
            const C = e[UA] === q1 ? -1 : e[UA];
            c = s[ii] = new Gi(C, s.name), this.emptyMerge && (c[ki] = !0), e[FA](c), this._setAndBind(s, c);
            continue;
          }
          this.emptyMerge && (c[ki] = !0), c = [c];
        }
      }
      c ? this._bindOccurrences(s, c, o) : h > 0 ? this._setAndBind(s, e) : i.push(s);
    }
    i.forEach(((s) => s[jt]()[Rs](s)));
  }
}
class Aw {
  constructor(t, e) {
    this.data = e, this.dataset = t.datasets || null;
  }
  serialize(t) {
    const e = [[-1, this.data[ee]()]];
    for (; e.length > 0; ) {
      const s = e.at(-1), [n, o] = s;
      if (n + 1 === o.length) {
        e.pop();
        continue;
      }
      const r = o[++s[0]], c = t.get(r[CA]);
      if (c) r[xe](c);
      else {
        const I = r[OE]();
        for (const C of I.values()) {
          const d = t.get(C[CA]);
          if (d) {
            C[xe](d);
            break;
          }
        }
      }
      const h = r[ee]();
      h.length > 0 && e.push([-1, h]);
    }
    const i = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
    if (this.dataset) for (const s of this.dataset[ee]()) s[hA] !== "data" && s[Ar](i);
    return this.data[Ar](i), i.push("</xfa:datasets>"), i.join("");
  }
}
const pt = JA.config.id;
class ew extends gt {
  constructor(t) {
    super(pt, "acrobat", !0), this.acrobat7 = null, this.autoSave = null, this.common = null, this.validate = null, this.validateApprovalSignatures = null, this.submitUrl = new P();
  }
}
class iw extends gt {
  constructor(t) {
    super(pt, "acrobat7", !0), this.dynamicRender = null;
  }
}
class sw extends uA {
  constructor(t) {
    super(pt, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
  }
}
class aw extends uA {
  constructor(t) {
    super(pt, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
  }
}
class nw extends WA {
  constructor(t) {
    super(pt, "addSilentPrint");
  }
}
class rw extends WA {
  constructor(t) {
    super(pt, "addViewerPreferences");
  }
}
class ow extends $E {
  constructor(t) {
    super(pt, "adjustData");
  }
}
class gw extends Qi {
  constructor(t) {
    super(pt, "adobeExtensionLevel", 0, ((e) => e >= 1 && e <= 8));
  }
}
class cw extends gt {
  constructor(t) {
    super(pt, "agent", !0), this.name = t.name ? t.name.trim() : "", this.common = new P();
  }
}
class hw extends xA {
  constructor(t) {
    super(pt, "alwaysEmbed");
  }
}
class lw extends iA {
  constructor(t) {
    super(pt, "amd");
  }
}
class Iw extends gt {
  constructor(t) {
    super(pt, "area"), this.level = Ot({ data: t.level, defaultValue: 0, validate: (e) => e >= 1 && e <= 3 }), this.name = Et(t.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
  }
}
class Cw extends uA {
  constructor(t) {
    super(pt, "attributes", ["preserve", "delegate", "ignore"]);
  }
}
class uw extends uA {
  constructor(t) {
    super(pt, "autoSave", ["disabled", "enabled"]);
  }
}
class Bw extends iA {
  constructor(t) {
    super(pt, "base");
  }
}
class dw extends gt {
  constructor(t) {
    super(pt, "batchOutput"), this.format = Et(t.format, ["none", "concat", "zip", "zipCompress"]);
  }
}
class Qw extends xA {
  constructor(t) {
    super(pt, "behaviorOverride");
  }
  [fA]() {
    this[Qt] = new Map(this[Qt].trim().split(/\s+/).filter(((t) => t.includes(":"))).map(((t) => t.split(":", 2))));
  }
}
class Ew extends gt {
  constructor(t) {
    super(pt, "cache", !0), this.templateCache = null;
  }
}
class fw extends WA {
  constructor(t) {
    super(pt, "change");
  }
}
class pw extends gt {
  constructor(t) {
    super(pt, "common", !0), this.data = null, this.locale = null, this.localeSet = null, this.messaging = null, this.suppressBanner = null, this.template = null, this.validationMessaging = null, this.versionControl = null, this.log = new P();
  }
}
class mw extends gt {
  constructor(t) {
    super(pt, "compress"), this.scope = Et(t.scope, ["imageOnly", "document"]);
  }
}
class yw extends WA {
  constructor(t) {
    super(pt, "compressLogicalStructure");
  }
}
class ww extends $E {
  constructor(t) {
    super(pt, "compressObjectStream");
  }
}
class bw extends gt {
  constructor(t) {
    super(pt, "compression", !0), this.compressLogicalStructure = null, this.compressObjectStream = null, this.level = null, this.type = null;
  }
}
class Dw extends gt {
  constructor(t) {
    super(pt, "config", !0), this.acrobat = null, this.present = null, this.trace = null, this.agent = new P();
  }
}
class kw extends uA {
  constructor(t) {
    super(pt, "conformance", ["A", "B"]);
  }
}
class Sw extends WA {
  constructor(t) {
    super(pt, "contentCopy");
  }
}
class Fw extends Qi {
  constructor(t) {
    super(pt, "copies", 1, ((e) => e >= 1));
  }
}
class Rw extends iA {
  constructor(t) {
    super(pt, "creator");
  }
}
class xw extends Qi {
  constructor(t) {
    super(pt, "currentPage", 0, ((e) => e >= 0));
  }
}
class Nw extends gt {
  constructor(t) {
    super(pt, "data", !0), this.adjustData = null, this.attributes = null, this.incrementalLoad = null, this.outputXSL = null, this.range = null, this.record = null, this.startNode = null, this.uri = null, this.window = null, this.xsl = null, this.excludeNS = new P(), this.transform = new P();
  }
}
class Gw extends gt {
  constructor(t) {
    super(pt, "debug", !0), this.uri = null;
  }
}
class vw extends xA {
  constructor(t) {
    super(pt, "defaultTypeface"), this.writingScript = Et(t.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
  }
}
class Mw extends uA {
  constructor(t) {
    super(pt, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
  }
}
class Lw extends WA {
  constructor(t) {
    super(pt, "documentAssembly");
  }
}
class Uw extends gt {
  constructor(t) {
    super(pt, "driver", !0), this.name = t.name ? t.name.trim() : "", this.fontInfo = null, this.xdc = null;
  }
}
class Hw extends uA {
  constructor(t) {
    super(pt, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
  }
}
class Jw extends uA {
  constructor(t) {
    super(pt, "dynamicRender", ["forbidden", "required"]);
  }
}
class Yw extends WA {
  constructor(t) {
    super(pt, "embed");
  }
}
class Tw extends WA {
  constructor(t) {
    super(pt, "encrypt");
  }
}
class Kw extends gt {
  constructor(t) {
    super(pt, "encryption", !0), this.encrypt = null, this.encryptionLevel = null, this.permissions = null;
  }
}
class qw extends uA {
  constructor(t) {
    super(pt, "encryptionLevel", ["40bit", "128bit"]);
  }
}
class Pw extends iA {
  constructor(t) {
    super(pt, "enforce");
  }
}
class _w extends gt {
  constructor(t) {
    super(pt, "equate"), this.force = Ot({ data: t.force, defaultValue: 1, validate: (e) => e === 0 }), this.from = t.from || "", this.to = t.to || "";
  }
}
class Ow extends gt {
  constructor(t) {
    super(pt, "equateRange"), this.from = t.from || "", this.to = t.to || "", this._unicodeRange = t.unicodeRange || "";
  }
  get unicodeRange() {
    const t = [], e = /U\+([0-9a-fA-F]+)/, i = this._unicodeRange;
    for (let s of i.split(",").map(((n) => n.trim())).filter(((n) => !!n))) s = s.split("-", 2).map(((n) => {
      const o = n.match(e);
      return o ? parseInt(o[1], 16) : 0;
    })), s.length === 1 && s.push(s[0]), t.push(s);
    return bt(this, "unicodeRange", t);
  }
}
class Ww extends xA {
  constructor(t) {
    super(pt, "exclude");
  }
  [fA]() {
    this[Qt] = this[Qt].trim().split(/\s+/).filter(((t) => t && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(t)));
  }
}
class jw extends iA {
  constructor(t) {
    super(pt, "excludeNS");
  }
}
class Zw extends uA {
  constructor(t) {
    super(pt, "flipLabel", ["usePrinterSetting", "on", "off"]);
  }
}
class Vw extends gt {
  constructor(t) {
    super(pt, "fontInfo", !0), this.embed = null, this.map = null, this.subsetBelow = null, this.alwaysEmbed = new P(), this.defaultTypeface = new P(), this.neverEmbed = new P();
  }
}
class Xw extends WA {
  constructor(t) {
    super(pt, "formFieldFilling");
  }
}
class zw extends iA {
  constructor(t) {
    super(pt, "groupParent");
  }
}
class $w extends uA {
  constructor(t) {
    super(pt, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
  }
}
class t4 extends iA {
  constructor(t) {
    super(pt, "includeXDPContent");
  }
}
class A4 extends uA {
  constructor(t) {
    super(pt, "incrementalLoad", ["none", "forwardOnly"]);
  }
}
class e4 extends WA {
  constructor(t) {
    super(pt, "incrementalMerge");
  }
}
class i4 extends WA {
  constructor(t) {
    super(pt, "interactive");
  }
}
class s4 extends uA {
  constructor(t) {
    super(pt, "jog", ["usePrinterSetting", "none", "pageSet"]);
  }
}
class a4 extends gt {
  constructor(t) {
    super(pt, "labelPrinter", !0), this.name = Et(t.name, ["zpl", "dpl", "ipl", "tcpl"]), this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
  }
}
class n4 extends uA {
  constructor(t) {
    super(pt, "layout", ["paginate", "panel"]);
  }
}
class r4 extends Qi {
  constructor(t) {
    super(pt, "level", 0, ((e) => e > 0));
  }
}
class o4 extends WA {
  constructor(t) {
    super(pt, "linearized");
  }
}
class g4 extends iA {
  constructor(t) {
    super(pt, "locale");
  }
}
class c4 extends iA {
  constructor(t) {
    super(pt, "localeSet");
  }
}
class h4 extends gt {
  constructor(t) {
    super(pt, "log", !0), this.mode = null, this.threshold = null, this.to = null, this.uri = null;
  }
}
class l4 extends gt {
  constructor(t) {
    super(pt, "map", !0), this.equate = new P(), this.equateRange = new P();
  }
}
class I4 extends gt {
  constructor(t) {
    super(pt, "mediumInfo", !0), this.map = null;
  }
}
class C4 extends gt {
  constructor(t) {
    super(pt, "message", !0), this.msgId = null, this.severity = null;
  }
}
class u4 extends gt {
  constructor(t) {
    super(pt, "messaging", !0), this.message = new P();
  }
}
class B4 extends uA {
  constructor(t) {
    super(pt, "mode", ["append", "overwrite"]);
  }
}
class d4 extends WA {
  constructor(t) {
    super(pt, "modifyAnnots");
  }
}
class Q4 extends Qi {
  constructor(t) {
    super(pt, "msgId", 1, ((e) => e >= 1));
  }
}
class E4 extends iA {
  constructor(t) {
    super(pt, "nameAttr");
  }
}
class f4 extends xA {
  constructor(t) {
    super(pt, "neverEmbed");
  }
}
class p4 extends Qi {
  constructor(t) {
    super(pt, "numberOfCopies", null, ((e) => e >= 2 && e <= 5));
  }
}
class m4 extends gt {
  constructor(t) {
    super(pt, "openAction", !0), this.destination = null;
  }
}
class y4 extends gt {
  constructor(t) {
    super(pt, "output", !0), this.to = null, this.type = null, this.uri = null;
  }
}
class w4 extends iA {
  constructor(t) {
    super(pt, "outputBin");
  }
}
class b4 extends gt {
  constructor(t) {
    super(pt, "outputXSL", !0), this.uri = null;
  }
}
class D4 extends uA {
  constructor(t) {
    super(pt, "overprint", ["none", "both", "draw", "field"]);
  }
}
class k4 extends iA {
  constructor(t) {
    super(pt, "packets");
  }
  [fA]() {
    this[Qt] !== "*" && (this[Qt] = this[Qt].trim().split(/\s+/).filter(((t) => ["config", "datasets", "template", "xfdf", "xslt"].includes(t))));
  }
}
class S4 extends gt {
  constructor(t) {
    super(pt, "pageOffset"), this.x = Ot({ data: t.x, defaultValue: "useXDCSetting", validate: (e) => !0 }), this.y = Ot({ data: t.y, defaultValue: "useXDCSetting", validate: (e) => !0 });
  }
}
class F4 extends iA {
  constructor(t) {
    super(pt, "pageRange");
  }
  [fA]() {
    const t = this[Qt].trim().split(/\s+/).map(((i) => parseInt(i, 10))), e = [];
    for (let i = 0, s = t.length; i < s; i += 2) e.push(t.slice(i, i + 2));
    this[Qt] = e;
  }
}
class R4 extends uA {
  constructor(t) {
    super(pt, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
  }
}
class x4 extends uA {
  constructor(t) {
    super(pt, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
  }
}
class N4 extends Qi {
  constructor(t) {
    super(pt, "part", 1, ((e) => !1));
  }
}
class G4 extends gt {
  constructor(t) {
    super(pt, "pcl", !0), this.name = t.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.pageOffset = null, this.staple = null, this.xdc = null;
  }
}
class v4 extends gt {
  constructor(t) {
    super(pt, "pdf", !0), this.name = t.name || "", this.adobeExtensionLevel = null, this.batchOutput = null, this.compression = null, this.creator = null, this.encryption = null, this.fontInfo = null, this.interactive = null, this.linearized = null, this.openAction = null, this.pdfa = null, this.producer = null, this.renderPolicy = null, this.scriptModel = null, this.silentPrint = null, this.submitFormat = null, this.tagged = null, this.version = null, this.viewerPreferences = null, this.xdc = null;
  }
}
class M4 extends gt {
  constructor(t) {
    super(pt, "pdfa", !0), this.amd = null, this.conformance = null, this.includeXDPContent = null, this.part = null;
  }
}
class L4 extends gt {
  constructor(t) {
    super(pt, "permissions", !0), this.accessibleContent = null, this.change = null, this.contentCopy = null, this.documentAssembly = null, this.formFieldFilling = null, this.modifyAnnots = null, this.plaintextMetadata = null, this.print = null, this.printHighQuality = null;
  }
}
class U4 extends WA {
  constructor(t) {
    super(pt, "pickTrayByPDFSize");
  }
}
class H4 extends iA {
  constructor(t) {
    super(pt, "picture");
  }
}
class J4 extends WA {
  constructor(t) {
    super(pt, "plaintextMetadata");
  }
}
class Y4 extends uA {
  constructor(t) {
    super(pt, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
  }
}
class T4 extends gt {
  constructor(t) {
    super(pt, "present", !0), this.behaviorOverride = null, this.cache = null, this.common = null, this.copies = null, this.destination = null, this.incrementalMerge = null, this.layout = null, this.output = null, this.overprint = null, this.pagination = null, this.paginationOverride = null, this.script = null, this.validate = null, this.xdp = null, this.driver = new P(), this.labelPrinter = new P(), this.pcl = new P(), this.pdf = new P(), this.ps = new P(), this.submitUrl = new P(), this.webClient = new P(), this.zpl = new P();
  }
}
class K4 extends WA {
  constructor(t) {
    super(pt, "print");
  }
}
class q4 extends WA {
  constructor(t) {
    super(pt, "printHighQuality");
  }
}
class P4 extends uA {
  constructor(t) {
    super(pt, "printScaling", ["appdefault", "noScaling"]);
  }
}
class _4 extends iA {
  constructor(t) {
    super(pt, "printerName");
  }
}
class O4 extends iA {
  constructor(t) {
    super(pt, "producer");
  }
}
class W4 extends gt {
  constructor(t) {
    super(pt, "ps", !0), this.name = t.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.staple = null, this.xdc = null;
  }
}
let j4 = class extends xA {
  constructor(A) {
    super(pt, "range");
  }
  [fA]() {
    this[Qt] = this[Qt].trim().split(/\s*,\s*/, 2).map(((A) => A.split("-").map(((t) => parseInt(t.trim(), 10))))).filter(((A) => A.every(((t) => !isNaN(t))))).map(((A) => (A.length === 1 && A.push(A[0]), A)));
  }
};
class Z4 extends xA {
  constructor(t) {
    super(pt, "record");
  }
  [fA]() {
    this[Qt] = this[Qt].trim();
    const t = parseInt(this[Qt], 10);
    !isNaN(t) && t >= 0 && (this[Qt] = t);
  }
}
class V4 extends xA {
  constructor(t) {
    super(pt, "relevant");
  }
  [fA]() {
    this[Qt] = this[Qt].trim().split(/\s+/);
  }
}
class X4 extends xA {
  constructor(t) {
    super(pt, "rename");
  }
  [fA]() {
    this[Qt] = this[Qt].trim(), (this[Qt].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[Qt])) && O("XFA - Rename: invalid XFA name");
  }
}
class z4 extends uA {
  constructor(t) {
    super(pt, "renderPolicy", ["server", "client"]);
  }
}
class $4 extends uA {
  constructor(t) {
    super(pt, "runScripts", ["both", "client", "none", "server"]);
  }
}
class t7 extends gt {
  constructor(t) {
    super(pt, "script", !0), this.currentPage = null, this.exclude = null, this.runScripts = null;
  }
}
class A7 extends uA {
  constructor(t) {
    super(pt, "scriptModel", ["XFA", "none"]);
  }
}
class e7 extends uA {
  constructor(t) {
    super(pt, "severity", ["ignore", "error", "information", "trace", "warning"]);
  }
}
class i7 extends gt {
  constructor(t) {
    super(pt, "silentPrint", !0), this.addSilentPrint = null, this.printerName = null;
  }
}
class s7 extends gt {
  constructor(t) {
    super(pt, "staple"), this.mode = Et(t.mode, ["usePrinterSetting", "on", "off"]);
  }
}
class a7 extends iA {
  constructor(t) {
    super(pt, "startNode");
  }
}
class n7 extends Qi {
  constructor(t) {
    super(pt, "startPage", 0, ((e) => !0));
  }
}
class r7 extends uA {
  constructor(t) {
    super(pt, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
  }
}
class o7 extends iA {
  constructor(t) {
    super(pt, "submitUrl");
  }
}
class g7 extends Qi {
  constructor(t) {
    super(pt, "subsetBelow", 100, ((e) => e >= 0 && e <= 100));
  }
}
class c7 extends WA {
  constructor(t) {
    super(pt, "suppressBanner");
  }
}
class h7 extends WA {
  constructor(t) {
    super(pt, "tagged");
  }
}
class l7 extends gt {
  constructor(t) {
    super(pt, "template", !0), this.base = null, this.relevant = null, this.startPage = null, this.uri = null, this.xsl = null;
  }
}
class I7 extends uA {
  constructor(t) {
    super(pt, "threshold", ["trace", "error", "information", "warning"]);
  }
}
class C7 extends uA {
  constructor(t) {
    super(pt, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
  }
}
class u7 extends gt {
  constructor(t) {
    super(pt, "templateCache"), this.maxEntries = Ot({ data: t.maxEntries, defaultValue: 5, validate: (e) => e >= 0 });
  }
}
class B7 extends gt {
  constructor(t) {
    super(pt, "trace", !0), this.area = new P();
  }
}
class d7 extends gt {
  constructor(t) {
    super(pt, "transform", !0), this.groupParent = null, this.ifEmpty = null, this.nameAttr = null, this.picture = null, this.presence = null, this.rename = null, this.whitespace = null;
  }
}
class Q7 extends uA {
  constructor(t) {
    super(pt, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
  }
}
class E7 extends iA {
  constructor(t) {
    super(pt, "uri");
  }
}
class f7 extends uA {
  constructor(t) {
    super(pt, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
  }
}
class p7 extends xA {
  constructor(t) {
    super(pt, "validateApprovalSignatures");
  }
  [fA]() {
    this[Qt] = this[Qt].trim().split(/\s+/).filter(((t) => ["docReady", "postSign"].includes(t)));
  }
}
class m7 extends uA {
  constructor(t) {
    super(pt, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
  }
}
class y7 extends uA {
  constructor(t) {
    super(pt, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
  }
}
class w7 extends gt {
  constructor(t) {
    super(pt, "VersionControl"), this.outputBelow = Et(t.outputBelow, ["warn", "error", "update"]), this.sourceAbove = Et(t.sourceAbove, ["warn", "error"]), this.sourceBelow = Et(t.sourceBelow, ["update", "maintain"]);
  }
}
class b7 extends gt {
  constructor(t) {
    super(pt, "viewerPreferences", !0), this.ADBE_JSConsole = null, this.ADBE_JSDebugger = null, this.addViewerPreferences = null, this.duplexOption = null, this.enforce = null, this.numberOfCopies = null, this.pageRange = null, this.pickTrayByPDFSize = null, this.printScaling = null;
  }
}
class D7 extends gt {
  constructor(t) {
    super(pt, "webClient", !0), this.name = t.name ? t.name.trim() : "", this.fontInfo = null, this.xdc = null;
  }
}
class k7 extends uA {
  constructor(t) {
    super(pt, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
  }
}
class S7 extends xA {
  constructor(t) {
    super(pt, "window");
  }
  [fA]() {
    const t = this[Qt].trim().split(/\s*,\s*/, 2).map(((e) => parseInt(e, 10)));
    t.some(((e) => isNaN(e))) ? this[Qt] = [0, 0] : (t.length === 1 && t.push(t[0]), this[Qt] = t);
  }
}
class F7 extends gt {
  constructor(t) {
    super(pt, "xdc", !0), this.uri = new P(), this.xsl = new P();
  }
}
class R7 extends gt {
  constructor(t) {
    super(pt, "xdp", !0), this.packets = null;
  }
}
class x7 extends gt {
  constructor(t) {
    super(pt, "xsl", !0), this.debug = null, this.uri = null;
  }
}
class N7 extends gt {
  constructor(t) {
    super(pt, "zpl", !0), this.name = t.name ? t.name.trim() : "", this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
  }
}
class ig {
  static [Bi](t, e) {
    if (ig.hasOwnProperty(t)) return ig[t](e);
  }
  static acrobat(t) {
    return new ew(t);
  }
  static acrobat7(t) {
    return new iw(t);
  }
  static ADBE_JSConsole(t) {
    return new sw(t);
  }
  static ADBE_JSDebugger(t) {
    return new aw(t);
  }
  static addSilentPrint(t) {
    return new nw(t);
  }
  static addViewerPreferences(t) {
    return new rw(t);
  }
  static adjustData(t) {
    return new ow(t);
  }
  static adobeExtensionLevel(t) {
    return new gw(t);
  }
  static agent(t) {
    return new cw(t);
  }
  static alwaysEmbed(t) {
    return new hw(t);
  }
  static amd(t) {
    return new lw(t);
  }
  static area(t) {
    return new Iw(t);
  }
  static attributes(t) {
    return new Cw(t);
  }
  static autoSave(t) {
    return new uw(t);
  }
  static base(t) {
    return new Bw(t);
  }
  static batchOutput(t) {
    return new dw(t);
  }
  static behaviorOverride(t) {
    return new Qw(t);
  }
  static cache(t) {
    return new Ew(t);
  }
  static change(t) {
    return new fw(t);
  }
  static common(t) {
    return new pw(t);
  }
  static compress(t) {
    return new mw(t);
  }
  static compressLogicalStructure(t) {
    return new yw(t);
  }
  static compressObjectStream(t) {
    return new ww(t);
  }
  static compression(t) {
    return new bw(t);
  }
  static config(t) {
    return new Dw(t);
  }
  static conformance(t) {
    return new kw(t);
  }
  static contentCopy(t) {
    return new Sw(t);
  }
  static copies(t) {
    return new Fw(t);
  }
  static creator(t) {
    return new Rw(t);
  }
  static currentPage(t) {
    return new xw(t);
  }
  static data(t) {
    return new Nw(t);
  }
  static debug(t) {
    return new Gw(t);
  }
  static defaultTypeface(t) {
    return new vw(t);
  }
  static destination(t) {
    return new Mw(t);
  }
  static documentAssembly(t) {
    return new Lw(t);
  }
  static driver(t) {
    return new Uw(t);
  }
  static duplexOption(t) {
    return new Hw(t);
  }
  static dynamicRender(t) {
    return new Jw(t);
  }
  static embed(t) {
    return new Yw(t);
  }
  static encrypt(t) {
    return new Tw(t);
  }
  static encryption(t) {
    return new Kw(t);
  }
  static encryptionLevel(t) {
    return new qw(t);
  }
  static enforce(t) {
    return new Pw(t);
  }
  static equate(t) {
    return new _w(t);
  }
  static equateRange(t) {
    return new Ow(t);
  }
  static exclude(t) {
    return new Ww(t);
  }
  static excludeNS(t) {
    return new jw(t);
  }
  static flipLabel(t) {
    return new Zw(t);
  }
  static fontInfo(t) {
    return new Vw(t);
  }
  static formFieldFilling(t) {
    return new Xw(t);
  }
  static groupParent(t) {
    return new zw(t);
  }
  static ifEmpty(t) {
    return new $w(t);
  }
  static includeXDPContent(t) {
    return new t4(t);
  }
  static incrementalLoad(t) {
    return new A4(t);
  }
  static incrementalMerge(t) {
    return new e4(t);
  }
  static interactive(t) {
    return new i4(t);
  }
  static jog(t) {
    return new s4(t);
  }
  static labelPrinter(t) {
    return new a4(t);
  }
  static layout(t) {
    return new n4(t);
  }
  static level(t) {
    return new r4(t);
  }
  static linearized(t) {
    return new o4(t);
  }
  static locale(t) {
    return new g4(t);
  }
  static localeSet(t) {
    return new c4(t);
  }
  static log(t) {
    return new h4(t);
  }
  static map(t) {
    return new l4(t);
  }
  static mediumInfo(t) {
    return new I4(t);
  }
  static message(t) {
    return new C4(t);
  }
  static messaging(t) {
    return new u4(t);
  }
  static mode(t) {
    return new B4(t);
  }
  static modifyAnnots(t) {
    return new d4(t);
  }
  static msgId(t) {
    return new Q4(t);
  }
  static nameAttr(t) {
    return new E4(t);
  }
  static neverEmbed(t) {
    return new f4(t);
  }
  static numberOfCopies(t) {
    return new p4(t);
  }
  static openAction(t) {
    return new m4(t);
  }
  static output(t) {
    return new y4(t);
  }
  static outputBin(t) {
    return new w4(t);
  }
  static outputXSL(t) {
    return new b4(t);
  }
  static overprint(t) {
    return new D4(t);
  }
  static packets(t) {
    return new k4(t);
  }
  static pageOffset(t) {
    return new S4(t);
  }
  static pageRange(t) {
    return new F4(t);
  }
  static pagination(t) {
    return new R4(t);
  }
  static paginationOverride(t) {
    return new x4(t);
  }
  static part(t) {
    return new N4(t);
  }
  static pcl(t) {
    return new G4(t);
  }
  static pdf(t) {
    return new v4(t);
  }
  static pdfa(t) {
    return new M4(t);
  }
  static permissions(t) {
    return new L4(t);
  }
  static pickTrayByPDFSize(t) {
    return new U4(t);
  }
  static picture(t) {
    return new H4(t);
  }
  static plaintextMetadata(t) {
    return new J4(t);
  }
  static presence(t) {
    return new Y4(t);
  }
  static present(t) {
    return new T4(t);
  }
  static print(t) {
    return new K4(t);
  }
  static printHighQuality(t) {
    return new q4(t);
  }
  static printScaling(t) {
    return new P4(t);
  }
  static printerName(t) {
    return new _4(t);
  }
  static producer(t) {
    return new O4(t);
  }
  static ps(t) {
    return new W4(t);
  }
  static range(t) {
    return new j4(t);
  }
  static record(t) {
    return new Z4(t);
  }
  static relevant(t) {
    return new V4(t);
  }
  static rename(t) {
    return new X4(t);
  }
  static renderPolicy(t) {
    return new z4(t);
  }
  static runScripts(t) {
    return new $4(t);
  }
  static script(t) {
    return new t7(t);
  }
  static scriptModel(t) {
    return new A7(t);
  }
  static severity(t) {
    return new e7(t);
  }
  static silentPrint(t) {
    return new i7(t);
  }
  static staple(t) {
    return new s7(t);
  }
  static startNode(t) {
    return new a7(t);
  }
  static startPage(t) {
    return new n7(t);
  }
  static submitFormat(t) {
    return new r7(t);
  }
  static submitUrl(t) {
    return new o7(t);
  }
  static subsetBelow(t) {
    return new g7(t);
  }
  static suppressBanner(t) {
    return new c7(t);
  }
  static tagged(t) {
    return new h7(t);
  }
  static template(t) {
    return new l7(t);
  }
  static templateCache(t) {
    return new u7(t);
  }
  static threshold(t) {
    return new I7(t);
  }
  static to(t) {
    return new C7(t);
  }
  static trace(t) {
    return new B7(t);
  }
  static transform(t) {
    return new d7(t);
  }
  static type(t) {
    return new Q7(t);
  }
  static uri(t) {
    return new E7(t);
  }
  static validate(t) {
    return new f7(t);
  }
  static validateApprovalSignatures(t) {
    return new p7(t);
  }
  static validationMessaging(t) {
    return new m7(t);
  }
  static version(t) {
    return new y7(t);
  }
  static versionControl(t) {
    return new w7(t);
  }
  static viewerPreferences(t) {
    return new b7(t);
  }
  static webClient(t) {
    return new D7(t);
  }
  static whitespace(t) {
    return new k7(t);
  }
  static window(t) {
    return new S7(t);
  }
  static xdc(t) {
    return new F7(t);
  }
  static xdp(t) {
    return new R7(t);
  }
  static xsl(t) {
    return new x7(t);
  }
  static zpl(t) {
    return new N7(t);
  }
}
const ri = JA.connectionSet.id;
class G7 extends gt {
  constructor(t) {
    super(ri, "connectionSet", !0), this.wsdlConnection = new P(), this.xmlConnection = new P(), this.xsdConnection = new P();
  }
}
class v7 extends gt {
  constructor(t) {
    super(ri, "effectiveInputPolicy"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class M7 extends gt {
  constructor(t) {
    super(ri, "effectiveOutputPolicy"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class L7 extends iA {
  constructor(t) {
    super(ri, "operation"), this.id = t.id || "", this.input = t.input || "", this.name = t.name || "", this.output = t.output || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class U7 extends iA {
  constructor(t) {
    super(ri, "rootElement"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class H7 extends iA {
  constructor(t) {
    super(ri, "soapAction"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class J7 extends iA {
  constructor(t) {
    super(ri, "soapAddress"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class Y7 extends iA {
  constructor(t) {
    super(ri, "uri"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class T7 extends iA {
  constructor(t) {
    super(ri, "wsdlAddress"), this.id = t.id || "", this.name = t.name || "", this.use = t.use || "", this.usehref = t.usehref || "";
  }
}
class K7 extends gt {
  constructor(t) {
    super(ri, "wsdlConnection", !0), this.dataDescription = t.dataDescription || "", this.name = t.name || "", this.effectiveInputPolicy = null, this.effectiveOutputPolicy = null, this.operation = null, this.soapAction = null, this.soapAddress = null, this.wsdlAddress = null;
  }
}
class q7 extends gt {
  constructor(t) {
    super(ri, "xmlConnection", !0), this.dataDescription = t.dataDescription || "", this.name = t.name || "", this.uri = null;
  }
}
class P7 extends gt {
  constructor(t) {
    super(ri, "xsdConnection", !0), this.dataDescription = t.dataDescription || "", this.name = t.name || "", this.rootElement = null, this.uri = null;
  }
}
class sg {
  static [Bi](t, e) {
    if (sg.hasOwnProperty(t)) return sg[t](e);
  }
  static connectionSet(t) {
    return new G7(t);
  }
  static effectiveInputPolicy(t) {
    return new v7(t);
  }
  static effectiveOutputPolicy(t) {
    return new M7(t);
  }
  static operation(t) {
    return new L7(t);
  }
  static rootElement(t) {
    return new U7(t);
  }
  static soapAction(t) {
    return new H7(t);
  }
  static soapAddress(t) {
    return new J7(t);
  }
  static uri(t) {
    return new Y7(t);
  }
  static wsdlAddress(t) {
    return new T7(t);
  }
  static wsdlConnection(t) {
    return new K7(t);
  }
  static xmlConnection(t) {
    return new q7(t);
  }
  static xsdConnection(t) {
    return new P7(t);
  }
}
const sl = JA.datasets.id;
class _7 extends Gi {
  constructor(t) {
    super(sl, "data", t);
  }
  [tr]() {
    return !0;
  }
}
class O7 extends gt {
  constructor(t) {
    super(sl, "datasets", !0), this.data = null, this.Signature = null;
  }
  [Ni](t) {
    const e = t[hA];
    (e === "data" && t[UA] === sl || e === "Signature" && t[UA] === JA.signature.id) && (this[e] = t), this[FA](t);
  }
}
class ag {
  static [Bi](t, e) {
    if (ag.hasOwnProperty(t)) return ag[t](e);
  }
  static datasets(t) {
    return new O7(t);
  }
  static data(t) {
    return new _7(t);
  }
}
const NA = JA.localeSet.id;
class W7 extends gt {
  constructor(t) {
    super(NA, "calendarSymbols", !0), this.name = "gregorian", this.dayNames = new P(2), this.eraNames = null, this.meridiemNames = null, this.monthNames = new P(2);
  }
}
class j7 extends iA {
  constructor(t) {
    super(NA, "currencySymbol"), this.name = Et(t.name, ["symbol", "isoname", "decimal"]);
  }
}
class Z7 extends gt {
  constructor(t) {
    super(NA, "currencySymbols", !0), this.currencySymbol = new P(3);
  }
}
class V7 extends iA {
  constructor(t) {
    super(NA, "datePattern"), this.name = Et(t.name, ["full", "long", "med", "short"]);
  }
}
class X7 extends gt {
  constructor(t) {
    super(NA, "datePatterns", !0), this.datePattern = new P(4);
  }
}
class z7 extends xA {
  constructor(t) {
    super(NA, "dateTimeSymbols");
  }
}
class $7 extends iA {
  constructor(t) {
    super(NA, "day");
  }
}
class tb extends gt {
  constructor(t) {
    super(NA, "dayNames", !0), this.abbr = Ot({ data: t.abbr, defaultValue: 0, validate: (e) => e === 1 }), this.day = new P(7);
  }
}
class Ab extends iA {
  constructor(t) {
    super(NA, "era");
  }
}
class eb extends gt {
  constructor(t) {
    super(NA, "eraNames", !0), this.era = new P(2);
  }
}
class ib extends gt {
  constructor(t) {
    super(NA, "locale", !0), this.desc = t.desc || "", this.name = "isoname", this.calendarSymbols = null, this.currencySymbols = null, this.datePatterns = null, this.dateTimeSymbols = null, this.numberPatterns = null, this.numberSymbols = null, this.timePatterns = null, this.typeFaces = null;
  }
}
class sb extends gt {
  constructor(t) {
    super(NA, "localeSet", !0), this.locale = new P();
  }
}
class ab extends iA {
  constructor(t) {
    super(NA, "meridiem");
  }
}
class nb extends gt {
  constructor(t) {
    super(NA, "meridiemNames", !0), this.meridiem = new P(2);
  }
}
class rb extends iA {
  constructor(t) {
    super(NA, "month");
  }
}
class ob extends gt {
  constructor(t) {
    super(NA, "monthNames", !0), this.abbr = Ot({ data: t.abbr, defaultValue: 0, validate: (e) => e === 1 }), this.month = new P(12);
  }
}
class gb extends iA {
  constructor(t) {
    super(NA, "numberPattern"), this.name = Et(t.name, ["full", "long", "med", "short"]);
  }
}
class cb extends gt {
  constructor(t) {
    super(NA, "numberPatterns", !0), this.numberPattern = new P(4);
  }
}
class hb extends iA {
  constructor(t) {
    super(NA, "numberSymbol"), this.name = Et(t.name, ["decimal", "grouping", "percent", "minus", "zero"]);
  }
}
class lb extends gt {
  constructor(t) {
    super(NA, "numberSymbols", !0), this.numberSymbol = new P(5);
  }
}
class Ib extends iA {
  constructor(t) {
    super(NA, "timePattern"), this.name = Et(t.name, ["full", "long", "med", "short"]);
  }
}
class Cb extends gt {
  constructor(t) {
    super(NA, "timePatterns", !0), this.timePattern = new P(4);
  }
}
class ub extends gt {
  constructor(t) {
    super(NA, "typeFace", !0), this.name = "" | t.name;
  }
}
class Bb extends gt {
  constructor(t) {
    super(NA, "typeFaces", !0), this.typeFace = new P();
  }
}
class ng {
  static [Bi](t, e) {
    if (ng.hasOwnProperty(t)) return ng[t](e);
  }
  static calendarSymbols(t) {
    return new W7(t);
  }
  static currencySymbol(t) {
    return new j7(t);
  }
  static currencySymbols(t) {
    return new Z7(t);
  }
  static datePattern(t) {
    return new V7(t);
  }
  static datePatterns(t) {
    return new X7(t);
  }
  static dateTimeSymbols(t) {
    return new z7(t);
  }
  static day(t) {
    return new $7(t);
  }
  static dayNames(t) {
    return new tb(t);
  }
  static era(t) {
    return new Ab(t);
  }
  static eraNames(t) {
    return new eb(t);
  }
  static locale(t) {
    return new ib(t);
  }
  static localeSet(t) {
    return new sb(t);
  }
  static meridiem(t) {
    return new ab(t);
  }
  static meridiemNames(t) {
    return new nb(t);
  }
  static month(t) {
    return new rb(t);
  }
  static monthNames(t) {
    return new ob(t);
  }
  static numberPattern(t) {
    return new gb(t);
  }
  static numberPatterns(t) {
    return new cb(t);
  }
  static numberSymbol(t) {
    return new hb(t);
  }
  static numberSymbols(t) {
    return new lb(t);
  }
  static timePattern(t) {
    return new Ib(t);
  }
  static timePatterns(t) {
    return new Cb(t);
  }
  static typeFace(t) {
    return new ub(t);
  }
  static typeFaces(t) {
    return new Bb(t);
  }
}
const db = JA.signature.id;
class Qb extends gt {
  constructor(t) {
    super(db, "signature", !0);
  }
}
class rg {
  static [Bi](t, e) {
    if (rg.hasOwnProperty(t)) return rg[t](e);
  }
  static signature(t) {
    return new Qb(t);
  }
}
const Eb = JA.stylesheet.id;
class fb extends gt {
  constructor(t) {
    super(Eb, "stylesheet", !0);
  }
}
class og {
  static [Bi](t, e) {
    if (og.hasOwnProperty(t)) return og[t](e);
  }
  static stylesheet(t) {
    return new fb(t);
  }
}
const pb = JA.xdp.id;
class mb extends gt {
  constructor(t) {
    super(pb, "xdp", !0), this.uuid = t.uuid || "", this.timeStamp = t.timeStamp || "", this.config = null, this.connectionSet = null, this.datasets = null, this.localeSet = null, this.stylesheet = new P(), this.template = null;
  }
  [zh](t) {
    const e = JA[t[hA]];
    return e && t[UA] === e.id;
  }
}
class gg {
  static [Bi](t, e) {
    if (gg.hasOwnProperty(t)) return gg[t](e);
  }
  static xdp(t) {
    return new mb(t);
  }
}
const yb = JA.xhtml.id, lo = Symbol(), wb = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]), bb = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (A) => A === "none" ? "none" : "normal"], ["xfa-font-horizontal-scale", (A) => `scaleX(${Math.max(0, Math.min(parseInt(A) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", (A) => `scaleY(${Math.max(0, Math.min(parseInt(A) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (A, t) => _t(0.99 * (A = t.fontSize = Nt(A)))], ["letter-spacing", (A) => _t(Nt(A))], ["line-height", (A) => _t(Nt(A))], ["margin", (A) => _t(Nt(A))], ["margin-bottom", (A) => _t(Nt(A))], ["margin-left", (A) => _t(Nt(A))], ["margin-right", (A) => _t(Nt(A))], ["margin-top", (A) => _t(Nt(A))], ["text-indent", (A) => _t(Nt(A))], ["font-family", (A) => A], ["vertical-align", (A) => _t(Nt(A))]]), Db = /\s+/g, kb = /[\r\n]+/g, Sb = /\r\n?/g;
function Fb(A, t, e) {
  const i = /* @__PURE__ */ Object.create(null);
  if (!A) return i;
  const s = /* @__PURE__ */ Object.create(null);
  for (const [n, o] of A.split(";").map(((r) => r.split(":", 2)))) {
    const r = bb.get(n);
    if (r === "") continue;
    let c = o;
    r && (c = typeof r == "string" ? r : r(o, s)), n.endsWith("scale") ? i.transform = i.transform ? `${i[n]} ${c}` : c : i[n.replaceAll(/-([a-zA-Z])/g, ((h, I) => I.toUpperCase()))] = c;
  }
  if (i.fontFamily && rf({ typeface: i.fontFamily, weight: i.fontWeight || "normal", posture: i.fontStyle || "normal", size: s.fontSize || 0 }, t, t[QA].fontFinder, i), e && i.verticalAlign && i.verticalAlign !== "0px" && i.fontSize) {
    const r = Nt(i.fontSize);
    i.fontSize = _t(r * 0.583), i.verticalAlign = _t(Math.sign(Nt(i.verticalAlign)) * r * 0.333);
  }
  return e && i.fontSize && (i.fontSize = `calc(${i.fontSize} * var(--scale-factor))`), sf(i), i;
}
const Rb = /* @__PURE__ */ new Set(["body", "html"]);
class We extends Gi {
  constructor(t, e) {
    super(yb, e), this[lo] = !1, this.style = t.style || "";
  }
  [si](t) {
    var e;
    super[si](t), this.style = (e = this).style ? e.style.trim().split(/\s*;\s*/).filter(((i) => !!i)).map(((i) => i.split(/\s*:\s*/, 2))).filter((([i, s]) => (i === "font-family" && e[QA].usedTypefaces.add(s), wb.has(i)))).map(((i) => i.join(":"))).join(";") : "";
  }
  [fg]() {
    return !Rb.has(this[hA]);
  }
  [$i](t, e = !1) {
    e ? this[lo] = !0 : (t = t.replaceAll(kb, ""), this.style.includes("xfa-spacerun:yes") || (t = t.replaceAll(Db, " "))), t && (this[Qt] += t);
  }
  [vi](t, e = !0) {
    const i = /* @__PURE__ */ Object.create(null), s = { top: NaN, bottom: NaN, left: NaN, right: NaN };
    let n = null;
    for (const [o, r] of this.style.split(";").map(((c) => c.split(":", 2)))) switch (o) {
      case "font-family":
        i.typeface = mg(r);
        break;
      case "font-size":
        i.size = Nt(r);
        break;
      case "font-weight":
        i.weight = r;
        break;
      case "font-style":
        i.posture = r;
        break;
      case "letter-spacing":
        i.letterSpacing = Nt(r);
        break;
      case "margin":
        const c = r.split(/ \t/).map(((h) => Nt(h)));
        switch (c.length) {
          case 1:
            s.top = s.bottom = s.left = s.right = c[0];
            break;
          case 2:
            s.top = s.bottom = c[0], s.left = s.right = c[1];
            break;
          case 3:
            s.top = c[0], s.bottom = c[2], s.left = s.right = c[1];
            break;
          case 4:
            s.top = c[0], s.left = c[1], s.bottom = c[2], s.right = c[3];
        }
        break;
      case "margin-top":
        s.top = Nt(r);
        break;
      case "margin-bottom":
        s.bottom = Nt(r);
        break;
      case "margin-left":
        s.left = Nt(r);
        break;
      case "margin-right":
        s.right = Nt(r);
        break;
      case "line-height":
        n = Nt(r);
    }
    if (t.pushData(i, s, n), this[Qt]) t.addString(this[Qt]);
    else for (const o of this[ee]()) o[hA] !== "#text" ? o[vi](t) : t.addString(o[Qt]);
    e && t.popFont();
  }
  [Tt](t) {
    const e = [];
    if (this[nt] = { children: e }, this[Ms]({}), e.length === 0 && !this[Qt]) return Yt.EMPTY;
    let i;
    return i = this[lo] ? this[Qt] ? this[Qt].replaceAll(Sb, `
`) : void 0 : this[Qt] || void 0, Yt.success({ name: this[hA], attributes: { href: this.href, style: Fb(this.style, this, this[lo]) }, children: e, value: i });
  }
}
class xb extends We {
  constructor(t) {
    super(t, "a"), this.href = of(t.href) || "";
  }
}
class Nb extends We {
  constructor(t) {
    super(t, "b");
  }
  [vi](t) {
    t.pushFont({ weight: "bold" }), super[vi](t), t.popFont();
  }
}
class Gb extends We {
  constructor(t) {
    super(t, "body");
  }
  [Tt](t) {
    const e = super[Tt](t), { html: i } = e;
    return i ? (i.name = "div", i.attributes.class = ["xfaRich"], e) : Yt.EMPTY;
  }
}
class vb extends We {
  constructor(t) {
    super(t, "br");
  }
  [OA]() {
    return `
`;
  }
  [vi](t) {
    t.addString(`
`);
  }
  [Tt](t) {
    return Yt.success({ name: "br" });
  }
}
class Mb extends We {
  constructor(t) {
    super(t, "html");
  }
  [Tt](t) {
    const e = [];
    if (this[nt] = { children: e }, this[Ms]({}), e.length === 0) return Yt.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, value: this[Qt] || "" });
    if (e.length === 1) {
      const i = e[0];
      if (i.attributes?.class.includes("xfaRich")) return Yt.success(i);
    }
    return Yt.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, children: e });
  }
}
class Lb extends We {
  constructor(t) {
    super(t, "i");
  }
  [vi](t) {
    t.pushFont({ posture: "italic" }), super[vi](t), t.popFont();
  }
}
class Ub extends We {
  constructor(t) {
    super(t, "li");
  }
}
class Hb extends We {
  constructor(t) {
    super(t, "ol");
  }
}
class Jb extends We {
  constructor(t) {
    super(t, "p");
  }
  [vi](t) {
    super[vi](t, !1), t.addString(`
`), t.addPara(), t.popFont();
  }
  [OA]() {
    return this[jt]()[ee]().at(-1) === this ? super[OA]() : super[OA]() + `
`;
  }
}
class Yb extends We {
  constructor(t) {
    super(t, "span");
  }
}
class Tb extends We {
  constructor(t) {
    super(t, "sub");
  }
}
class Kb extends We {
  constructor(t) {
    super(t, "sup");
  }
}
class qb extends We {
  constructor(t) {
    super(t, "ul");
  }
}
class en {
  static [Bi](t, e) {
    if (en.hasOwnProperty(t)) return en[t](e);
  }
  static a(t) {
    return new xb(t);
  }
  static b(t) {
    return new Nb(t);
  }
  static body(t) {
    return new Gb(t);
  }
  static br(t) {
    return new vb(t);
  }
  static html(t) {
    return new Mb(t);
  }
  static i(t) {
    return new Lb(t);
  }
  static li(t) {
    return new Ub(t);
  }
  static ol(t) {
    return new Hb(t);
  }
  static p(t) {
    return new Jb(t);
  }
  static span(t) {
    return new Yb(t);
  }
  static sub(t) {
    return new Tb(t);
  }
  static sup(t) {
    return new Kb(t);
  }
  static ul(t) {
    return new qb(t);
  }
}
const P1 = { config: ig, connection: sg, datasets: ag, localeSet: ng, signature: rg, stylesheet: og, template: eg, xdp: gg, xhtml: en };
class _1 {
  constructor(t) {
    this.namespaceId = t;
  }
  [Bi](t, e) {
    return new Gi(this.namespaceId, t, e);
  }
}
class Pb extends gt {
  constructor(t) {
    super(-1, "root", /* @__PURE__ */ Object.create(null)), this.element = null, this[Ga] = t;
  }
  [Ni](t) {
    return this.element = t, !0;
  }
  [fA]() {
    super[fA](), this.element.template instanceof eI && (this[Ga].set(WE, this.element), this.element.template[Kn](this[Ga]), this.element.template[Ga] = this[Ga]);
  }
}
class _b extends gt {
  constructor() {
    super(-1, "", /* @__PURE__ */ Object.create(null));
  }
  [Ni](t) {
    return !1;
  }
}
class Ob {
  constructor(t = null) {
    this._namespaceStack = [], this._nsAgnosticLevel = 0, this._namespacePrefixes = /* @__PURE__ */ new Map(), this._namespaces = /* @__PURE__ */ new Map(), this._nextNsId = Math.max(...Object.values(JA).map((({ id: e }) => e))), this._currentNamespace = t || new _1(++this._nextNsId);
  }
  buildRoot(t) {
    return new Pb(t);
  }
  build({ nsPrefix: t, name: e, attributes: i, namespace: s, prefixes: n }) {
    const o = s !== null;
    if (o && (this._namespaceStack.push(this._currentNamespace), this._currentNamespace = this._searchNamespace(s)), n && this._addNamespacePrefix(n), i.hasOwnProperty(Fs)) {
      const h = P1.datasets, I = i[Fs];
      let C = null;
      for (const [d, u] of Object.entries(I))
        if (this._getNamespaceToUse(d) === h) {
          C = { xfa: u };
          break;
        }
      C ? i[Fs] = C : delete i[Fs];
    }
    const r = this._getNamespaceToUse(t), c = r?.[Bi](e, i) || new _b();
    return c[tr]() && this._nsAgnosticLevel++, (o || n || c[tr]()) && (c[So] = { hasNamespace: o, prefixes: n, nsAgnostic: c[tr]() }), c;
  }
  isNsAgnostic() {
    return this._nsAgnosticLevel > 0;
  }
  _searchNamespace(t) {
    let e = this._namespaces.get(t);
    if (e) return e;
    for (const [i, { check: s }] of Object.entries(JA)) if (s(t)) {
      if (e = P1[i], e) return this._namespaces.set(t, e), e;
      break;
    }
    return e = new _1(++this._nextNsId), this._namespaces.set(t, e), e;
  }
  _addNamespacePrefix(t) {
    for (const { prefix: e, value: i } of t) {
      const s = this._searchNamespace(i);
      let n = this._namespacePrefixes.get(e);
      n || (n = [], this._namespacePrefixes.set(e, n)), n.push(s);
    }
  }
  _getNamespaceToUse(t) {
    if (!t) return this._currentNamespace;
    const e = this._namespacePrefixes.get(t);
    return e?.length > 0 ? e.at(-1) : (O(`Unknown namespace prefix: ${t}.`), null);
  }
  clean(t) {
    const { hasNamespace: e, prefixes: i, nsAgnostic: s } = t;
    e && (this._currentNamespace = this._namespaceStack.pop()), i && i.forEach((({ prefix: n }) => {
      this._namespacePrefixes.get(n).pop();
    })), s && this._nsAgnosticLevel--;
  }
}
class cg extends UE {
  constructor(t = null, e = !1) {
    super(), this._builder = new Ob(t), this._stack = [], this._globalData = { usedTypefaces: /* @__PURE__ */ new Set() }, this._ids = /* @__PURE__ */ new Map(), this._current = this._builder.buildRoot(this._ids), this._errorCode = Vn, this._whiteRegex = /^\s+$/, this._nbsps = /\xa0+/g, this._richText = e;
  }
  parse(t) {
    if (this.parseXml(t), this._errorCode === Vn) return this._current[fA](), this._current.element;
  }
  onText(t) {
    t = t.replace(this._nbsps, ((e) => e.slice(1) + " ")), this._richText || this._current[fg]() ? this._current[$i](t, this._richText) : this._whiteRegex.test(t) || this._current[$i](t.trim());
  }
  onCdata(t) {
    this._current[$i](t);
  }
  _mkAttributes(t, e) {
    let i = null, s = null;
    const n = /* @__PURE__ */ Object.create({});
    for (const { name: o, value: r } of t) if (o === "xmlns") i ? O(`XFA - multiple namespace definition in <${e}>`) : i = r;
    else if (o.startsWith("xmlns:")) {
      const c = o.substring(6);
      s || (s = []), s.push({ prefix: c, value: r });
    } else {
      const c = o.indexOf(":");
      if (c === -1) n[o] = r;
      else {
        let h = n[Fs];
        h || (h = n[Fs] = /* @__PURE__ */ Object.create(null));
        const [I, C] = [o.slice(0, c), o.slice(c + 1)];
        (h[I] ||= /* @__PURE__ */ Object.create(null))[C] = r;
      }
    }
    return [i, s, n];
  }
  _getNameAndPrefix(t, e) {
    const i = t.indexOf(":");
    return i === -1 ? [t, null] : [t.substring(i + 1), e ? "" : t.substring(0, i)];
  }
  onBeginElement(t, e, i) {
    const [s, n, o] = this._mkAttributes(e, t), [r, c] = this._getNameAndPrefix(t, this._builder.isNsAgnostic()), h = this._builder.build({ nsPrefix: c, name: r, attributes: o, namespace: s, prefixes: n });
    if (h[QA] = this._globalData, i) return h[fA](), this._current[Ni](h) && h[$h](this._ids), void h[si](this._builder);
    this._stack.push(this._current), this._current = h;
  }
  onEndElement(t) {
    const e = this._current;
    if (e[Pl]() && typeof e[Qt] == "string") {
      const i = new cg();
      i._globalData = this._globalData;
      const s = i.parse(e[Qt]);
      e[Qt] = null, e[Ni](s);
    }
    e[fA](), this._current = this._stack.pop(), this._current[Ni](e) && e[$h](this._ids), e[si](this._builder);
  }
  onError(t) {
    this._errorCode = t;
  }
}
class Rr {
  constructor(t) {
    try {
      this.root = new cg().parse(Rr._createDocument(t));
      const e = new tw(this.root);
      this.form = e.bind(), this.dataHandler = new Aw(this.root, e.getData()), this.form[QA].template = this.form;
    } catch (e) {
      O(`XFA - an error occurred during parsing and binding: ${e}`);
    }
  }
  isValid() {
    return this.root && this.form;
  }
  _createPagesHelper() {
    const t = this.form[ZE]();
    return new Promise(((e, i) => {
      const s = () => {
        try {
          const n = t.next();
          n.done ? e(n.value) : setTimeout(s, 0);
        } catch (n) {
          i(n);
        }
      };
      setTimeout(s, 0);
    }));
  }
  async _createPages() {
    try {
      this.pages = await this._createPagesHelper(), this.dims = this.pages.children.map(((t) => {
        const { width: e, height: i } = t.attributes.style;
        return [0, 0, parseInt(e), parseInt(i)];
      }));
    } catch (t) {
      O(`XFA - an error occurred during layout: ${t}`);
    }
  }
  getBoundingBox(t) {
    return this.dims[t];
  }
  async getNumPages() {
    return this.pages || await this._createPages(), this.dims.length;
  }
  setImages(t) {
    this.form[QA].images = t;
  }
  setFonts(t) {
    this.form[QA].fontFinder = new hy(t);
    const e = [];
    for (let i of this.form[QA].usedTypefaces)
      i = mg(i), this.form[QA].fontFinder.find(i) || e.push(i);
    return e.length > 0 ? e : null;
  }
  appendFonts(t, e) {
    this.form[QA].fontFinder.add(t, e);
  }
  async getPages() {
    this.pages || await this._createPages();
    const t = this.pages;
    return this.pages = null, t;
  }
  serializeData(t) {
    return this.dataHandler.serialize(t);
  }
  static _createDocument(t) {
    return t["/xdp:xdp"] ? Object.values(t).join("") : t["xdp:xdp"];
  }
  static getRichTextAsHtml(t) {
    if (!t || typeof t != "string") return null;
    try {
      let e = new cg(en, !0).parse(t);
      if (!["body", "xhtml"].includes(e[hA])) {
        const o = en.body({});
        o[FA](e), e = o;
      }
      const i = e[Tt]();
      if (!i.success) return null;
      const { html: s } = i, { attributes: n } = s;
      return n && (n.class && (n.class = n.class.filter(((o) => !o.startsWith("xfa")))), n.dir = "auto"), { html: s, str: e[OA]() };
    } catch (e) {
      O(`XFA - an error occurred during parsing of rich text: ${e}`);
    }
    return null;
  }
}
class ws {
  static createGlobals(t) {
    return Promise.all([t.ensureCatalog("acroForm"), t.ensureDoc("xfaDatasets"), t.ensureCatalog("structTreeRoot"), t.ensureCatalog("baseUrl"), t.ensureCatalog("attachments")]).then((([e, i, s, n, o]) => ({ pdfManager: t, acroForm: e instanceof z ? e : z.empty, xfaDatasets: i, structTreeRoot: s, baseUrl: n, attachments: o })), ((e) => (O(`createGlobals: "${e}".`), null)));
  }
  static async create(t, e, i, s, n, o) {
    const r = n ? await this._getPageIndex(t, e, i.pdfManager) : null;
    return i.pdfManager.ensure(this, "_create", [t, e, i, s, n, r, o]);
  }
  static _create(t, e, i, s, n = !1, o = null, r = null) {
    const c = t.fetchIfRef(e);
    if (!(c instanceof z)) return;
    const { acroForm: h, pdfManager: I } = i, C = e instanceof St ? e.toString() : `annot_${s.createObjId()}`;
    let d = c.get("Subtype");
    d = d instanceof at ? d.name : null;
    const u = { xref: t, ref: e, dict: c, subtype: d, id: C, annotationGlobals: i, collectFields: n, needAppearances: !n && h.get("NeedAppearances") === !0, pageIndex: o, evaluatorOptions: I.evaluatorOptions, pageRef: r };
    switch (d) {
      case "Link":
        return new zb(u);
      case "Text":
        return new Xb(u);
      case "Widget":
        let E = ei({ dict: c, key: "FT" });
        switch (E = E instanceof at ? E.name : null, E) {
          case "Tx":
            return new jb(u);
          case "Btn":
            return new Zb(u);
          case "Ch":
            return new Vb(u);
          case "Sig":
            return new Sf(u);
        }
        return O(`Unimplemented widget field type "${E}", falling back to base field type.`), new ui(u);
      case "Popup":
        return new Ff(u);
      case "FreeText":
        return new Ch(u);
      case "Line":
        return new $b(u);
      case "Square":
        return new tD(u);
      case "Circle":
        return new AD(u);
      case "PolyLine":
        return new Rf(u);
      case "Polygon":
        return new xf(u);
      case "Caret":
        return new eD(u);
      case "Ink":
        return new Un(u);
      case "Highlight":
        return new uh(u);
      case "Underline":
        return new iD(u);
      case "Squiggly":
        return new sD(u);
      case "StrikeOut":
        return new aD(u);
      case "Stamp":
        return new Io(u);
      case "FileAttachment":
        return new nD(u);
      default:
        return n || O(d ? `Unimplemented annotation type "${d}", falling back to base annotation.` : "Annotation is missing the required /Subtype."), new Nr(u);
    }
  }
  static async _getPageIndex(t, e, i) {
    try {
      const s = await t.fetchIfRefAsync(e);
      if (!(s instanceof z)) return -1;
      const n = s.getRaw("P");
      if (n instanceof St) try {
        return await i.ensureCatalog("getPageIndex", [n]);
      } catch (r) {
        tA(`_getPageIndex -- not a valid page reference: "${r}".`);
      }
      if (s.has("Kids")) return -1;
      const o = await i.ensureDoc("numPages");
      for (let r = 0; r < o; r++) {
        const c = await i.getPage(r), h = await i.ensure(c, "annotations");
        for (const I of h) if (I instanceof St && Po(I, e)) return r;
      }
    } catch (s) {
      O(`_getPageIndex: "${s}".`);
    }
    return -1;
  }
  static generateImages(t, e, i) {
    if (!i) return O("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."), null;
    let s;
    for (const { bitmapId: n, bitmap: o } of t) o && (s ||= /* @__PURE__ */ new Map(), s.set(n, Io.createImage(o, e)));
    return s;
  }
  static async saveNewAnnotations(t, e, i, s) {
    const n = t.xref;
    let o;
    const r = [], c = [], { isOffscreenCanvasSupported: h } = t.options;
    for (const I of i) if (!I.deleted) switch (I.annotationType) {
      case cC:
        if (!o) {
          const d = new z(n);
          d.set("BaseFont", at.get("Helvetica")), d.set("Type", at.get("Font")), d.set("Subtype", at.get("Type1")), d.set("Encoding", at.get("WinAnsiEncoding"));
          const u = [];
          o = n.getNewTemporaryRef(), await me(o, d, u, n), r.push({ ref: o, data: u.join("") });
        }
        c.push(Ch.createNewAnnotation(n, I, r, { evaluator: t, task: e, baseFontRef: o }));
        break;
      case hC:
        I.quadPoints ? c.push(uh.createNewAnnotation(n, I, r)) : c.push(Un.createNewAnnotation(n, I, r));
        break;
      case IC:
        c.push(Un.createNewAnnotation(n, I, r));
        break;
      case lC:
        if (!h) break;
        const C = await s.get(I.bitmapId);
        if (C.imageStream) {
          const { imageStream: d, smaskStream: u } = C, E = [];
          if (u) {
            const y = n.getNewTemporaryRef();
            await me(y, u, E, n), r.push({ ref: y, data: E.join("") }), d.dict.set("SMask", y), E.length = 0;
          }
          const p = C.imageRef = n.getNewTemporaryRef();
          await me(p, d, E, n), r.push({ ref: p, data: E.join("") }), C.imageStream = C.smaskStream = null;
        }
        c.push(Io.createNewAnnotation(n, I, r, { image: C }));
    }
    return { annotations: await Promise.all(c), dependencies: r };
  }
  static async printNewAnnotations(t, e, i, s, n) {
    if (!s) return null;
    const { options: o, xref: r } = e, c = [];
    for (const h of s) if (!h.deleted) switch (h.annotationType) {
      case cC:
        c.push(Ch.createNewPrintAnnotation(t, r, h, { evaluator: e, task: i, evaluatorOptions: o }));
        break;
      case hC:
        h.quadPoints ? c.push(uh.createNewPrintAnnotation(t, r, h, { evaluatorOptions: o })) : c.push(Un.createNewPrintAnnotation(t, r, h, { evaluatorOptions: o }));
        break;
      case IC:
        c.push(Un.createNewPrintAnnotation(t, r, h, { evaluatorOptions: o }));
        break;
      case lC:
        if (!o.isOffscreenCanvasSupported) break;
        const I = await n.get(h.bitmapId);
        if (I.imageStream) {
          const { imageStream: C, smaskStream: d } = I;
          d && C.dict.set("SMask", d), I.imageRef = new wl(C, C.length), I.imageStream = I.smaskStream = null;
        }
        c.push(Io.createNewPrintAnnotation(t, r, h, { image: I, evaluatorOptions: o }));
    }
    return Promise.all(c);
  }
}
function Oa(A, t = new Uint8ClampedArray(3)) {
  if (!Array.isArray(A)) return t;
  const e = t || new Uint8ClampedArray(3);
  switch (A.length) {
    case 0:
      return null;
    case 1:
      return Vt.singletons.gray.getRgbItem(A, 0, e, 0), e;
    case 3:
      return Vt.singletons.rgb.getRgbItem(A, 0, e, 0), e;
    case 4:
      return Vt.singletons.cmyk.getRgbItem(A, 0, e, 0), e;
    default:
      return t;
  }
}
function Ne(A) {
  return Array.from(A, ((t) => t / 255));
}
function xr(A, t) {
  const e = A.getArray("QuadPoints");
  if (!Pe(e, null) || e.length === 0 || e.length % 8 > 0) return null;
  const i = new Float32Array(e.length);
  for (let s = 0, n = e.length; s < n; s += 8) {
    const [o, r, c, h, I, C, d, u] = e.slice(s, s + 8), E = Math.min(o, c, I, d), p = Math.max(o, c, I, d), y = Math.min(r, h, C, u), b = Math.max(r, h, C, u);
    if (t !== null && (E < t[0] || p > t[2] || y < t[1] || b > t[3])) return null;
    i.set([E, b, p, b, E, y, p, y], s);
  }
  return i;
}
function al(A, t, e) {
  const [i, s, n, o] = PA.getAxialAlignedBoundingBox(t, e);
  if (i === n || s === o) return [1, 0, 0, 1, A[0], A[1]];
  const r = (A[2] - A[0]) / (n - i), c = (A[3] - A[1]) / (o - s);
  return [r, 0, 0, c, A[0] - i * r, A[1] - s * c];
}
class Nr {
  constructor(t) {
    const { dict: e, xref: i, annotationGlobals: s } = t;
    this.setTitle(e.get("T")), this.setContents(e.get("Contents")), this.setModificationDate(e.get("M")), this.setFlags(e.get("F")), this.setRectangle(e.getArray("Rect")), this.setColor(e.getArray("C")), this.setBorderStyle(e), this.setAppearance(e), this.setOptionalContent(e);
    const n = e.get("MK");
    this.setBorderAndBackgroundColors(n), this.setRotation(n, e), this.ref = t.ref instanceof St ? t.ref : null, this._streams = [], this.appearance && this._streams.push(this.appearance);
    const o = !!(this.flags & j9), r = !!(this.flags & Z9);
    if (s.structTreeRoot) {
      let c = e.get("StructParent");
      c = Number.isInteger(c) && c >= 0 ? c : -1, s.structTreeRoot.addAnnotationIdToPage(t.pageRef, c);
    }
    if (this.data = { annotationFlags: this.flags, borderStyle: this.borderStyle, color: this.color, backgroundColor: this.backgroundColor, borderColor: this.borderColor, rotation: this.rotation, contentsObj: this._contents, hasAppearance: !!this.appearance, id: t.id, modificationDate: this.modificationDate, rect: this.rectangle, subtype: t.subtype, hasOwnCanvas: !1, noRotate: !!(this.flags & W9), noHTML: o && r, isEditable: !1 }, t.collectFields) {
      const c = e.get("Kids");
      if (Array.isArray(c)) {
        const h = [];
        for (const I of c) I instanceof St && h.push(I.toString());
        h.length !== 0 && (this.data.kidIds = h);
      }
      this.data.actions = Bg(i, e, EQ), this.data.fieldName = this._constructFieldName(e), this.data.pageIndex = t.pageIndex;
    }
    this._isOffscreenCanvasSupported = t.evaluatorOptions.isOffscreenCanvasSupported, this._fallbackFontDict = null, this._needAppearances = !1;
  }
  _hasFlag(t, e) {
    return !!(t & e);
  }
  _isViewable(t) {
    return !this._hasFlag(t, Or) && !this._hasFlag(t, wh);
  }
  _isPrintable(t) {
    return this._hasFlag(t, O9) && !this._hasFlag(t, No) && !this._hasFlag(t, Or);
  }
  mustBeViewed(t, e) {
    const i = t?.get(this.data.id)?.noView;
    return i !== void 0 ? !i : this.viewable && !this._hasFlag(this.flags, No);
  }
  mustBePrinted(t) {
    const e = t?.get(this.data.id)?.noPrint;
    return e !== void 0 ? !e : this.printable;
  }
  mustBeViewedWhenEditing(t, e = null) {
    return t ? !this.data.isEditable : !e?.has(this.data.id);
  }
  get viewable() {
    return this.data.quadPoints !== null && (this.flags === 0 || this._isViewable(this.flags));
  }
  get printable() {
    return this.data.quadPoints !== null && this.flags !== 0 && this._isPrintable(this.flags);
  }
  _parseStringHelper(t) {
    const e = typeof t == "string" ? cA(t) : "";
    return { str: e, dir: e && xE(e).dir === "rtl" ? "rtl" : "ltr" };
  }
  setDefaultAppearance(t) {
    const { dict: e, annotationGlobals: i } = t, s = ei({ dict: e, key: "DA" }) || i.acroForm.get("DA");
    this._defaultAppearance = typeof s == "string" ? s : "", this.data.defaultAppearanceData = Hl(this._defaultAppearance);
  }
  setTitle(t) {
    this._title = this._parseStringHelper(t);
  }
  setContents(t) {
    this._contents = this._parseStringHelper(t);
  }
  setModificationDate(t) {
    this.modificationDate = typeof t == "string" ? t : null;
  }
  setFlags(t) {
    this.flags = Number.isInteger(t) && t > 0 ? t : 0, this.flags & Or && this.constructor.name !== "Annotation" && (this.flags ^= Or);
  }
  hasFlag(t) {
    return this._hasFlag(this.flags, t);
  }
  setRectangle(t) {
    this.rectangle = Zi(t, [0, 0, 0, 0]);
  }
  setColor(t) {
    this.color = Oa(t);
  }
  setLineEndings(t) {
    if (this.lineEndings = ["None", "None"], Array.isArray(t) && t.length === 2) for (let e = 0; e < 2; e++) {
      const i = t[e];
      if (i instanceof at) switch (i.name) {
        case "None":
          continue;
        case "Square":
        case "Circle":
        case "Diamond":
        case "OpenArrow":
        case "ClosedArrow":
        case "Butt":
        case "ROpenArrow":
        case "RClosedArrow":
        case "Slash":
          this.lineEndings[e] = i.name;
          continue;
      }
      O(`Ignoring invalid lineEnding: ${i}`);
    }
  }
  setRotation(t, e) {
    this.rotation = 0;
    let i = t instanceof z ? t.get("R") || 0 : e.get("Rotate") || 0;
    Number.isInteger(i) && i !== 0 && (i %= 360, i < 0 && (i += 360), i % 90 == 0 && (this.rotation = i));
  }
  setBorderAndBackgroundColors(t) {
    t instanceof z ? (this.borderColor = Oa(t.getArray("BC"), null), this.backgroundColor = Oa(t.getArray("BG"), null)) : this.borderColor = this.backgroundColor = null;
  }
  setBorderStyle(t) {
    if (this.borderStyle = new Wb(), t instanceof z) if (t.has("BS")) {
      const e = t.get("BS");
      if (e instanceof z) {
        const i = e.get("Type");
        i && !qA(i, "Border") || (this.borderStyle.setWidth(e.get("W"), this.rectangle), this.borderStyle.setStyle(e.get("S")), this.borderStyle.setDashArray(e.getArray("D")));
      }
    } else if (t.has("Border")) {
      const e = t.getArray("Border");
      Array.isArray(e) && e.length >= 3 && (this.borderStyle.setHorizontalCornerRadius(e[0]), this.borderStyle.setVerticalCornerRadius(e[1]), this.borderStyle.setWidth(e[2], this.rectangle), e.length === 4 && this.borderStyle.setDashArray(e[3], !0));
    } else this.borderStyle.setWidth(0);
  }
  setAppearance(t) {
    this.appearance = null;
    const e = t.get("AP");
    if (!(e instanceof z)) return;
    const i = e.get("N");
    if (i instanceof AA) return void (this.appearance = i);
    if (!(i instanceof z)) return;
    const s = t.get("AS");
    if (!(s instanceof at && i.has(s.name))) return;
    const n = i.get(s.name);
    n instanceof AA && (this.appearance = n);
  }
  setOptionalContent(t) {
    this.oc = null;
    const e = t.get("OC");
    e instanceof at ? O("setOptionalContent: Support for /Name-entry is not implemented.") : e instanceof z && (this.oc = e);
  }
  loadResources(t, e) {
    return e.dict.getAsync("Resources").then(((i) => {
      if (i)
        return new zo(i, t, i.xref).load().then((function() {
          return i;
        }));
    }));
  }
  async getOperatorList(t, e, i, s) {
    const { hasOwnCanvas: n, id: o, rect: r } = this.data;
    let c = this.appearance;
    const h = !!(n && i & Ro);
    if (h && (r[0] === r[2] || r[1] === r[3])) return this.data.hasOwnCanvas = !1, { opList: new ue(), separateForm: !1, separateCanvas: !1 };
    if (!c) {
      if (!h) return { opList: new ue(), separateForm: !1, separateCanvas: !1 };
      c = new _e(""), c.dict = new z();
    }
    const I = c.dict, C = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], c), d = Gh(I.getArray("BBox"), [0, 0, 1, 1]), u = ks(I.getArray("Matrix"), Ci), E = al(r, d, u), p = new ue();
    let y;
    return this.oc && (y = await t.parseMarkedContentProps(this.oc, null)), y !== void 0 && p.addOp(wi, ["OC", y]), p.addOp(YQ, [o, r, E, u, h]), await t.getOperatorList({ stream: c, task: e, resources: C, operatorList: p, fallbackFontDict: this._fallbackFontDict }), p.addOp(TQ, []), y !== void 0 && p.addOp(Wa, []), this.reset(), { opList: p, separateForm: !1, separateCanvas: h };
  }
  async save(t, e, i) {
    return null;
  }
  get hasTextContent() {
    return !1;
  }
  async extractTextContent(t, e, i) {
    if (!this.appearance) return;
    const s = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance), n = [], o = [];
    let r = null;
    const c = { desiredSize: Math.Infinity, ready: !0, enqueue(h, I) {
      for (const C of h.items) C.str !== void 0 && (r ||= C.transform.slice(-2), o.push(C.str), C.hasEOL && (n.push(o.join("").trimEnd()), o.length = 0));
    } };
    if (await t.getTextContent({ stream: this.appearance, task: e, resources: s, includeMarkedContent: !0, keepWhiteSpace: !0, sink: c, viewBox: i }), this.reset(), o.length && n.push(o.join("").trimEnd()), n.length > 1 || n[0]) {
      const h = this.appearance.dict, I = Gh(h.getArray("BBox"), null), C = ks(h.getArray("Matrix"), null);
      this.data.textPosition = this._transformPoint(r, I, C), this.data.textContent = n;
    }
  }
  _transformPoint(t, e, i) {
    const { rect: s } = this.data;
    e ||= [0, 0, 1, 1], i ||= [1, 0, 0, 1, 0, 0];
    const n = al(s, e, i);
    return n[4] -= s[0], n[5] -= s[1], t = PA.applyTransform(t, n), PA.applyTransform(t, i);
  }
  getFieldObject() {
    return this.data.kidIds ? { id: this.data.id, actions: this.data.actions, name: this.data.fieldName, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, type: "", kidIds: this.data.kidIds, page: this.data.pageIndex, rotation: this.rotation } : null;
  }
  reset() {
    for (const t of this._streams) t.reset();
  }
  _constructFieldName(t) {
    if (!t.has("T") && !t.has("Parent")) return O("Unknown field name, falling back to empty field name."), "";
    if (!t.has("Parent")) return cA(t.get("T"));
    const e = [];
    t.has("T") && e.unshift(cA(t.get("T")));
    let i = t;
    const s = new XA();
    for (t.objId && s.put(t.objId); i.has("Parent") && (i = i.get("Parent"), i instanceof z && (!i.objId || !s.has(i.objId))); ) i.objId && s.put(i.objId), i.has("T") && e.unshift(cA(i.get("T")));
    return e.join(".");
  }
}
class Wb {
  constructor() {
    this.width = 1, this.style = dC, this.dashArray = [3], this.horizontalCornerRadius = 0, this.verticalCornerRadius = 0;
  }
  setWidth(t, e = [0, 0, 0, 0]) {
    if (t instanceof at) this.width = 0;
    else if (typeof t == "number") {
      if (t > 0) {
        const i = (e[2] - e[0]) / 2, s = (e[3] - e[1]) / 2;
        i > 0 && s > 0 && (t > i || t > s) && (O(`AnnotationBorderStyle.setWidth - ignoring width: ${t}`), t = 1);
      }
      this.width = t;
    }
  }
  setStyle(t) {
    if (t instanceof at) switch (t.name) {
      case "S":
        this.style = dC;
        break;
      case "D":
        this.style = im;
        break;
      case "B":
        this.style = sm;
        break;
      case "I":
        this.style = am;
        break;
      case "U":
        this.style = nm;
    }
  }
  setDashArray(t, e = !1) {
    if (Array.isArray(t)) {
      let i = !0, s = !0;
      for (const n of t) {
        if (!(+n >= 0)) {
          i = !1;
          break;
        }
        n > 0 && (s = !1);
      }
      t.length === 0 || i && !s ? (this.dashArray = t, e && this.setStyle(at.get("D"))) : this.width = 0;
    } else t && (this.width = 0);
  }
  setHorizontalCornerRadius(t) {
    Number.isInteger(t) && (this.horizontalCornerRadius = t);
  }
  setVerticalCornerRadius(t) {
    Number.isInteger(t) && (this.verticalCornerRadius = t);
  }
}
class Ge extends Nr {
  constructor(t) {
    super(t);
    const { dict: e } = t;
    if (e.has("IRT")) {
      const s = e.getRaw("IRT");
      this.data.inReplyTo = s instanceof St ? s.toString() : null;
      const n = e.get("RT");
      this.data.replyType = n instanceof at ? n.name : _9;
    }
    let i = null;
    if (this.data.replyType === QQ) {
      const s = e.get("IRT");
      this.setTitle(s.get("T")), this.data.titleObj = this._title, this.setContents(s.get("Contents")), this.data.contentsObj = this._contents, s.has("CreationDate") ? (this.setCreationDate(s.get("CreationDate")), this.data.creationDate = this.creationDate) : this.data.creationDate = null, s.has("M") ? (this.setModificationDate(s.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, i = s.getRaw("Popup"), s.has("C") ? (this.setColor(s.getArray("C")), this.data.color = this.color) : this.data.color = null;
    } else this.data.titleObj = this._title, this.setCreationDate(e.get("CreationDate")), this.data.creationDate = this.creationDate, i = e.getRaw("Popup"), e.has("C") || (this.data.color = null);
    this.data.popupRef = i instanceof St ? i.toString() : null, e.has("RC") && (this.data.richText = Rr.getRichTextAsHtml(e.get("RC")));
  }
  setCreationDate(t) {
    this.creationDate = typeof t == "string" ? t : null;
  }
  _setDefaultAppearance({ xref: t, extra: e, strokeColor: i, fillColor: s, blendMode: n, strokeAlpha: o, fillAlpha: r, pointsCallback: c }) {
    let h = Number.MAX_VALUE, I = Number.MAX_VALUE, C = Number.MIN_VALUE, d = Number.MIN_VALUE;
    const u = ["q"];
    e && u.push(e), i && u.push(`${i[0]} ${i[1]} ${i[2]} RG`), s && u.push(`${s[0]} ${s[1]} ${s[2]} rg`);
    let E = this.data.quadPoints;
    E || (E = Float32Array.from([this.rectangle[0], this.rectangle[3], this.rectangle[2], this.rectangle[3], this.rectangle[0], this.rectangle[1], this.rectangle[2], this.rectangle[1]]));
    for (let U = 0, T = E.length; U < T; U += 8) {
      const [q, _, Y, ht] = c(u, E.subarray(U, U + 8));
      h = Math.min(h, q), C = Math.max(C, _), I = Math.min(I, Y), d = Math.max(d, ht);
    }
    u.push("Q");
    const p = new z(t), y = new z(t);
    y.set("Subtype", at.get("Form"));
    const b = new _e(u.join(" "));
    b.dict = y, p.set("Fm0", b);
    const D = new z(t);
    n && D.set("BM", at.get(n)), typeof o == "number" && D.set("CA", o), typeof r == "number" && D.set("ca", r);
    const S = new z(t);
    S.set("GS0", D);
    const R = new z(t);
    R.set("ExtGState", S), R.set("XObject", p);
    const x = new z(t);
    x.set("Resources", R);
    const N = this.data.rect = [h, I, C, d];
    x.set("BBox", N), this.appearance = new _e("/GS0 gs /Fm0 Do"), this.appearance.dict = x, this._streams.push(this.appearance, b);
  }
  static async createNewAnnotation(t, e, i, s) {
    let n;
    e.ref ? n = (await t.fetchIfRefAsync(e.ref)).clone() : e.ref = t.getNewTemporaryRef();
    const o = e.ref, r = await this.createNewAppearanceStream(e, t, s), c = [];
    let h;
    if (r) {
      const I = t.getNewTemporaryRef();
      h = this.createNewDict(e, t, { apRef: I, oldAnnotation: n }), await me(I, r, c, t), i.push({ ref: I, data: c.join("") });
    } else h = this.createNewDict(e, t, { oldAnnotation: n });
    return Number.isInteger(e.parentTreeId) && h.set("StructParent", e.parentTreeId), c.length = 0, await me(o, h, c, t), { ref: o, data: c.join("") };
  }
  static async createNewPrintAnnotation(t, e, i, s) {
    const n = await this.createNewAppearanceStream(i, e, s), o = this.createNewDict(i, e, { ap: n }), r = new this.prototype.constructor({ dict: o, xref: e, annotationGlobals: t, evaluatorOptions: s.evaluatorOptions });
    return i.ref && (r.ref = r.refToReplace = i.ref), r;
  }
}
class ui extends Nr {
  constructor(t) {
    super(t);
    const { dict: e, xref: i, annotationGlobals: s } = t, n = this.data;
    this._needAppearances = t.needAppearances, n.annotationType = P9, n.fieldName === void 0 && (n.fieldName = this._constructFieldName(e)), n.actions === void 0 && (n.actions = Bg(i, e, EQ));
    let o = ei({ dict: e, key: "V", getArray: !0 });
    n.fieldValue = this._decodeFormValue(o);
    const r = ei({ dict: e, key: "DV", getArray: !0 });
    if (n.defaultFieldValue = this._decodeFormValue(r), o === void 0 && s.xfaDatasets) {
      const d = this._title.str;
      d && (this._hasValueFromXFA = !0, n.fieldValue = o = s.xfaDatasets.getValue(d));
    }
    o === void 0 && n.defaultFieldValue !== null && (n.fieldValue = n.defaultFieldValue), n.alternativeText = cA(e.get("TU") || ""), this.setDefaultAppearance(t), n.hasAppearance ||= this._needAppearances && n.fieldValue !== void 0 && n.fieldValue !== null;
    const c = ei({ dict: e, key: "FT" });
    n.fieldType = c instanceof at ? c.name : null;
    const h = ei({ dict: e, key: "DR" }), I = s.acroForm.get("DR"), C = this.appearance?.dict.get("Resources");
    this._fieldResources = { localResources: h, acroFormResources: I, appearanceResources: C, mergedResources: z.merge({ xref: i, dictArray: [h, C, I], mergeSubDicts: !0 }) }, n.fieldFlags = ei({ dict: e, key: "Ff" }), (!Number.isInteger(n.fieldFlags) || n.fieldFlags < 0) && (n.fieldFlags = 0), n.readOnly = this.hasFieldFlag(V9), n.required = this.hasFieldFlag(X9), n.hidden = this._hasFlag(n.annotationFlags, No) || this._hasFlag(n.annotationFlags, wh);
  }
  _decodeFormValue(t) {
    return Array.isArray(t) ? t.filter(((e) => typeof e == "string")).map(((e) => cA(e))) : t instanceof at ? cA(t.name) : typeof t == "string" ? cA(t) : null;
  }
  hasFieldFlag(t) {
    return !!(this.data.fieldFlags & t);
  }
  _isViewable(t) {
    return !0;
  }
  mustBeViewed(t, e) {
    return e ? this.viewable : super.mustBeViewed(t, e) && !this._hasFlag(this.flags, wh);
  }
  getRotationMatrix(t) {
    let e = t?.get(this.data.id)?.rotation;
    return e === void 0 && (e = this.rotation), e === 0 ? Ci : Oo(e, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]);
  }
  getBorderAndBackgroundAppearances(t) {
    let e = t?.get(this.data.id)?.rotation;
    if (e === void 0 && (e = this.rotation), !this.backgroundColor && !this.borderColor) return "";
    const i = this.data.rect[2] - this.data.rect[0], s = this.data.rect[3] - this.data.rect[1], n = e === 0 || e === 180 ? `0 0 ${i} ${s} re` : `0 0 ${s} ${i} re`;
    let o = "";
    return this.backgroundColor && (o = `${Xi(this.backgroundColor, !0)} ${n} f `), this.borderColor && (o += `${this.borderStyle.width || 1} w ${Xi(this.borderColor, !1)} ${n} S `), o;
  }
  async getOperatorList(t, e, i, s) {
    if (i & BQ && !(this instanceof Sf) && !this.data.noHTML && !this.data.hasOwnCanvas) return { opList: new ue(), separateForm: !0, separateCanvas: !1 };
    if (!this._hasText) return super.getOperatorList(t, e, i, s);
    const n = await this._getAppearance(t, e, i, s);
    if (this.appearance && n === null) return super.getOperatorList(t, e, i, s);
    const o = new ue();
    if (!this._defaultAppearance || n === null) return { opList: o, separateForm: !1, separateCanvas: !1 };
    const r = !!(this.data.hasOwnCanvas && i & Ro), c = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]], h = al(this.data.rect, c, [1, 0, 0, 1, 0, 0]);
    let I;
    this.oc && (I = await t.parseMarkedContentProps(this.oc, null)), I !== void 0 && o.addOp(wi, ["OC", I]), o.addOp(YQ, [this.data.id, this.data.rect, h, this.getRotationMatrix(s), r]);
    const C = new _e(n);
    return await t.getOperatorList({ stream: C, task: e, resources: this._fieldResources.mergedResources, operatorList: o }), o.addOp(TQ, []), I !== void 0 && o.addOp(Wa, []), { opList: o, separateForm: !1, separateCanvas: r };
  }
  _getMKDict(t) {
    const e = new z(null);
    return t && e.set("R", t), this.borderColor && e.set("BC", Ne(this.borderColor)), this.backgroundColor && e.set("BG", Ne(this.backgroundColor)), e.size > 0 ? e : null;
  }
  amendSavedDict(t, e) {
  }
  async save(t, e, i) {
    const s = i?.get(this.data.id);
    let n = s?.value, o = s?.rotation;
    if (n === this.data.fieldValue || n === void 0) {
      if (!this._hasValueFromXFA && o === void 0) return null;
      n ||= this.data.fieldValue;
    }
    if (o === void 0 && !this._hasValueFromXFA && Array.isArray(n) && Array.isArray(this.data.fieldValue) && n.length === this.data.fieldValue.length && n.every(((y, b) => y === this.data.fieldValue[b]))) return null;
    o === void 0 && (o = this.rotation);
    let r = null;
    if (!this._needAppearances && (r = await this._getAppearance(t, e, gC, i), r === null)) return null;
    let c = !1;
    r?.needAppearances && (c = !0, r = null);
    const { xref: h } = t, I = h.fetchIfRef(this.ref);
    if (!(I instanceof z)) return null;
    const C = new z(h);
    for (const y of I.getKeys()) y !== "AP" && C.set(y, I.getRaw(y));
    const d = { path: this.data.fieldName, value: n };
    C.set("V", Array.isArray(n) ? n.map(xi) : xi(n)), this.amendSavedDict(i, C);
    const u = this._getMKDict(o);
    u && C.set("MK", u);
    const E = [], p = [{ ref: this.ref, data: "", xfa: d, needAppearances: c }];
    if (r !== null) {
      const y = h.getNewTemporaryRef(), b = new z(h);
      C.set("AP", b), b.set("N", y);
      const D = this._getSaveFieldResources(h), S = new _e(r), R = S.dict = new z(h);
      R.set("Subtype", at.get("Form")), R.set("Resources", D), R.set("BBox", [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]);
      const x = this.getRotationMatrix(i);
      x !== Ci && R.set("Matrix", x), await me(y, S, E, h), p.push({ ref: y, data: E.join(""), xfa: null, needAppearances: !1 }), E.length = 0;
    }
    return C.set("M", `D:${Gs()}`), await me(this.ref, C, E, h), p[0].data = E.join(""), p;
  }
  async _getAppearance(t, e, i, s) {
    if (this.hasFieldFlag(bh)) return null;
    const n = s?.get(this.data.id);
    let o, r;
    if (n && (o = n.formattedValue || n.value, r = n.rotation), r === void 0 && o === void 0 && !this._needAppearances && (!this._hasValueFromXFA || this.appearance)) return null;
    const c = this.getBorderAndBackgroundAppearances(s);
    if (o === void 0 && (o = this.data.fieldValue, !o)) return `/Tx BMC q ${c}Q EMC`;
    if (Array.isArray(o) && o.length === 1 && (o = o[0]), pe(typeof o == "string", "Expected `value` to be a string."), o = o.trim(), this.data.combo && (o = this.data.options.find((({ exportValue: T }) => o === T))?.displayValue || o), o === "") return `/Tx BMC q ${c}Q EMC`;
    r === void 0 && (r = this.rotation);
    let h, I = -1;
    this.data.multiLine ? (h = o.split(/\r\n?|\n/).map(((U) => U.normalize("NFC"))), I = h.length) : h = [o.replace(/\r\n?|\n/, "").normalize("NFC")];
    let C = this.data.rect[3] - this.data.rect[1], d = this.data.rect[2] - this.data.rect[0];
    r !== 90 && r !== 270 || ([d, C] = [C, d]), this._defaultAppearance || (this.data.defaultAppearanceData = Hl(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
    let u, E, p, y = await ui._getFontData(t, e, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    const b = [];
    let D = !1;
    for (const U of h) {
      const T = y.encodeString(U);
      T.length > 1 && (D = !0), b.push(T.join(""));
    }
    if (D && i & gC) return { needAppearances: !0 };
    if (D && this._isOffscreenCanvasSupported) {
      const U = this.data.comb ? "monospace" : "sans-serif", T = new Di(t.xref, U), q = T.createFontResources(h.join("")), _ = q.getRaw("Font");
      if (this._fieldResources.mergedResources.has("Font")) {
        const ut = this._fieldResources.mergedResources.get("Font");
        for (const j of _.getKeys()) ut.set(j, _.getRaw(j));
      } else this._fieldResources.mergedResources.set("Font", _);
      const Y = T.fontName.name;
      y = await ui._getFontData(t, e, { fontName: Y, fontSize: 0 }, q);
      for (let ut = 0, j = b.length; ut < j; ut++) b[ut] = sE(h[ut]);
      const ht = Object.assign(/* @__PURE__ */ Object.create(null), this.data.defaultAppearanceData);
      this.data.defaultAppearanceData.fontSize = 0, this.data.defaultAppearanceData.fontName = Y, [u, E, p] = this._computeFontSize(C - 2, d - 4, o, y, I), this.data.defaultAppearanceData = ht;
    } else this._isOffscreenCanvasSupported || O("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."), [u, E, p] = this._computeFontSize(C - 2, d - 4, o, y, I);
    let S = y.descent;
    S = isNaN(S) ? nC * p : Math.max(nC * p, Math.abs(S) * E);
    const R = Math.min(Math.floor((C - E) / 2), 1), x = this.data.textAlignment;
    if (this.data.multiLine) return this._getMultilineAppearance(u, b, y, E, d, C, x, 2, R, S, p, s);
    if (this.data.comb) return this._getCombAppearance(u, y, b[0], E, d, C, 2, R, S, p, s);
    const N = R + S;
    return x === 0 || x > 2 ? `/Tx BMC q ${c}BT ` + u + ` 1 0 0 1 ${BA(2)} ${BA(N)} Tm (${Za(b[0])}) Tj ET Q EMC` : `/Tx BMC q ${c}BT ` + u + ` 1 0 0 1 0 0 Tm ${this._renderText(b[0], y, E, d, x, { shift: 0 }, 2, N)} ET Q EMC`;
  }
  static async _getFontData(t, e, i, s) {
    const n = new ue(), o = { font: null, clone() {
      return this;
    } }, { fontName: r, fontSize: c } = i;
    return await t.handleSetFont(s, [r && at.get(r), c], null, n, e, o, null), o.font;
  }
  _getTextWidth(t, e) {
    return e.charsToGlyphs(t).reduce(((i, s) => i + s.width), 0) / 1e3;
  }
  _computeFontSize(t, e, i, s, n) {
    let { fontSize: o } = this.data.defaultAppearanceData, r = (o || 12) * na, c = Math.round(t / r);
    if (!o) {
      const h = (d) => Math.floor(100 * d) / 100;
      if (n === -1) {
        const d = this._getTextWidth(i, s);
        o = h(Math.min(t / na, d > e ? e / d : 1 / 0)), c = 1;
      } else {
        const d = i.split(/\r\n?|\n/), u = [];
        for (const p of d) {
          const y = s.encodeString(p).join(""), b = s.charsToGlyphs(y), D = s.getCharPositions(y);
          u.push({ line: y, glyphs: b, positions: D });
        }
        const E = (p) => {
          let y = 0;
          for (const b of u)
            if (y += this._splitLine(null, s, p, e, b).length * p, y > t) return !0;
          return !1;
        };
        for (c = Math.max(c, n); r = t / c, o = h(r / na), E(o); ) c++;
      }
      const { fontName: I, fontColor: C } = this.data.defaultAppearanceData;
      this._defaultAppearance = (function({ fontSize: d, fontName: u, fontColor: E }) {
        return `/${yl(u)} ${d} Tf ${Xi(E, !0)}`;
      })({ fontSize: o, fontName: I, fontColor: C });
    }
    return [this._defaultAppearance, o, t / c];
  }
  _renderText(t, e, i, s, n, o, r, c) {
    let h;
    n === 1 ? h = (s - this._getTextWidth(t, e) * i) / 2 : n === 2 ? h = s - this._getTextWidth(t, e) * i - r : h = r;
    const I = BA(h - o.shift);
    return o.shift = h, `${I} ${c = BA(c)} Td (${Za(t)}) Tj`;
  }
  _getSaveFieldResources(t) {
    const { localResources: e, appearanceResources: i, acroFormResources: s } = this._fieldResources, n = this.data.defaultAppearanceData?.fontName;
    if (!n) return e || z.empty;
    for (const o of [e, i]) if (o instanceof z) {
      const r = o.get("Font");
      if (r instanceof z && r.has(n)) return o;
    }
    if (s instanceof z) {
      const o = s.get("Font");
      if (o instanceof z && o.has(n)) {
        const r = new z(t);
        r.set(n, o.getRaw(n));
        const c = new z(t);
        return c.set("Font", r), z.merge({ xref: t, dictArray: [c, e], mergeSubDicts: !0 });
      }
    }
    return e || z.empty;
  }
  getFieldObject() {
    return null;
  }
}
class jb extends ui {
  constructor(t) {
    super(t);
    const { dict: e } = t;
    e.has("PMD") && (this.flags |= No, this.data.hidden = !0, O("Barcodes are not supported")), this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML, this._hasText = !0, typeof this.data.fieldValue != "string" && (this.data.fieldValue = "");
    let i = ei({ dict: e, key: "Q" });
    (!Number.isInteger(i) || i < 0 || i > 2) && (i = null), this.data.textAlignment = i;
    let s = ei({ dict: e, key: "MaxLen" });
    (!Number.isInteger(s) || s < 0) && (s = 0), this.data.maxLen = s, this.data.multiLine = this.hasFieldFlag(uC), this.data.comb = this.hasFieldFlag(em) && !this.hasFieldFlag(uC) && !this.hasFieldFlag(bh) && !this.hasFieldFlag($9) && this.data.maxLen !== 0, this.data.doNotScroll = this.hasFieldFlag(Am);
  }
  get hasTextContent() {
    return !!this.appearance && !this._needAppearances;
  }
  _getCombAppearance(t, e, i, s, n, o, r, c, h, I, C) {
    const d = n / this.data.maxLen, u = this.getBorderAndBackgroundAppearances(C), E = [], p = e.getCharPositions(i);
    for (const [b, D] of p) E.push(`(${Za(i.substring(b, D))}) Tj`);
    const y = E.join(` ${BA(d)} 0 Td `);
    return `/Tx BMC q ${u}BT ` + t + ` 1 0 0 1 ${BA(r)} ${BA(c + h)} Tm ${y} ET Q EMC`;
  }
  _getMultilineAppearance(t, e, i, s, n, o, r, c, h, I, C, d) {
    const u = [], E = n - 2 * c, p = { shift: 0 };
    for (let D = 0, S = e.length; D < S; D++) {
      const R = e[D], x = this._splitLine(R, i, s, E);
      for (let N = 0, U = x.length; N < U; N++) {
        const T = x[N], q = D === 0 && N === 0 ? -h - (C - I) : -C;
        u.push(this._renderText(T, i, s, n, r, p, c, q));
      }
    }
    const y = this.getBorderAndBackgroundAppearances(d), b = u.join(`
`);
    return `/Tx BMC q ${y}BT ` + t + ` 1 0 0 1 0 ${BA(o)} Tm ${b} ET Q EMC`;
  }
  _splitLine(t, e, i, s, n = {}) {
    t = n.line || t;
    const o = n.glyphs || e.charsToGlyphs(t);
    if (o.length <= 1) return [t];
    const r = n.positions || e.getCharPositions(t), c = i / 1e3, h = [];
    let I = -1, C = -1, d = -1, u = 0, E = 0;
    for (let p = 0, y = o.length; p < y; p++) {
      const [b, D] = r[p], S = o[p], R = S.width * c;
      S.unicode === " " ? E + R > s ? (h.push(t.substring(u, b)), u = b, E = R, I = -1, d = -1) : (E += R, I = b, C = D, d = p) : E + R > s ? I !== -1 ? (h.push(t.substring(u, C)), u = C, p = d + 1, I = -1, E = 0) : (h.push(t.substring(u, b)), u = b, E = R) : E += R;
    }
    return u < t.length && h.push(t.substring(u, t.length)), h;
  }
  getFieldObject() {
    return { id: this.data.id, value: this.data.fieldValue, defaultValue: this.data.defaultFieldValue || "", multiline: this.data.multiLine, password: this.hasFieldFlag(bh), charLimit: this.data.maxLen, comb: this.data.comb, editable: !this.data.readOnly, hidden: this.data.hidden, name: this.data.fieldName, rect: this.data.rect, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: "text" };
  }
}
class Zb extends ui {
  constructor(t) {
    super(t), this.checkedAppearance = null, this.uncheckedAppearance = null, this.data.checkBox = !this.hasFieldFlag(BC) && !this.hasFieldFlag(Yc), this.data.radioButton = this.hasFieldFlag(BC) && !this.hasFieldFlag(Yc), this.data.pushButton = this.hasFieldFlag(Yc), this.data.isTooltipOnly = !1, this.data.checkBox ? this._processCheckBox(t) : this.data.radioButton ? this._processRadioButton(t) : this.data.pushButton ? (this.data.hasOwnCanvas = !0, this.data.noHTML = !1, this._processPushButton(t)) : O("Invalid field flags for button widget annotation");
  }
  async getOperatorList(t, e, i, s) {
    if (this.data.pushButton) return super.getOperatorList(t, e, i, !1, s);
    let n = null, o = null;
    if (s) {
      const c = s.get(this.data.id);
      n = c ? c.value : null, o = c ? c.rotation : null;
    }
    if (n === null && this.appearance) return super.getOperatorList(t, e, i, s);
    n == null && (n = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
    const r = n ? this.checkedAppearance : this.uncheckedAppearance;
    if (r) {
      const c = this.appearance, h = ks(r.dict.getArray("Matrix"), Ci);
      o && r.dict.set("Matrix", this.getRotationMatrix(s)), this.appearance = r;
      const I = super.getOperatorList(t, e, i, s);
      return this.appearance = c, r.dict.set("Matrix", h), I;
    }
    return { opList: new ue(), separateForm: !1, separateCanvas: !1 };
  }
  async save(t, e, i) {
    return this.data.checkBox ? this._saveCheckbox(t, e, i) : this.data.radioButton ? this._saveRadioButton(t, e, i) : null;
  }
  async _saveCheckbox(t, e, i) {
    if (!i) return null;
    const s = i.get(this.data.id);
    let n = s?.rotation, o = s?.value;
    if (n === void 0 && (o === void 0 || this.data.fieldValue === this.data.exportValue === o))
      return null;
    const r = t.xref.fetchIfRef(this.ref);
    if (!(r instanceof z)) return null;
    n === void 0 && (n = this.rotation), o === void 0 && (o = this.data.fieldValue === this.data.exportValue);
    const c = { path: this.data.fieldName, value: o ? this.data.exportValue : "" }, h = at.get(o ? this.data.exportValue : "Off");
    r.set("V", h), r.set("AS", h), r.set("M", `D:${Gs()}`);
    const I = this._getMKDict(n);
    I && r.set("MK", I);
    const C = [];
    return await me(this.ref, r, C, t.xref), [{ ref: this.ref, data: C.join(""), xfa: c }];
  }
  async _saveRadioButton(t, e, i) {
    if (!i) return null;
    const s = i.get(this.data.id);
    let n = s?.rotation, o = s?.value;
    if (n === void 0 && (o === void 0 || this.data.fieldValue === this.data.buttonValue === o))
      return null;
    const r = t.xref.fetchIfRef(this.ref);
    if (!(r instanceof z)) return null;
    o === void 0 && (o = this.data.fieldValue === this.data.buttonValue), n === void 0 && (n = this.rotation);
    const c = { path: this.data.fieldName, value: o ? this.data.buttonValue : "" }, h = at.get(o ? this.data.buttonValue : "Off"), I = [];
    let C = null;
    if (o) if (this.parent instanceof St) {
      const E = t.xref.fetch(this.parent);
      E.set("V", h), await me(this.parent, E, I, t.xref), C = I.join(""), I.length = 0;
    } else this.parent instanceof z && this.parent.set("V", h);
    r.set("AS", h), r.set("M", `D:${Gs()}`);
    const d = this._getMKDict(n);
    d && r.set("MK", d), await me(this.ref, r, I, t.xref);
    const u = [{ ref: this.ref, data: I.join(""), xfa: c }];
    return C && u.push({ ref: this.parent, data: C, xfa: null }), u;
  }
  _getDefaultCheckedAppearance(t, e) {
    const i = this.data.rect[2] - this.data.rect[0], s = this.data.rect[3] - this.data.rect[1], n = [0, 0, i, s], o = 0.8 * Math.min(i, s);
    let r, c;
    e === "check" ? (r = { width: 0.755 * o, height: 0.705 * o }, c = "3") : e === "disc" ? (r = { width: 0.791 * o, height: 0.705 * o }, c = "l") : oA(`_getDefaultCheckedAppearance - unsupported type: ${e}`);
    const h = `q BT /PdfJsZaDb ${o} Tf 0 g ${BA((i - r.width) / 2)} ${BA((s - r.height) / 2)} Td (${c}) Tj ET Q`, I = new z(t.xref);
    I.set("FormType", 1), I.set("Subtype", at.get("Form")), I.set("Type", at.get("XObject")), I.set("BBox", n), I.set("Matrix", [1, 0, 0, 1, 0, 0]), I.set("Length", h.length);
    const C = new z(t.xref), d = new z(t.xref);
    d.set("PdfJsZaDb", this.fallbackFontDict), C.set("Font", d), I.set("Resources", C), this.checkedAppearance = new _e(h), this.checkedAppearance.dict = I, this._streams.push(this.checkedAppearance);
  }
  _processCheckBox(t) {
    const e = t.dict.get("AP");
    if (!(e instanceof z)) return;
    const i = e.get("N");
    if (!(i instanceof z)) return;
    const s = this._decodeFormValue(t.dict.get("AS"));
    typeof s == "string" && (this.data.fieldValue = s);
    const n = this.data.fieldValue !== null && this.data.fieldValue !== "Off" ? this.data.fieldValue : "Yes", o = i.getKeys();
    if (o.length === 0) o.push("Off", n);
    else if (o.length === 1) o[0] === "Off" ? o.push(n) : o.unshift("Off");
    else if (o.includes(n)) o.length = 0, o.push("Off", n);
    else {
      const h = o.find(((I) => I !== "Off"));
      o.length = 0, o.push("Off", h);
    }
    o.includes(this.data.fieldValue) || (this.data.fieldValue = "Off"), this.data.exportValue = o[1];
    const r = i.get(this.data.exportValue);
    this.checkedAppearance = r instanceof AA ? r : null;
    const c = i.get("Off");
    this.uncheckedAppearance = c instanceof AA ? c : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(t, "check"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, this.data.defaultFieldValue === null && (this.data.defaultFieldValue = "Off");
  }
  _processRadioButton(t) {
    this.data.buttonValue = null;
    const e = t.dict.get("Parent");
    if (e instanceof z) {
      this.parent = t.dict.getRaw("Parent");
      const r = e.get("V");
      r instanceof at && (this.data.fieldValue = this._decodeFormValue(r));
    }
    const i = t.dict.get("AP");
    if (!(i instanceof z)) return;
    const s = i.get("N");
    if (!(s instanceof z)) return;
    for (const r of s.getKeys()) if (r !== "Off") {
      this.data.buttonValue = this._decodeFormValue(r);
      break;
    }
    const n = s.get(this.data.buttonValue);
    this.checkedAppearance = n instanceof AA ? n : null;
    const o = s.get("Off");
    this.uncheckedAppearance = o instanceof AA ? o : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(t, "disc"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, this.data.defaultFieldValue === null && (this.data.defaultFieldValue = "Off");
  }
  _processPushButton(t) {
    const { dict: e, annotationGlobals: i } = t;
    e.has("A") || e.has("AA") || this.data.alternativeText ? (this.data.isTooltipOnly = !e.has("A") && !e.has("AA"), za.parseDestDictionary({ destDict: e, resultObj: this.data, docBaseUrl: i.baseUrl, docAttachments: i.attachments })) : O("Push buttons without action dictionaries are not supported");
  }
  getFieldObject() {
    let t, e = "button";
    return this.data.checkBox ? (e = "checkbox", t = this.data.exportValue) : this.data.radioButton && (e = "radiobutton", t = this.data.buttonValue), { id: this.data.id, value: this.data.fieldValue || "Off", defaultValue: this.data.defaultFieldValue, exportValues: t, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, hidden: this.data.hidden, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: e };
  }
  get fallbackFontDict() {
    const t = new z();
    return t.set("BaseFont", at.get("ZapfDingbats")), t.set("Type", at.get("FallbackType")), t.set("Subtype", at.get("FallbackType")), t.set("Encoding", at.get("ZapfDingbatsEncoding")), bt(this, "fallbackFontDict", t);
  }
}
class Vb extends ui {
  constructor(t) {
    super(t);
    const { dict: e, xref: i } = t;
    this.indices = e.getArray("I"), this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0, this.data.options = [];
    const s = ei({ dict: e, key: "Opt" });
    if (Array.isArray(s)) for (let n = 0, o = s.length; n < o; n++) {
      const r = i.fetchIfRef(s[n]), c = Array.isArray(r);
      this.data.options[n] = { exportValue: this._decodeFormValue(c ? i.fetchIfRef(r[0]) : r), displayValue: this._decodeFormValue(c ? i.fetchIfRef(r[1]) : r) };
    }
    if (this.hasIndices) {
      this.data.fieldValue = [];
      const n = this.data.options.length;
      for (const o of this.indices) Number.isInteger(o) && o >= 0 && o < n && this.data.fieldValue.push(this.data.options[o].exportValue);
    } else typeof this.data.fieldValue == "string" ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue || (this.data.fieldValue = []);
    this.data.combo = this.hasFieldFlag(z9), this.data.multiSelect = this.hasFieldFlag(tm), this._hasText = !0;
  }
  getFieldObject() {
    const t = this.data.combo ? "combobox" : "listbox", e = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
    return { id: this.data.id, value: e, defaultValue: this.data.defaultFieldValue, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, numItems: this.data.fieldValue.length, multipleSelection: this.data.multiSelect, hidden: this.data.hidden, actions: this.data.actions, items: this.data.options, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: t };
  }
  amendSavedDict(t, e) {
    if (!this.hasIndices) return;
    let i = t?.get(this.data.id)?.value;
    Array.isArray(i) || (i = [i]);
    const s = [], { options: n } = this.data;
    for (let o = 0, r = 0, c = n.length; o < c; o++) n[o].exportValue === i[r] && (s.push(o), r += 1);
    e.set("I", s);
  }
  async _getAppearance(t, e, i, s) {
    if (this.data.combo) return super._getAppearance(t, e, i, s);
    let n, o;
    const r = s?.get(this.data.id);
    if (r && (o = r.rotation, n = r.value), o === void 0 && n === void 0 && !this._needAppearances) return null;
    n === void 0 ? n = this.data.fieldValue : Array.isArray(n) || (n = [n]);
    let c = this.data.rect[3] - this.data.rect[1], h = this.data.rect[2] - this.data.rect[0];
    o !== 90 && o !== 270 || ([h, c] = [c, h]);
    const I = this.data.options.length, C = [];
    for (let N = 0; N < I; N++) {
      const { exportValue: U } = this.data.options[N];
      n.includes(U) && C.push(N);
    }
    this._defaultAppearance || (this.data.defaultAppearanceData = Hl(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
    const d = await ui._getFontData(t, e, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    let u, { fontSize: E } = this.data.defaultAppearanceData;
    if (E) u = this._defaultAppearance;
    else {
      const N = (c - 1) / I;
      let U, T = -1;
      for (const { displayValue: q } of this.data.options) {
        const _ = this._getTextWidth(q, d);
        _ > T && (T = _, U = q);
      }
      [u, E] = this._computeFontSize(N, h - 4, U, d, -1);
    }
    const p = E * na, y = (p - E) / 2, b = Math.floor(c / p);
    let D = 0;
    if (C.length > 0) {
      const N = Math.min(...C), U = Math.max(...C);
      D = Math.max(0, U - b + 1), D > N && (D = N);
    }
    const S = Math.min(D + b + 1, I), R = ["/Tx BMC q", `1 1 ${h} ${c} re W n`];
    if (C.length) {
      R.push("0.600006 0.756866 0.854904 rg");
      for (const N of C) D <= N && N < S && R.push(`1 ${c - (N - D + 1) * p} ${h} ${p} re f`);
    }
    R.push("BT", u, `1 0 0 1 0 ${c} Tm`);
    const x = { shift: 0 };
    for (let N = D; N < S; N++) {
      const { displayValue: U } = this.data.options[N], T = N === D ? y : 0;
      R.push(this._renderText(U, d, E, h, 0, x, 2, -p + T));
    }
    return R.push("ET Q EMC"), R.join(`
`);
  }
}
class Sf extends ui {
  constructor(t) {
    super(t), this.data.fieldValue = null, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !this.data.hasOwnCanvas;
  }
  getFieldObject() {
    return { id: this.data.id, value: null, page: this.data.pageIndex, type: "signature" };
  }
}
class Xb extends Ge {
  constructor(t) {
    super(t), this.data.noRotate = !0, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
    const { dict: e } = t;
    this.data.annotationType = k9, this.data.hasAppearance ? this.data.name = "NoIcon" : (this.data.rect[1] = this.data.rect[3] - 22, this.data.rect[2] = this.data.rect[0] + 22, this.data.name = e.has("Name") ? e.get("Name").name : "Note"), e.has("State") ? (this.data.state = e.get("State") || null, this.data.stateModel = e.get("StateModel") || null) : (this.data.state = null, this.data.stateModel = null);
  }
}
class zb extends Nr {
  constructor(t) {
    super(t);
    const { dict: e, annotationGlobals: i } = t;
    this.data.annotationType = S9, this.data.noHTML = !1;
    const s = xr(e, this.rectangle);
    s && (this.data.quadPoints = s), this.data.borderColor ||= this.data.color, za.parseDestDictionary({ destDict: e, resultObj: this.data, docBaseUrl: i.baseUrl, docAttachments: i.attachments });
  }
}
class Ff extends Nr {
  constructor(t) {
    super(t);
    const { dict: e } = t;
    this.data.annotationType = K9, this.data.noHTML = !1, this.data.rect[0] !== this.data.rect[2] && this.data.rect[1] !== this.data.rect[3] || (this.data.rect = null);
    let i = e.get("Parent");
    if (!i) return void O("Popup annotation has a missing or invalid parent annotation.");
    if (this.data.parentRect = Zi(i.getArray("Rect"), null), qA(i.get("RT"), QQ) && (i = i.get("IRT")), i.has("M") ? (this.setModificationDate(i.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, i.has("C") ? (this.setColor(i.getArray("C")), this.data.color = this.color) : this.data.color = null, !this.viewable) {
      const s = i.get("F");
      this._isViewable(s) && this.setFlags(s);
    }
    this.setTitle(i.get("T")), this.data.titleObj = this._title, this.setContents(i.get("Contents")), this.data.contentsObj = this._contents, i.has("RC") && (this.data.richText = Rr.getRichTextAsHtml(i.get("RC"))), this.data.open = !!e.get("Open");
  }
}
class Ch extends Ge {
  constructor(t) {
    super(t), this.data.hasOwnCanvas = this.data.noRotate, this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1;
    const { evaluatorOptions: e, xref: i } = t;
    if (this.data.annotationType = F9, this.setDefaultAppearance(t), this._hasAppearance = !!this.appearance, this._hasAppearance) {
      const { fontColor: s, fontSize: n } = (function(o, r, c) {
        return new j8(o, r, c).parse();
      })(this.appearance, e, i);
      this.data.defaultAppearanceData.fontColor = s, this.data.defaultAppearanceData.fontSize = n || 10;
    } else {
      this.data.defaultAppearanceData.fontSize ||= 10;
      const { fontColor: s, fontSize: n } = this.data.defaultAppearanceData;
      if (this._contents.str) {
        this.data.textContent = this._contents.str.split(/\r\n?|\n/).map(((h) => h.trimEnd()));
        const { coords: o, bbox: r, matrix: c } = Di.getFirstPositionInfo(this.rectangle, this.rotation, n);
        this.data.textPosition = this._transformPoint(o, r, c);
      }
      if (this._isOffscreenCanvasSupported) {
        const o = t.dict.get("CA"), r = new Di(i, "sans-serif");
        this.appearance = r.createAppearance(this._contents.str, this.rectangle, this.rotation, n, s, o), this._streams.push(this.appearance);
      } else O("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
    }
  }
  get hasTextContent() {
    return this._hasAppearance;
  }
  static createNewDict(t, e, { apRef: i, ap: s, oldAnnotation: n }) {
    const { color: o, fontSize: r, rect: c, rotation: h, user: I, value: C } = t, d = n || new z(e);
    d.set("Type", at.get("Annot")), d.set("Subtype", at.get("FreeText")), n ? (d.set("M", `D:${Gs()}`), d.delete("RC")) : d.set("CreationDate", `D:${Gs()}`), d.set("Rect", c);
    const u = `/Helv ${r} Tf ${Xi(o, !0)}`;
    if (d.set("DA", u), d.set("Contents", xi(C)), d.set("F", 4), d.set("Border", [0, 0, 0]), d.set("Rotate", h), I && d.set("T", xi(I)), i || s) {
      const E = new z(e);
      d.set("AP", E), i ? E.set("N", i) : E.set("N", s);
    }
    return d;
  }
  static async createNewAppearanceStream(t, e, i) {
    const { baseFontRef: s, evaluator: n, task: o } = i, { color: r, fontSize: c, rect: h, rotation: I, value: C } = t, d = new z(e), u = new z(e);
    if (s) u.set("Helv", s);
    else {
      const W = new z(e);
      W.set("BaseFont", at.get("Helvetica")), W.set("Type", at.get("Font")), W.set("Subtype", at.get("Type1")), W.set("Encoding", at.get("WinAnsiEncoding")), u.set("Helv", W);
    }
    d.set("Font", u);
    const E = await ui._getFontData(n, o, { fontName: "Helv", fontSize: c }, d), [p, y, b, D] = h;
    let S = b - p, R = D - y;
    I % 180 != 0 && ([S, R] = [R, S]);
    const x = C.split(`
`), N = c / 1e3;
    let U = -1 / 0;
    const T = [];
    for (let W of x) {
      const lt = E.encodeString(W);
      if (lt.length > 1) return null;
      W = lt.join(""), T.push(W);
      let $ = 0;
      const ot = E.charsToGlyphs(W);
      for (const V of ot) $ += V.width * N;
      U = Math.max(U, $);
    }
    let q = 1;
    U > S && (q = S / U);
    let _ = 1;
    const Y = na * c, ht = 1 * c, ut = Y * x.length;
    ut > R && (_ = R / ut);
    const j = c * Math.min(q, _);
    let it, tt, Z;
    switch (I) {
      case 0:
        Z = [1, 0, 0, 1], tt = [h[0], h[1], S, R], it = [h[0], h[3] - ht];
        break;
      case 90:
        Z = [0, 1, -1, 0], tt = [h[1], -h[2], S, R], it = [h[1], -h[0] - ht];
        break;
      case 180:
        Z = [-1, 0, 0, -1], tt = [-h[2], -h[3], S, R], it = [-h[2], -h[1] - ht];
        break;
      case 270:
        Z = [0, -1, 1, 0], tt = [-h[3], h[0], S, R], it = [-h[3], h[2] - ht];
    }
    const st = ["q", `${Z.join(" ")} 0 0 cm`, `${tt.join(" ")} re W n`, "BT", `${Xi(r, !0)}`, `0 Tc /Helv ${BA(j)} Tf`];
    st.push(`${it.join(" ")} Td (${Za(T[0])}) Tj`);
    const dt = BA(Y);
    for (let W = 1, lt = T.length; W < lt; W++) {
      const $ = T[W];
      st.push(`0 -${dt} Td (${Za($)}) Tj`);
    }
    st.push("ET", "Q");
    const ct = st.join(`
`), M = new z(e);
    M.set("FormType", 1), M.set("Subtype", at.get("Form")), M.set("Type", at.get("XObject")), M.set("BBox", h), M.set("Resources", d), M.set("Matrix", [1, 0, 0, 1, -h[0], -h[1]]);
    const H = new _e(ct);
    return H.dict = M, H;
  }
}
class $b extends Ge {
  constructor(t) {
    super(t);
    const { dict: e, xref: i } = t;
    this.data.annotationType = R9, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
    const s = Gh(e.getArray("L"), [0, 0, 0, 0]);
    if (this.data.lineCoordinates = PA.normalizeRect(s), this.setLineEndings(e.getArray("LE")), this.data.lineEndings = this.lineEndings, !this.appearance) {
      const n = this.color ? Ne(this.color) : [0, 0, 0], o = e.get("CA"), r = Oa(e.getArray("IC"), null), c = r ? Ne(r) : null, h = c ? o : null, I = this.borderStyle.width || 1, C = 2 * I, d = [this.data.lineCoordinates[0] - C, this.data.lineCoordinates[1] - C, this.data.lineCoordinates[2] + C, this.data.lineCoordinates[3] + C];
      PA.intersect(this.rectangle, d) || (this.rectangle = d), this._setDefaultAppearance({ xref: i, extra: `${I} w`, strokeColor: n, fillColor: c, strokeAlpha: o, fillAlpha: h, pointsCallback: (u, E) => (u.push(`${s[0]} ${s[1]} m`, `${s[2]} ${s[3]} l`, "S"), [E[0] - I, E[2] + I, E[7] - I, E[3] + I]) });
    }
  }
}
class tD extends Ge {
  constructor(t) {
    super(t);
    const { dict: e, xref: i } = t;
    if (this.data.annotationType = x9, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1, !this.appearance) {
      const s = this.color ? Ne(this.color) : [0, 0, 0], n = e.get("CA"), o = Oa(e.getArray("IC"), null), r = o ? Ne(o) : null, c = r ? n : null;
      if (this.borderStyle.width === 0 && !r) return;
      this._setDefaultAppearance({ xref: i, extra: `${this.borderStyle.width} w`, strokeColor: s, fillColor: r, strokeAlpha: n, fillAlpha: c, pointsCallback: (h, I) => {
        const C = I[4] + this.borderStyle.width / 2, d = I[5] + this.borderStyle.width / 2, u = I[6] - I[4] - this.borderStyle.width, E = I[3] - I[7] - this.borderStyle.width;
        return h.push(`${C} ${d} ${u} ${E} re`), r ? h.push("B") : h.push("S"), [I[0], I[2], I[7], I[3]];
      } });
    }
  }
}
class AD extends Ge {
  constructor(t) {
    super(t);
    const { dict: e, xref: i } = t;
    if (this.data.annotationType = N9, !this.appearance) {
      const s = this.color ? Ne(this.color) : [0, 0, 0], n = e.get("CA"), o = Oa(e.getArray("IC"), null), r = o ? Ne(o) : null, c = r ? n : null;
      if (this.borderStyle.width === 0 && !r) return;
      const h = 4 / 3 * Math.tan(Math.PI / 8);
      this._setDefaultAppearance({ xref: i, extra: `${this.borderStyle.width} w`, strokeColor: s, fillColor: r, strokeAlpha: n, fillAlpha: c, pointsCallback: (I, C) => {
        const d = C[0] + this.borderStyle.width / 2, u = C[1] - this.borderStyle.width / 2, E = C[6] - this.borderStyle.width / 2, p = C[7] + this.borderStyle.width / 2, y = d + (E - d) / 2, b = u + (p - u) / 2, D = (E - d) / 2 * h, S = (p - u) / 2 * h;
        return I.push(`${y} ${p} m`, `${y + D} ${p} ${E} ${b + S} ${E} ${b} c`, `${E} ${b - S} ${y + D} ${u} ${y} ${u} c`, `${y - D} ${u} ${d} ${b - S} ${d} ${b} c`, `${d} ${b + S} ${y - D} ${p} ${y} ${p} c`, "h"), r ? I.push("B") : I.push("S"), [C[0], C[2], C[7], C[3]];
      } });
    }
  }
}
class Rf extends Ge {
  constructor(t) {
    super(t);
    const { dict: e, xref: i } = t;
    this.data.annotationType = v9, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1, this.data.vertices = null, this instanceof xf || (this.setLineEndings(e.getArray("LE")), this.data.lineEndings = this.lineEndings);
    const s = e.getArray("Vertices");
    if (!Pe(s, null)) return;
    const n = this.data.vertices = Float32Array.from(s);
    if (!this.appearance) {
      const o = this.color ? Ne(this.color) : [0, 0, 0], r = e.get("CA"), c = this.borderStyle.width || 1, h = 2 * c, I = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (let C = 0, d = n.length; C < d; C += 2) I[0] = Math.min(I[0], n[C] - h), I[1] = Math.min(I[1], n[C + 1] - h), I[2] = Math.max(I[2], n[C] + h), I[3] = Math.max(I[3], n[C + 1] + h);
      PA.intersect(this.rectangle, I) || (this.rectangle = I), this._setDefaultAppearance({ xref: i, extra: `${c} w`, strokeColor: o, strokeAlpha: r, pointsCallback: (C, d) => {
        for (let u = 0, E = n.length; u < E; u += 2) C.push(`${n[u]} ${n[u + 1]} ${u === 0 ? "m" : "l"}`);
        return C.push("S"), [d[0], d[2], d[7], d[3]];
      } });
    }
  }
}
class xf extends Rf {
  constructor(t) {
    super(t), this.data.annotationType = G9;
  }
}
class eD extends Ge {
  constructor(t) {
    super(t), this.data.annotationType = Y9;
  }
}
class Un extends Ge {
  constructor(t) {
    super(t), this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
    const { dict: e, xref: i } = t;
    this.data.annotationType = T9, this.data.inkLists = [];
    const s = e.getArray("InkList");
    if (Array.isArray(s)) {
      for (let n = 0, o = s.length; n < o; ++n) {
        if (!Array.isArray(s[n])) continue;
        const r = new Float32Array(s[n].length);
        this.data.inkLists.push(r);
        for (let c = 0, h = s[n].length; c < h; c += 2) {
          const I = i.fetchIfRef(s[n][c]), C = i.fetchIfRef(s[n][c + 1]);
          typeof I == "number" && typeof C == "number" && (r[c] = I, r[c + 1] = C);
        }
      }
      if (!this.appearance) {
        const n = this.color ? Ne(this.color) : [0, 0, 0], o = e.get("CA"), r = this.borderStyle.width || 1, c = 2 * r, h = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const I of this.data.inkLists) for (let C = 0, d = I.length; C < d; C += 2) h[0] = Math.min(h[0], I[C] - c), h[1] = Math.min(h[1], I[C + 1] - c), h[2] = Math.max(h[2], I[C] + c), h[3] = Math.max(h[3], I[C + 1] + c);
        PA.intersect(this.rectangle, h) || (this.rectangle = h), this._setDefaultAppearance({ xref: i, extra: `${r} w`, strokeColor: n, strokeAlpha: o, pointsCallback: (I, C) => {
          for (const d of this.data.inkLists) {
            for (let u = 0, E = d.length; u < E; u += 2) I.push(`${d[u]} ${d[u + 1]} ${u === 0 ? "m" : "l"}`);
            I.push("S");
          }
          return [C[0], C[2], C[7], C[3]];
        } });
      }
    }
  }
  static createNewDict(t, e, { apRef: i, ap: s }) {
    const { color: n, opacity: o, paths: r, outlines: c, rect: h, rotation: I, thickness: C } = t, d = new z(e);
    d.set("Type", at.get("Annot")), d.set("Subtype", at.get("Ink")), d.set("CreationDate", `D:${Gs()}`), d.set("Rect", h), d.set("InkList", c?.points || r.map(((p) => p.points))), d.set("F", 4), d.set("Rotate", I), c && d.set("IT", at.get("InkHighlight"));
    const u = new z(e);
    d.set("BS", u), u.set("W", C), d.set("C", Array.from(n, ((p) => p / 255))), d.set("CA", o);
    const E = new z(e);
    return d.set("AP", E), i ? E.set("N", i) : E.set("N", s), d;
  }
  static async createNewAppearanceStream(t, e, i) {
    if (t.outlines) return this.createNewAppearanceStreamForHighlight(t, e, i);
    const { color: s, rect: n, paths: o, thickness: r, opacity: c } = t, h = [`${r} w 1 J 1 j`, `${Xi(s, !1)}`];
    c !== 1 && h.push("/R0 gs");
    const I = [];
    for (const { bezier: E } of o) {
      if (I.length = 0, I.push(`${BA(E[0])} ${BA(E[1])} m`), E.length === 2) I.push(`${BA(E[0])} ${BA(E[1])} l S`);
      else {
        for (let p = 2, y = E.length; p < y; p += 6) {
          const b = E.slice(p, p + 6).map(BA).join(" ");
          I.push(`${b} c`);
        }
        I.push("S");
      }
      h.push(I.join(`
`));
    }
    const C = h.join(`
`), d = new z(e);
    if (d.set("FormType", 1), d.set("Subtype", at.get("Form")), d.set("Type", at.get("XObject")), d.set("BBox", n), d.set("Length", C.length), c !== 1) {
      const E = new z(e), p = new z(e), y = new z(e);
      y.set("CA", c), y.set("Type", at.get("ExtGState")), p.set("R0", y), E.set("ExtGState", p), d.set("Resources", E);
    }
    const u = new _e(C);
    return u.dict = d, u;
  }
  static async createNewAppearanceStreamForHighlight(t, e, i) {
    const { color: s, rect: n, outlines: { outline: o }, opacity: r } = t, c = [`${Xi(s, !0)}`, "/R0 gs"];
    c.push(`${BA(o[4])} ${BA(o[5])} m`);
    for (let p = 6, y = o.length; p < y; p += 6) if (isNaN(o[p]) || o[p] === null) c.push(`${BA(o[p + 4])} ${BA(o[p + 5])} l`);
    else {
      const b = o.slice(p, p + 6).map(BA).join(" ");
      c.push(`${b} c`);
    }
    c.push("h f");
    const h = c.join(`
`), I = new z(e);
    I.set("FormType", 1), I.set("Subtype", at.get("Form")), I.set("Type", at.get("XObject")), I.set("BBox", n), I.set("Length", h.length);
    const C = new z(e), d = new z(e);
    C.set("ExtGState", d), I.set("Resources", C);
    const u = new z(e);
    d.set("R0", u), u.set("BM", at.get("Multiply")), r !== 1 && (u.set("ca", r), u.set("Type", at.get("ExtGState")));
    const E = new _e(h);
    return E.dict = I, E;
  }
}
class uh extends Ge {
  constructor(t) {
    super(t);
    const { dict: e, xref: i } = t;
    if (this.data.annotationType = M9, this.data.quadPoints = xr(e, null)) {
      const s = this.appearance?.dict.get("Resources");
      if (!this.appearance || !s?.has("ExtGState")) {
        this.appearance && O("HighlightAnnotation - ignoring built-in appearance stream.");
        const n = this.color ? Ne(this.color) : [1, 1, 0], o = e.get("CA");
        this._setDefaultAppearance({ xref: i, fillColor: n, blendMode: "Multiply", fillAlpha: o, pointsCallback: (r, c) => (r.push(`${c[0]} ${c[1]} m`, `${c[2]} ${c[3]} l`, `${c[6]} ${c[7]} l`, `${c[4]} ${c[5]} l`, "f"), [c[0], c[2], c[7], c[3]]) });
      }
    } else this.data.popupRef = null;
  }
  static createNewDict(t, e, { apRef: i, ap: s }) {
    const { color: n, opacity: o, rect: r, rotation: c, user: h, quadPoints: I } = t, C = new z(e);
    if (C.set("Type", at.get("Annot")), C.set("Subtype", at.get("Highlight")), C.set("CreationDate", `D:${Gs()}`), C.set("Rect", r), C.set("F", 4), C.set("Border", [0, 0, 0]), C.set("Rotate", c), C.set("QuadPoints", I), C.set("C", Array.from(n, ((d) => d / 255))), C.set("CA", o), h && C.set("T", xi(h)), i || s) {
      const d = new z(e);
      C.set("AP", d), d.set("N", i || s);
    }
    return C;
  }
  static async createNewAppearanceStream(t, e, i) {
    const { color: s, rect: n, outlines: o, opacity: r } = t, c = [`${Xi(s, !0)}`, "/R0 gs"], h = [];
    for (const y of o) {
      h.length = 0, h.push(`${BA(y[0])} ${BA(y[1])} m`);
      for (let b = 2, D = y.length; b < D; b += 2) h.push(`${BA(y[b])} ${BA(y[b + 1])} l`);
      h.push("h"), c.push(h.join(`
`));
    }
    c.push("f*");
    const I = c.join(`
`), C = new z(e);
    C.set("FormType", 1), C.set("Subtype", at.get("Form")), C.set("Type", at.get("XObject")), C.set("BBox", n), C.set("Length", I.length);
    const d = new z(e), u = new z(e);
    d.set("ExtGState", u), C.set("Resources", d);
    const E = new z(e);
    u.set("R0", E), E.set("BM", at.get("Multiply")), r !== 1 && (E.set("ca", r), E.set("Type", at.get("ExtGState")));
    const p = new _e(I);
    return p.dict = C, p;
  }
}
class iD extends Ge {
  constructor(t) {
    super(t);
    const { dict: e, xref: i } = t;
    if (this.data.annotationType = L9, this.data.quadPoints = xr(e, null)) {
      if (!this.appearance) {
        const s = this.color ? Ne(this.color) : [0, 0, 0], n = e.get("CA");
        this._setDefaultAppearance({ xref: i, extra: "[] 0 d 0.571 w", strokeColor: s, strokeAlpha: n, pointsCallback: (o, r) => (o.push(`${r[4]} ${r[5] + 1.3} m`, `${r[6]} ${r[7] + 1.3} l`, "S"), [r[0], r[2], r[7], r[3]]) });
      }
    } else this.data.popupRef = null;
  }
}
class sD extends Ge {
  constructor(t) {
    super(t);
    const { dict: e, xref: i } = t;
    if (this.data.annotationType = U9, this.data.quadPoints = xr(e, null)) {
      if (!this.appearance) {
        const s = this.color ? Ne(this.color) : [0, 0, 0], n = e.get("CA");
        this._setDefaultAppearance({ xref: i, extra: "[] 0 d 1 w", strokeColor: s, strokeAlpha: n, pointsCallback: (o, r) => {
          const c = (r[1] - r[5]) / 6;
          let h = c, I = r[4];
          const C = r[5], d = r[6];
          o.push(`${I} ${C + h} m`);
          do
            I += 2, h = h === 0 ? c : 0, o.push(`${I} ${C + h} l`);
          while (I < d);
          return o.push("S"), [r[4], d, C - 2 * c, C + 2 * c];
        } });
      }
    } else this.data.popupRef = null;
  }
}
class aD extends Ge {
  constructor(t) {
    super(t);
    const { dict: e, xref: i } = t;
    if (this.data.annotationType = H9, this.data.quadPoints = xr(e, null)) {
      if (!this.appearance) {
        const s = this.color ? Ne(this.color) : [0, 0, 0], n = e.get("CA");
        this._setDefaultAppearance({ xref: i, extra: "[] 0 d 1 w", strokeColor: s, strokeAlpha: n, pointsCallback: (o, r) => (o.push((r[0] + r[4]) / 2 + " " + (r[1] + r[5]) / 2 + " m", (r[2] + r[6]) / 2 + " " + (r[3] + r[7]) / 2 + " l", "S"), [r[0], r[2], r[7], r[3]]) });
      }
    } else this.data.popupRef = null;
  }
}
class Io extends Ge {
  constructor(t) {
    super(t), this.data.annotationType = J9, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
  }
  static async createImage(t, e) {
    const { width: i, height: s } = t, n = new OffscreenCanvas(i, s), o = n.getContext("2d", { alpha: !0 });
    o.drawImage(t, 0, 0);
    const r = o.getImageData(0, 0, i, s).data, c = new Uint32Array(r.buffer), h = c.some(es.isLittleEndian ? (p) => p >>> 24 != 255 : (p) => !!(255 & ~p));
    h && (o.fillStyle = "white", o.fillRect(0, 0, i, s), o.drawImage(t, 0, 0));
    const I = n.convertToBlob({ type: "image/jpeg", quality: 1 }).then(((p) => p.arrayBuffer())), C = at.get("XObject"), d = at.get("Image"), u = new z(e);
    u.set("Type", C), u.set("Subtype", d), u.set("BitsPerComponent", 8), u.set("ColorSpace", at.get("DeviceRGB")), u.set("Filter", at.get("DCTDecode")), u.set("BBox", [0, 0, i, s]), u.set("Width", i), u.set("Height", s);
    let E = null;
    if (h) {
      const p = new Uint8Array(c.length);
      if (es.isLittleEndian) for (let b = 0, D = c.length; b < D; b++) p[b] = c[b] >>> 24;
      else for (let b = 0, D = c.length; b < D; b++) p[b] = 255 & c[b];
      const y = new z(e);
      y.set("Type", C), y.set("Subtype", d), y.set("BitsPerComponent", 8), y.set("ColorSpace", at.get("DeviceGray")), y.set("Width", i), y.set("Height", s), E = new RA(p, 0, 0, y);
    }
    return { imageStream: new RA(await I, 0, 0, u), smaskStream: E, width: i, height: s };
  }
  static createNewDict(t, e, { apRef: i, ap: s }) {
    const { rect: n, rotation: o, user: r } = t, c = new z(e);
    if (c.set("Type", at.get("Annot")), c.set("Subtype", at.get("Stamp")), c.set("CreationDate", `D:${Gs()}`), c.set("Rect", n), c.set("F", 4), c.set("Border", [0, 0, 0]), c.set("Rotate", o), r && c.set("T", xi(r)), i || s) {
      const h = new z(e);
      c.set("AP", h), i ? h.set("N", i) : h.set("N", s);
    }
    return c;
  }
  static async createNewAppearanceStream(t, e, i) {
    const { rotation: s } = t, { imageRef: n, width: o, height: r } = i.image, c = new z(e), h = new z(e);
    c.set("XObject", h), h.set("Im0", n);
    const I = `q ${o} 0 0 ${r} 0 0 cm /Im0 Do Q`, C = new z(e);
    if (C.set("FormType", 1), C.set("Subtype", at.get("Form")), C.set("Type", at.get("XObject")), C.set("BBox", [0, 0, o, r]), C.set("Resources", c), s) {
      const u = Oo(s, o, r);
      C.set("Matrix", u);
    }
    const d = new _e(I);
    return d.dict = C, d;
  }
}
class nD extends Ge {
  constructor(t) {
    super(t);
    const { dict: e, xref: i } = t, s = new Wh(e.get("FS"), i);
    this.data.annotationType = q9, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1, this.data.file = s.serializable;
    const n = e.get("Name");
    this.data.name = n instanceof at ? cA(n.name) : "PushPin";
    const o = e.get("ca");
    this.data.fillAlpha = typeof o == "number" && o >= 0 && o <= 1 ? o : null;
  }
}
function O1(A) {
  try {
    return ar(A);
  } catch (t) {
    return O(`UTF-8 decoding failed: "${t}".`), A;
  }
}
class rD extends Qg {
  constructor(t) {
    super(t), this.node = null;
  }
  onEndElement(t) {
    const e = super.onEndElement(t);
    if (e && t === "xfa:datasets") throw this.node = e, new Error("Aborting DatasetXMLParser.");
  }
}
class oD {
  constructor(t) {
    if (t.datasets) this.node = new Qg({ hasAttributes: !0 }).parseFromString(t.datasets).documentElement;
    else {
      const e = new rD({ hasAttributes: !0 });
      try {
        e.parseFromString(t["xdp:xdp"]);
      } catch {
      }
      this.node = e.node;
    }
  }
  getValue(t) {
    if (!this.node || !t) return "";
    const e = this.node.searchNode(AE(t), 0);
    return e ? e.firstChild?.nodeName === "value" ? e.children.map(((s) => O1(s.textContent))) : O1(e.textContent) : "";
  }
}
class gD {
  #t = null;
  constructor(t, e) {
    this.stream = t, this.pdfManager = e, this.entries = [], this._xrefStms = /* @__PURE__ */ new Set(), this._cacheMap = /* @__PURE__ */ new Map(), this._pendingRefs = new XA(), this._newPersistentRefNum = null, this._newTemporaryRefNum = null, this._persistentRefsCache = null;
  }
  getNewPersistentRef(t) {
    this._newPersistentRefNum === null && (this._newPersistentRefNum = this.entries.length || 1);
    const e = this._newPersistentRefNum++;
    return this._cacheMap.set(e, t), St.get(e, 0);
  }
  getNewTemporaryRef() {
    if (this._newTemporaryRefNum === null && (this._newTemporaryRefNum = this.entries.length || 1, this._newPersistentRefNum)) {
      this._persistentRefsCache = /* @__PURE__ */ new Map();
      for (let t = this._newTemporaryRefNum; t < this._newPersistentRefNum; t++) this._persistentRefsCache.set(t, this._cacheMap.get(t)), this._cacheMap.delete(t);
    }
    return St.get(this._newTemporaryRefNum++, 0);
  }
  resetNewTemporaryRef() {
    if (this._newTemporaryRefNum = null, this._persistentRefsCache) for (const [t, e] of this._persistentRefsCache) this._cacheMap.set(t, e);
    this._persistentRefsCache = null;
  }
  setStartXRef(t) {
    this.startXRefQueue = [t];
  }
  parse(t = !1) {
    let e, i, s;
    t ? (O("Indexing all PDF objects"), e = this.indexObjects()) : e = this.readXRef(), e.assignXref(this), this.trailer = e;
    try {
      i = e.get("Encrypt");
    } catch (n) {
      if (n instanceof yA) throw n;
      O(`XRef.parse - Invalid "Encrypt" reference: "${n}".`);
    }
    if (i instanceof z) {
      const n = e.get("ID"), o = n?.length ? n[0] : "";
      i.suppressEncryption = !0, this.encrypt = new Ja(i, o, this.pdfManager.password);
    }
    try {
      s = e.get("Root");
    } catch (n) {
      if (n instanceof yA) throw n;
      O(`XRef.parse - Invalid "Root" reference: "${n}".`);
    }
    if (s instanceof z) try {
      if (s.get("Pages") instanceof z) return void (this.root = s);
    } catch (n) {
      if (n instanceof yA) throw n;
      O(`XRef.parse - Invalid "Pages" reference: "${n}".`);
    }
    throw t ? new qo("Invalid Root reference.") : new qa();
  }
  processXRefTable(t) {
    if ("tableState" in this || (this.tableState = { entryNum: 0, streamPos: t.lexer.stream.pos, parserBuf1: t.buf1, parserBuf2: t.buf2 }), !zA(this.readXRefTable(t), "trailer")) throw new Ct("Invalid XRef table: could not find trailer dictionary");
    let e = t.getObj();
    if (e instanceof z || !e.dict || (e = e.dict), !(e instanceof z)) throw new Ct("Invalid XRef table: could not parse trailer dictionary");
    return delete this.tableState, e;
  }
  readXRefTable(t) {
    const e = t.lexer.stream, i = this.tableState;
    let s;
    for (e.pos = i.streamPos, t.buf1 = i.parserBuf1, t.buf2 = i.parserBuf2; ; ) {
      if (!("firstEntryNum" in i) || !("entryCount" in i)) {
        if (zA(s = t.getObj(), "trailer")) break;
        i.firstEntryNum = s, i.entryCount = t.getObj();
      }
      let n = i.firstEntryNum;
      const o = i.entryCount;
      if (!Number.isInteger(n) || !Number.isInteger(o)) throw new Ct("Invalid XRef table: wrong types in subsection header");
      for (let r = i.entryNum; r < o; r++) {
        i.streamPos = e.pos, i.entryNum = r, i.parserBuf1 = t.buf1, i.parserBuf2 = t.buf2;
        const c = {};
        c.offset = t.getObj(), c.gen = t.getObj();
        const h = t.getObj();
        if (h instanceof KA) switch (h.cmd) {
          case "f":
            c.free = !0;
            break;
          case "n":
            c.uncompressed = !0;
        }
        if (!Number.isInteger(c.offset) || !Number.isInteger(c.gen) || !c.free && !c.uncompressed) throw new Ct(`Invalid entry in XRef subsection: ${n}, ${o}`);
        r === 0 && c.free && n === 1 && (n = 0), this.entries[r + n] || (this.entries[r + n] = c);
      }
      i.entryNum = 0, i.streamPos = e.pos, i.parserBuf1 = t.buf1, i.parserBuf2 = t.buf2, delete i.firstEntryNum, delete i.entryCount;
    }
    if (this.entries[0] && !this.entries[0].free) throw new Ct("Invalid XRef table: unexpected first object");
    return s;
  }
  processXRefStream(t) {
    if (!("streamState" in this)) {
      const e = t.dict, i = e.get("W");
      let s = e.get("Index");
      s || (s = [0, e.get("Size")]), this.streamState = { entryRanges: s, byteWidths: i, entryNum: 0, streamPos: t.pos };
    }
    return this.readXRefStream(t), delete this.streamState, t.dict;
  }
  readXRefStream(t) {
    const e = this.streamState;
    t.pos = e.streamPos;
    const [i, s, n] = e.byteWidths, o = e.entryRanges;
    for (; o.length > 0; ) {
      const [r, c] = o;
      if (!Number.isInteger(r) || !Number.isInteger(c)) throw new Ct(`Invalid XRef range fields: ${r}, ${c}`);
      if (!Number.isInteger(i) || !Number.isInteger(s) || !Number.isInteger(n)) throw new Ct(`Invalid XRef entry fields length: ${r}, ${c}`);
      for (let h = e.entryNum; h < c; ++h) {
        e.entryNum = h, e.streamPos = t.pos;
        let I = 0, C = 0, d = 0;
        for (let E = 0; E < i; ++E) {
          const p = t.getByte();
          if (p === -1) throw new Ct("Invalid XRef byteWidths 'type'.");
          I = I << 8 | p;
        }
        i === 0 && (I = 1);
        for (let E = 0; E < s; ++E) {
          const p = t.getByte();
          if (p === -1) throw new Ct("Invalid XRef byteWidths 'offset'.");
          C = C << 8 | p;
        }
        for (let E = 0; E < n; ++E) {
          const p = t.getByte();
          if (p === -1) throw new Ct("Invalid XRef byteWidths 'generation'.");
          d = d << 8 | p;
        }
        const u = {};
        switch (u.offset = C, u.gen = d, I) {
          case 0:
            u.free = !0;
            break;
          case 1:
            u.uncompressed = !0;
            break;
          case 2:
            break;
          default:
            throw new Ct(`Invalid XRef entry type: ${I}`);
        }
        this.entries[r + h] || (this.entries[r + h] = u);
      }
      e.entryNum = 0, e.streamPos = t.pos, o.splice(0, 2);
    }
  }
  indexObjects() {
    function t(R, x) {
      let N = "", U = R[x];
      for (; U !== 10 && U !== 13 && U !== 60 && !(++x >= R.length); ) N += String.fromCharCode(U), U = R[x];
      return N;
    }
    function e(R, x, N) {
      const U = N.length, T = R.length;
      let q = 0;
      for (; x < T; ) {
        let _ = 0;
        for (; _ < U && R[x + _] === N[_]; ) ++_;
        if (_ >= U) break;
        x++, q++;
      }
      return q;
    }
    const i = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, s = /\b(startxref|\d+\s+\d+\s+obj)\b/g, n = /^(\d+)\s+(\d+)\s+obj\b/, o = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), r = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), c = new Uint8Array([47, 88, 82, 101, 102]);
    this.entries.length = 0, this._cacheMap.clear();
    const h = this.stream;
    h.pos = 0;
    const I = h.getBytes(), C = Re(I), d = I.length;
    let u = h.start;
    const E = [], p = [];
    for (; u < d; ) {
      let R = I[u];
      if (R === 9 || R === 10 || R === 13 || R === 32) {
        ++u;
        continue;
      }
      if (R === 37) {
        do {
          if (++u, u >= d) break;
          R = I[u];
        } while (R !== 10 && R !== 13);
        continue;
      }
      const x = t(I, u);
      let N;
      if (x.startsWith("xref") && (x.length === 4 || /\s/.test(x[4]))) u += e(I, u, o), E.push(u), u += e(I, u, r);
      else if (N = n.exec(x)) {
        const U = 0 | N[1], T = 0 | N[2], q = u + x.length;
        let _, Y = !1;
        if (this.entries[U]) {
          if (this.entries[U].gen === T) try {
            new Es({ lexer: new hi(h.makeSubStream(q)) }).getObj(), Y = !0;
          } catch (it) {
            it instanceof Nh ? O(`indexObjects -- checking object (${x}): "${it}".`) : Y = !0;
          }
        } else Y = !0;
        Y && (this.entries[U] = { offset: u - h.start, gen: T, uncompressed: !0 }), i.lastIndex = q;
        const ht = i.exec(C);
        ht ? (_ = i.lastIndex + 1 - u, ht[1] !== "endobj" && (O(`indexObjects: Found "${ht[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`), _ -= ht[1].length + 1)) : _ = d - u;
        const ut = I.subarray(u, u + _), j = e(ut, 0, c);
        j < _ && ut[j + 5] < 64 && (p.push(u - h.start), this._xrefStms.add(u - h.start)), u += _;
      } else if (x.startsWith("trailer") && (x.length === 7 || /\s/.test(x[7]))) {
        E.push(u);
        const U = u + x.length;
        let T;
        s.lastIndex = U;
        const q = s.exec(C);
        q ? (T = s.lastIndex + 1 - u, q[1] !== "startxref" && (O(`indexObjects: Found "${q[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`), T -= q[1].length + 1)) : T = d - u, u += T;
      } else u += x.length + 1;
    }
    for (const R of p) this.startXRefQueue.push(R), this.readXRef(!0);
    const y = [];
    let b, D, S = !1;
    for (const R of E) {
      h.pos = R;
      const x = new Es({ lexer: new hi(h), xref: this, allowStreams: !0, recoveryMode: !0 });
      if (!zA(x.getObj(), "trailer")) continue;
      const N = x.getObj();
      N instanceof z && (y.push(N), N.has("Encrypt") && (S = !0));
    }
    for (const R of [...y, "genFallback", ...y]) {
      if (R === "genFallback") {
        if (!D) break;
        this._generationFallback = !0;
        continue;
      }
      let x = !1;
      try {
        const N = R.get("Root");
        if (!(N instanceof z)) continue;
        const U = N.get("Pages");
        if (!(U instanceof z)) continue;
        const T = U.get("Count");
        Number.isInteger(T) && (x = !0);
      } catch (N) {
        D = N;
        continue;
      }
      if (x && (!S || R.has("Encrypt")) && R.has("ID")) return R;
      b = R;
    }
    if (b) return b;
    if (this.topDict) return this.topDict;
    throw new qo("Invalid PDF structure.");
  }
  readXRef(t = !1) {
    const e = this.stream, i = /* @__PURE__ */ new Set();
    for (; this.startXRefQueue.length; ) {
      try {
        const s = this.startXRefQueue[0];
        if (i.has(s)) {
          O("readXRef - skipping XRef table since it was already parsed."), this.startXRefQueue.shift();
          continue;
        }
        i.add(s), e.pos = s + e.start;
        const n = new Es({ lexer: new hi(e), xref: this, allowStreams: !0 });
        let o, r = n.getObj();
        if (zA(r, "xref")) o = this.processXRefTable(n), this.topDict || (this.topDict = o), r = o.get("XRefStm"), Number.isInteger(r) && !this._xrefStms.has(r) && (this._xrefStms.add(r), this.startXRefQueue.push(r), this.#t ??= r);
        else {
          if (!Number.isInteger(r)) throw new Ct("Invalid XRef stream header");
          if (!(Number.isInteger(n.getObj()) && zA(n.getObj(), "obj") && (r = n.getObj()) instanceof AA)) throw new Ct("Invalid XRef stream");
          if (o = this.processXRefStream(r), this.topDict || (this.topDict = o), !o) throw new Ct("Failed to read XRef stream");
        }
        r = o.get("Prev"), Number.isInteger(r) ? this.startXRefQueue.push(r) : r instanceof St && this.startXRefQueue.push(r.num);
      } catch (s) {
        if (s instanceof yA) throw s;
        tA("(while reading XRef): " + s);
      }
      this.startXRefQueue.shift();
    }
    if (this.topDict) return this.topDict;
    if (!t) throw new qa();
  }
  get lastXRefStreamPos() {
    return this.#t ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
  }
  getEntry(t) {
    const e = this.entries[t];
    return e && !e.free && e.offset ? e : null;
  }
  fetchIfRef(t, e = !1) {
    return t instanceof St ? this.fetch(t, e) : t;
  }
  fetch(t, e = !1) {
    if (!(t instanceof St)) throw new Error("ref object is not a reference");
    const i = t.num, s = this._cacheMap.get(i);
    if (s !== void 0) return s instanceof z && !s.objId && (s.objId = t.toString()), s;
    let n = this.getEntry(i);
    if (n === null) return this._cacheMap.set(i, n), n;
    if (this._pendingRefs.has(t)) return this._pendingRefs.remove(t), O(`Ignoring circular reference: ${t}.`), _m;
    this._pendingRefs.put(t);
    try {
      n = n.uncompressed ? this.fetchUncompressed(t, n, e) : this.fetchCompressed(t, n, e), this._pendingRefs.remove(t);
    } catch (o) {
      throw this._pendingRefs.remove(t), o;
    }
    return n instanceof z ? n.objId = t.toString() : n instanceof AA && (n.dict.objId = t.toString()), n;
  }
  fetchUncompressed(t, e, i = !1) {
    const s = t.gen;
    let n = t.num;
    if (e.gen !== s) {
      const C = `Inconsistent generation in XRef: ${t}`;
      if (this._generationFallback && e.gen < s) return O(C), this.fetchUncompressed(St.get(n, e.gen), e, i);
      throw new Ds(C);
    }
    const o = this.stream.makeSubStream(e.offset + this.stream.start), r = new Es({ lexer: new hi(o), xref: this, allowStreams: !0 }), c = r.getObj(), h = r.getObj(), I = r.getObj();
    if (c !== n || h !== s || !(I instanceof KA)) throw new Ds(`Bad (uncompressed) XRef entry: ${t}`);
    if (I.cmd !== "obj") {
      if (I.cmd.startsWith("obj") && (n = parseInt(I.cmd.substring(3), 10), !Number.isNaN(n))) return n;
      throw new Ds(`Bad (uncompressed) XRef entry: ${t}`);
    }
    return (e = this.encrypt && !i ? r.getObj(this.encrypt.createCipherTransform(n, s)) : r.getObj()) instanceof AA || this._cacheMap.set(n, e), e;
  }
  fetchCompressed(t, e, i = !1) {
    const s = e.offset, n = this.fetch(St.get(s, 0));
    if (!(n instanceof AA)) throw new Ct("bad ObjStm stream");
    const o = n.dict.get("First"), r = n.dict.get("N");
    if (!Number.isInteger(o) || !Number.isInteger(r)) throw new Ct("invalid first and n parameters for ObjStm stream");
    let c = new Es({ lexer: new hi(n), xref: this, allowStreams: !0 });
    const h = new Array(r), I = new Array(r);
    for (let u = 0; u < r; ++u) {
      const E = c.getObj();
      if (!Number.isInteger(E)) throw new Ct(`invalid object number in the ObjStm stream: ${E}`);
      const p = c.getObj();
      if (!Number.isInteger(p)) throw new Ct(`invalid object offset in the ObjStm stream: ${p}`);
      h[u] = E, I[u] = p;
    }
    const C = (n.start || 0) + o, d = new Array(r);
    for (let u = 0; u < r; ++u) {
      const E = u < r - 1 ? I[u + 1] - I[u] : void 0;
      if (E < 0) throw new Ct("Invalid offset in the ObjStm stream.");
      c = new Es({ lexer: new hi(n.makeSubStream(C + I[u], E, n.dict)), xref: this, allowStreams: !0 });
      const p = c.getObj();
      if (d[u] = p, p instanceof AA) continue;
      const y = h[u], b = this.entries[y];
      b && b.offset === s && b.gen === u && this._cacheMap.set(y, p);
    }
    if ((e = d[e.gen]) === void 0) throw new Ds(`Bad (compressed) XRef entry: ${t}`);
    return e;
  }
  async fetchIfRefAsync(t, e) {
    return t instanceof St ? this.fetchAsync(t, e) : t;
  }
  async fetchAsync(t, e) {
    try {
      return this.fetch(t, e);
    } catch (i) {
      if (!(i instanceof yA)) throw i;
      return await this.pdfManager.requestRange(i.begin, i.end), this.fetchAsync(t, e);
    }
  }
  getCatalogObj() {
    return this.root;
  }
}
const cD = [0, 0, 612, 792];
class W1 {
  constructor({ pdfManager: t, xref: e, pageIndex: i, pageDict: s, ref: n, globalIdFactory: o, fontCache: r, builtInCMapCache: c, standardFontDataCache: h, globalImageCache: I, systemFontCache: C, nonBlendModesSet: d, xfaFactory: u }) {
    this.pdfManager = t, this.pageIndex = i, this.pageDict = s, this.xref = e, this.ref = n, this.fontCache = r, this.builtInCMapCache = c, this.standardFontDataCache = h, this.globalImageCache = I, this.systemFontCache = C, this.nonBlendModesSet = d, this.evaluatorOptions = t.evaluatorOptions, this.resourcesPromise = null, this.xfaFactory = u;
    const E = { obj: 0 };
    this._localIdFactory = class extends o {
      static createObjId() {
        return `p${i}_${++E.obj}`;
      }
      static getPageObjId() {
        return `p${n.toString()}`;
      }
    };
  }
  _getInheritableProperty(t, e = !1) {
    const i = ei({ dict: this.pageDict, key: t, getArray: e, stopWhenFound: !1 });
    return Array.isArray(i) ? i.length !== 1 && i[0] instanceof z ? z.merge({ xref: this.xref, dictArray: i }) : i[0] : i;
  }
  get content() {
    return this.pageDict.getArray("Contents");
  }
  get resources() {
    const t = this._getInheritableProperty("Resources");
    return bt(this, "resources", t instanceof z ? t : z.empty);
  }
  _getBoundingBox(t) {
    if (this.xfaData) return this.xfaData.bbox;
    const e = Zi(this._getInheritableProperty(t, !0), null);
    if (e) {
      if (e[2] - e[0] > 0 && e[3] - e[1] > 0) return e;
      O(`Empty, or invalid, /${t} entry.`);
    }
    return null;
  }
  get mediaBox() {
    return bt(this, "mediaBox", this._getBoundingBox("MediaBox") || cD);
  }
  get cropBox() {
    return bt(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
  }
  get userUnit() {
    let t = this.pageDict.get("UserUnit");
    return (typeof t != "number" || t <= 0) && (t = 1), bt(this, "userUnit", t);
  }
  get view() {
    const { cropBox: t, mediaBox: e } = this;
    if (t !== e && !ja(t, e)) {
      const i = PA.intersect(t, e);
      if (i && i[2] - i[0] > 0 && i[3] - i[1] > 0) return bt(this, "view", i);
      O("Empty /CropBox and /MediaBox intersection.");
    }
    return bt(this, "view", e);
  }
  get rotate() {
    let t = this._getInheritableProperty("Rotate") || 0;
    return t % 90 != 0 ? t = 0 : t >= 360 ? t %= 360 : t < 0 && (t = (t % 360 + 360) % 360), bt(this, "rotate", t);
  }
  _onSubStreamError(t, e) {
    if (!this.evaluatorOptions.ignoreErrors) throw t;
    O(`getContentStream - ignoring sub-stream (${e}): "${t}".`);
  }
  getContentStream() {
    return this.pdfManager.ensure(this, "content").then(((t) => t instanceof AA ? t : Array.isArray(t) ? new c3(t, this._onSubStreamError.bind(this)) : new Wo()));
  }
  get xfaData() {
    return bt(this, "xfaData", this.xfaFactory ? { bbox: this.xfaFactory.getBoundingBox(this.pageIndex) } : null);
  }
  #t(t, e, i) {
    for (const s of t) if (s.id) {
      const n = St.fromString(s.id);
      if (!n) {
        O(`A non-linked annotation cannot be modified: ${s.id}`);
        continue;
      }
      if (s.deleted) {
        e.put(n, n);
        continue;
      }
      i?.put(n), s.ref = n, delete s.id;
    }
  }
  async saveNewAnnotations(t, e, i, s) {
    if (this.xfaFactory) throw new Error("XFA: Cannot save new annotations.");
    const n = new Ri({ xref: this.xref, handler: t, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }), o = new Ii(), r = new XA();
    this.#t(i, o, r);
    const c = this.pageDict, h = this.annotations.filter(((E) => !(E instanceof St && o.has(E)))), I = await ws.saveNewAnnotations(n, e, i, s);
    for (const { ref: E } of I.annotations) E instanceof St && !r.has(E) && h.push(E);
    const C = c.get("Annots");
    c.set("Annots", h);
    const d = [];
    await me(this.ref, c, d, this.xref), C && c.set("Annots", C);
    const u = I.dependencies;
    u.push({ ref: this.ref, data: d.join("") }, ...I.annotations);
    for (const E of o) u.push({ ref: E, data: null });
    return u;
  }
  save(t, e, i) {
    const s = new Ri({ xref: this.xref, handler: t, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions });
    return this._parsedAnnotations.then((function(n) {
      const o = [];
      for (const r of n) r.mustBePrinted(i) && o.push(r.save(s, e, i).catch((function(c) {
        return O(`save - ignoring annotation data during "${e.name}" task: "${c}".`), null;
      })));
      return Promise.all(o).then((function(r) {
        return r.filter(((c) => !!c));
      }));
    }));
  }
  loadResources(t) {
    return this.resourcesPromise ||= this.pdfManager.ensure(this, "resources"), this.resourcesPromise.then((() => new zo(this.resources, t, this.xref).load()));
  }
  getOperatorList({ handler: t, sink: e, task: i, intent: s, cacheKey: n, annotationStorage: o = null, modifiedIds: r = null }) {
    const c = this.getContentStream(), h = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]), I = new Ri({ xref: this.xref, handler: t, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }), C = this.xfaFactory ? null : iE(o), d = C?.get(this.pageIndex);
    let u = Promise.resolve(null), E = null;
    if (d) {
      const y = this.pdfManager.ensureDoc("annotationGlobals");
      let b;
      const D = /* @__PURE__ */ new Set();
      for (const { bitmapId: R, bitmap: x } of d) !R || x || D.has(R) || D.add(R);
      const { isOffscreenCanvasSupported: S } = this.evaluatorOptions;
      if (D.size > 0) {
        const R = d.slice();
        for (const [x, N] of o) x.startsWith(dQ) && N.bitmap && D.has(N.bitmapId) && R.push(N);
        b = ws.generateImages(R, this.xref, S);
      } else b = ws.generateImages(d, this.xref, S);
      E = new XA(), this.#t(d, E, null), u = y.then(((R) => R ? ws.printNewAnnotations(R, I, i, d, b) : null));
    }
    const p = Promise.all([c, h]).then((([y]) => {
      const b = new ue(s, e);
      return t.send("StartRenderPage", { transparency: I.hasBlendModes(this.resources, this.nonBlendModesSet), pageIndex: this.pageIndex, cacheKey: n }), I.getOperatorList({ stream: y, task: i, resources: this.resources, operatorList: b }).then((function() {
        return b;
      }));
    }));
    return Promise.all([p, this._parsedAnnotations, u]).then((function([y, b, D]) {
      if (D) {
        b = b.filter(((q) => !(q.ref && E.has(q.ref))));
        for (let q = 0, _ = D.length; q < _; q++) {
          const Y = D[q];
          if (Y.refToReplace) {
            const ht = b.findIndex(((ut) => ut.ref && Po(ut.ref, Y.refToReplace)));
            ht >= 0 && (b.splice(ht, 1, Y), D.splice(q--, 1), _--);
          }
        }
        b = b.concat(D);
      }
      if (b.length === 0 || s & m9) return y.flush(!0), { length: y.totalLength };
      const S = !!(s & BQ), R = !!(s & y9), x = !!(s & rC), N = !!(s & Ro), U = !!(s & oC), T = [];
      for (const q of b) (x || N && q.mustBeViewed(o, S) && q.mustBeViewedWhenEditing(R, r) || U && q.mustBePrinted(o)) && T.push(q.getOperatorList(I, i, s, o).catch((function(_) {
        return O(`getOperatorList - ignoring annotation data during "${i.name}" task: "${_}".`), { opList: null, separateForm: !1, separateCanvas: !1 };
      })));
      return Promise.all(T).then((function(q) {
        let _ = !1, Y = !1;
        for (const { opList: ht, separateForm: ut, separateCanvas: j } of q) y.addOpList(ht), _ ||= ut, Y ||= j;
        return y.flush(!0, { form: _, canvas: Y }), { length: y.totalLength };
      }));
    }));
  }
  async extractTextContent({ handler: t, task: e, includeMarkedContent: i, disableNormalization: s, sink: n }) {
    const o = this.getContentStream(), r = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]), c = this.pdfManager.ensureCatalog("lang"), [h, , I] = await Promise.all([o, r, c]);
    return new Ri({ xref: this.xref, handler: t, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }).getTextContent({ stream: h, task: e, resources: this.resources, includeMarkedContent: i, disableNormalization: s, sink: n, viewBox: this.view, lang: I });
  }
  async getStructTree() {
    const t = await this.pdfManager.ensureCatalog("structTreeRoot");
    return t ? (await this._parsedAnnotations, (await this.pdfManager.ensure(this, "_parseStructTree", [t])).serializable) : null;
  }
  _parseStructTree(t) {
    const e = new ny(t, this.pageDict);
    return e.parse(this.ref), e;
  }
  async getAnnotationsData(t, e, i) {
    const s = await this._parsedAnnotations;
    if (s.length === 0) return s;
    const n = [], o = [];
    let r;
    const c = !!(i & rC), h = !!(i & Ro), I = !!(i & oC);
    for (const C of s) {
      const d = c || h && C.viewable;
      (d || I && C.printable) && n.push(C.data), C.hasTextContent && d && (r ||= new Ri({ xref: this.xref, handler: t, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }), o.push(C.extractTextContent(r, e, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]).catch((function(u) {
        O(`getAnnotationsData - ignoring textContent during "${e.name}" task: "${u}".`);
      }))));
    }
    return await Promise.all(o), n;
  }
  get annotations() {
    const t = this._getInheritableProperty("Annots");
    return bt(this, "annotations", Array.isArray(t) ? t : []);
  }
  get _parsedAnnotations() {
    return bt(this, "_parsedAnnotations", this.pdfManager.ensure(this, "annotations").then((async (t) => {
      if (t.length === 0) return t;
      const e = await this.pdfManager.ensureDoc("annotationGlobals");
      if (!e) return [];
      const i = [];
      for (const r of t) i.push(ws.create(this.xref, r, e, this._localIdFactory, !1, this.ref).catch((function(c) {
        return O(`_parsedAnnotations: "${c}".`), null;
      })));
      const s = [];
      let n, o;
      for (const r of await Promise.all(i)) r && (r instanceof ui ? (o ||= []).push(r) : r instanceof Ff ? (n ||= []).push(r) : s.push(r));
      return o && s.push(...o), n && s.push(...n), s;
    })));
  }
  get jsActions() {
    return bt(this, "jsActions", Bg(this.xref, this.pageDict, om));
  }
}
const j1 = new Uint8Array([37, 80, 68, 70, 45]), Z1 = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), hD = new Uint8Array([101, 110, 100, 111, 98, 106]);
function Bh(A, t, e = 1024, i = !1) {
  const s = t.length, n = A.peekBytes(e), o = n.length - s;
  if (o <= 0) return !1;
  if (i) {
    const r = s - 1;
    let c = n.length - 1;
    for (; c >= r; ) {
      let h = 0;
      for (; h < s && n[c - h] === t[r - h]; ) h++;
      if (h >= s) return A.pos += c - r, !0;
      c--;
    }
  } else {
    let r = 0;
    for (; r <= o; ) {
      let c = 0;
      for (; c < s && n[r + c] === t[c]; ) c++;
      if (c >= s) return A.pos += r, !0;
      r++;
    }
  }
  return !1;
}
class Nf {
  constructor(t, e) {
    if (e.length <= 0) throw new qo("The PDF file is empty, i.e. its size is zero bytes.");
    this.pdfManager = t, this.stream = e, this.xref = new gD(e, t), this._pagePromises = /* @__PURE__ */ new Map(), this._version = null;
    const i = { font: 0 };
    this._globalIdFactory = class {
      static getDocId() {
        return `g_${t.docId}`;
      }
      static createFontId() {
        return "f" + ++i.font;
      }
      static createObjId() {
        oA("Abstract method `createObjId` called.");
      }
      static getPageObjId() {
        oA("Abstract method `getPageObjId` called.");
      }
    };
  }
  parse(t) {
    this.xref.parse(t), this.catalog = new za(this.pdfManager, this.xref);
  }
  get linearization() {
    let t = null;
    try {
      t = T3.create(this.stream);
    } catch (e) {
      if (e instanceof yA) throw e;
      tA(e);
    }
    return bt(this, "linearization", t);
  }
  get startXRef() {
    const t = this.stream;
    let e = 0;
    if (this.linearization) {
      if (t.reset(), Bh(t, hD)) {
        t.skip(6);
        let i = t.peekByte();
        for (; qe(i); ) t.pos++, i = t.peekByte();
        e = t.pos - t.start;
      }
    } else {
      const s = Z1.length;
      let n = !1, o = t.end;
      for (; !n && o > 0; ) o -= 1024 - s, o < 0 && (o = 0), t.pos = o, n = Bh(t, Z1, 1024, !0);
      if (n) {
        let r;
        t.skip(9);
        do
          r = t.getByte();
        while (qe(r));
        let c = "";
        for (; r >= 32 && r <= 57; ) c += String.fromCharCode(r), r = t.getByte();
        e = parseInt(c, 10), isNaN(e) && (e = 0);
      }
    }
    return bt(this, "startXRef", e);
  }
  checkHeader() {
    const t = this.stream;
    if (t.reset(), !Bh(t, j1)) return;
    t.moveStart(), t.skip(j1.length);
    let e, i = "";
    for (; (e = t.getByte()) > 32 && i.length < 7; ) i += String.fromCharCode(e);
    $Q.test(i) ? this._version = i : O(`Invalid PDF header version: ${i}`);
  }
  parseStartXRef() {
    this.xref.setStartXRef(this.startXRef);
  }
  get numPages() {
    let t = 0;
    return t = this.catalog.hasActualNumPages ? this.catalog.numPages : this.xfaFactory ? this.xfaFactory.getNumPages() : this.linearization ? this.linearization.numPages : this.catalog.numPages, bt(this, "numPages", t);
  }
  _hasOnlyDocumentSignatures(t, e = 0) {
    return !!Array.isArray(t) && t.every(((i) => {
      if (!((i = this.xref.fetchIfRef(i)) instanceof z)) return !1;
      if (i.has("Kids")) return ++e > 10 ? (O("_hasOnlyDocumentSignatures: maximum recursion depth reached"), !1) : this._hasOnlyDocumentSignatures(i.get("Kids"), e);
      const s = qA(i.get("FT"), "Sig"), n = i.get("Rect"), o = Array.isArray(n) && n.every(((r) => r === 0));
      return s && o;
    }));
  }
  get _xfaStreams() {
    const t = this.catalog.acroForm;
    if (!t) return null;
    const e = t.get("XFA"), i = { "xdp:xdp": "", template: "", datasets: "", config: "", connectionSet: "", localeSet: "", stylesheet: "", "/xdp:xdp": "" };
    if (e instanceof AA && !e.isEmpty) return i["xdp:xdp"] = e, i;
    if (!Array.isArray(e) || e.length === 0) return null;
    for (let s = 0, n = e.length; s < n; s += 2) {
      let o;
      if (o = s === 0 ? "xdp:xdp" : s === n - 2 ? "/xdp:xdp" : e[s], !i.hasOwnProperty(o)) continue;
      const r = this.xref.fetchIfRef(e[s + 1]);
      r instanceof AA && !r.isEmpty && (i[o] = r);
    }
    return i;
  }
  get xfaDatasets() {
    const t = this._xfaStreams;
    if (!t) return bt(this, "xfaDatasets", null);
    for (const e of ["datasets", "xdp:xdp"]) {
      const i = t[e];
      if (i) try {
        const s = ar(i.getString());
        return bt(this, "xfaDatasets", new oD({ [e]: s }));
      } catch {
        O("XFA - Invalid utf-8 string.");
        break;
      }
    }
    return bt(this, "xfaDatasets", null);
  }
  get xfaData() {
    const t = this._xfaStreams;
    if (!t) return null;
    const e = /* @__PURE__ */ Object.create(null);
    for (const [i, s] of Object.entries(t)) if (s) try {
      e[i] = ar(s.getString());
    } catch {
      return O("XFA - Invalid utf-8 string."), null;
    }
    return e;
  }
  get xfaFactory() {
    let t;
    return this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (t = this.xfaData), bt(this, "xfaFactory", t ? new Rr(t) : null);
  }
  get isPureXfa() {
    return !!this.xfaFactory && this.xfaFactory.isValid();
  }
  get htmlForXfa() {
    return this.xfaFactory ? this.xfaFactory.getPages() : null;
  }
  async loadXfaImages() {
    const t = await this.pdfManager.ensureCatalog("xfaImages");
    if (!t) return;
    const e = t.getKeys();
    await new zo(t, e, this.xref).load();
    const s = /* @__PURE__ */ new Map();
    for (const n of e) {
      const o = t.get(n);
      o instanceof AA && s.set(n, o.getBytes());
    }
    this.xfaFactory.setImages(s);
  }
  async loadXfaFonts(t, e) {
    const i = await this.pdfManager.ensureCatalog("acroForm");
    if (!i) return;
    const s = await i.getAsync("DR");
    if (!(s instanceof z)) return;
    await new zo(s, ["Font"], this.xref).load();
    const o = s.get("Font");
    if (!(o instanceof z)) return;
    const r = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
    r.useSystemFonts = !1;
    const c = new Ri({ xref: this.xref, handler: t, pageIndex: -1, idFactory: this._globalIdFactory, fontCache: this.catalog.fontCache, builtInCMapCache: this.catalog.builtInCMapCache, standardFontDataCache: this.catalog.standardFontDataCache, options: r }), h = new ue(), I = [], C = { get font() {
      return I.at(-1);
    }, set font(y) {
      I.push(y);
    }, clone() {
      return this;
    } }, d = /* @__PURE__ */ new Map();
    o.forEach(((y, b) => {
      d.set(y, b);
    }));
    const u = [];
    for (const [y, b] of d) {
      const D = b.get("FontDescriptor");
      if (!(D instanceof z)) continue;
      let S = D.get("FontFamily");
      S = S.replaceAll(/[ ]+(\d)/g, "$1");
      const R = { fontFamily: S, fontWeight: D.get("FontWeight"), italicAngle: -D.get("ItalicAngle") };
      Zm(R) && u.push(c.handleSetFont(s, [at.get(y), 1], null, h, e, C, null, R).catch((function(x) {
        return O(`loadXfaFonts: "${x}".`), null;
      })));
    }
    await Promise.all(u);
    const E = this.xfaFactory.setFonts(I);
    if (!E) return;
    r.ignoreErrors = !0, u.length = 0, I.length = 0;
    const p = /* @__PURE__ */ new Set();
    for (const y of E) Ll(`${y}-Regular`) || p.add(y);
    p.size && E.push("PdfJS-Fallback");
    for (const y of E) if (!p.has(y)) for (const b of [{ name: "Regular", fontWeight: 400, italicAngle: 0 }, { name: "Bold", fontWeight: 700, italicAngle: 0 }, { name: "Italic", fontWeight: 400, italicAngle: 12 }, { name: "BoldItalic", fontWeight: 700, italicAngle: 12 }]) {
      const D = `${y}-${b.name}`, S = SE(D);
      u.push(c.handleSetFont(s, [at.get(D), 1], null, h, e, C, S, { fontFamily: y, fontWeight: b.fontWeight, italicAngle: b.italicAngle }).catch((function(R) {
        return O(`loadXfaFonts: "${R}".`), null;
      })));
    }
    await Promise.all(u), this.xfaFactory.appendFonts(I, p);
  }
  async serializeXfaData(t) {
    return this.xfaFactory ? this.xfaFactory.serializeData(t) : null;
  }
  get version() {
    return this.catalog.version || this._version;
  }
  get formInfo() {
    const t = { hasFields: !1, hasAcroForm: !1, hasXfa: !1, hasSignatures: !1 }, e = this.catalog.acroForm;
    if (!e) return bt(this, "formInfo", t);
    try {
      const i = e.get("Fields"), s = Array.isArray(i) && i.length > 0;
      t.hasFields = s;
      const n = e.get("XFA");
      t.hasXfa = Array.isArray(n) && n.length > 0 || n instanceof AA && !n.isEmpty;
      const o = !!(1 & e.get("SigFlags")), r = o && this._hasOnlyDocumentSignatures(i);
      t.hasAcroForm = s && !r, t.hasSignatures = o;
    } catch (i) {
      if (i instanceof yA) throw i;
      O(`Cannot fetch form information: "${i}".`);
    }
    return bt(this, "formInfo", t);
  }
  get documentInfo() {
    const t = { PDFFormatVersion: this.version, Language: this.catalog.lang, EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null, IsLinearized: !!this.linearization, IsAcroFormPresent: this.formInfo.hasAcroForm, IsXFAPresent: this.formInfo.hasXfa, IsCollectionPresent: !!this.catalog.collection, IsSignaturesPresent: this.formInfo.hasSignatures };
    let e;
    try {
      e = this.xref.trailer.get("Info");
    } catch (i) {
      if (i instanceof yA) throw i;
      tA("The document information dictionary is invalid.");
    }
    if (!(e instanceof z)) return bt(this, "documentInfo", t);
    for (const i of e.getKeys()) {
      const s = e.get(i);
      switch (i) {
        case "Title":
        case "Author":
        case "Subject":
        case "Keywords":
        case "Creator":
        case "Producer":
        case "CreationDate":
        case "ModDate":
          if (typeof s == "string") {
            t[i] = cA(s);
            continue;
          }
          break;
        case "Trapped":
          if (s instanceof at) {
            t[i] = s;
            continue;
          }
          break;
        default:
          let n;
          switch (typeof s) {
            case "string":
              n = cA(s);
              break;
            case "number":
            case "boolean":
              n = s;
              break;
            default:
              s instanceof at && (n = s);
          }
          if (n === void 0) {
            O(`Bad value, for custom key "${i}", in Info: ${s}.`);
            continue;
          }
          t.Custom || (t.Custom = /* @__PURE__ */ Object.create(null)), t.Custom[i] = n;
          continue;
      }
      O(`Bad value, for key "${i}", in Info: ${s}.`);
    }
    return bt(this, "documentInfo", t);
  }
  get fingerprints() {
    function t(o) {
      return typeof o == "string" && o.length > 0 && o !== "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
    }
    function e(o) {
      const r = [];
      for (const c of o) {
        const h = c.toString(16);
        r.push(h.padStart(2, "0"));
      }
      return r.join("");
    }
    const i = this.xref.trailer.get("ID");
    let s, n;
    return Array.isArray(i) && t(i[0]) ? (s = re(i[0]), i[1] !== i[0] && t(i[1]) && (n = re(i[1]))) : s = ps(this.stream.getByteRange(0, 1024), 0, 1024), bt(this, "fingerprints", [e(s), n ? e(n) : null]);
  }
  async _getLinearizationPage(t) {
    const { catalog: e, linearization: i, xref: s } = this, n = St.get(i.objectNumberFirst, 0);
    try {
      const o = await s.fetchAsync(n);
      if (o instanceof z) {
        let r = o.getRaw("Type");
        if (r instanceof St && (r = await s.fetchAsync(r)), qA(r, "Page") || !o.has("Type") && !o.has("Kids") && o.has("Contents")) return e.pageKidsCountCache.has(n) || e.pageKidsCountCache.put(n, 1), e.pageIndexCache.has(n) || e.pageIndexCache.put(n, 0), [o, n];
      }
      throw new Ct("The Linearization dictionary doesn't point to a valid Page dictionary.");
    } catch (o) {
      return O(`_getLinearizationPage: "${o.message}".`), e.getPageDict(t);
    }
  }
  getPage(t) {
    const e = this._pagePromises.get(t);
    if (e) return e;
    const { catalog: i, linearization: s, xfaFactory: n } = this;
    let o;
    return o = n ? Promise.resolve([z.empty, null]) : s?.pageFirst === t ? this._getLinearizationPage(t) : i.getPageDict(t), o = o.then((([r, c]) => new W1({ pdfManager: this.pdfManager, xref: this.xref, pageIndex: t, pageDict: r, ref: c, globalIdFactory: this._globalIdFactory, fontCache: i.fontCache, builtInCMapCache: i.builtInCMapCache, standardFontDataCache: i.standardFontDataCache, globalImageCache: i.globalImageCache, systemFontCache: i.systemFontCache, nonBlendModesSet: i.nonBlendModesSet, xfaFactory: n }))), this._pagePromises.set(t, o), o;
  }
  async checkFirstPage(t = !1) {
    if (!t) try {
      await this.getPage(0);
    } catch (e) {
      if (e instanceof Ds) throw this._pagePromises.delete(0), await this.cleanup(), new qa();
    }
  }
  async checkLastPage(t = !1) {
    const { catalog: e, pdfManager: i } = this;
    let s;
    e.setActualNumPages();
    try {
      if (await Promise.all([i.ensureDoc("xfaFactory"), i.ensureDoc("linearization"), i.ensureCatalog("numPages")]), this.xfaFactory) return;
      if (s = this.linearization ? this.linearization.numPages : e.numPages, !Number.isInteger(s)) throw new Ct("Page count is not an integer.");
      if (s <= 1) return;
      await this.getPage(s - 1);
    } catch (n) {
      if (this._pagePromises.delete(s - 1), await this.cleanup(), n instanceof Ds && !t) throw new qa();
      let o;
      O(`checkLastPage - invalid /Pages tree /Count: ${s}.`);
      try {
        o = await e.getAllPageDicts(t);
      } catch (r) {
        if (r instanceof Ds && !t) throw new qa();
        return void e.setActualNumPages(1);
      }
      for (const [r, [c, h]] of o) {
        let I;
        c instanceof Error ? (I = Promise.reject(c), I.catch((() => {
        }))) : I = Promise.resolve(new W1({ pdfManager: i, xref: this.xref, pageIndex: r, pageDict: c, ref: h, globalIdFactory: this._globalIdFactory, fontCache: e.fontCache, builtInCMapCache: e.builtInCMapCache, standardFontDataCache: e.standardFontDataCache, globalImageCache: e.globalImageCache, systemFontCache: e.systemFontCache, nonBlendModesSet: e.nonBlendModesSet, xfaFactory: null })), this._pagePromises.set(r, I);
      }
      e.setActualNumPages(o.size);
    }
  }
  fontFallback(t, e) {
    return this.catalog.fontFallback(t, e);
  }
  async cleanup(t = !1) {
    return this.catalog ? this.catalog.cleanup(t) : Yl();
  }
  async #t(t, e, i, s, n) {
    const { xref: o } = this;
    if (!(e instanceof St) || n.has(e)) return;
    n.put(e);
    const r = await o.fetchAsync(e);
    if (!(r instanceof z)) return;
    if (r.has("T")) {
      const h = cA(await r.getAsync("T"));
      t = t === "" ? h : `${t}.${h}`;
    } else {
      let h = r;
      for (; ; ) {
        if (h = h.getRaw("Parent"), h instanceof St) {
          if (n.has(h)) break;
          h = await o.fetchAsync(h);
        }
        if (!(h instanceof z)) break;
        if (h.has("T")) {
          const I = cA(await h.getAsync("T"));
          t = t === "" ? I : `${t}.${I}`;
          break;
        }
      }
    }
    if (i.has(t) || i.set(t, []), i.get(t).push(ws.create(o, e, s, null, !0, null).then(((h) => h?.getFieldObject())).catch((function(h) {
      return O(`#collectFieldObjects: "${h}".`), null;
    }))), !r.has("Kids")) return;
    const c = await r.getAsync("Kids");
    if (Array.isArray(c)) for (const h of c) await this.#t(t, h, i, s, n);
  }
  get fieldObjects() {
    if (!this.formInfo.hasFields) return bt(this, "fieldObjects", Promise.resolve(null));
    const t = Promise.all([this.pdfManager.ensureDoc("annotationGlobals"), this.pdfManager.ensureCatalog("acroForm")]).then((async ([e, i]) => {
      if (!e) return null;
      const s = new XA(), n = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
      for (const c of await i.getAsync("Fields")) await this.#t("", c, o, e, s);
      const r = [];
      for (const [c, h] of o) r.push(Promise.all(h).then(((I) => {
        (I = I.filter(((C) => !!C))).length > 0 && (n[c] = I);
      })));
      return await Promise.all(r), n;
    }));
    return bt(this, "fieldObjects", t);
  }
  get hasJSActions() {
    return bt(this, "hasJSActions", this.pdfManager.ensureDoc("_parseHasJSActions"));
  }
  async _parseHasJSActions() {
    const [t, e] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
    return !!t || !!e && Object.values(e).some(((i) => i.some(((s) => s.actions !== null))));
  }
  get calculationOrderIds() {
    const t = this.catalog.acroForm;
    if (!t?.has("CO")) return bt(this, "calculationOrderIds", null);
    const e = t.get("CO");
    if (!Array.isArray(e) || e.length === 0) return bt(this, "calculationOrderIds", null);
    const i = [];
    for (const s of e) s instanceof St && i.push(s.toString());
    return i.length === 0 ? bt(this, "calculationOrderIds", null) : bt(this, "calculationOrderIds", i);
  }
  get annotationGlobals() {
    return bt(this, "annotationGlobals", ws.createGlobals(this.pdfManager));
  }
}
class Gf {
  constructor(t) {
    this._docBaseUrl = (function(e) {
      if (e) {
        const i = Yo(e);
        if (i) return i.href;
        O(`Invalid absolute docBaseUrl: "${e}".`);
      }
      return null;
    })(t.docBaseUrl), this._docId = t.docId, this._password = t.password, this.enableXfa = t.enableXfa, t.evaluatorOptions.isOffscreenCanvasSupported &&= es.isOffscreenCanvasSupported, this.evaluatorOptions = Object.freeze(t.evaluatorOptions);
  }
  get docId() {
    return this._docId;
  }
  get password() {
    return this._password;
  }
  get docBaseUrl() {
    return this._docBaseUrl;
  }
  get catalog() {
    return this.pdfDocument.catalog;
  }
  ensureDoc(t, e) {
    return this.ensure(this.pdfDocument, t, e);
  }
  ensureXRef(t, e) {
    return this.ensure(this.pdfDocument.xref, t, e);
  }
  ensureCatalog(t, e) {
    return this.ensure(this.pdfDocument.catalog, t, e);
  }
  getPage(t) {
    return this.pdfDocument.getPage(t);
  }
  fontFallback(t, e) {
    return this.pdfDocument.fontFallback(t, e);
  }
  loadXfaFonts(t, e) {
    return this.pdfDocument.loadXfaFonts(t, e);
  }
  loadXfaImages() {
    return this.pdfDocument.loadXfaImages();
  }
  serializeXfaData(t) {
    return this.pdfDocument.serializeXfaData(t);
  }
  cleanup(t = !1) {
    return this.pdfDocument.cleanup(t);
  }
  async ensure(t, e, i) {
    oA("Abstract method `ensure` called");
  }
  requestRange(t, e) {
    oA("Abstract method `requestRange` called");
  }
  requestLoadedStream(t = !1) {
    oA("Abstract method `requestLoadedStream` called");
  }
  sendProgressiveData(t) {
    oA("Abstract method `sendProgressiveData` called");
  }
  updatePassword(t) {
    this._password = t;
  }
  terminate(t) {
    oA("Abstract method `terminate` called");
  }
}
class V1 extends Gf {
  constructor(t) {
    super(t);
    const e = new RA(t.source);
    this.pdfDocument = new Nf(this, e), this._loadedStreamPromise = Promise.resolve(e);
  }
  async ensure(t, e, i) {
    const s = t[e];
    return typeof s == "function" ? s.apply(t, i) : s;
  }
  requestRange(t, e) {
    return Promise.resolve();
  }
  requestLoadedStream(t = !1) {
    return this._loadedStreamPromise;
  }
  terminate(t) {
  }
}
class lD extends Gf {
  constructor(t) {
    super(t), this.streamManager = new zm(t.source, { msgHandler: t.handler, length: t.length, disableAutoFetch: t.disableAutoFetch, rangeChunkSize: t.rangeChunkSize }), this.pdfDocument = new Nf(this, this.streamManager.getStream());
  }
  async ensure(t, e, i) {
    try {
      const s = t[e];
      return typeof s == "function" ? s.apply(t, i) : s;
    } catch (s) {
      if (!(s instanceof yA)) throw s;
      return await this.requestRange(s.begin, s.end), this.ensure(t, e, i);
    }
  }
  requestRange(t, e) {
    return this.streamManager.requestRange(t, e);
  }
  requestLoadedStream(t = !1) {
    return this.streamManager.requestAllChunks(t);
  }
  sendProgressiveData(t) {
    this.streamManager.onReceiveData({ chunk: t });
  }
  terminate(t) {
    this.streamManager.abort(t);
  }
}
const X1 = 1, z1 = 2, $1 = 1, dh = 2, tu = 3, Au = 4, eu = 5, iu = 6, Co = 7, Qh = 8;
function Je(A) {
  switch (A instanceof Error || typeof A == "object" && A !== null || oA('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), A.name) {
    case "AbortException":
      return new fe(A.message);
    case "MissingPDFException":
      return new qQ(A.message);
    case "PasswordException":
      return new To(A.message, A.code);
    case "UnexpectedResponseException":
      return new PQ(A.message, A.status);
    case "UnknownErrorException":
      return new Ko(A.message, A.details);
    default:
      return new Ko(A.message, A.toString());
  }
}
class su {
  constructor(t, e, i) {
    this.sourceName = t, this.targetName = e, this.comObj = i, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (s) => {
      const n = s.data;
      if (n.targetName !== this.sourceName) return;
      if (n.stream) return void this.#A(n);
      if (n.callback) {
        const r = n.callbackId, c = this.callbackCapabilities[r];
        if (!c) throw new Error(`Cannot resolve callback ${r}`);
        if (delete this.callbackCapabilities[r], n.callback === X1) c.resolve(n.data);
        else {
          if (n.callback !== z1) throw new Error("Unexpected callback case");
          c.reject(Je(n.reason));
        }
        return;
      }
      const o = this.actionHandler[n.action];
      if (!o) throw new Error(`Unknown action from worker: ${n.action}`);
      if (n.callbackId) {
        const r = this.sourceName, c = n.sourceName;
        new Promise((function(h) {
          h(o(n.data));
        })).then((function(h) {
          i.postMessage({ sourceName: r, targetName: c, callback: X1, callbackId: n.callbackId, data: h });
        }), (function(h) {
          i.postMessage({ sourceName: r, targetName: c, callback: z1, callbackId: n.callbackId, reason: Je(h) });
        }));
      } else n.streamId ? this.#t(n) : o(n.data);
    }, i.addEventListener("message", this._onComObjOnMessage);
  }
  on(t, e) {
    const i = this.actionHandler;
    if (i[t]) throw new Error(`There is already an actionName called "${t}"`);
    i[t] = e;
  }
  send(t, e, i) {
    this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: t, data: e }, i);
  }
  sendWithPromise(t, e, i) {
    const s = this.callbackId++, n = Promise.withResolvers();
    this.callbackCapabilities[s] = n;
    try {
      this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: t, callbackId: s, data: e }, i);
    } catch (o) {
      n.reject(o);
    }
    return n.promise;
  }
  sendWithStream(t, e, i, s) {
    const n = this.streamId++, o = this.sourceName, r = this.targetName, c = this.comObj;
    return new ReadableStream({ start: (h) => {
      const I = Promise.withResolvers();
      return this.streamControllers[n] = { controller: h, startCall: I, pullCall: null, cancelCall: null, isClosed: !1 }, c.postMessage({ sourceName: o, targetName: r, action: t, streamId: n, data: e, desiredSize: h.desiredSize }, s), I.promise;
    }, pull: (h) => {
      const I = Promise.withResolvers();
      return this.streamControllers[n].pullCall = I, c.postMessage({ sourceName: o, targetName: r, stream: iu, streamId: n, desiredSize: h.desiredSize }), I.promise;
    }, cancel: (h) => {
      pe(h instanceof Error, "cancel must have a valid reason");
      const I = Promise.withResolvers();
      return this.streamControllers[n].cancelCall = I, this.streamControllers[n].isClosed = !0, c.postMessage({ sourceName: o, targetName: r, stream: $1, streamId: n, reason: Je(h) }), I.promise;
    } }, i);
  }
  #t(t) {
    const e = t.streamId, i = this.sourceName, s = t.sourceName, n = this.comObj, o = this, r = this.actionHandler[t.action], c = { enqueue(h, I = 1, C) {
      if (this.isCancelled) return;
      const d = this.desiredSize;
      this.desiredSize -= I, d > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), n.postMessage({ sourceName: i, targetName: s, stream: Au, streamId: e, chunk: h }, C);
    }, close() {
      this.isCancelled || (this.isCancelled = !0, n.postMessage({ sourceName: i, targetName: s, stream: tu, streamId: e }), delete o.streamSinks[e]);
    }, error(h) {
      pe(h instanceof Error, "error must have a valid reason"), this.isCancelled || (this.isCancelled = !0, n.postMessage({ sourceName: i, targetName: s, stream: eu, streamId: e, reason: Je(h) }));
    }, sinkCapability: Promise.withResolvers(), onPull: null, onCancel: null, isCancelled: !1, desiredSize: t.desiredSize, ready: null };
    c.sinkCapability.resolve(), c.ready = c.sinkCapability.promise, this.streamSinks[e] = c, new Promise((function(h) {
      h(r(t.data, c));
    })).then((function() {
      n.postMessage({ sourceName: i, targetName: s, stream: Qh, streamId: e, success: !0 });
    }), (function(h) {
      n.postMessage({ sourceName: i, targetName: s, stream: Qh, streamId: e, reason: Je(h) });
    }));
  }
  #A(t) {
    const e = t.streamId, i = this.sourceName, s = t.sourceName, n = this.comObj, o = this.streamControllers[e], r = this.streamSinks[e];
    switch (t.stream) {
      case Qh:
        t.success ? o.startCall.resolve() : o.startCall.reject(Je(t.reason));
        break;
      case Co:
        t.success ? o.pullCall.resolve() : o.pullCall.reject(Je(t.reason));
        break;
      case iu:
        if (!r) {
          n.postMessage({ sourceName: i, targetName: s, stream: Co, streamId: e, success: !0 });
          break;
        }
        r.desiredSize <= 0 && t.desiredSize > 0 && r.sinkCapability.resolve(), r.desiredSize = t.desiredSize, new Promise((function(c) {
          c(r.onPull?.());
        })).then((function() {
          n.postMessage({ sourceName: i, targetName: s, stream: Co, streamId: e, success: !0 });
        }), (function(c) {
          n.postMessage({ sourceName: i, targetName: s, stream: Co, streamId: e, reason: Je(c) });
        }));
        break;
      case Au:
        if (pe(o, "enqueue should have stream controller"), o.isClosed) break;
        o.controller.enqueue(t.chunk);
        break;
      case tu:
        if (pe(o, "close should have stream controller"), o.isClosed) break;
        o.isClosed = !0, o.controller.close(), this.#e(o, e);
        break;
      case eu:
        pe(o, "error should have stream controller"), o.controller.error(Je(t.reason)), this.#e(o, e);
        break;
      case dh:
        t.success ? o.cancelCall.resolve() : o.cancelCall.reject(Je(t.reason)), this.#e(o, e);
        break;
      case $1:
        if (!r) break;
        new Promise((function(c) {
          c(r.onCancel?.(Je(t.reason)));
        })).then((function() {
          n.postMessage({ sourceName: i, targetName: s, stream: dh, streamId: e, success: !0 });
        }), (function(c) {
          n.postMessage({ sourceName: i, targetName: s, stream: dh, streamId: e, reason: Je(c) });
        })), r.sinkCapability.reject(Je(t.reason)), r.isCancelled = !0, delete this.streamSinks[e];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  }
  async #e(t, e) {
    await Promise.allSettled([t.startCall?.promise, t.pullCall?.promise, t.cancelCall?.promise]), delete this.streamControllers[e];
  }
  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }
}
class ID {
  constructor(t) {
    this._msgHandler = t, this._contentLength = null, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  getFullReader() {
    return pe(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once."), this._fullRequestReader = new CD(this._msgHandler), this._fullRequestReader;
  }
  getRangeReader(t, e) {
    const i = new uD(t, e, this._msgHandler);
    return this._rangeRequestReaders.push(i), i;
  }
  cancelAllRequests(t) {
    this._fullRequestReader?.cancel(t);
    for (const e of this._rangeRequestReaders.slice(0)) e.cancel(t);
  }
}
class CD {
  constructor(t) {
    this._msgHandler = t, this.onProgress = null, this._contentLength = null, this._isRangeSupported = !1, this._isStreamingSupported = !1;
    const e = this._msgHandler.sendWithStream("GetReader");
    this._reader = e.getReader(), this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then(((i) => {
      this._isStreamingSupported = i.isStreamingSupported, this._isRangeSupported = i.isRangeSupported, this._contentLength = i.contentLength;
    }));
  }
  get headersReady() {
    return this._headersReady;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  async read() {
    const { value: t, done: e } = await this._reader.read();
    return e ? { value: void 0, done: !0 } : { value: t.buffer, done: !1 };
  }
  cancel(t) {
    this._reader.cancel(t);
  }
}
class uD {
  constructor(t, e, i) {
    this._msgHandler = i, this.onProgress = null;
    const s = this._msgHandler.sendWithStream("GetRangeReader", { begin: t, end: e });
    this._reader = s.getReader();
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    const { value: t, done: e } = await this._reader.read();
    return e ? { value: void 0, done: !0 } : { value: t.buffer, done: !1 };
  }
  cancel(t) {
    this._reader.cancel(t);
  }
}
class Xs {
  constructor(t) {
    this.name = t, this.terminated = !1, this._capability = Promise.withResolvers();
  }
  get finished() {
    return this._capability.promise;
  }
  finish() {
    this._capability.resolve();
  }
  terminate() {
    this.terminated = !0;
  }
  ensureNotTerminated() {
    if (this.terminated) throw new Error("Worker task was terminated");
  }
}
class fr {
  static setup(t, e) {
    let i = !1;
    t.on("test", (function(s) {
      i || (i = !0, t.send("test", s instanceof Uint8Array));
    })), t.on("configure", (function(s) {
      var n;
      n = s.verbosity, Number.isInteger(n) && (ug = n);
    })), t.on("GetDocRequest", (function(s) {
      return fr.createDocumentHandler(s, e);
    }));
  }
  static createDocumentHandler(t, e) {
    let i, s = !1, n = null;
    const o = /* @__PURE__ */ new Set(), r = Jm(), { docId: c, apiVersion: h } = t, I = "4.6.82";
    if (h !== I) throw new Error(`The API version "${h}" does not match the Worker version "${I}".`);
    const C = [];
    for (const S in []) C.push(S);
    if (C.length) throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + C.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
    const d = c + "_worker";
    let u = new su(d, c, e);
    function E() {
      if (s) throw new Error("Worker was terminated");
    }
    function p(S) {
      o.add(S);
    }
    function y(S) {
      S.finish(), o.delete(S);
    }
    async function b(S) {
      await i.ensureDoc("checkHeader"), await i.ensureDoc("parseStartXRef"), await i.ensureDoc("parse", [S]), await i.ensureDoc("checkFirstPage", [S]), await i.ensureDoc("checkLastPage", [S]);
      const R = await i.ensureDoc("isPureXfa");
      if (R) {
        const U = new Xs("loadXfaFonts");
        p(U), await Promise.all([i.loadXfaFonts(u, U).catch(((T) => {
        })).then((() => y(U))), i.loadXfaImages()]);
      }
      const [x, N] = await Promise.all([i.ensureDoc("numPages"), i.ensureDoc("fingerprints")]);
      return { numPages: x, fingerprints: N, htmlForXfa: R ? await i.ensureDoc("htmlForXfa") : null };
    }
    function D({ data: S, password: R, disableAutoFetch: x, rangeChunkSize: N, length: U, docBaseUrl: T, enableXfa: q, evaluatorOptions: _ }) {
      const Y = { source: null, disableAutoFetch: x, docBaseUrl: T, docId: c, enableXfa: q, evaluatorOptions: _, handler: u, length: U, password: R, rangeChunkSize: N }, ht = Promise.withResolvers();
      let ut;
      if (S) {
        try {
          Y.source = S, ut = new V1(Y), ht.resolve(ut);
        } catch (st) {
          ht.reject(st);
        }
        return ht.promise;
      }
      let j, it = [];
      try {
        j = new ID(u);
      } catch (st) {
        return ht.reject(st), ht.promise;
      }
      const tt = j.getFullReader();
      tt.headersReady.then((function() {
        if (tt.isRangeSupported) {
          Y.source = j, Y.length = tt.contentLength, Y.disableAutoFetch ||= tt.isStreamingSupported, ut = new lD(Y);
          for (const st of it) ut.sendProgressiveData(st);
          it = [], ht.resolve(ut), n = null;
        }
      })).catch((function(st) {
        ht.reject(st), n = null;
      }));
      let Z = 0;
      return new Promise((function(st, dt) {
        const ct = function({ value: M, done: H }) {
          try {
            if (E(), H) return ut || (function() {
              const W = tE(it);
              U && W.length !== U && O("reported HTTP length is different from actual");
              try {
                Y.source = W, ut = new V1(Y), ht.resolve(ut);
              } catch (lt) {
                ht.reject(lt);
              }
              it = [];
            })(), void (n = null);
            Z += M.byteLength, tt.isStreamingSupported || u.send("DocProgress", { loaded: Z, total: Math.max(Z, tt.contentLength || 0) }), ut ? ut.sendProgressiveData(M) : it.push(M), tt.read().then(ct, dt);
          } catch (W) {
            dt(W);
          }
        };
        tt.read().then(ct, dt);
      })).catch((function(st) {
        ht.reject(st), n = null;
      })), n = function(st) {
        j.cancelAllRequests(st);
      }, ht.promise;
    }
    return u.on("GetPage", (function(S) {
      return i.getPage(S.pageIndex).then((function(R) {
        return Promise.all([i.ensure(R, "rotate"), i.ensure(R, "ref"), i.ensure(R, "userUnit"), i.ensure(R, "view")]).then((function([x, N, U, T]) {
          return { rotate: x, ref: N, refStr: N?.toString() ?? null, userUnit: U, view: T };
        }));
      }));
    })), u.on("GetPageIndex", (function(S) {
      const R = St.get(S.num, S.gen);
      return i.ensureCatalog("getPageIndex", [R]);
    })), u.on("GetDestinations", (function(S) {
      return i.ensureCatalog("destinations");
    })), u.on("GetDestination", (function(S) {
      return i.ensureCatalog("getDestination", [S.id]);
    })), u.on("GetPageLabels", (function(S) {
      return i.ensureCatalog("pageLabels");
    })), u.on("GetPageLayout", (function(S) {
      return i.ensureCatalog("pageLayout");
    })), u.on("GetPageMode", (function(S) {
      return i.ensureCatalog("pageMode");
    })), u.on("GetViewerPreferences", (function(S) {
      return i.ensureCatalog("viewerPreferences");
    })), u.on("GetOpenAction", (function(S) {
      return i.ensureCatalog("openAction");
    })), u.on("GetAttachments", (function(S) {
      return i.ensureCatalog("attachments");
    })), u.on("GetDocJSActions", (function(S) {
      return i.ensureCatalog("jsActions");
    })), u.on("GetPageJSActions", (function({ pageIndex: S }) {
      return i.getPage(S).then((function(R) {
        return i.ensure(R, "jsActions");
      }));
    })), u.on("GetOutline", (function(S) {
      return i.ensureCatalog("documentOutline");
    })), u.on("GetOptionalContentConfig", (function(S) {
      return i.ensureCatalog("optionalContentConfig");
    })), u.on("GetPermissions", (function(S) {
      return i.ensureCatalog("permissions");
    })), u.on("GetMetadata", (function(S) {
      return Promise.all([i.ensureDoc("documentInfo"), i.ensureCatalog("metadata")]);
    })), u.on("GetMarkInfo", (function(S) {
      return i.ensureCatalog("markInfo");
    })), u.on("GetData", (function(S) {
      return i.requestLoadedStream().then((function(R) {
        return R.bytes;
      }));
    })), u.on("GetAnnotations", (function({ pageIndex: S, intent: R }) {
      return i.getPage(S).then((function(x) {
        const N = new Xs(`GetAnnotations: page ${S}`);
        return p(N), x.getAnnotationsData(u, N, R).then(((U) => (y(N), U)), ((U) => {
          throw y(N), U;
        }));
      }));
    })), u.on("GetFieldObjects", (function(S) {
      return i.ensureDoc("fieldObjects");
    })), u.on("HasJSActions", (function(S) {
      return i.ensureDoc("hasJSActions");
    })), u.on("GetCalculationOrderIds", (function(S) {
      return i.ensureDoc("calculationOrderIds");
    })), u.on("SaveDocument", (async function({ isPureXfa: S, numPages: R, annotationStorage: x, filename: N }) {
      const U = [i.requestLoadedStream(), i.ensureCatalog("acroForm"), i.ensureCatalog("acroFormRef"), i.ensureDoc("startXRef"), i.ensureDoc("xref"), i.ensureDoc("linearization"), i.ensureCatalog("structTreeRoot")], T = [], q = S ? null : iE(x), [_, Y, ht, ut, j, it, tt] = await Promise.all(U), Z = j.trailer.getRaw("Root") || null;
      let st;
      if (q) {
        tt ? await tt.canUpdateStructTree({ pdfManager: i, xref: j, newAnnotationsByPage: q }) && (st = tt) : await Xa.canCreateStructureTree({ catalogRef: Z, pdfManager: i, newAnnotationsByPage: q }) && (st = null);
        const V = ws.generateImages(x.values(), j, i.evaluatorOptions.isOffscreenCanvasSupported), rt = st === void 0 ? T : [];
        for (const [Bt, Rt] of q) rt.push(i.getPage(Bt).then(((Ft) => {
          const ft = new Xs(`Save (editor): page ${Bt}`);
          return Ft.saveNewAnnotations(u, ft, Rt, V).finally((function() {
            y(ft);
          }));
        })));
        st === null ? T.push(Promise.all(rt).then((async (Bt) => (await Xa.createStructureTree({ newAnnotationsByPage: q, xref: j, catalogRef: Z, pdfManager: i, newRefs: Bt }), Bt)))) : st && T.push(Promise.all(rt).then((async (Bt) => (await st.updateStructureTree({ newAnnotationsByPage: q, pdfManager: i, newRefs: Bt }), Bt))));
      }
      if (S) T.push(i.serializeXfaData(x));
      else for (let V = 0; V < R; V++) T.push(i.getPage(V).then((function(rt) {
        const Bt = new Xs(`Save: page ${V}`);
        return rt.save(u, Bt, x).finally((function() {
          y(Bt);
        }));
      })));
      const dt = await Promise.all(T);
      let ct = [], M = null;
      if (S) {
        if (M = dt[0], !M) return _.bytes;
      } else if (ct = dt.flat(2), ct.length === 0) return _.bytes;
      const H = ht && Y instanceof z && ct.some(((V) => V.needAppearances)), W = Y instanceof z && Y.get("XFA") || null;
      let lt = null, $ = !1;
      if (Array.isArray(W)) {
        for (let V = 0, rt = W.length; V < rt; V += 2) W[V] === "datasets" && (lt = W[V + 1], $ = !0);
        lt === null && (lt = j.getNewTemporaryRef());
      } else W && O("Unsupported XFA type.");
      let ot = /* @__PURE__ */ Object.create(null);
      if (j.trailer) {
        const V = /* @__PURE__ */ Object.create(null), rt = j.trailer.get("Info") || null;
        rt instanceof z && rt.forEach(((Bt, Rt) => {
          typeof Rt == "string" && (V[Bt] = cA(Rt));
        })), ot = { rootRef: Z, encryptRef: j.trailer.getRaw("Encrypt") || null, newRef: j.getNewTemporaryRef(), infoRef: j.trailer.getRaw("Info") || null, info: V, fileIds: j.trailer.get("ID") || null, startXRef: it ? ut : j.lastXRefStreamPos ?? ut, filename: N };
      }
      return sy({ originalData: _.bytes, xrefInfo: ot, newRefs: ct, xref: j, hasXfa: !!W, xfaDatasetsRef: lt, hasXfaDatasetsEntry: $, needAppearances: H, acroFormRef: ht, acroForm: Y, xfaData: M, useXrefStream: zQ(j.topDict, "XRef") }).finally((() => {
        j.resetNewTemporaryRef();
      }));
    })), u.on("GetOperatorList", (function(S, R) {
      const x = S.pageIndex;
      i.getPage(x).then((function(N) {
        const U = new Xs(`GetOperatorList: page ${x}`);
        p(U);
        const T = r >= Dh ? Date.now() : 0;
        N.getOperatorList({ handler: u, sink: R, task: U, intent: S.intent, cacheKey: S.cacheKey, annotationStorage: S.annotationStorage, modifiedIds: S.modifiedIds }).then((function(q) {
          y(U), T && tA(`page=${x + 1} - getOperatorList: time=${Date.now() - T}ms, len=${q.length}`), R.close();
        }), (function(q) {
          y(U), U.terminated || R.error(q);
        }));
      }));
    })), u.on("GetTextContent", (function(S, R) {
      const { pageIndex: x, includeMarkedContent: N, disableNormalization: U } = S;
      i.getPage(x).then((function(T) {
        const q = new Xs("GetTextContent: page " + x);
        p(q);
        const _ = r >= Dh ? Date.now() : 0;
        T.extractTextContent({ handler: u, task: q, sink: R, includeMarkedContent: N, disableNormalization: U }).then((function() {
          y(q), _ && tA(`page=${x + 1} - getTextContent: time=` + (Date.now() - _) + "ms"), R.close();
        }), (function(Y) {
          y(q), q.terminated || R.error(Y);
        }));
      }));
    })), u.on("GetStructTree", (function(S) {
      return i.getPage(S.pageIndex).then((function(R) {
        return i.ensure(R, "getStructTree");
      }));
    })), u.on("FontFallback", (function(S) {
      return i.fontFallback(S.id, u);
    })), u.on("Cleanup", (function(S) {
      return i.cleanup(!0);
    })), u.on("Terminate", (function(S) {
      s = !0;
      const R = [];
      if (i) {
        i.terminate(new fe("Worker was terminated."));
        const x = i.cleanup();
        R.push(x), i = null;
      } else Yl();
      n && n(new fe("Worker was terminated."));
      for (const x of o) R.push(x.finished), x.terminate();
      return Promise.all(R).then((function() {
        u.destroy(), u = null;
      }));
    })), u.on("Ready", (function(S) {
      (function(R) {
        function x(T) {
          E(), u.send("GetDoc", { pdfInfo: T });
        }
        function N(T) {
          if (E(), T instanceof To) {
            const q = new Xs(`PasswordException: response ${T.code}`);
            p(q), u.sendWithPromise("PasswordRequest", T).then((function({ password: _ }) {
              y(q), i.updatePassword(_), U();
            })).catch((function() {
              y(q), u.send("DocException", T);
            }));
          } else T instanceof qo || T instanceof qQ || T instanceof PQ || T instanceof Ko ? u.send("DocException", T) : u.send("DocException", new Ko(T.message, T.toString()));
        }
        function U() {
          E(), b(!1).then(x, (function(T) {
            E(), T instanceof qa ? i.requestLoadedStream().then((function() {
              E(), b(!0).then(x, N);
            })) : N(T);
          }));
        }
        E(), D(R).then((function(T) {
          if (s) throw T.terminate(new fe("Worker was terminated.")), new Error("Worker was terminated");
          i = T, i.requestLoadedStream(!0).then(((q) => {
            u.send("DataLoaded", { length: q.bytes.byteLength });
          }));
        })).then(U, N);
      })(t), t = null;
    })), d;
  }
  static initializeFromPort(t) {
    const e = new su("worker", "main", t);
    fr.setup(e, t), e.send("ready", null);
  }
}
var au;
async function BD() {
  var A = { d: (G, a) => {
    for (var g in a) A.o(a, g) && !A.o(G, g) && Object.defineProperty(G, g, { enumerable: !0, get: a[g] });
  }, o: (G, a) => Object.prototype.hasOwnProperty.call(G, a) }, t = globalThis.pdfjsLib = {};
  A.d(t, { AbortException: () => Us, AnnotationEditorLayer: () => Ji, AnnotationEditorParamsType: () => y, AnnotationEditorType: () => p, AnnotationEditorUIManager: () => ss, AnnotationLayer: () => rp, AnnotationMode: () => E, CMapCompressionType: () => Kt, ColorPicker: () => fi, DOMSVGFactory: () => Gg, DrawLayer: () => ge, FeatureTest: () => be, GlobalWorkerOptions: () => Bn, ImageKind: () => T, InvalidPDFException: () => gn, MissingPDFException: () => Mi, OPS: () => yt, PDFDataRangeTransport: () => KI, PDFDateString: () => BI, PDFWorker: () => $A, PasswordResponses: () => vt, PermissionFlag: () => b, PixelsPerInch: () => fa, RenderingCancelledException: () => vg, TextLayer: () => Le, UnexpectedResponseException: () => Ea, Util: () => Pt, VerbosityLevel: () => ft, XfaLayer: () => OI, build: () => K2, createValidAbsoluteUrl: () => GA, fetchData: () => vr, getDocument: () => M2, getFilenameFromUrl: () => Of, getPdfFilenameFromUrl: () => Wf, getXfaPageViewport: () => jf, isDataScheme: () => Mr, isPdfFile: () => Mg, noContextMenu: () => je, normalizeUnicode: () => Mf, setLayerDimensions: () => Hs, shadow: () => aA, version: () => T2 });
  const e = typeof document > "u", i = [1, 0, 0, 1, 0, 0], s = [1e-3, 0, 0, 1e-3, 0, 0], n = 1.35, o = 1, r = 2, c = 4, h = 16, I = 32, C = 64, d = 128, u = 256, E = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 }, p = { DISABLE: -1, NONE: 0, FREETEXT: 3, HIGHLIGHT: 9, STAMP: 13, INK: 15 }, y = { RESIZE: 1, CREATE: 2, FREETEXT_SIZE: 11, FREETEXT_COLOR: 12, FREETEXT_OPACITY: 13, INK_COLOR: 21, INK_THICKNESS: 22, INK_OPACITY: 23, HIGHLIGHT_COLOR: 31, HIGHLIGHT_DEFAULT_COLOR: 32, HIGHLIGHT_THICKNESS: 33, HIGHLIGHT_FREE: 34, HIGHLIGHT_SHOW_ALL: 35 }, b = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 }, D = 0, S = 1, R = 2, x = 3, N = 3, U = 4, T = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }, q = 1, _ = 2, Y = 3, ht = 4, ut = 5, j = 6, it = 7, tt = 8, Z = 9, st = 10, dt = 11, ct = 12, M = 13, H = 14, W = 15, lt = 16, $ = 17, ot = 20, V = 1, rt = 2, Bt = 3, Rt = 4, Ft = 5, ft = { ERRORS: 0, WARNINGS: 1, INFOS: 5 }, Kt = { NONE: 0, BINARY: 1 }, yt = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotation: 80, endAnnotation: 81, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91, setStrokeTransparent: 92, setFillTransparent: 93 }, vt = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 };
  let Ht = ft.WARNINGS;
  function Jt(G) {
    Number.isInteger(G) && (Ht = G);
  }
  function Gt() {
    return Ht;
  }
  function Zt(G) {
    Ht >= ft.INFOS && console.log(`Info: ${G}`);
  }
  function qt(G) {
    Ht >= ft.WARNINGS && console.log(`Warning: ${G}`);
  }
  function Xt(G) {
    throw new Error(G);
  }
  function wA(G, a) {
    G || Xt(a);
  }
  function GA(G, a = null, g = null) {
    if (!G) return null;
    try {
      if (g && typeof G == "string" && (g.addDefaultProtocol && G.startsWith("www.") && G.match(/\./g)?.length >= 2 && (G = `http://${G}`), g.tryConvertEncoding))
        try {
          G = decodeURIComponent(escape(G));
        } catch {
        }
      const l = a ? new URL(G, a) : new URL(G);
      if ((function(B) {
        switch (B?.protocol) {
          case "http:":
          case "https:":
          case "ftp:":
          case "mailto:":
          case "tel:":
            return !0;
          default:
            return !1;
        }
      })(l)) return l;
    } catch {
    }
    return null;
  }
  function aA(G, a, g, l = !1) {
    return Object.defineProperty(G, a, { value: g, enumerable: !l, configurable: !0, writable: !1 }), g;
  }
  const we = (function() {
    function G(a, g) {
      this.message = a, this.name = g;
    }
    return G.prototype = new Error(), G.constructor = G, G;
  })();
  class da extends we {
    constructor(a, g) {
      super(a, "PasswordException"), this.code = g;
    }
  }
  class Qa extends we {
    constructor(a, g) {
      super(a, "UnknownErrorException"), this.details = g;
    }
  }
  class gn extends we {
    constructor(a) {
      super(a, "InvalidPDFException");
    }
  }
  class Mi extends we {
    constructor(a) {
      super(a, "MissingPDFException");
    }
  }
  class Ea extends we {
    constructor(a, g) {
      super(a, "UnexpectedResponseException"), this.status = g;
    }
  }
  class vf extends we {
    constructor(a) {
      super(a, "FormatError");
    }
  }
  class Us extends we {
    constructor(a) {
      super(a, "AbortException");
    }
  }
  function aI(G) {
    typeof G == "object" && G?.length !== void 0 || Xt("Invalid argument for bytesToString");
    const a = G.length, g = 8192;
    if (a < g) return String.fromCharCode.apply(null, G);
    const l = [];
    for (let B = 0; B < a; B += g) {
      const Q = Math.min(B + g, a), f = G.subarray(B, Q);
      l.push(String.fromCharCode.apply(null, f));
    }
    return l.join("");
  }
  function Gr(G) {
    typeof G != "string" && Xt("Invalid argument for stringToBytes");
    const a = G.length, g = new Uint8Array(a);
    for (let l = 0; l < a; ++l) g[l] = 255 & G.charCodeAt(l);
    return g;
  }
  function Rg(G) {
    const a = /* @__PURE__ */ Object.create(null);
    for (const [g, l] of G) a[g] = l;
    return a;
  }
  class be {
    static get isLittleEndian() {
      return aA(this, "isLittleEndian", (function() {
        const a = new Uint8Array(4);
        return a[0] = 1, new Uint32Array(a.buffer, 0, 1)[0] === 1;
      })());
    }
    static get isEvalSupported() {
      return aA(this, "isEvalSupported", (function() {
        try {
          return new Function(""), !0;
        } catch {
          return !1;
        }
      })());
    }
    static get isOffscreenCanvasSupported() {
      return aA(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
    }
    static get platform() {
      return typeof navigator < "u" && typeof navigator?.platform == "string" ? aA(this, "platform", { isMac: navigator.platform.includes("Mac") }) : aA(this, "platform", { isMac: !1 });
    }
    static get isCSSRoundSupported() {
      return aA(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
    }
  }
  const xg = Array.from(Array(256).keys(), ((G) => G.toString(16).padStart(2, "0")));
  class Pt {
    static makeHexColor(a, g, l) {
      return `#${xg[a]}${xg[g]}${xg[l]}`;
    }
    static scaleMinMax(a, g) {
      let l;
      a[0] ? (a[0] < 0 && (l = g[0], g[0] = g[2], g[2] = l), g[0] *= a[0], g[2] *= a[0], a[3] < 0 && (l = g[1], g[1] = g[3], g[3] = l), g[1] *= a[3], g[3] *= a[3]) : (l = g[0], g[0] = g[1], g[1] = l, l = g[2], g[2] = g[3], g[3] = l, a[1] < 0 && (l = g[1], g[1] = g[3], g[3] = l), g[1] *= a[1], g[3] *= a[1], a[2] < 0 && (l = g[0], g[0] = g[2], g[2] = l), g[0] *= a[2], g[2] *= a[2]), g[0] += a[4], g[1] += a[5], g[2] += a[4], g[3] += a[5];
    }
    static transform(a, g) {
      return [a[0] * g[0] + a[2] * g[1], a[1] * g[0] + a[3] * g[1], a[0] * g[2] + a[2] * g[3], a[1] * g[2] + a[3] * g[3], a[0] * g[4] + a[2] * g[5] + a[4], a[1] * g[4] + a[3] * g[5] + a[5]];
    }
    static applyTransform(a, g) {
      return [a[0] * g[0] + a[1] * g[2] + g[4], a[0] * g[1] + a[1] * g[3] + g[5]];
    }
    static applyInverseTransform(a, g) {
      const l = g[0] * g[3] - g[1] * g[2];
      return [(a[0] * g[3] - a[1] * g[2] + g[2] * g[5] - g[4] * g[3]) / l, (-a[0] * g[1] + a[1] * g[0] + g[4] * g[1] - g[5] * g[0]) / l];
    }
    static getAxialAlignedBoundingBox(a, g) {
      const l = this.applyTransform(a, g), B = this.applyTransform(a.slice(2, 4), g), Q = this.applyTransform([a[0], a[3]], g), f = this.applyTransform([a[2], a[1]], g);
      return [Math.min(l[0], B[0], Q[0], f[0]), Math.min(l[1], B[1], Q[1], f[1]), Math.max(l[0], B[0], Q[0], f[0]), Math.max(l[1], B[1], Q[1], f[1])];
    }
    static inverseTransform(a) {
      const g = a[0] * a[3] - a[1] * a[2];
      return [a[3] / g, -a[1] / g, -a[2] / g, a[0] / g, (a[2] * a[5] - a[4] * a[3]) / g, (a[4] * a[1] - a[5] * a[0]) / g];
    }
    static singularValueDecompose2dScale(a) {
      const g = [a[0], a[2], a[1], a[3]], l = a[0] * g[0] + a[1] * g[2], B = a[0] * g[1] + a[1] * g[3], Q = a[2] * g[0] + a[3] * g[2], f = a[2] * g[1] + a[3] * g[3], m = (l + f) / 2, w = Math.sqrt((l + f) ** 2 - 4 * (l * f - Q * B)) / 2, k = m + w || 1, F = m - w || 1;
      return [Math.sqrt(k), Math.sqrt(F)];
    }
    static normalizeRect(a) {
      const g = a.slice(0);
      return a[0] > a[2] && (g[0] = a[2], g[2] = a[0]), a[1] > a[3] && (g[1] = a[3], g[3] = a[1]), g;
    }
    static intersect(a, g) {
      const l = Math.max(Math.min(a[0], a[2]), Math.min(g[0], g[2])), B = Math.min(Math.max(a[0], a[2]), Math.max(g[0], g[2]));
      if (l > B) return null;
      const Q = Math.max(Math.min(a[1], a[3]), Math.min(g[1], g[3])), f = Math.min(Math.max(a[1], a[3]), Math.max(g[1], g[3]));
      return Q > f ? null : [l, Q, B, f];
    }
    static #t(a, g, l, B, Q, f, m, w, k, F) {
      if (k <= 0 || k >= 1) return;
      const v = 1 - k, L = k * k, J = L * k, K = v * (v * (v * a + 3 * k * g) + 3 * L * l) + J * B, X = v * (v * (v * Q + 3 * k * f) + 3 * L * m) + J * w;
      F[0] = Math.min(F[0], K), F[1] = Math.min(F[1], X), F[2] = Math.max(F[2], K), F[3] = Math.max(F[3], X);
    }
    static #A(a, g, l, B, Q, f, m, w, k, F, v, L) {
      if (Math.abs(k) < 1e-12) return void (Math.abs(F) >= 1e-12 && this.#t(a, g, l, B, Q, f, m, w, -v / F, L));
      const J = F ** 2 - 4 * v * k;
      if (J < 0) return;
      const K = Math.sqrt(J), X = 2 * k;
      this.#t(a, g, l, B, Q, f, m, w, (-F + K) / X, L), this.#t(a, g, l, B, Q, f, m, w, (-F - K) / X, L);
    }
    static bezierBoundingBox(a, g, l, B, Q, f, m, w, k) {
      return k ? (k[0] = Math.min(k[0], a, m), k[1] = Math.min(k[1], g, w), k[2] = Math.max(k[2], a, m), k[3] = Math.max(k[3], g, w)) : k = [Math.min(a, m), Math.min(g, w), Math.max(a, m), Math.max(g, w)], this.#A(a, l, Q, m, g, B, f, w, 3 * (3 * (l - Q) - a + m), 6 * (a - 2 * l + Q), 3 * (l - a), k), this.#A(a, l, Q, m, g, B, f, w, 3 * (3 * (B - f) - g + w), 6 * (g - 2 * B + f), 3 * (B - g), k), k;
    }
  }
  let Ng = null, nI = null;
  function Mf(G) {
    return Ng || (Ng = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, nI = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), G.replaceAll(Ng, ((a, g, l) => g ? g.normalize("NFKC") : nI.get(l)));
  }
  const rI = "pdfjs_internal_id_", Lf = 0, Uf = 1, Hf = 2, Jf = 3, Yf = 4, Tf = 5, Kf = 6, qf = 7, Pf = 8;
  class oI {
    addFilter(a) {
      return "none";
    }
    addHCMFilter(a, g) {
      return "none";
    }
    addAlphaFilter(a) {
      return "none";
    }
    addLuminosityFilter(a) {
      return "none";
    }
    addHighlightHCMFilter(a, g, l, B, Q) {
      return "none";
    }
    destroy(a = !1) {
    }
  }
  class gI {
    #t = !1;
    constructor({ enableHWA: a = !1 } = {}) {
      this.#t = a;
    }
    create(a, g) {
      if (a <= 0 || g <= 0) throw new Error("Invalid canvas size");
      const l = this._createCanvas(a, g);
      return { canvas: l, context: l.getContext("2d", { willReadFrequently: !this.#t }) };
    }
    reset(a, g, l) {
      if (!a.canvas) throw new Error("Canvas is not specified");
      if (g <= 0 || l <= 0) throw new Error("Invalid canvas size");
      a.canvas.width = g, a.canvas.height = l;
    }
    destroy(a) {
      if (!a.canvas) throw new Error("Canvas is not specified");
      a.canvas.width = 0, a.canvas.height = 0, a.canvas = null, a.context = null;
    }
    _createCanvas(a, g) {
      Xt("Abstract method `_createCanvas` called.");
    }
  }
  class cI {
    constructor({ baseUrl: a = null, isCompressed: g = !0 }) {
      this.baseUrl = a, this.isCompressed = g;
    }
    async fetch({ name: a }) {
      if (!this.baseUrl) throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
      if (!a) throw new Error("CMap name must be specified.");
      const g = this.baseUrl + a + (this.isCompressed ? ".bcmap" : ""), l = this.isCompressed ? Kt.BINARY : Kt.NONE;
      return this._fetchData(g, l).catch(((B) => {
        throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${g}`);
      }));
    }
    _fetchData(a, g) {
      Xt("Abstract method `_fetchData` called.");
    }
  }
  class hI {
    constructor({ baseUrl: a = null }) {
      this.baseUrl = a;
    }
    async fetch({ filename: a }) {
      if (!this.baseUrl) throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
      if (!a) throw new Error("Font filename must be specified.");
      const g = `${this.baseUrl}${a}`;
      return this._fetchData(g).catch(((l) => {
        throw new Error(`Unable to load font data at: ${g}`);
      }));
    }
    _fetchData(a) {
      Xt("Abstract method `_fetchData` called.");
    }
  }
  class _f {
    create(a, g, l = !1) {
      if (a <= 0 || g <= 0) throw new Error("Invalid SVG dimensions");
      const B = this._createSVG("svg:svg");
      return B.setAttribute("version", "1.1"), l || (B.setAttribute("width", `${a}px`), B.setAttribute("height", `${g}px`)), B.setAttribute("preserveAspectRatio", "none"), B.setAttribute("viewBox", `0 0 ${a} ${g}`), B;
    }
    createElement(a) {
      if (typeof a != "string") throw new Error("Invalid SVG element type");
      return this._createSVG(a);
    }
    _createSVG(a) {
      Xt("Abstract method `_createSVG` called.");
    }
  }
  const Li = "http://www.w3.org/2000/svg";
  class fa {
    static CSS = 96;
    static PDF = 72;
    static PDF_TO_CSS_UNITS = this.CSS / this.PDF;
  }
  async function vr(G, a = "text") {
    if (hn(G, document.baseURI)) {
      const g = await fetch(G);
      if (!g.ok) throw new Error(g.statusText);
      switch (a) {
        case "arraybuffer":
          return g.arrayBuffer();
        case "blob":
          return g.blob();
        case "json":
          return g.json();
      }
      return g.text();
    }
    return new Promise(((g, l) => {
      const B = new XMLHttpRequest();
      B.open("GET", G, !0), B.responseType = a, B.onreadystatechange = () => {
        if (B.readyState === XMLHttpRequest.DONE) if (B.status !== 200 && B.status !== 0) l(new Error(B.statusText));
        else {
          switch (a) {
            case "arraybuffer":
            case "blob":
            case "json":
              return void g(B.response);
          }
          g(B.responseText);
        }
      }, B.send(null);
    }));
  }
  class lI extends cI {
    _fetchData(a, g) {
      return vr(a, this.isCompressed ? "arraybuffer" : "text").then(((l) => ({ cMapData: l instanceof ArrayBuffer ? new Uint8Array(l) : Gr(l), compressionType: g })));
    }
  }
  class II extends hI {
    _fetchData(a) {
      return vr(a, "arraybuffer").then(((g) => new Uint8Array(g)));
    }
  }
  class Gg extends _f {
    _createSVG(a) {
      return document.createElementNS(Li, a);
    }
  }
  class cn {
    constructor({ viewBox: a, scale: g, rotation: l, offsetX: B = 0, offsetY: Q = 0, dontFlip: f = !1 }) {
      this.viewBox = a, this.scale = g, this.rotation = l, this.offsetX = B, this.offsetY = Q;
      const m = (a[2] + a[0]) / 2, w = (a[3] + a[1]) / 2;
      let k, F, v, L, J, K, X, et;
      switch ((l %= 360) < 0 && (l += 360), l) {
        case 180:
          k = -1, F = 0, v = 0, L = 1;
          break;
        case 90:
          k = 0, F = 1, v = 1, L = 0;
          break;
        case 270:
          k = 0, F = -1, v = -1, L = 0;
          break;
        case 0:
          k = 1, F = 0, v = 0, L = -1;
          break;
        default:
          throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
      }
      f && (v = -v, L = -L), k === 0 ? (J = Math.abs(w - a[1]) * g + B, K = Math.abs(m - a[0]) * g + Q, X = (a[3] - a[1]) * g, et = (a[2] - a[0]) * g) : (J = Math.abs(m - a[0]) * g + B, K = Math.abs(w - a[1]) * g + Q, X = (a[2] - a[0]) * g, et = (a[3] - a[1]) * g), this.transform = [k * g, F * g, v * g, L * g, J - k * g * m - v * g * w, K - F * g * m - L * g * w], this.width = X, this.height = et;
    }
    get rawDims() {
      const { viewBox: a } = this;
      return aA(this, "rawDims", { pageWidth: a[2] - a[0], pageHeight: a[3] - a[1], pageX: a[0], pageY: a[1] });
    }
    clone({ scale: a = this.scale, rotation: g = this.rotation, offsetX: l = this.offsetX, offsetY: B = this.offsetY, dontFlip: Q = !1 } = {}) {
      return new cn({ viewBox: this.viewBox.slice(), scale: a, rotation: g, offsetX: l, offsetY: B, dontFlip: Q });
    }
    convertToViewportPoint(a, g) {
      return Pt.applyTransform([a, g], this.transform);
    }
    convertToViewportRectangle(a) {
      const g = Pt.applyTransform([a[0], a[1]], this.transform), l = Pt.applyTransform([a[2], a[3]], this.transform);
      return [g[0], g[1], l[0], l[1]];
    }
    convertToPdfPoint(a, g) {
      return Pt.applyInverseTransform([a, g], this.transform);
    }
  }
  class vg extends we {
    constructor(a, g = 0) {
      super(a, "RenderingCancelledException"), this.extraDelay = g;
    }
  }
  function Mr(G) {
    const a = G.length;
    let g = 0;
    for (; g < a && G[g].trim() === ""; ) g++;
    return G.substring(g, g + 5).toLowerCase() === "data:";
  }
  function Mg(G) {
    return typeof G == "string" && /\.pdf$/i.test(G);
  }
  function Of(G) {
    return [G] = G.split(/[#?]/, 1), G.substring(G.lastIndexOf("/") + 1);
  }
  function Wf(G, a = "document.pdf") {
    if (typeof G != "string") return a;
    if (Mr(G)) return qt('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), a;
    const g = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, l = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/.exec(G);
    let B = g.exec(l[1]) || g.exec(l[2]) || g.exec(l[3]);
    if (B && (B = B[0], B.includes("%"))) try {
      B = g.exec(decodeURIComponent(B))[0];
    } catch {
    }
    return B || a;
  }
  class CI {
    started = /* @__PURE__ */ Object.create(null);
    times = [];
    time(a) {
      a in this.started && qt(`Timer is already running for ${a}`), this.started[a] = Date.now();
    }
    timeEnd(a) {
      a in this.started || qt(`Timer has not been started for ${a}`), this.times.push({ name: a, start: this.started[a], end: Date.now() }), delete this.started[a];
    }
    toString() {
      const a = [];
      let g = 0;
      for (const { name: l } of this.times) g = Math.max(l.length, g);
      for (const { name: l, start: B, end: Q } of this.times) a.push(`${l.padEnd(g)} ${Q - B}ms
`);
      return a.join("");
    }
  }
  function hn(G, a) {
    try {
      const { protocol: g } = a ? new URL(G, a) : new URL(G);
      return g === "http:" || g === "https:";
    } catch {
      return !1;
    }
  }
  function je(G) {
    G.preventDefault();
  }
  let uI;
  class BI {
    static toDateObject(a) {
      if (!a || typeof a != "string") return null;
      uI ||= new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
      const g = uI.exec(a);
      if (!g) return null;
      const l = parseInt(g[1], 10);
      let B = parseInt(g[2], 10);
      B = B >= 1 && B <= 12 ? B - 1 : 0;
      let Q = parseInt(g[3], 10);
      Q = Q >= 1 && Q <= 31 ? Q : 1;
      let f = parseInt(g[4], 10);
      f = f >= 0 && f <= 23 ? f : 0;
      let m = parseInt(g[5], 10);
      m = m >= 0 && m <= 59 ? m : 0;
      let w = parseInt(g[6], 10);
      w = w >= 0 && w <= 59 ? w : 0;
      const k = g[7] || "Z";
      let F = parseInt(g[8], 10);
      F = F >= 0 && F <= 23 ? F : 0;
      let v = parseInt(g[9], 10) || 0;
      return v = v >= 0 && v <= 59 ? v : 0, k === "-" ? (f += F, m += v) : k === "+" && (f -= F, m -= v), new Date(Date.UTC(l, B, Q, f, m, w));
    }
  }
  function jf(G, { scale: a = 1, rotation: g = 0 }) {
    const { width: l, height: B } = G.attributes.style, Q = [0, 0, parseInt(l), parseInt(B)];
    return new cn({ viewBox: Q, scale: a, rotation: g });
  }
  function Lg(G) {
    if (G.startsWith("#")) {
      const a = parseInt(G.slice(1), 16);
      return [(16711680 & a) >> 16, (65280 & a) >> 8, 255 & a];
    }
    return G.startsWith("rgb(") ? G.slice(4, -1).split(",").map(((a) => parseInt(a))) : G.startsWith("rgba(") ? G.slice(5, -1).split(",").map(((a) => parseInt(a))).slice(0, 3) : (qt(`Not a valid color format: "${G}"`), [0, 0, 0]);
  }
  function vA(G) {
    const { a, b: g, c: l, d: B, e: Q, f } = G.getTransform();
    return [a, g, l, B, Q, f];
  }
  function Ui(G) {
    const { a, b: g, c: l, d: B, e: Q, f } = G.getTransform().invertSelf();
    return [a, g, l, B, Q, f];
  }
  function Hs(G, a, g = !1, l = !0) {
    if (a instanceof cn) {
      const { pageWidth: B, pageHeight: Q } = a.rawDims, { style: f } = G, m = be.isCSSRoundSupported, w = `var(--scale-factor) * ${B}px`, k = `var(--scale-factor) * ${Q}px`, F = m ? `round(${w}, 1px)` : `calc(${w})`, v = m ? `round(${k}, 1px)` : `calc(${k})`;
      g && a.rotation % 180 != 0 ? (f.width = v, f.height = F) : (f.width = F, f.height = v);
    }
    l && G.setAttribute("data-main-rotation", a.rotation);
  }
  class ln {
    #t = null;
    #A = null;
    #e;
    #s = null;
    #a = null;
    static #i = null;
    constructor(a) {
      this.#e = a, ln.#i ||= Object.freeze({ freetext: "pdfjs-editor-remove-freetext-button", highlight: "pdfjs-editor-remove-highlight-button", ink: "pdfjs-editor-remove-ink-button", stamp: "pdfjs-editor-remove-stamp-button" });
    }
    render() {
      const a = this.#t = document.createElement("div");
      a.className = "editToolbar", a.setAttribute("role", "toolbar");
      const g = this.#e._uiManager._signal;
      a.addEventListener("contextmenu", je, { signal: g }), a.addEventListener("pointerdown", ln.#r, { signal: g });
      const l = this.#s = document.createElement("div");
      l.className = "buttons", a.append(l);
      const B = this.#e.toolbarPosition;
      if (B) {
        const { style: Q } = a, f = this.#e._uiManager.direction === "ltr" ? 1 - B[0] : B[0];
        Q.insetInlineEnd = 100 * f + "%", Q.top = `calc(${100 * B[1]}% + var(--editor-toolbar-vert-offset))`;
      }
      return this.#c(), a;
    }
    static #r(a) {
      a.stopPropagation();
    }
    #o(a) {
      this.#e._focusEventsAllowed = !1, a.preventDefault(), a.stopPropagation();
    }
    #h(a) {
      this.#e._focusEventsAllowed = !0, a.preventDefault(), a.stopPropagation();
    }
    #g(a) {
      const g = this.#e._uiManager._signal;
      a.addEventListener("focusin", this.#o.bind(this), { capture: !0, signal: g }), a.addEventListener("focusout", this.#h.bind(this), { capture: !0, signal: g }), a.addEventListener("contextmenu", je, { signal: g });
    }
    hide() {
      this.#t.classList.add("hidden"), this.#A?.hideDropdown();
    }
    show() {
      this.#t.classList.remove("hidden"), this.#a?.shown();
    }
    #c() {
      const { editorType: a, _uiManager: g } = this.#e, l = document.createElement("button");
      l.className = "delete", l.tabIndex = 0, l.setAttribute("data-l10n-id", ln.#i[a]), this.#g(l), l.addEventListener("click", ((B) => {
        g.delete();
      }), { signal: g._signal }), this.#s.append(l);
    }
    get #n() {
      const a = document.createElement("div");
      return a.className = "divider", a;
    }
    async addAltText(a) {
      const g = await a.render();
      this.#g(g), this.#s.prepend(g, this.#n), this.#a = a;
    }
    addColorPicker(a) {
      this.#A = a;
      const g = a.renderButton();
      this.#g(g), this.#s.prepend(g, this.#n);
    }
    remove() {
      this.#t.remove(), this.#A?.destroy(), this.#A = null;
    }
  }
  class Zf {
    #t = null;
    #A = null;
    #e;
    constructor(a) {
      this.#e = a;
    }
    #s() {
      const a = this.#A = document.createElement("div");
      a.className = "editToolbar", a.setAttribute("role", "toolbar"), a.addEventListener("contextmenu", je, { signal: this.#e._signal });
      const g = this.#t = document.createElement("div");
      return g.className = "buttons", a.append(g), this.#i(), a;
    }
    #a(a, g) {
      let l = 0, B = 0;
      for (const Q of a) {
        const f = Q.y + Q.height;
        if (f < l) continue;
        const m = Q.x + (g ? Q.width : 0);
        f > l ? (B = m, l = f) : g ? m > B && (B = m) : m < B && (B = m);
      }
      return [g ? 1 - B : B, l];
    }
    show(a, g, l) {
      const [B, Q] = this.#a(g, l), { style: f } = this.#A ||= this.#s();
      a.append(this.#A), f.insetInlineEnd = 100 * B + "%", f.top = `calc(${100 * Q}% + var(--editor-toolbar-vert-offset))`;
    }
    hide() {
      this.#A.remove();
    }
    #i() {
      const a = document.createElement("button");
      a.className = "highlightButton", a.tabIndex = 0, a.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button1");
      const g = document.createElement("span");
      a.append(g), g.className = "visuallyHidden", g.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label");
      const l = this.#e._signal;
      a.addEventListener("contextmenu", je, { signal: l }), a.addEventListener("click", (() => {
        this.#e.highlightSelection("floating_button");
      }), { signal: l }), this.#t.append(a);
    }
  }
  function Lr(G, a, g) {
    for (const l of g) a.addEventListener(l, G[l].bind(G));
  }
  class Vf {
    #t = 0;
    get id() {
      return "pdfjs_internal_editor_" + this.#t++;
    }
  }
  class Ug {
    #t = (function() {
      if (typeof crypto < "u" && typeof crypto?.randomUUID == "function") return crypto.randomUUID();
      const a = new Uint8Array(32);
      if (typeof crypto < "u" && typeof crypto?.getRandomValues == "function") crypto.getRandomValues(a);
      else for (let g = 0; g < 32; g++) a[g] = Math.floor(255 * Math.random());
      return aI(a);
    })();
    #A = 0;
    #e = null;
    static get _isSVGFittingCanvas() {
      const a = new OffscreenCanvas(1, 3).getContext("2d", { willReadFrequently: !0 }), g = new Image();
      return g.src = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', aA(this, "_isSVGFittingCanvas", g.decode().then((() => (a.drawImage(g, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(a.getImageData(0, 0, 1, 1).data.buffer)[0] === 0))));
    }
    async #s(a, g) {
      this.#e ||= /* @__PURE__ */ new Map();
      let l = this.#e.get(a);
      if (l === null) return null;
      if (l?.bitmap) return l.refCounter += 1, l;
      try {
        let B;
        if (l ||= { bitmap: null, id: `image_${this.#t}_${this.#A++}`, refCounter: 0, isSvg: !1 }, typeof g == "string" ? (l.url = g, B = await vr(g, "blob")) : B = l.file = g, B.type === "image/svg+xml") {
          const Q = Ug._isSVGFittingCanvas, f = new FileReader(), m = new Image(), w = new Promise(((k, F) => {
            m.onload = () => {
              l.bitmap = m, l.isSvg = !0, k();
            }, f.onload = async () => {
              const v = l.svgUrl = f.result;
              m.src = await Q ? `${v}#svgView(preserveAspectRatio(none))` : v;
            }, m.onerror = f.onerror = F;
          }));
          f.readAsDataURL(B), await w;
        } else l.bitmap = await createImageBitmap(B);
        l.refCounter = 1;
      } catch (B) {
        console.error(B), l = null;
      }
      return this.#e.set(a, l), l && this.#e.set(l.id, l), l;
    }
    async getFromFile(a) {
      const { lastModified: g, name: l, size: B, type: Q } = a;
      return this.#s(`${g}_${l}_${B}_${Q}`, a);
    }
    async getFromUrl(a) {
      return this.#s(a, a);
    }
    async getFromId(a) {
      this.#e ||= /* @__PURE__ */ new Map();
      const g = this.#e.get(a);
      return g ? g.bitmap ? (g.refCounter += 1, g) : g.file ? this.getFromFile(g.file) : this.getFromUrl(g.url) : null;
    }
    getSvgUrl(a) {
      const g = this.#e.get(a);
      return g?.isSvg ? g.svgUrl : null;
    }
    deleteId(a) {
      this.#e ||= /* @__PURE__ */ new Map();
      const g = this.#e.get(a);
      g && (g.refCounter -= 1, g.refCounter === 0 && (g.bitmap = null));
    }
    isValidId(a) {
      return a.startsWith(`image_${this.#t}_`);
    }
  }
  class Xf {
    #t = [];
    #A = !1;
    #e;
    #s = -1;
    constructor(a = 128) {
      this.#e = a;
    }
    add({ cmd: a, undo: g, post: l, mustExec: B, type: Q = NaN, overwriteIfSameType: f = !1, keepUndo: m = !1 }) {
      if (B && a(), this.#A) return;
      const w = { cmd: a, undo: g, post: l, type: Q };
      if (this.#s === -1) return this.#t.length > 0 && (this.#t.length = 0), this.#s = 0, void this.#t.push(w);
      if (f && this.#t[this.#s].type === Q) return m && (w.undo = this.#t[this.#s].undo), void (this.#t[this.#s] = w);
      const k = this.#s + 1;
      k === this.#e ? this.#t.splice(0, 1) : (this.#s = k, k < this.#t.length && this.#t.splice(k)), this.#t.push(w);
    }
    undo() {
      if (this.#s === -1) return;
      this.#A = !0;
      const { undo: a, post: g } = this.#t[this.#s];
      a(), g?.(), this.#A = !1, this.#s -= 1;
    }
    redo() {
      if (this.#s < this.#t.length - 1) {
        this.#s += 1, this.#A = !0;
        const { cmd: a, post: g } = this.#t[this.#s];
        a(), g?.(), this.#A = !1;
      }
    }
    hasSomethingToUndo() {
      return this.#s !== -1;
    }
    hasSomethingToRedo() {
      return this.#s < this.#t.length - 1;
    }
    destroy() {
      this.#t = null;
    }
  }
  class In {
    constructor(a) {
      this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
      const { isMac: g } = be.platform;
      for (const [l, B, Q = {}] of a) for (const f of l) {
        const m = f.startsWith("mac+");
        g && m ? (this.callbacks.set(f.slice(4), { callback: B, options: Q }), this.allKeys.add(f.split("+").at(-1))) : g || m || (this.callbacks.set(f, { callback: B, options: Q }), this.allKeys.add(f.split("+").at(-1)));
      }
    }
    #t(a) {
      a.altKey && this.buffer.push("alt"), a.ctrlKey && this.buffer.push("ctrl"), a.metaKey && this.buffer.push("meta"), a.shiftKey && this.buffer.push("shift"), this.buffer.push(a.key);
      const g = this.buffer.join("+");
      return this.buffer.length = 0, g;
    }
    exec(a, g) {
      if (!this.allKeys.has(g.key)) return;
      const l = this.callbacks.get(this.#t(g));
      if (!l) return;
      const { callback: B, options: { bubbles: Q = !1, args: f = [], checker: m = null } } = l;
      m && !m(a, g) || (B.bind(a, ...f, g)(), Q || (g.stopPropagation(), g.preventDefault()));
    }
  }
  class Hg {
    static _colorsMapping = /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]);
    get _colors() {
      const a = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
      return (function(g) {
        const l = document.createElement("span");
        l.style.visibility = "hidden", document.body.append(l);
        for (const B of g.keys()) {
          l.style.color = B;
          const Q = window.getComputedStyle(l).color;
          g.set(B, Lg(Q));
        }
        l.remove();
      })(a), aA(this, "_colors", a);
    }
    convert(a) {
      const g = Lg(a);
      if (!window.matchMedia("(forced-colors: active)").matches) return g;
      for (const [l, B] of this._colors) if (B.every(((Q, f) => Q === g[f]))) return Hg._colorsMapping.get(l);
      return g;
    }
    getHexCode(a) {
      const g = this._colors.get(a);
      return g ? Pt.makeHexColor(...g) : a;
    }
  }
  class ss {
    #t = new AbortController();
    #A = null;
    #e = /* @__PURE__ */ new Map();
    #s = /* @__PURE__ */ new Map();
    #a = null;
    #i = null;
    #r = null;
    #o = new Xf();
    #h = null;
    #g = 0;
    #c = /* @__PURE__ */ new Set();
    #n = null;
    #l = null;
    #C = /* @__PURE__ */ new Set();
    #I = !1;
    #B = !1;
    #d = !1;
    #u = null;
    #E = null;
    #p = null;
    #y = null;
    #k = !1;
    #S = null;
    #x = new Vf();
    #w = !1;
    #f = !1;
    #b = null;
    #D = null;
    #N = null;
    #G = null;
    #m = p.NONE;
    #Q = /* @__PURE__ */ new Set();
    #R = null;
    #v = null;
    #M = null;
    #K = { isEditing: !1, isEmpty: !0, hasSomethingToUndo: !1, hasSomethingToRedo: !1, hasSelectedEditor: !1, hasSelectedText: !1 };
    #J = [0, 0];
    #L = null;
    #U = null;
    #T = null;
    static TRANSLATE_SMALL = 1;
    static TRANSLATE_BIG = 10;
    static get _keyboardManager() {
      const a = ss.prototype, g = (f) => f.#U.contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && f.hasSomethingToControl(), l = (f, { target: m }) => {
        if (m instanceof HTMLInputElement) {
          const { type: w } = m;
          return w !== "text" && w !== "number";
        }
        return !0;
      }, B = this.TRANSLATE_SMALL, Q = this.TRANSLATE_BIG;
      return aA(this, "_keyboardManager", new In([[["ctrl+a", "mac+meta+a"], a.selectAll, { checker: l }], [["ctrl+z", "mac+meta+z"], a.undo, { checker: l }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], a.redo, { checker: l }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], a.delete, { checker: l }], [["Enter", "mac+Enter"], a.addNewEditorFromKeyboard, { checker: (f, { target: m }) => !(m instanceof HTMLButtonElement) && f.#U.contains(m) && !f.isEnterHandled }], [[" ", "mac+ "], a.addNewEditorFromKeyboard, { checker: (f, { target: m }) => !(m instanceof HTMLButtonElement) && f.#U.contains(document.activeElement) }], [["Escape", "mac+Escape"], a.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], a.translateSelectedEditors, { args: [-B, 0], checker: g }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], a.translateSelectedEditors, { args: [-Q, 0], checker: g }], [["ArrowRight", "mac+ArrowRight"], a.translateSelectedEditors, { args: [B, 0], checker: g }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], a.translateSelectedEditors, { args: [Q, 0], checker: g }], [["ArrowUp", "mac+ArrowUp"], a.translateSelectedEditors, { args: [0, -B], checker: g }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], a.translateSelectedEditors, { args: [0, -Q], checker: g }], [["ArrowDown", "mac+ArrowDown"], a.translateSelectedEditors, { args: [0, B], checker: g }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], a.translateSelectedEditors, { args: [0, Q], checker: g }]]));
    }
    constructor(a, g, l, B, Q, f, m, w, k, F, v) {
      const L = this._signal = this.#t.signal;
      this.#U = a, this.#T = g, this.#a = l, this._eventBus = B, B._on("editingaction", this.onEditingAction.bind(this), { signal: L }), B._on("pagechanging", this.onPageChanging.bind(this), { signal: L }), B._on("scalechanging", this.onScaleChanging.bind(this), { signal: L }), B._on("rotationchanging", this.onRotationChanging.bind(this), { signal: L }), B._on("setpreference", this.onSetPreference.bind(this), { signal: L }), B._on("switchannotationeditorparams", ((J) => this.updateParams(J.type, J.value)), { signal: L }), this.#$(), this.#it(), this.#O(), this.#i = Q.annotationStorage, this.#u = Q.filterFactory, this.#v = f, this.#y = m || null, this.#I = w, this.#B = k, this.#d = F, this.#G = v || null, this.viewParameters = { realScale: fa.PDF_TO_CSS_UNITS, rotation: 0 }, this.isShiftKeyDown = !1;
    }
    destroy() {
      this.#t?.abort(), this.#t = null, this._signal = null;
      for (const a of this.#s.values()) a.destroy();
      this.#s.clear(), this.#e.clear(), this.#C.clear(), this.#A = null, this.#Q.clear(), this.#o.destroy(), this.#a?.destroy(), this.#S?.hide(), this.#S = null, this.#E && (clearTimeout(this.#E), this.#E = null), this.#L && (clearTimeout(this.#L), this.#L = null);
    }
    combinedSignal(a) {
      return AbortSignal.any([this._signal, a.signal]);
    }
    get mlManager() {
      return this.#G;
    }
    get useNewAltTextFlow() {
      return this.#B;
    }
    get useNewAltTextWhenAddingImage() {
      return this.#d;
    }
    get hcmFilter() {
      return aA(this, "hcmFilter", this.#v ? this.#u.addHCMFilter(this.#v.foreground, this.#v.background) : "none");
    }
    get direction() {
      return aA(this, "direction", getComputedStyle(this.#U).direction);
    }
    get highlightColors() {
      return aA(this, "highlightColors", this.#y ? new Map(this.#y.split(",").map(((a) => a.split("=").map(((g) => g.trim()))))) : null);
    }
    get highlightColorNames() {
      return aA(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, ((a) => a.reverse()))) : null);
    }
    setMainHighlightColorPicker(a) {
      this.#N = a;
    }
    editAltText(a, g = !1) {
      this.#a?.editAltText(this, a, g);
    }
    switchToMode(a, g) {
      this._eventBus.on("annotationeditormodechanged", g, { once: !0, signal: this._signal }), this._eventBus.dispatch("showannotationeditorui", { source: this, mode: a });
    }
    setPreference(a, g) {
      this._eventBus.dispatch("setpreference", { source: this, name: a, value: g });
    }
    onSetPreference({ name: a, value: g }) {
      a === "enableNewAltTextWhenAddingImage" && (this.#d = g);
    }
    onPageChanging({ pageNumber: a }) {
      this.#g = a - 1;
    }
    focusMainContainer() {
      this.#U.focus();
    }
    findParent(a, g) {
      for (const l of this.#s.values()) {
        const { x: B, y: Q, width: f, height: m } = l.div.getBoundingClientRect();
        if (a >= B && a <= B + f && g >= Q && g <= Q + m) return l;
      }
      return null;
    }
    disableUserSelect(a = !1) {
      this.#T.classList.toggle("noUserSelect", a);
    }
    addShouldRescale(a) {
      this.#C.add(a);
    }
    removeShouldRescale(a) {
      this.#C.delete(a);
    }
    onScaleChanging({ scale: a }) {
      this.commitOrRemove(), this.viewParameters.realScale = a * fa.PDF_TO_CSS_UNITS;
      for (const g of this.#C) g.onScaleChanging();
    }
    onRotationChanging({ pagesRotation: a }) {
      this.commitOrRemove(), this.viewParameters.rotation = a;
    }
    #H({ anchorNode: a }) {
      return a.nodeType === Node.TEXT_NODE ? a.parentElement : a;
    }
    #_(a) {
      const { currentLayer: g } = this;
      if (g.hasTextLayer(a)) return g;
      for (const l of this.#s.values()) if (l.hasTextLayer(a)) return l;
      return null;
    }
    highlightSelection(a = "") {
      const g = document.getSelection();
      if (!g || g.isCollapsed) return;
      const { anchorNode: l, anchorOffset: B, focusNode: Q, focusOffset: f } = g, m = g.toString(), w = this.#H(g).closest(".textLayer"), k = this.getSelectionBoxes(w);
      if (!k) return;
      g.empty();
      const F = this.#_(w), v = this.#m === p.NONE, L = () => {
        F?.createAndAddNewEditor({ x: 0, y: 0 }, !1, { methodOfCreation: a, boxes: k, anchorNode: l, anchorOffset: B, focusNode: Q, focusOffset: f, text: m }), v && this.showAllEditors("highlight", !0, !0);
      };
      v ? this.switchToMode(p.HIGHLIGHT, L) : L();
    }
    #X() {
      const a = document.getSelection();
      if (!a || a.isCollapsed) return;
      const g = this.#H(a).closest(".textLayer"), l = this.getSelectionBoxes(g);
      l && (this.#S ||= new Zf(this), this.#S.show(g, l, this.direction === "ltr"));
    }
    addToAnnotationStorage(a) {
      a.isEmpty() || !this.#i || this.#i.has(a.id) || this.#i.setValue(a.id, a);
    }
    #z() {
      const a = document.getSelection();
      if (!a || a.isCollapsed) return void (this.#R && (this.#S?.hide(), this.#R = null, this.#F({ hasSelectedText: !1 })));
      const { anchorNode: g } = a;
      if (g === this.#R) return;
      const l = this.#H(a).closest(".textLayer");
      if (l) {
        if (this.#S?.hide(), this.#R = g, this.#F({ hasSelectedText: !0 }), (this.#m === p.HIGHLIGHT || this.#m === p.NONE) && (this.#m === p.HIGHLIGHT && this.showAllEditors("highlight", !0, !0), this.#k = this.isShiftKeyDown, !this.isShiftKeyDown)) {
          const B = this.#m === p.HIGHLIGHT ? this.#_(l) : null;
          B?.toggleDrawing();
          const Q = new AbortController(), f = this.combinedSignal(Q), m = (w) => {
            w.type === "pointerup" && w.button !== 0 || (Q.abort(), B?.toggleDrawing(!0), w.type === "pointerup" && this.#P("main_toolbar"));
          };
          window.addEventListener("pointerup", m, { signal: f }), window.addEventListener("blur", m, { signal: f });
        }
      } else this.#R && (this.#S?.hide(), this.#R = null, this.#F({ hasSelectedText: !1 }));
    }
    #P(a = "") {
      this.#m === p.HIGHLIGHT ? this.highlightSelection(a) : this.#I && this.#X();
    }
    #$() {
      document.addEventListener("selectionchange", this.#z.bind(this), { signal: this._signal });
    }
    #tt() {
      if (this.#p) return;
      this.#p = new AbortController();
      const a = this.combinedSignal(this.#p);
      window.addEventListener("focus", this.focus.bind(this), { signal: a }), window.addEventListener("blur", this.blur.bind(this), { signal: a });
    }
    #At() {
      this.#p?.abort(), this.#p = null;
    }
    blur() {
      if (this.isShiftKeyDown = !1, this.#k && (this.#k = !1, this.#P("main_toolbar")), !this.hasSelection) return;
      const { activeElement: a } = document;
      for (const g of this.#Q) if (g.div.contains(a)) {
        this.#D = [g, a], g._focusEventsAllowed = !1;
        break;
      }
    }
    focus() {
      if (!this.#D) return;
      const [a, g] = this.#D;
      this.#D = null, g.addEventListener("focusin", (() => {
        a._focusEventsAllowed = !0;
      }), { once: !0, signal: this._signal }), g.focus();
    }
    #O() {
      if (this.#b) return;
      this.#b = new AbortController();
      const a = this.combinedSignal(this.#b);
      window.addEventListener("keydown", this.keydown.bind(this), { signal: a }), window.addEventListener("keyup", this.keyup.bind(this), { signal: a });
    }
    #et() {
      this.#b?.abort(), this.#b = null;
    }
    #W() {
      if (this.#h) return;
      this.#h = new AbortController();
      const a = this.combinedSignal(this.#h);
      document.addEventListener("copy", this.copy.bind(this), { signal: a }), document.addEventListener("cut", this.cut.bind(this), { signal: a }), document.addEventListener("paste", this.paste.bind(this), { signal: a });
    }
    #j() {
      this.#h?.abort(), this.#h = null;
    }
    #it() {
      const a = this._signal;
      document.addEventListener("dragover", this.dragOver.bind(this), { signal: a }), document.addEventListener("drop", this.drop.bind(this), { signal: a });
    }
    addEditListeners() {
      this.#O(), this.#W();
    }
    removeEditListeners() {
      this.#et(), this.#j();
    }
    dragOver(a) {
      for (const { type: g } of a.dataTransfer.items) for (const l of this.#l) if (l.isHandlingMimeForPasting(g)) return a.dataTransfer.dropEffect = "copy", void a.preventDefault();
    }
    drop(a) {
      for (const g of a.dataTransfer.items) for (const l of this.#l) if (l.isHandlingMimeForPasting(g.type)) return l.paste(g, this.currentLayer), void a.preventDefault();
    }
    copy(a) {
      if (a.preventDefault(), this.#A?.commitOrRemove(), !this.hasSelection) return;
      const g = [];
      for (const l of this.#Q) {
        const B = l.serialize(!0);
        B && g.push(B);
      }
      g.length !== 0 && a.clipboardData.setData("application/pdfjs", JSON.stringify(g));
    }
    cut(a) {
      this.copy(a), this.delete();
    }
    paste(a) {
      a.preventDefault();
      const { clipboardData: g } = a;
      for (const Q of g.items) for (const f of this.#l) if (f.isHandlingMimeForPasting(Q.type)) return void f.paste(Q, this.currentLayer);
      let l = g.getData("application/pdfjs");
      if (!l) return;
      try {
        l = JSON.parse(l);
      } catch (Q) {
        return void qt(`paste: "${Q.message}".`);
      }
      if (!Array.isArray(l)) return;
      this.unselectAll();
      const B = this.currentLayer;
      try {
        const Q = [];
        for (const w of l) {
          const k = B.deserialize(w);
          if (!k) return;
          Q.push(k);
        }
        const f = () => {
          for (const w of Q) this.#Z(w);
          this.#V(Q);
        }, m = () => {
          for (const w of Q) w.remove();
        };
        this.addCommands({ cmd: f, undo: m, mustExec: !0 });
      } catch (Q) {
        qt(`paste: "${Q.message}".`);
      }
    }
    keydown(a) {
      this.isShiftKeyDown || a.key !== "Shift" || (this.isShiftKeyDown = !0), this.#m === p.NONE || this.isEditorHandlingKeyboard || ss._keyboardManager.exec(this, a);
    }
    keyup(a) {
      this.isShiftKeyDown && a.key === "Shift" && (this.isShiftKeyDown = !1, this.#k && (this.#k = !1, this.#P("main_toolbar")));
    }
    onEditingAction({ name: a }) {
      switch (a) {
        case "undo":
        case "redo":
        case "delete":
        case "selectAll":
          this[a]();
          break;
        case "highlightSelection":
          this.highlightSelection("context_menu");
      }
    }
    #F(a) {
      Object.entries(a).some((([g, l]) => this.#K[g] !== l)) && (this._eventBus.dispatch("annotationeditorstateschanged", { source: this, details: Object.assign(this.#K, a) }), this.#m === p.HIGHLIGHT && a.hasSelectedEditor === !1 && this.#Y([[y.HIGHLIGHT_FREE, !0]]));
    }
    #Y(a) {
      this._eventBus.dispatch("annotationeditorparamschanged", { source: this, details: a });
    }
    setEditingState(a) {
      a ? (this.#tt(), this.#W(), this.#F({ isEditing: this.#m !== p.NONE, isEmpty: this.#q(), hasSomethingToUndo: this.#o.hasSomethingToUndo(), hasSomethingToRedo: this.#o.hasSomethingToRedo(), hasSelectedEditor: !1 })) : (this.#At(), this.#j(), this.#F({ isEditing: !1 }), this.disableUserSelect(!1));
    }
    registerEditorTypes(a) {
      if (!this.#l) {
        this.#l = a;
        for (const g of this.#l) this.#Y(g.defaultPropertiesToUpdate);
      }
    }
    getId() {
      return this.#x.id;
    }
    get currentLayer() {
      return this.#s.get(this.#g);
    }
    getLayer(a) {
      return this.#s.get(a);
    }
    get currentPageIndex() {
      return this.#g;
    }
    addLayer(a) {
      this.#s.set(a.pageIndex, a), this.#w ? a.enable() : a.disable();
    }
    removeLayer(a) {
      this.#s.delete(a.pageIndex);
    }
    updateMode(a, g = null, l = !1) {
      if (this.#m !== a) {
        if (this.#m = a, a === p.NONE) return this.setEditingState(!1), void this.#at();
        this.setEditingState(!0), this.#st(), this.unselectAll();
        for (const B of this.#s.values()) B.updateMode(a);
        if (g || !l) {
          if (g) {
            for (const B of this.#e.values()) if (B.annotationElementId === g) {
              this.setSelected(B), B.enterInEditMode();
              break;
            }
          }
        } else this.addNewEditorFromKeyboard();
      }
    }
    addNewEditorFromKeyboard() {
      this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
    }
    updateToolbar(a) {
      a !== this.#m && this._eventBus.dispatch("switchannotationeditormode", { source: this, mode: a });
    }
    updateParams(a, g) {
      if (this.#l) {
        switch (a) {
          case y.CREATE:
            return void this.currentLayer.addNewEditor();
          case y.HIGHLIGHT_DEFAULT_COLOR:
            this.#N?.updateColor(g);
            break;
          case y.HIGHLIGHT_SHOW_ALL:
            this._eventBus.dispatch("reporttelemetry", { source: this, details: { type: "editing", data: { type: "highlight", action: "toggle_visibility" } } }), (this.#M ||= /* @__PURE__ */ new Map()).set(a, g), this.showAllEditors("highlight", g);
        }
        for (const l of this.#Q) l.updateParams(a, g);
        for (const l of this.#l) l.updateDefaultParams(a, g);
      }
    }
    showAllEditors(a, g, l = !1) {
      for (const B of this.#e.values()) B.editorType === a && B.show(g);
      (this.#M?.get(y.HIGHLIGHT_SHOW_ALL) ?? !0) !== g && this.#Y([[y.HIGHLIGHT_SHOW_ALL, g]]);
    }
    enableWaiting(a = !1) {
      if (this.#f !== a) {
        this.#f = a;
        for (const g of this.#s.values()) a ? g.disableClick() : g.enableClick(), g.div.classList.toggle("waiting", a);
      }
    }
    #st() {
      if (!this.#w) {
        this.#w = !0;
        for (const a of this.#s.values()) a.enable();
        for (const a of this.#e.values()) a.enable();
      }
    }
    #at() {
      if (this.unselectAll(), this.#w) {
        this.#w = !1;
        for (const a of this.#s.values()) a.disable();
        for (const a of this.#e.values()) a.disable();
      }
    }
    getEditors(a) {
      const g = [];
      for (const l of this.#e.values()) l.pageIndex === a && g.push(l);
      return g;
    }
    getEditor(a) {
      return this.#e.get(a);
    }
    addEditor(a) {
      this.#e.set(a.id, a);
    }
    removeEditor(a) {
      a.div.contains(document.activeElement) && (this.#E && clearTimeout(this.#E), this.#E = setTimeout((() => {
        this.focusMainContainer(), this.#E = null;
      }), 0)), this.#e.delete(a.id), this.unselect(a), a.annotationElementId && this.#c.has(a.annotationElementId) || this.#i?.remove(a.id);
    }
    addDeletedAnnotationElement(a) {
      this.#c.add(a.annotationElementId), this.addChangedExistingAnnotation(a), a.deleted = !0;
    }
    isDeletedAnnotationElement(a) {
      return this.#c.has(a);
    }
    removeDeletedAnnotationElement(a) {
      this.#c.delete(a.annotationElementId), this.removeChangedExistingAnnotation(a), a.deleted = !1;
    }
    #Z(a) {
      const g = this.#s.get(a.pageIndex);
      g ? g.addOrRebuild(a) : (this.addEditor(a), this.addToAnnotationStorage(a));
    }
    setActiveEditor(a) {
      this.#A !== a && (this.#A = a, a && this.#Y(a.propertiesToUpdate));
    }
    get #nt() {
      let a = null;
      for (a of this.#Q) ;
      return a;
    }
    updateUI(a) {
      this.#nt === a && this.#Y(a.propertiesToUpdate);
    }
    toggleSelected(a) {
      if (this.#Q.has(a)) return this.#Q.delete(a), a.unselect(), void this.#F({ hasSelectedEditor: this.hasSelection });
      this.#Q.add(a), a.select(), this.#Y(a.propertiesToUpdate), this.#F({ hasSelectedEditor: !0 });
    }
    setSelected(a) {
      for (const g of this.#Q) g !== a && g.unselect();
      this.#Q.clear(), this.#Q.add(a), a.select(), this.#Y(a.propertiesToUpdate), this.#F({ hasSelectedEditor: !0 });
    }
    isSelected(a) {
      return this.#Q.has(a);
    }
    get firstSelectedEditor() {
      return this.#Q.values().next().value;
    }
    unselect(a) {
      a.unselect(), this.#Q.delete(a), this.#F({ hasSelectedEditor: this.hasSelection });
    }
    get hasSelection() {
      return this.#Q.size !== 0;
    }
    get isEnterHandled() {
      return this.#Q.size === 1 && this.firstSelectedEditor.isEnterHandled;
    }
    undo() {
      this.#o.undo(), this.#F({ hasSomethingToUndo: this.#o.hasSomethingToUndo(), hasSomethingToRedo: !0, isEmpty: this.#q() });
    }
    redo() {
      this.#o.redo(), this.#F({ hasSomethingToUndo: !0, hasSomethingToRedo: this.#o.hasSomethingToRedo(), isEmpty: this.#q() });
    }
    addCommands(a) {
      this.#o.add(a), this.#F({ hasSomethingToUndo: !0, hasSomethingToRedo: !1, isEmpty: this.#q() });
    }
    #q() {
      if (this.#e.size === 0) return !0;
      if (this.#e.size === 1) for (const a of this.#e.values()) return a.isEmpty();
      return !1;
    }
    delete() {
      if (this.commitOrRemove(), !this.hasSelection) return;
      const a = [...this.#Q];
      this.addCommands({ cmd: () => {
        for (const g of a) g.remove();
      }, undo: () => {
        for (const g of a) this.#Z(g);
      }, mustExec: !0 });
    }
    commitOrRemove() {
      this.#A?.commitOrRemove();
    }
    hasSomethingToControl() {
      return this.#A || this.hasSelection;
    }
    #V(a) {
      for (const g of this.#Q) g.unselect();
      this.#Q.clear();
      for (const g of a) g.isEmpty() || (this.#Q.add(g), g.select());
      this.#F({ hasSelectedEditor: this.hasSelection });
    }
    selectAll() {
      for (const a of this.#Q) a.commit();
      this.#V(this.#e.values());
    }
    unselectAll() {
      if ((!this.#A || (this.#A.commitOrRemove(), this.#m === p.NONE)) && this.hasSelection) {
        for (const a of this.#Q) a.unselect();
        this.#Q.clear(), this.#F({ hasSelectedEditor: !1 });
      }
    }
    translateSelectedEditors(a, g, l = !1) {
      if (l || this.commitOrRemove(), !this.hasSelection) return;
      this.#J[0] += a, this.#J[1] += g;
      const [B, Q] = this.#J, f = [...this.#Q];
      this.#L && clearTimeout(this.#L), this.#L = setTimeout((() => {
        this.#L = null, this.#J[0] = this.#J[1] = 0, this.addCommands({ cmd: () => {
          for (const m of f) this.#e.has(m.id) && m.translateInPage(B, Q);
        }, undo: () => {
          for (const m of f) this.#e.has(m.id) && m.translateInPage(-B, -Q);
        }, mustExec: !1 });
      }), 1e3);
      for (const m of f) m.translateInPage(a, g);
    }
    setUpDragSession() {
      if (this.hasSelection) {
        this.disableUserSelect(!0), this.#n = /* @__PURE__ */ new Map();
        for (const a of this.#Q) this.#n.set(a, { savedX: a.x, savedY: a.y, savedPageIndex: a.pageIndex, newX: 0, newY: 0, newPageIndex: -1 });
      }
    }
    endDragSession() {
      if (!this.#n) return !1;
      this.disableUserSelect(!1);
      const a = this.#n;
      this.#n = null;
      let g = !1;
      for (const [{ x: B, y: Q, pageIndex: f }, m] of a) m.newX = B, m.newY = Q, m.newPageIndex = f, g ||= B !== m.savedX || Q !== m.savedY || f !== m.savedPageIndex;
      if (!g) return !1;
      const l = (B, Q, f, m) => {
        if (this.#e.has(B.id)) {
          const w = this.#s.get(m);
          w ? B._setParentAndPosition(w, Q, f) : (B.pageIndex = m, B.x = Q, B.y = f);
        }
      };
      return this.addCommands({ cmd: () => {
        for (const [B, { newX: Q, newY: f, newPageIndex: m }] of a) l(B, Q, f, m);
      }, undo: () => {
        for (const [B, { savedX: Q, savedY: f, savedPageIndex: m }] of a) l(B, Q, f, m);
      }, mustExec: !0 }), !0;
    }
    dragSelectedEditors(a, g) {
      if (this.#n) for (const l of this.#n.keys()) l.drag(a, g);
    }
    rebuild(a) {
      if (a.parent === null) {
        const g = this.getLayer(a.pageIndex);
        g ? (g.changeParent(a), g.addOrRebuild(a)) : (this.addEditor(a), this.addToAnnotationStorage(a), a.rebuild());
      } else a.parent.addOrRebuild(a);
    }
    get isEditorHandlingKeyboard() {
      return this.getActive()?.shouldGetKeyboardEvents() || this.#Q.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
    }
    isActive(a) {
      return this.#A === a;
    }
    getActive() {
      return this.#A;
    }
    getMode() {
      return this.#m;
    }
    get imageManager() {
      return aA(this, "imageManager", new Ug());
    }
    getSelectionBoxes(a) {
      if (!a) return null;
      const g = document.getSelection();
      for (let k = 0, F = g.rangeCount; k < F; k++) if (!a.contains(g.getRangeAt(k).commonAncestorContainer)) return null;
      const { x: l, y: B, width: Q, height: f } = a.getBoundingClientRect();
      let m;
      switch (a.getAttribute("data-main-rotation")) {
        case "90":
          m = (k, F, v, L) => ({ x: (F - B) / f, y: 1 - (k + v - l) / Q, width: L / f, height: v / Q });
          break;
        case "180":
          m = (k, F, v, L) => ({ x: 1 - (k + v - l) / Q, y: 1 - (F + L - B) / f, width: v / Q, height: L / f });
          break;
        case "270":
          m = (k, F, v, L) => ({ x: 1 - (F + L - B) / f, y: (k - l) / Q, width: L / f, height: v / Q });
          break;
        default:
          m = (k, F, v, L) => ({ x: (k - l) / Q, y: (F - B) / f, width: v / Q, height: L / f });
      }
      const w = [];
      for (let k = 0, F = g.rangeCount; k < F; k++) {
        const v = g.getRangeAt(k);
        if (!v.collapsed) for (const { x: L, y: J, width: K, height: X } of v.getClientRects()) K !== 0 && X !== 0 && w.push(m(L, J, K, X));
      }
      return w.length === 0 ? null : w;
    }
    addChangedExistingAnnotation({ annotationElementId: a, id: g }) {
      (this.#r ||= /* @__PURE__ */ new Map()).set(a, g);
    }
    removeChangedExistingAnnotation({ annotationElementId: a }) {
      this.#r?.delete(a);
    }
    renderAnnotationElement(a) {
      const g = this.#r?.get(a.data.id);
      if (!g) return;
      const l = this.#i.getRawValue(g);
      l && (this.#m !== p.NONE || l.hasBeenModified) && l.renderAnnotationElement(a);
    }
  }
  class Ei {
    #t = null;
    #A = !1;
    #e = null;
    #s = null;
    #a = null;
    #i = !1;
    #r = null;
    #o = null;
    #h = null;
    #g = null;
    #c = !1;
    static _l10nPromise = null;
    constructor(a) {
      this.#o = a, this.#c = a._uiManager.useNewAltTextFlow;
    }
    static initialize(a) {
      Ei._l10nPromise ||= a;
    }
    async render() {
      const a = this.#e = document.createElement("button");
      let g;
      a.className = "altText", this.#c ? (a.classList.add("new"), g = await Ei._l10nPromise.get("pdfjs-editor-new-alt-text-missing-button-label")) : g = await Ei._l10nPromise.get("pdfjs-editor-alt-text-button-label"), a.textContent = g, a.setAttribute("aria-label", g), a.tabIndex = "0";
      const l = this.#o._uiManager._signal;
      a.addEventListener("contextmenu", je, { signal: l }), a.addEventListener("pointerdown", ((Q) => Q.stopPropagation()), { signal: l });
      const B = (Q) => {
        Q.preventDefault(), this.#o._uiManager.editAltText(this.#o), this.#c && this.#o._reportTelemetry({ action: "pdfjs.image.alt_text.image_status_label_clicked", data: { label: this.#n } });
      };
      return a.addEventListener("click", B, { capture: !0, signal: l }), a.addEventListener("keydown", ((Q) => {
        Q.target === a && Q.key === "Enter" && (this.#i = !0, B(Q));
      }), { signal: l }), await this.#l(), a;
    }
    get #n() {
      return (this.#t ? "added" : this.#t === null && this.guessedText && "review") || "missing";
    }
    finish() {
      this.#e && (this.#e.focus({ focusVisible: this.#i }), this.#i = !1);
    }
    isEmpty() {
      return this.#c ? this.#t === null : !this.#t && !this.#A;
    }
    hasData() {
      return this.#c ? this.#t !== null || !!this.#h : this.isEmpty();
    }
    get guessedText() {
      return this.#h;
    }
    async setGuessedText(a) {
      this.#t === null && (this.#h = a, this.#g = await Ei._l10nPromise.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer")({ generatedAltText: a }), this.#l());
    }
    toggleAltTextBadge(a = !1) {
      if (!this.#c || this.#t) return this.#r?.remove(), void (this.#r = null);
      if (!this.#r) {
        const g = this.#r = document.createElement("div");
        g.className = "noAltTextBadge", this.#o.div.append(g);
      }
      this.#r.classList.toggle("hidden", !a);
    }
    serialize(a) {
      let g = this.#t;
      return a || this.#h !== g || (g = this.#g), { altText: g, decorative: this.#A, guessedText: this.#h, textWithDisclaimer: this.#g };
    }
    get data() {
      return { altText: this.#t, decorative: this.#A };
    }
    set data({ altText: a, decorative: g, guessedText: l, textWithDisclaimer: B, cancel: Q = !1 }) {
      l && (this.#h = l, this.#g = B), this.#t === a && this.#A === g || (Q || (this.#t = a, this.#A = g), this.#l());
    }
    toggle(a = !1) {
      this.#e && (!a && this.#a && (clearTimeout(this.#a), this.#a = null), this.#e.disabled = !a);
    }
    shown() {
      this.#o._reportTelemetry({ action: "pdfjs.image.alt_text.image_status_label_displayed", data: { label: this.#n } });
    }
    destroy() {
      this.#e?.remove(), this.#e = null, this.#s = null, this.#r?.remove(), this.#r = null;
    }
    async #l() {
      const a = this.#e;
      if (!a) return;
      if (this.#c) {
        const B = this.#n, Q = B === "review" ? "to-review" : B;
        if (a.classList.toggle("done", !!this.#t), Ei._l10nPromise.get(`pdfjs-editor-new-alt-text-${Q}-button-label`).then(((f) => {
          a.setAttribute("aria-label", f);
          for (const m of a.childNodes) if (m.nodeType === Node.TEXT_NODE) {
            m.textContent = f;
            break;
          }
        })), !this.#t) return void this.#s?.remove();
      } else {
        if (!this.#t && !this.#A) return a.classList.remove("done"), void this.#s?.remove();
        a.classList.add("done"), Ei._l10nPromise.get("pdfjs-editor-alt-text-edit-button-label").then(((B) => {
          a.setAttribute("aria-label", B);
        }));
      }
      let g = this.#s;
      if (!g) {
        this.#s = g = document.createElement("span"), g.className = "tooltip", g.setAttribute("role", "tooltip");
        const B = g.id = `alt-text-tooltip-${this.#o.id}`;
        a.setAttribute("aria-describedby", B);
        const Q = 100, f = this.#o._uiManager._signal;
        f.addEventListener("abort", (() => {
          clearTimeout(this.#a), this.#a = null;
        }), { once: !0 }), a.addEventListener("mouseenter", (() => {
          this.#a = setTimeout((() => {
            this.#a = null, this.#s.classList.add("show"), this.#o._reportTelemetry({ action: "alt_text_tooltip" });
          }), Q);
        }), { signal: f }), a.addEventListener("mouseleave", (() => {
          this.#a && (clearTimeout(this.#a), this.#a = null), this.#s?.classList.remove("show");
        }), { signal: f });
      }
      g.innerText = this.#A ? await Ei._l10nPromise.get("pdfjs-editor-alt-text-decorative-tooltip") : this.#t, g.parentNode || a.append(g), this.#o.getImageForAltText()?.setAttribute("aria-describedby", g.id);
    }
  }
  class $t {
    #t = null;
    #A = null;
    #e = null;
    #s = !1;
    #a = !1;
    #i = null;
    #r = null;
    #o = null;
    #h = "";
    #g = !1;
    #c = null;
    #n = !1;
    #l = !1;
    #C = !1;
    #I = null;
    #B = 0;
    #d = 0;
    #u = null;
    _editToolbar = null;
    _initialOptions = /* @__PURE__ */ Object.create(null);
    _isVisible = !0;
    _uiManager = null;
    _focusEventsAllowed = !0;
    static _l10nPromise = null;
    static _l10nResizer = null;
    #E = !1;
    #p = $t._zIndex++;
    static _borderLineWidth = -1;
    static _colorManager = new Hg();
    static _zIndex = 1;
    static _telemetryTimeout = 1e3;
    static get _resizerKeyboardManager() {
      const a = $t.prototype._resizeWithKeyboard, g = ss.TRANSLATE_SMALL, l = ss.TRANSLATE_BIG;
      return aA(this, "_resizerKeyboardManager", new In([[["ArrowLeft", "mac+ArrowLeft"], a, { args: [-g, 0] }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], a, { args: [-l, 0] }], [["ArrowRight", "mac+ArrowRight"], a, { args: [g, 0] }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], a, { args: [l, 0] }], [["ArrowUp", "mac+ArrowUp"], a, { args: [0, -g] }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], a, { args: [0, -l] }], [["ArrowDown", "mac+ArrowDown"], a, { args: [0, g] }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], a, { args: [0, l] }], [["Escape", "mac+Escape"], $t.prototype._stopResizingWithKeyboard]]));
    }
    constructor(a) {
      this.parent = a.parent, this.id = a.id, this.width = this.height = null, this.pageIndex = a.parent.pageIndex, this.name = a.name, this.div = null, this._uiManager = a.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = a.isCentered, this._structTreeParentId = null;
      const { rotation: g, rawDims: { pageWidth: l, pageHeight: B, pageX: Q, pageY: f } } = this.parent.viewport;
      this.rotation = g, this.pageRotation = (360 + g - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [l, B], this.pageTranslation = [Q, f];
      const [m, w] = this.parentDimensions;
      this.x = a.x / m, this.y = a.y / w, this.isAttachedToDOM = !1, this.deleted = !1;
    }
    get editorType() {
      return Object.getPrototypeOf(this).constructor._type;
    }
    static get _defaultLineColor() {
      return aA(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
    }
    static deleteAnnotationElement(a) {
      const g = new zf({ id: a.parent.getNextId(), parent: a.parent, uiManager: a._uiManager });
      g.annotationElementId = a.annotationElementId, g.deleted = !0, g._uiManager.addToAnnotationStorage(g);
    }
    static initialize(a, g, l) {
      if ($t._l10nResizer ||= Object.freeze({ topLeft: "pdfjs-editor-resizer-top-left", topMiddle: "pdfjs-editor-resizer-top-middle", topRight: "pdfjs-editor-resizer-top-right", middleRight: "pdfjs-editor-resizer-middle-right", bottomRight: "pdfjs-editor-resizer-bottom-right", bottomMiddle: "pdfjs-editor-resizer-bottom-middle", bottomLeft: "pdfjs-editor-resizer-bottom-left", middleLeft: "pdfjs-editor-resizer-middle-left" }), $t._l10nPromise ||= new Map([...["pdfjs-editor-alt-text-button-label", "pdfjs-editor-alt-text-edit-button-label", "pdfjs-editor-alt-text-decorative-tooltip", "pdfjs-editor-new-alt-text-added-button-label", "pdfjs-editor-new-alt-text-missing-button-label", "pdfjs-editor-new-alt-text-to-review-button-label"].map(((Q) => [Q, a.get(Q)])), ...["pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer"].map(((Q) => [Q, a.get.bind(a, Q)]))]), l?.strings) for (const Q of l.strings) $t._l10nPromise.set(Q, a.get(Q));
      if ($t._borderLineWidth !== -1) return;
      const B = getComputedStyle(document.documentElement);
      $t._borderLineWidth = parseFloat(B.getPropertyValue("--outline-width")) || 0;
    }
    static updateDefaultParams(a, g) {
    }
    static get defaultPropertiesToUpdate() {
      return [];
    }
    static isHandlingMimeForPasting(a) {
      return !1;
    }
    static paste(a, g) {
      Xt("Not implemented");
    }
    get propertiesToUpdate() {
      return [];
    }
    get _isDraggable() {
      return this.#E;
    }
    set _isDraggable(a) {
      this.#E = a, this.div?.classList.toggle("draggable", a);
    }
    get isEnterHandled() {
      return !0;
    }
    center() {
      const [a, g] = this.pageDimensions;
      switch (this.parentRotation) {
        case 90:
          this.x -= this.height * g / (2 * a), this.y += this.width * a / (2 * g);
          break;
        case 180:
          this.x += this.width / 2, this.y += this.height / 2;
          break;
        case 270:
          this.x += this.height * g / (2 * a), this.y -= this.width * a / (2 * g);
          break;
        default:
          this.x -= this.width / 2, this.y -= this.height / 2;
      }
      this.fixAndSetPosition();
    }
    addCommands(a) {
      this._uiManager.addCommands(a);
    }
    get currentLayer() {
      return this._uiManager.currentLayer;
    }
    setInBackground() {
      this.div.style.zIndex = 0;
    }
    setInForeground() {
      this.div.style.zIndex = this.#p;
    }
    setParent(a) {
      a !== null ? (this.pageIndex = a.pageIndex, this.pageDimensions = a.pageDimensions) : this.#M(), this.parent = a;
    }
    focusin(a) {
      this._focusEventsAllowed && (this.#g ? this.#g = !1 : this.parent.setSelected(this));
    }
    focusout(a) {
      if (!this._focusEventsAllowed || !this.isAttachedToDOM) return;
      a.relatedTarget?.closest(`#${this.id}`) || (a.preventDefault(), this.parent?.isMultipleSelection || this.commitOrRemove());
    }
    commitOrRemove() {
      this.isEmpty() ? this.remove() : this.commit();
    }
    commit() {
      this.addToAnnotationStorage();
    }
    addToAnnotationStorage() {
      this._uiManager.addToAnnotationStorage(this);
    }
    setAt(a, g, l, B) {
      const [Q, f] = this.parentDimensions;
      [l, B] = this.screenToPageTranslation(l, B), this.x = (a + l) / Q, this.y = (g + B) / f, this.fixAndSetPosition();
    }
    #y([a, g], l, B) {
      [l, B] = this.screenToPageTranslation(l, B), this.x += l / a, this.y += B / g, this.fixAndSetPosition();
    }
    translate(a, g) {
      this.#y(this.parentDimensions, a, g);
    }
    translateInPage(a, g) {
      this.#c ||= [this.x, this.y], this.#y(this.pageDimensions, a, g), this.div.scrollIntoView({ block: "nearest" });
    }
    drag(a, g) {
      this.#c ||= [this.x, this.y];
      const [l, B] = this.parentDimensions;
      if (this.x += a / l, this.y += g / B, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
        const { x: k, y: F } = this.div.getBoundingClientRect();
        this.parent.findNewParent(this, k, F) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
      }
      let { x: Q, y: f } = this;
      const [m, w] = this.getBaseTranslation();
      Q += m, f += w, this.div.style.left = `${(100 * Q).toFixed(2)}%`, this.div.style.top = `${(100 * f).toFixed(2)}%`, this.div.scrollIntoView({ block: "nearest" });
    }
    get _hasBeenMoved() {
      return !!this.#c && (this.#c[0] !== this.x || this.#c[1] !== this.y);
    }
    getBaseTranslation() {
      const [a, g] = this.parentDimensions, { _borderLineWidth: l } = $t, B = l / a, Q = l / g;
      switch (this.rotation) {
        case 90:
          return [-B, Q];
        case 180:
          return [B, Q];
        case 270:
          return [B, -Q];
        default:
          return [-B, -Q];
      }
    }
    get _mustFixPosition() {
      return !0;
    }
    fixAndSetPosition(a = this.rotation) {
      const [g, l] = this.pageDimensions;
      let { x: B, y: Q, width: f, height: m } = this;
      if (f *= g, m *= l, B *= g, Q *= l, this._mustFixPosition) switch (a) {
        case 0:
          B = Math.max(0, Math.min(g - f, B)), Q = Math.max(0, Math.min(l - m, Q));
          break;
        case 90:
          B = Math.max(0, Math.min(g - m, B)), Q = Math.min(l, Math.max(f, Q));
          break;
        case 180:
          B = Math.min(g, Math.max(f, B)), Q = Math.min(l, Math.max(m, Q));
          break;
        case 270:
          B = Math.min(g, Math.max(m, B)), Q = Math.max(0, Math.min(l - f, Q));
      }
      this.x = B /= g, this.y = Q /= l;
      const [w, k] = this.getBaseTranslation();
      B += w, Q += k;
      const { style: F } = this.div;
      F.left = `${(100 * B).toFixed(2)}%`, F.top = `${(100 * Q).toFixed(2)}%`, this.moveInDOM();
    }
    static #k(a, g, l) {
      switch (l) {
        case 90:
          return [g, -a];
        case 180:
          return [-a, -g];
        case 270:
          return [-g, a];
        default:
          return [a, g];
      }
    }
    screenToPageTranslation(a, g) {
      return $t.#k(a, g, this.parentRotation);
    }
    pageTranslationToScreen(a, g) {
      return $t.#k(a, g, 360 - this.parentRotation);
    }
    #S(a) {
      switch (a) {
        case 90: {
          const [g, l] = this.pageDimensions;
          return [0, -g / l, l / g, 0];
        }
        case 180:
          return [-1, 0, 0, -1];
        case 270: {
          const [g, l] = this.pageDimensions;
          return [0, g / l, -l / g, 0];
        }
        default:
          return [1, 0, 0, 1];
      }
    }
    get parentScale() {
      return this._uiManager.viewParameters.realScale;
    }
    get parentRotation() {
      return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
    }
    get parentDimensions() {
      const { parentScale: a, pageDimensions: [g, l] } = this, B = g * a, Q = l * a;
      return be.isCSSRoundSupported ? [Math.round(B), Math.round(Q)] : [B, Q];
    }
    setDims(a, g) {
      const [l, B] = this.parentDimensions;
      this.div.style.width = `${(100 * a / l).toFixed(2)}%`, this.#a || (this.div.style.height = `${(100 * g / B).toFixed(2)}%`);
    }
    fixDims() {
      const { style: a } = this.div, { height: g, width: l } = a, B = l.endsWith("%"), Q = !this.#a && g.endsWith("%");
      if (B && Q) return;
      const [f, m] = this.parentDimensions;
      B || (a.width = `${(100 * parseFloat(l) / f).toFixed(2)}%`), this.#a || Q || (a.height = `${(100 * parseFloat(g) / m).toFixed(2)}%`);
    }
    getInitialTranslation() {
      return [0, 0];
    }
    #x() {
      if (this.#i) return;
      this.#i = document.createElement("div"), this.#i.classList.add("resizers");
      const a = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"], g = this._uiManager._signal;
      for (const l of a) {
        const B = document.createElement("div");
        this.#i.append(B), B.classList.add("resizer", l), B.setAttribute("data-resizer-name", l), B.addEventListener("pointerdown", this.#w.bind(this, l), { signal: g }), B.addEventListener("contextmenu", je, { signal: g }), B.tabIndex = -1;
      }
      this.div.prepend(this.#i);
    }
    #w(a, g) {
      g.preventDefault();
      const { isMac: l } = be.platform;
      if (g.button !== 0 || g.ctrlKey && l) return;
      this.#e?.toggle(!1);
      const B = this._isDraggable;
      this._isDraggable = !1;
      const Q = new AbortController(), f = this._uiManager.combinedSignal(Q);
      this.parent.togglePointerEvents(!1), window.addEventListener("pointermove", this.#b.bind(this, a), { passive: !0, capture: !0, signal: f }), window.addEventListener("contextmenu", je, { signal: f });
      const m = this.x, w = this.y, k = this.width, F = this.height, v = this.parent.div.style.cursor, L = this.div.style.cursor;
      this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(g.target).cursor;
      const J = () => {
        Q.abort(), this.parent.togglePointerEvents(!0), this.#e?.toggle(!0), this._isDraggable = B, this.parent.div.style.cursor = v, this.div.style.cursor = L, this.#f(m, w, k, F);
      };
      window.addEventListener("pointerup", J, { signal: f }), window.addEventListener("blur", J, { signal: f });
    }
    #f(a, g, l, B) {
      const Q = this.x, f = this.y, m = this.width, w = this.height;
      Q === a && f === g && m === l && w === B || this.addCommands({ cmd: () => {
        this.width = m, this.height = w, this.x = Q, this.y = f;
        const [k, F] = this.parentDimensions;
        this.setDims(k * m, F * w), this.fixAndSetPosition();
      }, undo: () => {
        this.width = l, this.height = B, this.x = a, this.y = g;
        const [k, F] = this.parentDimensions;
        this.setDims(k * l, F * B), this.fixAndSetPosition();
      }, mustExec: !0 });
    }
    #b(a, g) {
      const [l, B] = this.parentDimensions, Q = this.x, f = this.y, m = this.width, w = this.height, k = $t.MIN_SIZE / l, F = $t.MIN_SIZE / B, v = (rA) => Math.round(1e4 * rA) / 1e4, L = this.#S(this.rotation), J = (rA, dA) => [L[0] * rA + L[2] * dA, L[1] * rA + L[3] * dA], K = this.#S(360 - this.rotation);
      let X, et, At = !1, It = !1;
      switch (a) {
        case "topLeft":
          At = !0, X = (rA, dA) => [0, 0], et = (rA, dA) => [rA, dA];
          break;
        case "topMiddle":
          X = (rA, dA) => [rA / 2, 0], et = (rA, dA) => [rA / 2, dA];
          break;
        case "topRight":
          At = !0, X = (rA, dA) => [rA, 0], et = (rA, dA) => [0, dA];
          break;
        case "middleRight":
          It = !0, X = (rA, dA) => [rA, dA / 2], et = (rA, dA) => [0, dA / 2];
          break;
        case "bottomRight":
          At = !0, X = (rA, dA) => [rA, dA], et = (rA, dA) => [0, 0];
          break;
        case "bottomMiddle":
          X = (rA, dA) => [rA / 2, dA], et = (rA, dA) => [rA / 2, 0];
          break;
        case "bottomLeft":
          At = !0, X = (rA, dA) => [0, dA], et = (rA, dA) => [rA, 0];
          break;
        case "middleLeft":
          It = !0, X = (rA, dA) => [0, dA / 2], et = (rA, dA) => [rA, dA / 2];
      }
      const kt = X(m, w), Mt = et(m, w);
      let Ut = J(...Mt);
      const xt = v(Q + Ut[0]), Wt = v(f + Ut[1]);
      let eA = 1, nA = 1, [EA, sA] = this.screenToPageTranslation(g.movementX, g.movementY);
      var ke, ZA;
      if ([EA, sA] = (ke = EA / l, ZA = sA / B, [K[0] * ke + K[2] * ZA, K[1] * ke + K[3] * ZA]), At) {
        const rA = Math.hypot(m, w);
        eA = nA = Math.max(Math.min(Math.hypot(Mt[0] - kt[0] - EA, Mt[1] - kt[1] - sA) / rA, 1 / m, 1 / w), k / m, F / w);
      } else It ? eA = Math.max(k, Math.min(1, Math.abs(Mt[0] - kt[0] - EA))) / m : nA = Math.max(F, Math.min(1, Math.abs(Mt[1] - kt[1] - sA))) / w;
      const kA = v(m * eA), se = v(w * nA);
      Ut = J(...et(kA, se));
      const oi = xt - Ut[0], os = Wt - Ut[1];
      this.width = kA, this.height = se, this.x = oi, this.y = os, this.setDims(l * kA, B * se), this.fixAndSetPosition();
    }
    altTextFinish() {
      this.#e?.finish();
    }
    async addEditToolbar() {
      return this._editToolbar || this.#l || (this._editToolbar = new ln(this), this.div.append(this._editToolbar.render()), this.#e && await this._editToolbar.addAltText(this.#e)), this._editToolbar;
    }
    removeEditToolbar() {
      this._editToolbar && (this._editToolbar.remove(), this._editToolbar = null, this.#e?.destroy());
    }
    getClientDimensions() {
      return this.div.getBoundingClientRect();
    }
    async addAltTextButton() {
      this.#e || (Ei.initialize($t._l10nPromise), this.#e = new Ei(this), this.#t && (this.#e.data = this.#t, this.#t = null), await this.addEditToolbar());
    }
    get altTextData() {
      return this.#e?.data;
    }
    set altTextData(a) {
      this.#e && (this.#e.data = a);
    }
    get guessedAltText() {
      return this.#e?.guessedText;
    }
    async setGuessedAltText(a) {
      await this.#e?.setGuessedText(a);
    }
    serializeAltText(a) {
      return this.#e?.serialize(a);
    }
    hasAltText() {
      return !!this.#e && !this.#e.isEmpty();
    }
    hasAltTextData() {
      return this.#e?.hasData() ?? !1;
    }
    render() {
      this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.tabIndex = this.#s ? -1 : 0, this._isVisible || this.div.classList.add("hidden"), this.setInForeground(), this.#G();
      const [a, g] = this.parentDimensions;
      this.parentRotation % 180 != 0 && (this.div.style.maxWidth = `${(100 * g / a).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * a / g).toFixed(2)}%`);
      const [l, B] = this.getInitialTranslation();
      return this.translate(l, B), Lr(this, this.div, ["pointerdown"]), this.div;
    }
    pointerdown(a) {
      const { isMac: g } = be.platform;
      a.button !== 0 || a.ctrlKey && g ? a.preventDefault() : (this.#g = !0, this._isDraggable ? this.#N(a) : this.#D(a));
    }
    #D(a) {
      const { isMac: g } = be.platform;
      a.ctrlKey && !g || a.shiftKey || a.metaKey && g ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
    }
    #N(a) {
      const g = this._uiManager.isSelected(this);
      this._uiManager.setUpDragSession();
      const l = new AbortController(), B = this._uiManager.combinedSignal(l);
      if (g) {
        this.div.classList.add("moving"), this.#B = a.clientX, this.#d = a.clientY;
        const f = (m) => {
          const { clientX: w, clientY: k } = m, [F, v] = this.screenToPageTranslation(w - this.#B, k - this.#d);
          this.#B = w, this.#d = k, this._uiManager.dragSelectedEditors(F, v);
        };
        window.addEventListener("pointermove", f, { passive: !0, capture: !0, signal: B });
      }
      const Q = () => {
        l.abort(), g && this.div.classList.remove("moving"), this.#g = !1, this._uiManager.endDragSession() || this.#D(a);
      };
      window.addEventListener("pointerup", Q, { signal: B }), window.addEventListener("blur", Q, { signal: B });
    }
    moveInDOM() {
      this.#I && clearTimeout(this.#I), this.#I = setTimeout((() => {
        this.#I = null, this.parent?.moveEditorInDOM(this);
      }), 0);
    }
    _setParentAndPosition(a, g, l) {
      a.changeParent(this), this.x = g, this.y = l, this.fixAndSetPosition();
    }
    getRect(a, g, l = this.rotation) {
      const B = this.parentScale, [Q, f] = this.pageDimensions, [m, w] = this.pageTranslation, k = a / B, F = g / B, v = this.x * Q, L = this.y * f, J = this.width * Q, K = this.height * f;
      switch (l) {
        case 0:
          return [v + k + m, f - L - F - K + w, v + k + J + m, f - L - F + w];
        case 90:
          return [v + F + m, f - L + k + w, v + F + K + m, f - L + k + J + w];
        case 180:
          return [v - k - J + m, f - L + F + w, v - k + m, f - L + F + K + w];
        case 270:
          return [v - F - K + m, f - L - k - J + w, v - F + m, f - L - k + w];
        default:
          throw new Error("Invalid rotation");
      }
    }
    getRectInCurrentCoords(a, g) {
      const [l, B, Q, f] = a, m = Q - l, w = f - B;
      switch (this.rotation) {
        case 0:
          return [l, g - f, m, w];
        case 90:
          return [l, g - B, w, m];
        case 180:
          return [Q, g - B, m, w];
        case 270:
          return [Q, g - f, w, m];
        default:
          throw new Error("Invalid rotation");
      }
    }
    onceAdded() {
    }
    isEmpty() {
      return !1;
    }
    enableEditMode() {
      this.#l = !0;
    }
    disableEditMode() {
      this.#l = !1;
    }
    isInEditMode() {
      return this.#l;
    }
    shouldGetKeyboardEvents() {
      return this.#C;
    }
    needsToBeRebuilt() {
      return this.div && !this.isAttachedToDOM;
    }
    #G() {
      if (this.#o || !this.div) return;
      this.#o = new AbortController();
      const a = this._uiManager.combinedSignal(this.#o);
      this.div.addEventListener("focusin", this.focusin.bind(this), { signal: a }), this.div.addEventListener("focusout", this.focusout.bind(this), { signal: a });
    }
    rebuild() {
      this.#G();
    }
    rotate(a) {
    }
    serialize(a = !1, g = null) {
      Xt("An editor must be serializable");
    }
    static deserialize(a, g, l) {
      const B = new this.prototype.constructor({ parent: g, id: g.getNextId(), uiManager: l });
      B.rotation = a.rotation, B.#t = a.accessibilityData;
      const [Q, f] = B.pageDimensions, [m, w, k, F] = B.getRectInCurrentCoords(a.rect, f);
      return B.x = m / Q, B.y = w / f, B.width = k / Q, B.height = F / f, B;
    }
    get hasBeenModified() {
      return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
    }
    remove() {
      if (this.#o?.abort(), this.#o = null, this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), this.#I && (clearTimeout(this.#I), this.#I = null), this.#M(), this.removeEditToolbar(), this.#u) {
        for (const a of this.#u.values()) clearTimeout(a);
        this.#u = null;
      }
      this.parent = null;
    }
    get isResizable() {
      return !1;
    }
    makeResizable() {
      this.isResizable && (this.#x(), this.#i.classList.remove("hidden"), Lr(this, this.div, ["keydown"]));
    }
    get toolbarPosition() {
      return null;
    }
    keydown(a) {
      if (!this.isResizable || a.target !== this.div || a.key !== "Enter") return;
      this._uiManager.setSelected(this), this.#r = { savedX: this.x, savedY: this.y, savedWidth: this.width, savedHeight: this.height };
      const g = this.#i.children;
      if (!this.#A) {
        this.#A = Array.from(g);
        const f = this.#m.bind(this), m = this.#Q.bind(this), w = this._uiManager._signal;
        for (const k of this.#A) {
          const F = k.getAttribute("data-resizer-name");
          k.setAttribute("role", "spinbutton"), k.addEventListener("keydown", f, { signal: w }), k.addEventListener("blur", m, { signal: w }), k.addEventListener("focus", this.#R.bind(this, F), { signal: w }), k.setAttribute("data-l10n-id", $t._l10nResizer[F]);
        }
      }
      const l = this.#A[0];
      let B = 0;
      for (const f of g) {
        if (f === l) break;
        B++;
      }
      const Q = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#A.length / 4);
      if (Q !== B) {
        if (Q < B) for (let m = 0; m < B - Q; m++) this.#i.append(this.#i.firstChild);
        else if (Q > B) for (let m = 0; m < Q - B; m++) this.#i.firstChild.before(this.#i.lastChild);
        let f = 0;
        for (const m of g) {
          const w = this.#A[f++].getAttribute("data-resizer-name");
          m.setAttribute("data-l10n-id", $t._l10nResizer[w]);
        }
      }
      this.#v(0), this.#C = !0, this.#i.firstChild.focus({ focusVisible: !0 }), a.preventDefault(), a.stopImmediatePropagation();
    }
    #m(a) {
      $t._resizerKeyboardManager.exec(this, a);
    }
    #Q(a) {
      this.#C && a.relatedTarget?.parentNode !== this.#i && this.#M();
    }
    #R(a) {
      this.#h = this.#C ? a : "";
    }
    #v(a) {
      if (this.#A) for (const g of this.#A) g.tabIndex = a;
    }
    _resizeWithKeyboard(a, g) {
      this.#C && this.#b(this.#h, { movementX: a, movementY: g });
    }
    #M() {
      if (this.#C = !1, this.#v(-1), this.#r) {
        const { savedX: a, savedY: g, savedWidth: l, savedHeight: B } = this.#r;
        this.#f(a, g, l, B), this.#r = null;
      }
    }
    _stopResizingWithKeyboard() {
      this.#M(), this.div.focus();
    }
    select() {
      this.makeResizable(), this.div?.classList.add("selectedEditor"), this._editToolbar ? (this._editToolbar?.show(), this.#e?.toggleAltTextBadge(!1)) : this.addEditToolbar().then((() => {
        this.div?.classList.contains("selectedEditor") && this._editToolbar?.show();
      }));
    }
    unselect() {
      this.#i?.classList.add("hidden"), this.div?.classList.remove("selectedEditor"), this.div?.contains(document.activeElement) && this._uiManager.currentLayer.div.focus({ preventScroll: !0 }), this._editToolbar?.hide(), this.#e?.toggleAltTextBadge(!0);
    }
    updateParams(a, g) {
    }
    disableEditing() {
    }
    enableEditing() {
    }
    enterInEditMode() {
    }
    getImageForAltText() {
      return null;
    }
    get contentDiv() {
      return this.div;
    }
    get isEditing() {
      return this.#n;
    }
    set isEditing(a) {
      this.#n = a, this.parent && (a ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
    }
    setAspectRatio(a, g) {
      this.#a = !0;
      const l = a / g, { style: B } = this.div;
      B.aspectRatio = l, B.height = "auto";
    }
    static get MIN_SIZE() {
      return 16;
    }
    static canCreateNewEmptyEditor() {
      return !0;
    }
    get telemetryInitialData() {
      return { action: "added" };
    }
    get telemetryFinalData() {
      return null;
    }
    _reportTelemetry(a, g = !1) {
      if (g) {
        this.#u ||= /* @__PURE__ */ new Map();
        const { action: l } = a;
        let B = this.#u.get(l);
        return B && clearTimeout(B), B = setTimeout((() => {
          this._reportTelemetry(a), this.#u.delete(l), this.#u.size === 0 && (this.#u = null);
        }), $t._telemetryTimeout), void this.#u.set(l, B);
      }
      a.type ||= this.editorType, this._uiManager._eventBus.dispatch("reporttelemetry", { source: this, details: { type: "editing", data: a } });
    }
    show(a = this._isVisible) {
      this.div.classList.toggle("hidden", !a), this._isVisible = a;
    }
    enable() {
      this.div && (this.div.tabIndex = 0), this.#s = !1;
    }
    disable() {
      this.div && (this.div.tabIndex = -1), this.#s = !0;
    }
    renderAnnotationElement(a) {
      let g = a.container.querySelector(".annotationContent");
      if (g) {
        if (g.nodeName === "CANVAS") {
          const l = g;
          g = document.createElement("div"), g.classList.add("annotationContent", this.editorType), l.before(g);
        }
      } else g = document.createElement("div"), g.classList.add("annotationContent", this.editorType), a.container.prepend(g);
      return g;
    }
    resetAnnotationElement(a) {
      const { firstChild: g } = a.container;
      g.nodeName === "DIV" && g.classList.contains("annotationContent") && g.remove();
    }
  }
  class zf extends $t {
    constructor(a) {
      super(a), this.annotationElementId = a.annotationElementId, this.deleted = !0;
    }
    serialize() {
      return { id: this.annotationElementId, deleted: !0, pageIndex: this.pageIndex };
    }
  }
  const dI = 3285377520, Ze = 4294901760, as = 65535;
  class QI {
    constructor(a) {
      this.h1 = a ? 4294967295 & a : dI, this.h2 = a ? 4294967295 & a : dI;
    }
    update(a) {
      let g, l;
      if (typeof a == "string") {
        g = new Uint8Array(2 * a.length), l = 0;
        for (let X = 0, et = a.length; X < et; X++) {
          const At = a.charCodeAt(X);
          At <= 255 ? g[l++] = At : (g[l++] = At >>> 8, g[l++] = 255 & At);
        }
      } else {
        if (!ArrayBuffer.isView(a)) throw new Error("Invalid data format, must be a string or TypedArray.");
        g = a.slice(), l = g.byteLength;
      }
      const B = l >> 2, Q = l - 4 * B, f = new Uint32Array(g.buffer, 0, B);
      let m = 0, w = 0, k = this.h1, F = this.h2;
      const v = 3432918353, L = 461845907, J = 11601, K = 13715;
      for (let X = 0; X < B; X++) 1 & X ? (m = f[X], m = m * v & Ze | m * J & as, m = m << 15 | m >>> 17, m = m * L & Ze | m * K & as, k ^= m, k = k << 13 | k >>> 19, k = 5 * k + 3864292196) : (w = f[X], w = w * v & Ze | w * J & as, w = w << 15 | w >>> 17, w = w * L & Ze | w * K & as, F ^= w, F = F << 13 | F >>> 19, F = 5 * F + 3864292196);
      switch (m = 0, Q) {
        case 3:
          m ^= g[4 * B + 2] << 16;
        case 2:
          m ^= g[4 * B + 1] << 8;
        case 1:
          m ^= g[4 * B], m = m * v & Ze | m * J & as, m = m << 15 | m >>> 17, m = m * L & Ze | m * K & as, 1 & B ? k ^= m : F ^= m;
      }
      this.h1 = k, this.h2 = F;
    }
    hexdigest() {
      let a = this.h1, g = this.h2;
      return a ^= g >>> 1, a = 3981806797 * a & Ze | 36045 * a & as, g = 4283543511 * g & Ze | (2950163797 * (g << 16 | a >>> 16) & Ze) >>> 16, a ^= g >>> 1, a = 444984403 * a & Ze | 60499 * a & as, g = 3301882366 * g & Ze | (3120437893 * (g << 16 | a >>> 16) & Ze) >>> 16, a ^= g >>> 1, (a >>> 0).toString(16).padStart(8, "0") + (g >>> 0).toString(16).padStart(8, "0");
    }
  }
  const Jg = Object.freeze({ map: null, hash: "", transfer: void 0 });
  class Yg {
    #t = !1;
    #A = null;
    #e = /* @__PURE__ */ new Map();
    constructor() {
      this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
    }
    getValue(a, g) {
      const l = this.#e.get(a);
      return l === void 0 ? g : Object.assign(g, l);
    }
    getRawValue(a) {
      return this.#e.get(a);
    }
    remove(a) {
      if (this.#e.delete(a), this.#e.size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
        for (const g of this.#e.values()) if (g instanceof $t) return;
        this.onAnnotationEditor(null);
      }
    }
    setValue(a, g) {
      const l = this.#e.get(a);
      let B = !1;
      if (l !== void 0) for (const [Q, f] of Object.entries(g)) l[Q] !== f && (B = !0, l[Q] = f);
      else B = !0, this.#e.set(a, g);
      B && this.#s(), g instanceof $t && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(g.constructor._type);
    }
    has(a) {
      return this.#e.has(a);
    }
    getAll() {
      return this.#e.size > 0 ? Rg(this.#e) : null;
    }
    setAll(a) {
      for (const [g, l] of Object.entries(a)) this.setValue(g, l);
    }
    get size() {
      return this.#e.size;
    }
    #s() {
      this.#t || (this.#t = !0, typeof this.onSetModified == "function" && this.onSetModified());
    }
    resetModified() {
      this.#t && (this.#t = !1, typeof this.onResetModified == "function" && this.onResetModified());
    }
    get print() {
      return new EI(this);
    }
    get serializable() {
      if (this.#e.size === 0) return Jg;
      const a = /* @__PURE__ */ new Map(), g = new QI(), l = [], B = /* @__PURE__ */ Object.create(null);
      let Q = !1;
      for (const [f, m] of this.#e) {
        const w = m instanceof $t ? m.serialize(!1, B) : m;
        w && (a.set(f, w), g.update(`${f}:${JSON.stringify(w)}`), Q ||= !!w.bitmap);
      }
      if (Q) for (const f of a.values()) f.bitmap && l.push(f.bitmap);
      return a.size > 0 ? { map: a, hash: g.hexdigest(), transfer: l } : Jg;
    }
    get editorStats() {
      let a = null;
      const g = /* @__PURE__ */ new Map();
      for (const l of this.#e.values()) {
        if (!(l instanceof $t)) continue;
        const B = l.telemetryFinalData;
        if (!B) continue;
        const { type: Q } = B;
        g.has(Q) || g.set(Q, Object.getPrototypeOf(l).constructor), a ||= /* @__PURE__ */ Object.create(null);
        const f = a[Q] ||= /* @__PURE__ */ new Map();
        for (const [m, w] of Object.entries(B)) {
          if (m === "type") continue;
          let k = f.get(m);
          k || (k = /* @__PURE__ */ new Map(), f.set(m, k));
          const F = k.get(w) ?? 0;
          k.set(w, F + 1);
        }
      }
      for (const [l, B] of g) a[l] = B.computeTelemetryFinalData(a[l]);
      return a;
    }
    resetModifiedIds() {
      this.#A = null;
    }
    get modifiedIds() {
      if (this.#A) return this.#A;
      const a = [];
      for (const g of this.#e.values()) g instanceof $t && g.annotationElementId && g.serialize() && a.push(g.annotationElementId);
      return this.#A = { ids: new Set(a), hash: a.join(",") };
    }
  }
  class EI extends Yg {
    #t;
    constructor(a) {
      super();
      const { map: g, hash: l, transfer: B } = a.serializable, Q = structuredClone(g, B ? { transfer: B } : null);
      this.#t = { map: Q, hash: l, transfer: B };
    }
    get print() {
      Xt("Should not call PrintAnnotationStorage.print");
    }
    get serializable() {
      return this.#t;
    }
    get modifiedIds() {
      return aA(this, "modifiedIds", { ids: /* @__PURE__ */ new Set(), hash: "" });
    }
  }
  class $f {
    #t = /* @__PURE__ */ new Set();
    constructor({ ownerDocument: a = globalThis.document, styleElement: g = null }) {
      this._document = a, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
    }
    addNativeFontFace(a) {
      this.nativeFontFaces.add(a), this._document.fonts.add(a);
    }
    removeNativeFontFace(a) {
      this.nativeFontFaces.delete(a), this._document.fonts.delete(a);
    }
    insertRule(a) {
      this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
      const g = this.styleElement.sheet;
      g.insertRule(a, g.cssRules.length);
    }
    clear() {
      for (const a of this.nativeFontFaces) this._document.fonts.delete(a);
      this.nativeFontFaces.clear(), this.#t.clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
    }
    async loadSystemFont({ systemFontInfo: a, _inspectFont: g }) {
      if (a && !this.#t.has(a.loadedName)) if (wA(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
        const { loadedName: l, src: B, style: Q } = a, f = new FontFace(l, B, Q);
        this.addNativeFontFace(f);
        try {
          await f.load(), this.#t.add(l), g?.(a);
        } catch {
          qt(`Cannot load system font: ${a.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(f);
        }
      } else Xt("Not implemented: loadSystemFont without the Font Loading API.");
    }
    async bind(a) {
      if (a.attached || a.missingFile && !a.systemFontInfo) return;
      if (a.attached = !0, a.systemFontInfo) return void await this.loadSystemFont(a);
      if (this.isFontLoadingAPISupported) {
        const l = a.createNativeFontFace();
        if (l) {
          this.addNativeFontFace(l);
          try {
            await l.loaded;
          } catch (B) {
            throw qt(`Failed to load font '${l.family}': '${B}'.`), a.disableFontFace = !0, B;
          }
        }
        return;
      }
      const g = a.createFontFaceRule();
      if (g) {
        if (this.insertRule(g), this.isSyncFontLoadingSupported) return;
        await new Promise(((l) => {
          const B = this._queueLoadingCallback(l);
          this._prepareFontLoadEvent(a, B);
        }));
      }
    }
    get isFontLoadingAPISupported() {
      return aA(this, "isFontLoadingAPISupported", !!this._document?.fonts);
    }
    get isSyncFontLoadingSupported() {
      let a = !1;
      return (e || typeof navigator < "u" && typeof navigator?.userAgent == "string" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (a = !0), aA(this, "isSyncFontLoadingSupported", a);
    }
    _queueLoadingCallback(a) {
      const { loadingRequests: g } = this, l = { done: !1, complete: function() {
        for (wA(!l.done, "completeRequest() cannot be called twice."), l.done = !0; g.length > 0 && g[0].done; ) {
          const B = g.shift();
          setTimeout(B.callback, 0);
        }
      }, callback: a };
      return g.push(l), l;
    }
    get _loadTestFont() {
      return aA(this, "_loadTestFont", atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA=="));
    }
    _prepareFontLoadEvent(a, g) {
      function l(At, It) {
        return At.charCodeAt(It) << 24 | At.charCodeAt(It + 1) << 16 | At.charCodeAt(It + 2) << 8 | 255 & At.charCodeAt(It + 3);
      }
      function B(At, It, kt, Mt) {
        return At.substring(0, It) + Mt + At.substring(It + kt);
      }
      let Q, f;
      const m = this._document.createElement("canvas");
      m.width = 1, m.height = 1;
      const w = m.getContext("2d");
      let k = 0;
      const F = `lt${Date.now()}${this.loadTestFontId++}`;
      let v = this._loadTestFont;
      v = B(v, 976, F.length, F);
      const L = 1482184792;
      let J = l(v, 16);
      for (Q = 0, f = F.length - 3; Q < f; Q += 4) J = J - L + l(F, Q) | 0;
      var K;
      Q < F.length && (J = J - L + l(F + "XXX", Q) | 0), v = B(v, 16, 4, (K = J, String.fromCharCode(K >> 24 & 255, K >> 16 & 255, K >> 8 & 255, 255 & K)));
      const X = `@font-face {font-family:"${F}";src:${`url(data:font/opentype;base64,${btoa(v)});`}}`;
      this.insertRule(X);
      const et = this._document.createElement("div");
      et.style.visibility = "hidden", et.style.width = et.style.height = "10px", et.style.position = "absolute", et.style.top = et.style.left = "0px";
      for (const At of [a.loadedName, F]) {
        const It = this._document.createElement("span");
        It.textContent = "Hi", It.style.fontFamily = At, et.append(It);
      }
      this._document.body.append(et), (function At(It, kt) {
        if (++k > 30) return qt("Load test font never loaded."), void kt();
        w.font = "30px " + It, w.fillText(".", 0, 20), w.getImageData(0, 0, 1, 1).data[3] > 0 ? kt() : setTimeout(At.bind(null, It, kt));
      })(F, (() => {
        et.remove(), g.complete();
      }));
    }
  }
  class t2 {
    constructor(a, { disableFontFace: g = !1, inspectFont: l = null }) {
      this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
      for (const B in a) this[B] = a[B];
      this.disableFontFace = g === !0, this._inspectFont = l;
    }
    createNativeFontFace() {
      if (!this.data || this.disableFontFace) return null;
      let a;
      if (this.cssFontInfo) {
        const g = { weight: this.cssFontInfo.fontWeight };
        this.cssFontInfo.italicAngle && (g.style = `oblique ${this.cssFontInfo.italicAngle}deg`), a = new FontFace(this.cssFontInfo.fontFamily, this.data, g);
      } else a = new FontFace(this.loadedName, this.data, {});
      return this._inspectFont?.(this), a;
    }
    createFontFaceRule() {
      if (!this.data || this.disableFontFace) return null;
      const a = aI(this.data), g = `url(data:${this.mimetype};base64,${btoa(a)});`;
      let l;
      if (this.cssFontInfo) {
        let B = `font-weight: ${this.cssFontInfo.fontWeight};`;
        this.cssFontInfo.italicAngle && (B += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), l = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${B}src:${g}}`;
      } else l = `@font-face {font-family:"${this.loadedName}";src:${g}}`;
      return this._inspectFont?.(this, g), l;
    }
    getPathGenerator(a, g) {
      if (this.compiledGlyphs[g] !== void 0) return this.compiledGlyphs[g];
      let l;
      try {
        l = a.get(this.loadedName + "_path_" + g);
      } catch (Q) {
        qt(`getPathGenerator - ignoring character: "${Q}".`);
      }
      if (!Array.isArray(l) || l.length === 0) return this.compiledGlyphs[g] = function(Q, f) {
      };
      const B = [];
      for (let Q = 0, f = l.length; Q < f; ) switch (l[Q++]) {
        case Lf:
          {
            const [m, w, k, F, v, L] = l.slice(Q, Q + 6);
            B.push(((J) => J.bezierCurveTo(m, w, k, F, v, L))), Q += 6;
          }
          break;
        case Uf:
          {
            const [m, w] = l.slice(Q, Q + 2);
            B.push(((k) => k.moveTo(m, w))), Q += 2;
          }
          break;
        case Hf:
          {
            const [m, w] = l.slice(Q, Q + 2);
            B.push(((k) => k.lineTo(m, w))), Q += 2;
          }
          break;
        case Jf:
          {
            const [m, w, k, F] = l.slice(Q, Q + 4);
            B.push(((v) => v.quadraticCurveTo(m, w, k, F))), Q += 4;
          }
          break;
        case Yf:
          B.push(((m) => m.restore()));
          break;
        case Tf:
          B.push(((m) => m.save()));
          break;
        case Kf:
          wA(B.length === 2, "Scale command is only valid at the third position.");
          break;
        case qf:
          {
            const [m, w, k, F, v, L] = l.slice(Q, Q + 6);
            B.push(((J) => J.transform(m, w, k, F, v, L))), Q += 6;
          }
          break;
        case Pf: {
          const [m, w] = l.slice(Q, Q + 2);
          B.push(((k) => k.translate(m, w))), Q += 2;
        }
      }
      return this.compiledGlyphs[g] = function(Q, f) {
        B[0](Q), B[1](Q), Q.scale(f, -f);
        for (let m = 2, w = B.length; m < w; m++) B[m](Q);
      };
    }
  }
  if (e) {
    var Tg = Promise.withResolvers(), Kg = null;
    (async () => {
      const G = await Promise.resolve().then((function() {
        return qp;
      })), a = await Promise.resolve().then((function() {
        return I9;
      })), g = await Promise.resolve().then((function() {
        return d9;
      })), l = await Promise.resolve().then((function() {
        return E9;
      }));
      return new Map(Object.entries({ fs: G, http: a, https: g, url: l, canvas: void 0, path2d: void 0 }));
    })().then(((G) => {
      Kg = G, Tg.resolve();
    }), ((G) => {
      qt(`loadPackages: ${G}`), Kg = /* @__PURE__ */ new Map(), Tg.resolve();
    }));
  }
  class ns {
    static get promise() {
      return Tg.promise;
    }
    static get(a) {
      return Kg?.get(a);
    }
  }
  const fI = function(G) {
    return ns.get("fs").promises.readFile(G).then(((a) => new Uint8Array(a)));
  }, Js = "Fill", qg = "Stroke", Cn = "Shading";
  function Pg(G, a) {
    if (!a) return;
    const g = a[2] - a[0], l = a[3] - a[1], B = new Path2D();
    B.rect(a[0], a[1], g, l), G.clip(B);
  }
  class _g {
    getPattern() {
      Xt("Abstract method `getPattern` called.");
    }
  }
  class A2 extends _g {
    constructor(a) {
      super(), this._type = a[1], this._bbox = a[2], this._colorStops = a[3], this._p0 = a[4], this._p1 = a[5], this._r0 = a[6], this._r1 = a[7], this.matrix = null;
    }
    _createGradient(a) {
      let g;
      this._type === "axial" ? g = a.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (g = a.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
      for (const l of this._colorStops) g.addColorStop(l[0], l[1]);
      return g;
    }
    getPattern(a, g, l, B) {
      let Q;
      if (B === qg || B === Js) {
        const f = g.current.getClippedPathBoundingBox(B, vA(a)) || [0, 0, 0, 0], m = Math.ceil(f[2] - f[0]) || 1, w = Math.ceil(f[3] - f[1]) || 1, k = g.cachedCanvases.getCanvas("pattern", m, w, !0), F = k.context;
        F.clearRect(0, 0, F.canvas.width, F.canvas.height), F.beginPath(), F.rect(0, 0, F.canvas.width, F.canvas.height), F.translate(-f[0], -f[1]), l = Pt.transform(l, [1, 0, 0, 1, f[0], f[1]]), F.transform(...g.baseTransform), this.matrix && F.transform(...this.matrix), Pg(F, this._bbox), F.fillStyle = this._createGradient(F), F.fill(), Q = a.createPattern(k.canvas, "no-repeat");
        const v = new DOMMatrix(l);
        Q.setTransform(v);
      } else Pg(a, this._bbox), Q = this._createGradient(a);
      return Q;
    }
  }
  function Og(G, a, g, l, B, Q, f, m) {
    const w = a.coords, k = a.colors, F = G.data, v = 4 * G.width;
    let L;
    w[g + 1] > w[l + 1] && (L = g, g = l, l = L, L = Q, Q = f, f = L), w[l + 1] > w[B + 1] && (L = l, l = B, B = L, L = f, f = m, m = L), w[g + 1] > w[l + 1] && (L = g, g = l, l = L, L = Q, Q = f, f = L);
    const J = (w[g] + a.offsetX) * a.scaleX, K = (w[g + 1] + a.offsetY) * a.scaleY, X = (w[l] + a.offsetX) * a.scaleX, et = (w[l + 1] + a.offsetY) * a.scaleY, At = (w[B] + a.offsetX) * a.scaleX, It = (w[B + 1] + a.offsetY) * a.scaleY;
    if (K >= It) return;
    const kt = k[Q], Mt = k[Q + 1], Ut = k[Q + 2], xt = k[f], Wt = k[f + 1], eA = k[f + 2], nA = k[m], EA = k[m + 1], sA = k[m + 2], ke = Math.round(K), ZA = Math.round(It);
    let kA, se, oi, os, rA, dA, qr, ya;
    for (let Ue = ke; Ue <= ZA; Ue++) {
      if (Ue < et) {
        const ae = Ue < K ? 0 : (K - Ue) / (K - et);
        kA = J - (J - X) * ae, se = kt - (kt - xt) * ae, oi = Mt - (Mt - Wt) * ae, os = Ut - (Ut - eA) * ae;
      } else {
        let ae;
        ae = Ue > It ? 1 : et === It ? 0 : (et - Ue) / (et - It), kA = X - (X - At) * ae, se = xt - (xt - nA) * ae, oi = Wt - (Wt - EA) * ae, os = eA - (eA - sA) * ae;
      }
      let Qe;
      Qe = Ue < K ? 0 : Ue > It ? 1 : (K - Ue) / (K - It), rA = J - (J - At) * Qe, dA = kt - (kt - nA) * Qe, qr = Mt - (Mt - EA) * Qe, ya = Ut - (Ut - sA) * Qe;
      const mA = Math.round(Math.min(kA, rA)), pn = Math.round(Math.max(kA, rA));
      let He = v * Ue + 4 * mA;
      for (let ae = mA; ae <= pn; ae++) Qe = (kA - ae) / (kA - rA), Qe < 0 ? Qe = 0 : Qe > 1 && (Qe = 1), F[He++] = se - (se - dA) * Qe | 0, F[He++] = oi - (oi - qr) * Qe | 0, F[He++] = os - (os - ya) * Qe | 0, F[He++] = 255;
    }
  }
  function e2(G, a, g) {
    const l = a.coords, B = a.colors;
    let Q, f;
    switch (a.type) {
      case "lattice":
        const m = a.verticesPerRow, w = Math.floor(l.length / m) - 1, k = m - 1;
        for (Q = 0; Q < w; Q++) {
          let F = Q * m;
          for (let v = 0; v < k; v++, F++) Og(G, g, l[F], l[F + 1], l[F + m], B[F], B[F + 1], B[F + m]), Og(G, g, l[F + m + 1], l[F + 1], l[F + m], B[F + m + 1], B[F + 1], B[F + m]);
        }
        break;
      case "triangles":
        for (Q = 0, f = l.length; Q < f; Q += 3) Og(G, g, l[Q], l[Q + 1], l[Q + 2], B[Q], B[Q + 1], B[Q + 2]);
        break;
      default:
        throw new Error("illegal figure");
    }
  }
  class i2 extends _g {
    constructor(a) {
      super(), this._coords = a[2], this._colors = a[3], this._figures = a[4], this._bounds = a[5], this._bbox = a[7], this._background = a[8], this.matrix = null;
    }
    _createMeshCanvas(a, g, l) {
      const B = Math.floor(this._bounds[0]), Q = Math.floor(this._bounds[1]), f = Math.ceil(this._bounds[2]) - B, m = Math.ceil(this._bounds[3]) - Q, w = Math.min(Math.ceil(Math.abs(f * a[0] * 1.1)), 3e3), k = Math.min(Math.ceil(Math.abs(m * a[1] * 1.1)), 3e3), F = f / w, v = m / k, L = { coords: this._coords, colors: this._colors, offsetX: -B, offsetY: -Q, scaleX: 1 / F, scaleY: 1 / v }, J = w + 4, K = k + 4, X = l.getCanvas("mesh", J, K, !1), et = X.context, At = et.createImageData(w, k);
      if (g) {
        const It = At.data;
        for (let kt = 0, Mt = It.length; kt < Mt; kt += 4) It[kt] = g[0], It[kt + 1] = g[1], It[kt + 2] = g[2], It[kt + 3] = 255;
      }
      for (const It of this._figures) e2(At, It, L);
      return et.putImageData(At, 2, 2), { canvas: X.canvas, offsetX: B - 2 * F, offsetY: Q - 2 * v, scaleX: F, scaleY: v };
    }
    getPattern(a, g, l, B) {
      let Q;
      if (Pg(a, this._bbox), B === Cn) Q = Pt.singularValueDecompose2dScale(vA(a));
      else if (Q = Pt.singularValueDecompose2dScale(g.baseTransform), this.matrix) {
        const m = Pt.singularValueDecompose2dScale(this.matrix);
        Q = [Q[0] * m[0], Q[1] * m[1]];
      }
      const f = this._createMeshCanvas(Q, B === Cn ? null : this._background, g.cachedCanvases);
      return B !== Cn && (a.setTransform(...g.baseTransform), this.matrix && a.transform(...this.matrix)), a.translate(f.offsetX, f.offsetY), a.scale(f.scaleX, f.scaleY), a.createPattern(f.canvas, "no-repeat");
    }
  }
  class s2 extends _g {
    getPattern() {
      return "hotpink";
    }
  }
  const a2 = 1, n2 = 2;
  class Wg {
    static MAX_PATTERN_SIZE = 3e3;
    constructor(a, g, l, B, Q) {
      this.operatorList = a[2], this.matrix = a[3], this.bbox = a[4], this.xstep = a[5], this.ystep = a[6], this.paintType = a[7], this.tilingType = a[8], this.color = g, this.ctx = l, this.canvasGraphicsFactory = B, this.baseTransform = Q;
    }
    createPatternCanvas(a) {
      const g = this.operatorList, l = this.bbox, B = this.xstep, Q = this.ystep, f = this.paintType, m = this.tilingType, w = this.color, k = this.canvasGraphicsFactory;
      Zt("TilingType: " + m);
      const F = l[0], v = l[1], L = l[2], J = l[3], K = Pt.singularValueDecompose2dScale(this.matrix), X = Pt.singularValueDecompose2dScale(this.baseTransform), et = [K[0] * X[0], K[1] * X[1]], At = this.getSizeAndScale(B, this.ctx.canvas.width, et[0]), It = this.getSizeAndScale(Q, this.ctx.canvas.height, et[1]), kt = a.cachedCanvases.getCanvas("pattern", At.size, It.size, !0), Mt = kt.context, Ut = k.createCanvasGraphics(Mt);
      Ut.groupLevel = a.groupLevel, this.setFillAndStrokeStyleToContext(Ut, f, w);
      let xt = F, Wt = v, eA = L, nA = J;
      return F < 0 && (xt = 0, eA += Math.abs(F)), v < 0 && (Wt = 0, nA += Math.abs(v)), Mt.translate(-At.scale * xt, -It.scale * Wt), Ut.transform(At.scale, 0, 0, It.scale, 0, 0), Mt.save(), this.clipBbox(Ut, xt, Wt, eA, nA), Ut.baseTransform = vA(Ut.ctx), Ut.executeOperatorList(g), Ut.endDrawing(), { canvas: kt.canvas, scaleX: At.scale, scaleY: It.scale, offsetX: xt, offsetY: Wt };
    }
    getSizeAndScale(a, g, l) {
      a = Math.abs(a);
      const B = Math.max(Wg.MAX_PATTERN_SIZE, g);
      let Q = Math.ceil(a * l);
      return Q >= B ? Q = B : l = Q / a, { scale: l, size: Q };
    }
    clipBbox(a, g, l, B, Q) {
      const f = B - g, m = Q - l;
      a.ctx.rect(g, l, f, m), a.current.updateRectMinMax(vA(a.ctx), [g, l, B, Q]), a.clip(), a.endPath();
    }
    setFillAndStrokeStyleToContext(a, g, l) {
      const B = a.ctx, Q = a.current;
      switch (g) {
        case a2:
          const f = this.ctx;
          B.fillStyle = f.fillStyle, B.strokeStyle = f.strokeStyle, Q.fillColor = f.fillStyle, Q.strokeColor = f.strokeStyle;
          break;
        case n2:
          const m = Pt.makeHexColor(l[0], l[1], l[2]);
          B.fillStyle = m, B.strokeStyle = m, Q.fillColor = m, Q.strokeColor = m;
          break;
        default:
          throw new vf(`Unsupported paint type: ${g}`);
      }
    }
    getPattern(a, g, l, B) {
      let Q = l;
      B !== Cn && (Q = Pt.transform(Q, g.baseTransform), this.matrix && (Q = Pt.transform(Q, this.matrix)));
      const f = this.createPatternCanvas(g);
      let m = new DOMMatrix(Q);
      m = m.translate(f.offsetX, f.offsetY), m = m.scale(1 / f.scaleX, 1 / f.scaleY);
      const w = a.createPattern(f.canvas, "repeat");
      return w.setTransform(m), w;
    }
  }
  function r2({ src: G, srcPos: a = 0, dest: g, width: l, height: B, nonBlackColor: Q = 4294967295, inverseDecode: f = !1 }) {
    const m = be.isLittleEndian ? 4278190080 : 255, [w, k] = f ? [Q, m] : [m, Q], F = l >> 3, v = 7 & l, L = G.length;
    g = new Uint32Array(g.buffer);
    let J = 0;
    for (let K = 0; K < B; K++) {
      for (const et = a + F; a < et; a++) {
        const At = a < L ? G[a] : 255;
        g[J++] = 128 & At ? k : w, g[J++] = 64 & At ? k : w, g[J++] = 32 & At ? k : w, g[J++] = 16 & At ? k : w, g[J++] = 8 & At ? k : w, g[J++] = 4 & At ? k : w, g[J++] = 2 & At ? k : w, g[J++] = 1 & At ? k : w;
      }
      if (v === 0) continue;
      const X = a < L ? G[a++] : 255;
      for (let et = 0; et < v; et++) g[J++] = X & 1 << 7 - et ? k : w;
    }
    return { srcPos: a, destPos: J };
  }
  const De = 16;
  class o2 {
    constructor(a) {
      this.canvasFactory = a, this.cache = /* @__PURE__ */ Object.create(null);
    }
    getCanvas(a, g, l) {
      let B;
      return this.cache[a] !== void 0 ? (B = this.cache[a], this.canvasFactory.reset(B, g, l)) : (B = this.canvasFactory.create(g, l), this.cache[a] = B), B;
    }
    delete(a) {
      delete this.cache[a];
    }
    clear() {
      for (const a in this.cache) {
        const g = this.cache[a];
        this.canvasFactory.destroy(g), delete this.cache[a];
      }
    }
  }
  function Ur(G, a, g, l, B, Q, f, m, w, k) {
    const [F, v, L, J, K, X] = vA(G);
    if (v === 0 && L === 0) {
      const et = f * F + K, At = Math.round(et), It = m * J + X, kt = Math.round(It), Mt = (f + w) * F + K, Ut = Math.abs(Math.round(Mt) - At) || 1, xt = (m + k) * J + X, Wt = Math.abs(Math.round(xt) - kt) || 1;
      return G.setTransform(Math.sign(F), 0, 0, Math.sign(J), At, kt), G.drawImage(a, g, l, B, Q, 0, 0, Ut, Wt), G.setTransform(F, v, L, J, K, X), [Ut, Wt];
    }
    if (F === 0 && J === 0) {
      const et = m * L + K, At = Math.round(et), It = f * v + X, kt = Math.round(It), Mt = (m + k) * L + K, Ut = Math.abs(Math.round(Mt) - At) || 1, xt = (f + w) * v + X, Wt = Math.abs(Math.round(xt) - kt) || 1;
      return G.setTransform(0, Math.sign(v), Math.sign(L), 0, At, kt), G.drawImage(a, g, l, B, Q, 0, 0, Wt, Ut), G.setTransform(F, v, L, J, K, X), [Wt, Ut];
    }
    return G.drawImage(a, g, l, B, Q, f, m, w, k), [Math.hypot(F, v) * w, Math.hypot(L, J) * k];
  }
  class pI {
    constructor(a, g) {
      this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = i, this.textMatrixScale = 1, this.fontMatrix = s, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = D, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, a, g]);
    }
    clone() {
      const a = Object.create(this);
      return a.clipBox = this.clipBox.slice(), a;
    }
    setCurrentPoint(a, g) {
      this.x = a, this.y = g;
    }
    updatePathMinMax(a, g, l) {
      [g, l] = Pt.applyTransform([g, l], a), this.minX = Math.min(this.minX, g), this.minY = Math.min(this.minY, l), this.maxX = Math.max(this.maxX, g), this.maxY = Math.max(this.maxY, l);
    }
    updateRectMinMax(a, g) {
      const l = Pt.applyTransform(g, a), B = Pt.applyTransform(g.slice(2), a), Q = Pt.applyTransform([g[0], g[3]], a), f = Pt.applyTransform([g[2], g[1]], a);
      this.minX = Math.min(this.minX, l[0], B[0], Q[0], f[0]), this.minY = Math.min(this.minY, l[1], B[1], Q[1], f[1]), this.maxX = Math.max(this.maxX, l[0], B[0], Q[0], f[0]), this.maxY = Math.max(this.maxY, l[1], B[1], Q[1], f[1]);
    }
    updateScalingPathMinMax(a, g) {
      Pt.scaleMinMax(a, g), this.minX = Math.min(this.minX, g[0]), this.minY = Math.min(this.minY, g[1]), this.maxX = Math.max(this.maxX, g[2]), this.maxY = Math.max(this.maxY, g[3]);
    }
    updateCurvePathMinMax(a, g, l, B, Q, f, m, w, k, F) {
      const v = Pt.bezierBoundingBox(g, l, B, Q, f, m, w, k, F);
      F || this.updateRectMinMax(a, v);
    }
    getPathBoundingBox(a = Js, g = null) {
      const l = [this.minX, this.minY, this.maxX, this.maxY];
      if (a === qg) {
        g || Xt("Stroke bounding box must include transform.");
        const B = Pt.singularValueDecompose2dScale(g), Q = B[0] * this.lineWidth / 2, f = B[1] * this.lineWidth / 2;
        l[0] -= Q, l[1] -= f, l[2] += Q, l[3] += f;
      }
      return l;
    }
    updateClipFromPath() {
      const a = Pt.intersect(this.clipBox, this.getPathBoundingBox());
      this.startNewPathAndClipBox(a || [0, 0, 0, 0]);
    }
    isEmptyClip() {
      return this.minX === 1 / 0;
    }
    startNewPathAndClipBox(a) {
      this.clipBox = a, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
    }
    getClippedPathBoundingBox(a = Js, g = null) {
      return Pt.intersect(this.clipBox, this.getPathBoundingBox(a, g));
    }
  }
  function mI(G, a) {
    if (typeof ImageData < "u" && a instanceof ImageData) return void G.putImageData(a, 0, 0);
    const g = a.height, l = a.width, B = g % De, Q = (g - B) / De, f = B === 0 ? Q : Q + 1, m = G.createImageData(l, De);
    let w, k = 0;
    const F = a.data, v = m.data;
    let L, J, K, X;
    if (a.kind === T.GRAYSCALE_1BPP) {
      const et = F.byteLength, At = new Uint32Array(v.buffer, 0, v.byteLength >> 2), It = At.length, kt = l + 7 >> 3, Mt = 4294967295, Ut = be.isLittleEndian ? 4278190080 : 255;
      for (L = 0; L < f; L++) {
        for (K = L < Q ? De : B, w = 0, J = 0; J < K; J++) {
          const xt = et - k;
          let Wt = 0;
          const eA = xt > kt ? l : 8 * xt - 7, nA = -8 & eA;
          let EA = 0, sA = 0;
          for (; Wt < nA; Wt += 8) sA = F[k++], At[w++] = 128 & sA ? Mt : Ut, At[w++] = 64 & sA ? Mt : Ut, At[w++] = 32 & sA ? Mt : Ut, At[w++] = 16 & sA ? Mt : Ut, At[w++] = 8 & sA ? Mt : Ut, At[w++] = 4 & sA ? Mt : Ut, At[w++] = 2 & sA ? Mt : Ut, At[w++] = 1 & sA ? Mt : Ut;
          for (; Wt < eA; Wt++) EA === 0 && (sA = F[k++], EA = 128), At[w++] = sA & EA ? Mt : Ut, EA >>= 1;
        }
        for (; w < It; ) At[w++] = 0;
        G.putImageData(m, 0, L * De);
      }
    } else if (a.kind === T.RGBA_32BPP) {
      for (J = 0, X = l * De * 4, L = 0; L < Q; L++) v.set(F.subarray(k, k + X)), k += X, G.putImageData(m, 0, J), J += De;
      L < f && (X = l * B * 4, v.set(F.subarray(k, k + X)), G.putImageData(m, 0, J));
    } else {
      if (a.kind !== T.RGB_24BPP) throw new Error(`bad image kind: ${a.kind}`);
      for (K = De, X = l * K, L = 0; L < f; L++) {
        for (L >= Q && (K = B, X = l * K), w = 0, J = X; J--; ) v[w++] = F[k++], v[w++] = F[k++], v[w++] = F[k++], v[w++] = 255;
        G.putImageData(m, 0, L * De);
      }
    }
  }
  function yI(G, a) {
    if (a.bitmap) return void G.drawImage(a.bitmap, 0, 0);
    const g = a.height, l = a.width, B = g % De, Q = (g - B) / De, f = B === 0 ? Q : Q + 1, m = G.createImageData(l, De);
    let w = 0;
    const k = a.data, F = m.data;
    for (let v = 0; v < f; v++) {
      const L = v < Q ? De : B;
      ({ srcPos: w } = r2({ src: k, srcPos: w, dest: F, width: l, height: L, nonBlackColor: 0 })), G.putImageData(m, 0, v * De);
    }
  }
  function un(G, a) {
    const g = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
    for (const l of g) G[l] !== void 0 && (a[l] = G[l]);
    G.setLineDash !== void 0 && (a.setLineDash(G.getLineDash()), a.lineDashOffset = G.lineDashOffset);
  }
  function Hr(G) {
    if (G.strokeStyle = G.fillStyle = "#000000", G.fillRule = "nonzero", G.globalAlpha = 1, G.lineWidth = 1, G.lineCap = "butt", G.lineJoin = "miter", G.miterLimit = 10, G.globalCompositeOperation = "source-over", G.font = "10px sans-serif", G.setLineDash !== void 0 && (G.setLineDash([]), G.lineDashOffset = 0), !e) {
      const { filter: a } = G;
      a !== "none" && a !== "" && (G.filter = "none");
    }
  }
  function wI(G, a) {
    if (a) return !0;
    const g = Pt.singularValueDecompose2dScale(G);
    g[0] = Math.fround(g[0]), g[1] = Math.fround(g[1]);
    const l = Math.fround((globalThis.devicePixelRatio || 1) * fa.PDF_TO_CSS_UNITS);
    return g[0] <= l && g[1] <= l;
  }
  const g2 = ["butt", "round", "square"], c2 = ["miter", "round", "bevel"], h2 = {}, bI = {};
  class pa {
    constructor(a, g, l, B, Q, { optionalContentConfig: f, markedContentStack: m = null }, w, k) {
      this.ctx = a, this.current = new pI(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = g, this.objs = l, this.canvasFactory = B, this.filterFactory = Q, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = m || [], this.optionalContentConfig = f, this.cachedCanvases = new o2(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = w, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = k, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
    }
    getObject(a, g = null) {
      return typeof a == "string" ? a.startsWith("g_") ? this.commonObjs.get(a) : this.objs.get(a) : g;
    }
    beginDrawing({ transform: a, viewport: g, transparency: l = !1, background: B = null }) {
      const Q = this.ctx.canvas.width, f = this.ctx.canvas.height, m = this.ctx.fillStyle;
      if (this.ctx.fillStyle = B || "#ffffff", this.ctx.fillRect(0, 0, Q, f), this.ctx.fillStyle = m, l) {
        const w = this.cachedCanvases.getCanvas("transparent", Q, f);
        this.compositeCtx = this.ctx, this.transparentCanvas = w.canvas, this.ctx = w.context, this.ctx.save(), this.ctx.transform(...vA(this.compositeCtx));
      }
      this.ctx.save(), Hr(this.ctx), a && (this.ctx.transform(...a), this.outputScaleX = a[0], this.outputScaleY = a[0]), this.ctx.transform(...g.transform), this.viewportScale = g.scale, this.baseTransform = vA(this.ctx);
    }
    executeOperatorList(a, g, l, B) {
      const Q = a.argsArray, f = a.fnArray;
      let m = g || 0;
      const w = Q.length;
      if (w === m) return m;
      const k = w - m > 10 && typeof l == "function", F = k ? Date.now() + 15 : 0;
      let v = 0;
      const L = this.commonObjs, J = this.objs;
      let K;
      for (; ; ) {
        if (B !== void 0 && m === B.nextBreakPoint) return B.breakIt(m, l), m;
        if (K = f[m], K !== yt.dependency) this[K].apply(this, Q[m]);
        else for (const X of Q[m]) {
          const et = X.startsWith("g_") ? L : J;
          if (!et.has(X)) return et.get(X, l), m;
        }
        if (m++, m === w) return m;
        if (k && ++v > 10) {
          if (Date.now() > F) return l(), m;
          v = 0;
        }
      }
    }
    #t() {
      for (; this.stateStack.length || this.inSMaskMode; ) this.restore();
      this.current.activeSMask = null, this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
    }
    endDrawing() {
      this.#t(), this.cachedCanvases.clear(), this.cachedPatterns.clear();
      for (const a of this._cachedBitmapsMap.values()) {
        for (const g of a.values()) typeof HTMLCanvasElement < "u" && g instanceof HTMLCanvasElement && (g.width = g.height = 0);
        a.clear();
      }
      this._cachedBitmapsMap.clear(), this.#A();
    }
    #A() {
      if (this.pageColors) {
        const a = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
        if (a !== "none") {
          const g = this.ctx.filter;
          this.ctx.filter = a, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = g;
        }
      }
    }
    _scaleImage(a, g) {
      const l = a.width, B = a.height;
      let Q, f, m = Math.max(Math.hypot(g[0], g[1]), 1), w = Math.max(Math.hypot(g[2], g[3]), 1), k = l, F = B, v = "prescale1";
      for (; m > 2 && k > 1 || w > 2 && F > 1; ) {
        let L = k, J = F;
        m > 2 && k > 1 && (L = k >= 16384 ? Math.floor(k / 2) - 1 || 1 : Math.ceil(k / 2), m /= k / L), w > 2 && F > 1 && (J = F >= 16384 ? Math.floor(F / 2) - 1 || 1 : Math.ceil(F) / 2, w /= F / J), Q = this.cachedCanvases.getCanvas(v, L, J), f = Q.context, f.clearRect(0, 0, L, J), f.drawImage(a, 0, 0, k, F, 0, 0, L, J), a = Q.canvas, k = L, F = J, v = v === "prescale1" ? "prescale2" : "prescale1";
      }
      return { img: a, paintWidth: k, paintHeight: F };
    }
    _createMaskCanvas(a) {
      const g = this.ctx, { width: l, height: B } = a, Q = this.current.fillColor, f = this.current.patternFill, m = vA(g);
      let w, k, F, v;
      if ((a.bitmap || a.data) && a.count > 1) {
        const eA = a.bitmap || a.data.buffer;
        k = JSON.stringify(f ? m : [m.slice(0, 4), Q]), w = this._cachedBitmapsMap.get(eA), w || (w = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(eA, w));
        const nA = w.get(k);
        if (nA && !f)
          return { canvas: nA, offsetX: Math.round(Math.min(m[0], m[2]) + m[4]), offsetY: Math.round(Math.min(m[1], m[3]) + m[5]) };
        F = nA;
      }
      F || (v = this.cachedCanvases.getCanvas("maskCanvas", l, B), yI(v.context, a));
      let L = Pt.transform(m, [1 / l, 0, 0, -1 / B, 0, 0]);
      L = Pt.transform(L, [1, 0, 0, 1, 0, -B]);
      const [J, K, X, et] = Pt.getAxialAlignedBoundingBox([0, 0, l, B], L), At = Math.round(X - J) || 1, It = Math.round(et - K) || 1, kt = this.cachedCanvases.getCanvas("fillCanvas", At, It), Mt = kt.context, Ut = J, xt = K;
      Mt.translate(-Ut, -xt), Mt.transform(...L), F || (F = this._scaleImage(v.canvas, Ui(Mt)), F = F.img, w && f && w.set(k, F)), Mt.imageSmoothingEnabled = wI(vA(Mt), a.interpolate), Ur(Mt, F, 0, 0, F.width, F.height, 0, 0, l, B), Mt.globalCompositeOperation = "source-in";
      const Wt = Pt.transform(Ui(Mt), [1, 0, 0, 1, -Ut, -xt]);
      return Mt.fillStyle = f ? Q.getPattern(g, this, Wt, Js) : Q, Mt.fillRect(0, 0, l, B), w && !f && (this.cachedCanvases.delete("fillCanvas"), w.set(k, kt.canvas)), { canvas: kt.canvas, offsetX: Math.round(Ut), offsetY: Math.round(xt) };
    }
    setLineWidth(a) {
      a !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = a, this.ctx.lineWidth = a;
    }
    setLineCap(a) {
      this.ctx.lineCap = g2[a];
    }
    setLineJoin(a) {
      this.ctx.lineJoin = c2[a];
    }
    setMiterLimit(a) {
      this.ctx.miterLimit = a;
    }
    setDash(a, g) {
      const l = this.ctx;
      l.setLineDash !== void 0 && (l.setLineDash(a), l.lineDashOffset = g);
    }
    setRenderingIntent(a) {
    }
    setFlatness(a) {
    }
    setGState(a) {
      for (const [g, l] of a) switch (g) {
        case "LW":
          this.setLineWidth(l);
          break;
        case "LC":
          this.setLineCap(l);
          break;
        case "LJ":
          this.setLineJoin(l);
          break;
        case "ML":
          this.setMiterLimit(l);
          break;
        case "D":
          this.setDash(l[0], l[1]);
          break;
        case "RI":
          this.setRenderingIntent(l);
          break;
        case "FL":
          this.setFlatness(l);
          break;
        case "Font":
          this.setFont(l[0], l[1]);
          break;
        case "CA":
          this.current.strokeAlpha = l;
          break;
        case "ca":
          this.current.fillAlpha = l, this.ctx.globalAlpha = l;
          break;
        case "BM":
          this.ctx.globalCompositeOperation = l;
          break;
        case "SMask":
          this.current.activeSMask = l ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
          break;
        case "TR":
          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(l);
      }
    }
    get inSMaskMode() {
      return !!this.suspendedCtx;
    }
    checkSMaskState() {
      const a = this.inSMaskMode;
      this.current.activeSMask && !a ? this.beginSMaskMode() : !this.current.activeSMask && a && this.endSMaskMode();
    }
    beginSMaskMode() {
      if (this.inSMaskMode) throw new Error("beginSMaskMode called while already in smask mode");
      const a = this.ctx.canvas.width, g = this.ctx.canvas.height, l = "smaskGroupAt" + this.groupLevel, B = this.cachedCanvases.getCanvas(l, a, g);
      this.suspendedCtx = this.ctx, this.ctx = B.context;
      const Q = this.ctx;
      Q.setTransform(...vA(this.suspendedCtx)), un(this.suspendedCtx, Q), (function(f, m) {
        if (f._removeMirroring) throw new Error("Context is already forwarding operations.");
        f.__originalSave = f.save, f.__originalRestore = f.restore, f.__originalRotate = f.rotate, f.__originalScale = f.scale, f.__originalTranslate = f.translate, f.__originalTransform = f.transform, f.__originalSetTransform = f.setTransform, f.__originalResetTransform = f.resetTransform, f.__originalClip = f.clip, f.__originalMoveTo = f.moveTo, f.__originalLineTo = f.lineTo, f.__originalBezierCurveTo = f.bezierCurveTo, f.__originalRect = f.rect, f.__originalClosePath = f.closePath, f.__originalBeginPath = f.beginPath, f._removeMirroring = () => {
          f.save = f.__originalSave, f.restore = f.__originalRestore, f.rotate = f.__originalRotate, f.scale = f.__originalScale, f.translate = f.__originalTranslate, f.transform = f.__originalTransform, f.setTransform = f.__originalSetTransform, f.resetTransform = f.__originalResetTransform, f.clip = f.__originalClip, f.moveTo = f.__originalMoveTo, f.lineTo = f.__originalLineTo, f.bezierCurveTo = f.__originalBezierCurveTo, f.rect = f.__originalRect, f.closePath = f.__originalClosePath, f.beginPath = f.__originalBeginPath, delete f._removeMirroring;
        }, f.save = function() {
          m.save(), this.__originalSave();
        }, f.restore = function() {
          m.restore(), this.__originalRestore();
        }, f.translate = function(w, k) {
          m.translate(w, k), this.__originalTranslate(w, k);
        }, f.scale = function(w, k) {
          m.scale(w, k), this.__originalScale(w, k);
        }, f.transform = function(w, k, F, v, L, J) {
          m.transform(w, k, F, v, L, J), this.__originalTransform(w, k, F, v, L, J);
        }, f.setTransform = function(w, k, F, v, L, J) {
          m.setTransform(w, k, F, v, L, J), this.__originalSetTransform(w, k, F, v, L, J);
        }, f.resetTransform = function() {
          m.resetTransform(), this.__originalResetTransform();
        }, f.rotate = function(w) {
          m.rotate(w), this.__originalRotate(w);
        }, f.clip = function(w) {
          m.clip(w), this.__originalClip(w);
        }, f.moveTo = function(w, k) {
          m.moveTo(w, k), this.__originalMoveTo(w, k);
        }, f.lineTo = function(w, k) {
          m.lineTo(w, k), this.__originalLineTo(w, k);
        }, f.bezierCurveTo = function(w, k, F, v, L, J) {
          m.bezierCurveTo(w, k, F, v, L, J), this.__originalBezierCurveTo(w, k, F, v, L, J);
        }, f.rect = function(w, k, F, v) {
          m.rect(w, k, F, v), this.__originalRect(w, k, F, v);
        }, f.closePath = function() {
          m.closePath(), this.__originalClosePath();
        }, f.beginPath = function() {
          m.beginPath(), this.__originalBeginPath();
        };
      })(Q, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
    }
    endSMaskMode() {
      if (!this.inSMaskMode) throw new Error("endSMaskMode called while not in smask mode");
      this.ctx._removeMirroring(), un(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
    }
    compose(a) {
      if (!this.current.activeSMask) return;
      a ? (a[0] = Math.floor(a[0]), a[1] = Math.floor(a[1]), a[2] = Math.ceil(a[2]), a[3] = Math.ceil(a[3])) : a = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
      const g = this.current.activeSMask, l = this.suspendedCtx;
      this.composeSMask(l, g, this.ctx, a), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
    }
    composeSMask(a, g, l, B) {
      const Q = B[0], f = B[1], m = B[2] - Q, w = B[3] - f;
      m !== 0 && w !== 0 && (this.genericComposeSMask(g.context, l, m, w, g.subtype, g.backdrop, g.transferMap, Q, f, g.offsetX, g.offsetY), a.save(), a.globalAlpha = 1, a.globalCompositeOperation = "source-over", a.setTransform(1, 0, 0, 1, 0, 0), a.drawImage(l.canvas, 0, 0), a.restore());
    }
    genericComposeSMask(a, g, l, B, Q, f, m, w, k, F, v) {
      let L = a.canvas, J = w - F, K = k - v;
      if (f) {
        if (J < 0 || K < 0 || J + l > L.width || K + B > L.height) {
          const et = this.cachedCanvases.getCanvas("maskExtension", l, B), At = et.context;
          At.drawImage(L, -J, -K), f.some(((It) => It !== 0)) && (At.globalCompositeOperation = "destination-atop", At.fillStyle = Pt.makeHexColor(...f), At.fillRect(0, 0, l, B), At.globalCompositeOperation = "source-over"), L = et.canvas, J = K = 0;
        } else if (f.some(((et) => et !== 0))) {
          a.save(), a.globalAlpha = 1, a.setTransform(1, 0, 0, 1, 0, 0);
          const et = new Path2D();
          et.rect(J, K, l, B), a.clip(et), a.globalCompositeOperation = "destination-atop", a.fillStyle = Pt.makeHexColor(...f), a.fillRect(J, K, l, B), a.restore();
        }
      }
      g.save(), g.globalAlpha = 1, g.setTransform(1, 0, 0, 1, 0, 0), Q === "Alpha" && m ? g.filter = this.filterFactory.addAlphaFilter(m) : Q === "Luminosity" && (g.filter = this.filterFactory.addLuminosityFilter(m));
      const X = new Path2D();
      X.rect(w, k, l, B), g.clip(X), g.globalCompositeOperation = "destination-in", g.drawImage(L, J, K, l, B, w, k, l, B), g.restore();
    }
    save() {
      this.inSMaskMode ? (un(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
      const a = this.current;
      this.stateStack.push(a), this.current = a.clone();
    }
    restore() {
      this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), un(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
    }
    transform(a, g, l, B, Q, f) {
      this.ctx.transform(a, g, l, B, Q, f), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
    }
    constructPath(a, g, l) {
      const B = this.ctx, Q = this.current;
      let f, m, w = Q.x, k = Q.y;
      const F = vA(B), v = F[0] === 0 && F[3] === 0 || F[1] === 0 && F[2] === 0, L = v ? l.slice(0) : null;
      for (let J = 0, K = 0, X = a.length; J < X; J++) switch (0 | a[J]) {
        case yt.rectangle:
          w = g[K++], k = g[K++];
          const et = g[K++], At = g[K++], It = w + et, kt = k + At;
          B.moveTo(w, k), et === 0 || At === 0 ? B.lineTo(It, kt) : (B.lineTo(It, k), B.lineTo(It, kt), B.lineTo(w, kt)), v || Q.updateRectMinMax(F, [w, k, It, kt]), B.closePath();
          break;
        case yt.moveTo:
          w = g[K++], k = g[K++], B.moveTo(w, k), v || Q.updatePathMinMax(F, w, k);
          break;
        case yt.lineTo:
          w = g[K++], k = g[K++], B.lineTo(w, k), v || Q.updatePathMinMax(F, w, k);
          break;
        case yt.curveTo:
          f = w, m = k, w = g[K + 4], k = g[K + 5], B.bezierCurveTo(g[K], g[K + 1], g[K + 2], g[K + 3], w, k), Q.updateCurvePathMinMax(F, f, m, g[K], g[K + 1], g[K + 2], g[K + 3], w, k, L), K += 6;
          break;
        case yt.curveTo2:
          f = w, m = k, B.bezierCurveTo(w, k, g[K], g[K + 1], g[K + 2], g[K + 3]), Q.updateCurvePathMinMax(F, f, m, w, k, g[K], g[K + 1], g[K + 2], g[K + 3], L), w = g[K + 2], k = g[K + 3], K += 4;
          break;
        case yt.curveTo3:
          f = w, m = k, w = g[K + 2], k = g[K + 3], B.bezierCurveTo(g[K], g[K + 1], w, k, w, k), Q.updateCurvePathMinMax(F, f, m, g[K], g[K + 1], w, k, w, k, L), K += 4;
          break;
        case yt.closePath:
          B.closePath();
      }
      v && Q.updateScalingPathMinMax(F, L), Q.setCurrentPoint(w, k);
    }
    closePath() {
      this.ctx.closePath();
    }
    stroke(a = !0) {
      const g = this.ctx, l = this.current.strokeColor;
      g.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof l == "object" && l?.getPattern ? (g.save(), g.strokeStyle = l.getPattern(g, this, Ui(g), qg), this.rescaleAndStroke(!1), g.restore()) : this.rescaleAndStroke(!0)), a && this.consumePath(this.current.getClippedPathBoundingBox()), g.globalAlpha = this.current.fillAlpha;
    }
    closeStroke() {
      this.closePath(), this.stroke();
    }
    fill(a = !0) {
      const g = this.ctx, l = this.current.fillColor;
      let B = !1;
      this.current.patternFill && (g.save(), g.fillStyle = l.getPattern(g, this, Ui(g), Js), B = !0);
      const Q = this.current.getClippedPathBoundingBox();
      this.contentVisible && Q !== null && (this.pendingEOFill ? (g.fill("evenodd"), this.pendingEOFill = !1) : g.fill()), B && g.restore(), a && this.consumePath(Q);
    }
    eoFill() {
      this.pendingEOFill = !0, this.fill();
    }
    fillStroke() {
      this.fill(!1), this.stroke(!1), this.consumePath();
    }
    eoFillStroke() {
      this.pendingEOFill = !0, this.fillStroke();
    }
    closeFillStroke() {
      this.closePath(), this.fillStroke();
    }
    closeEOFillStroke() {
      this.pendingEOFill = !0, this.closePath(), this.fillStroke();
    }
    endPath() {
      this.consumePath();
    }
    clip() {
      this.pendingClip = h2;
    }
    eoClip() {
      this.pendingClip = bI;
    }
    beginText() {
      this.current.textMatrix = i, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
    }
    endText() {
      const a = this.pendingTextPaths, g = this.ctx;
      if (a !== void 0) {
        g.save(), g.beginPath();
        for (const l of a) g.setTransform(...l.transform), g.translate(l.x, l.y), l.addToPath(g, l.fontSize);
        g.restore(), g.clip(), g.beginPath(), delete this.pendingTextPaths;
      } else g.beginPath();
    }
    setCharSpacing(a) {
      this.current.charSpacing = a;
    }
    setWordSpacing(a) {
      this.current.wordSpacing = a;
    }
    setHScale(a) {
      this.current.textHScale = a / 100;
    }
    setLeading(a) {
      this.current.leading = -a;
    }
    setFont(a, g) {
      const l = this.commonObjs.get(a), B = this.current;
      if (!l) throw new Error(`Can't find font for ${a}`);
      if (B.fontMatrix = l.fontMatrix || s, B.fontMatrix[0] !== 0 && B.fontMatrix[3] !== 0 || qt("Invalid font matrix for font " + a), g < 0 ? (g = -g, B.fontDirection = -1) : B.fontDirection = 1, this.current.font = l, this.current.fontSize = g, l.isType3Font) return;
      const Q = l.loadedName || "sans-serif", f = l.systemFontInfo?.css || `"${Q}", ${l.fallbackName}`;
      let m = "normal";
      l.black ? m = "900" : l.bold && (m = "bold");
      const w = l.italic ? "italic" : "normal";
      let k = g;
      g < 16 ? k = 16 : g > 100 && (k = 100), this.current.fontSizeScale = g / k, this.ctx.font = `${w} ${m} ${k}px ${f}`;
    }
    setTextRenderingMode(a) {
      this.current.textRenderingMode = a;
    }
    setTextRise(a) {
      this.current.textRise = a;
    }
    moveText(a, g) {
      this.current.x = this.current.lineX += a, this.current.y = this.current.lineY += g;
    }
    setLeadingMoveText(a, g) {
      this.setLeading(-g), this.moveText(a, g);
    }
    setTextMatrix(a, g, l, B, Q, f) {
      this.current.textMatrix = [a, g, l, B, Q, f], this.current.textMatrixScale = Math.hypot(a, g), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
    }
    nextLine() {
      this.moveText(0, this.current.leading);
    }
    paintChar(a, g, l, B) {
      const Q = this.ctx, f = this.current, m = f.font, w = f.textRenderingMode, k = f.fontSize / f.fontSizeScale, F = w & N, v = !!(w & U), L = f.patternFill && !m.missingFile;
      let J;
      (m.disableFontFace || v || L) && (J = m.getPathGenerator(this.commonObjs, a)), m.disableFontFace || L ? (Q.save(), Q.translate(g, l), Q.beginPath(), J(Q, k), B && Q.setTransform(...B), F !== D && F !== R || Q.fill(), F !== S && F !== R || Q.stroke(), Q.restore()) : (F !== D && F !== R || Q.fillText(a, g, l), F !== S && F !== R || Q.strokeText(a, g, l)), v && (this.pendingTextPaths ||= []).push({ transform: vA(Q), x: g, y: l, fontSize: k, addToPath: J });
    }
    get isFontSubpixelAAEnabled() {
      const { context: a } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
      a.scale(1.5, 1), a.fillText("I", 0, 10);
      const g = a.getImageData(0, 0, 10, 10).data;
      let l = !1;
      for (let B = 3; B < g.length; B += 4) if (g[B] > 0 && g[B] < 255) {
        l = !0;
        break;
      }
      return aA(this, "isFontSubpixelAAEnabled", l);
    }
    showText(a) {
      const g = this.current, l = g.font;
      if (l.isType3Font) return this.showType3Text(a);
      const B = g.fontSize;
      if (B === 0) return;
      const Q = this.ctx, f = g.fontSizeScale, m = g.charSpacing, w = g.wordSpacing, k = g.fontDirection, F = g.textHScale * k, v = a.length, L = l.vertical, J = L ? 1 : -1, K = l.defaultVMetrics, X = B * g.fontMatrix[0], et = g.textRenderingMode === D && !l.disableFontFace && !g.patternFill;
      let At;
      if (Q.save(), Q.transform(...g.textMatrix), Q.translate(g.x, g.y + g.textRise), k > 0 ? Q.scale(F, -1) : Q.scale(F, 1), g.patternFill) {
        Q.save();
        const xt = g.fillColor.getPattern(Q, this, Ui(Q), Js);
        At = vA(Q), Q.restore(), Q.fillStyle = xt;
      }
      let It = g.lineWidth;
      const kt = g.textMatrixScale;
      if (kt === 0 || It === 0) {
        const xt = g.textRenderingMode & N;
        xt !== S && xt !== R || (It = this.getSinglePixelWidth());
      } else It /= kt;
      if (f !== 1 && (Q.scale(f, f), It /= f), Q.lineWidth = It, l.isInvalidPDFjsFont) {
        const xt = [];
        let Wt = 0;
        for (const eA of a) xt.push(eA.unicode), Wt += eA.width;
        return Q.fillText(xt.join(""), 0, 0), g.x += Wt * X * F, Q.restore(), void this.compose();
      }
      let Mt, Ut = 0;
      for (Mt = 0; Mt < v; ++Mt) {
        const xt = a[Mt];
        if (typeof xt == "number") {
          Ut += J * xt * B / 1e3;
          continue;
        }
        let Wt = !1;
        const eA = (xt.isSpace ? w : 0) + m, nA = xt.fontChar, EA = xt.accent;
        let sA, ke, ZA = xt.width;
        if (L) {
          const kA = xt.vmetric || K, se = -(xt.vmetric ? kA[1] : 0.5 * ZA) * X, oi = kA[2] * X;
          ZA = kA ? -kA[0] : ZA, sA = se / f, ke = (Ut + oi) / f;
        } else sA = Ut / f, ke = 0;
        if (l.remeasure && ZA > 0) {
          const kA = 1e3 * Q.measureText(nA).width / B * f;
          if (ZA < kA && this.isFontSubpixelAAEnabled) {
            const se = ZA / kA;
            Wt = !0, Q.save(), Q.scale(se, 1), sA /= se;
          } else ZA !== kA && (sA += (ZA - kA) / 2e3 * B / f);
        }
        if (this.contentVisible && (xt.isInFont || l.missingFile)) {
          if (et && !EA) Q.fillText(nA, sA, ke);
          else if (this.paintChar(nA, sA, ke, At), EA) {
            const kA = sA + B * EA.offset.x / f, se = ke - B * EA.offset.y / f;
            this.paintChar(EA.fontChar, kA, se, At);
          }
        }
        Ut += L ? ZA * X - eA * k : ZA * X + eA * k, Wt && Q.restore();
      }
      L ? g.y -= Ut : g.x += Ut * F, Q.restore(), this.compose();
    }
    showType3Text(a) {
      const g = this.ctx, l = this.current, B = l.font, Q = l.fontSize, f = l.fontDirection, m = B.vertical ? 1 : -1, w = l.charSpacing, k = l.wordSpacing, F = l.textHScale * f, v = l.fontMatrix || s, L = a.length;
      let J, K, X, et;
      if (l.textRenderingMode !== x && Q !== 0) {
        for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, g.save(), g.transform(...l.textMatrix), g.translate(l.x, l.y), g.scale(F, f), J = 0; J < L; ++J) {
          if (K = a[J], typeof K == "number") {
            et = m * K * Q / 1e3, this.ctx.translate(et, 0), l.x += et * F;
            continue;
          }
          const At = (K.isSpace ? k : 0) + w, It = B.charProcOperatorList[K.operatorListId];
          if (!It) {
            qt(`Type3 character "${K.operatorListId}" is not available.`);
            continue;
          }
          this.contentVisible && (this.processingType3 = K, this.save(), g.scale(Q, Q), g.transform(...v), this.executeOperatorList(It), this.restore()), X = Pt.applyTransform([K.width, 0], v)[0] * Q + At, g.translate(X, 0), l.x += X * F;
        }
        g.restore(), this.processingType3 = null;
      }
    }
    setCharWidth(a, g) {
    }
    setCharWidthAndBounds(a, g, l, B, Q, f) {
      this.ctx.rect(l, B, Q - l, f - B), this.ctx.clip(), this.endPath();
    }
    getColorN_Pattern(a) {
      let g;
      if (a[0] === "TilingPattern") {
        const l = a[1], B = this.baseTransform || vA(this.ctx), Q = { createCanvasGraphics: (f) => new pa(f, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: this.optionalContentConfig, markedContentStack: this.markedContentStack }) };
        g = new Wg(a, l, this.ctx, Q, B);
      } else g = this._getPattern(a[1], a[2]);
      return g;
    }
    setStrokeColorN() {
      this.current.strokeColor = this.getColorN_Pattern(arguments);
    }
    setFillColorN() {
      this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
    }
    setStrokeRGBColor(a, g, l) {
      this.ctx.strokeStyle = this.current.strokeColor = Pt.makeHexColor(a, g, l);
    }
    setStrokeTransparent() {
      this.ctx.strokeStyle = this.current.strokeColor = "transparent";
    }
    setFillRGBColor(a, g, l) {
      this.ctx.fillStyle = this.current.fillColor = Pt.makeHexColor(a, g, l), this.current.patternFill = !1;
    }
    setFillTransparent() {
      this.ctx.fillStyle = this.current.fillColor = "transparent", this.current.patternFill = !1;
    }
    _getPattern(a, g = null) {
      let l;
      return this.cachedPatterns.has(a) ? l = this.cachedPatterns.get(a) : (l = (function(B) {
        switch (B[0]) {
          case "RadialAxial":
            return new A2(B);
          case "Mesh":
            return new i2(B);
          case "Dummy":
            return new s2();
        }
        throw new Error(`Unknown IR type: ${B[0]}`);
      })(this.getObject(a)), this.cachedPatterns.set(a, l)), g && (l.matrix = g), l;
    }
    shadingFill(a) {
      if (!this.contentVisible) return;
      const g = this.ctx;
      this.save();
      const l = this._getPattern(a);
      g.fillStyle = l.getPattern(g, this, Ui(g), Cn);
      const B = Ui(g);
      if (B) {
        const { width: Q, height: f } = g.canvas, [m, w, k, F] = Pt.getAxialAlignedBoundingBox([0, 0, Q, f], B);
        this.ctx.fillRect(m, w, k - m, F - w);
      } else this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
      this.compose(this.current.getClippedPathBoundingBox()), this.restore();
    }
    beginInlineImage() {
      Xt("Should not call beginInlineImage");
    }
    beginImageData() {
      Xt("Should not call beginImageData");
    }
    paintFormXObjectBegin(a, g) {
      if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), a && this.transform(...a), this.baseTransform = vA(this.ctx), g)) {
        const l = g[2] - g[0], B = g[3] - g[1];
        this.ctx.rect(g[0], g[1], l, B), this.current.updateRectMinMax(vA(this.ctx), g), this.clip(), this.endPath();
      }
    }
    paintFormXObjectEnd() {
      this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
    }
    beginGroup(a) {
      if (!this.contentVisible) return;
      this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
      const g = this.ctx;
      a.isolated || Zt("TODO: Support non-isolated groups."), a.knockout && qt("Knockout groups not supported.");
      const l = vA(g);
      if (a.matrix && g.transform(...a.matrix), !a.bbox) throw new Error("Bounding box is required.");
      let B = Pt.getAxialAlignedBoundingBox(a.bbox, vA(g));
      const Q = [0, 0, g.canvas.width, g.canvas.height];
      B = Pt.intersect(B, Q) || [0, 0, 0, 0];
      const f = Math.floor(B[0]), m = Math.floor(B[1]), w = Math.max(Math.ceil(B[2]) - f, 1), k = Math.max(Math.ceil(B[3]) - m, 1);
      this.current.startNewPathAndClipBox([0, 0, w, k]);
      let F = "groupAt" + this.groupLevel;
      a.smask && (F += "_smask_" + this.smaskCounter++ % 2);
      const v = this.cachedCanvases.getCanvas(F, w, k), L = v.context;
      L.translate(-f, -m), L.transform(...l), a.smask ? this.smaskStack.push({ canvas: v.canvas, context: L, offsetX: f, offsetY: m, subtype: a.smask.subtype, backdrop: a.smask.backdrop, transferMap: a.smask.transferMap || null, startTransformInverse: null }) : (g.setTransform(1, 0, 0, 1, 0, 0), g.translate(f, m), g.save()), un(g, L), this.ctx = L, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(g), this.groupLevel++;
    }
    endGroup(a) {
      if (!this.contentVisible) return;
      this.groupLevel--;
      const g = this.ctx, l = this.groupStack.pop();
      if (this.ctx = l, this.ctx.imageSmoothingEnabled = !1, a.smask) this.tempSMask = this.smaskStack.pop(), this.restore();
      else {
        this.ctx.restore();
        const B = vA(this.ctx);
        this.restore(), this.ctx.save(), this.ctx.setTransform(...B);
        const Q = Pt.getAxialAlignedBoundingBox([0, 0, g.canvas.width, g.canvas.height], B);
        this.ctx.drawImage(g.canvas, 0, 0), this.ctx.restore(), this.compose(Q);
      }
    }
    beginAnnotation(a, g, l, B, Q) {
      if (this.#t(), Hr(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), g) {
        const f = g[2] - g[0], m = g[3] - g[1];
        if (Q && this.annotationCanvasMap) {
          (l = l.slice())[4] -= g[0], l[5] -= g[1], (g = g.slice())[0] = g[1] = 0, g[2] = f, g[3] = m;
          const [w, k] = Pt.singularValueDecompose2dScale(vA(this.ctx)), { viewportScale: F } = this, v = Math.ceil(f * this.outputScaleX * F), L = Math.ceil(m * this.outputScaleY * F);
          this.annotationCanvas = this.canvasFactory.create(v, L);
          const { canvas: J, context: K } = this.annotationCanvas;
          this.annotationCanvasMap.set(a, J), this.annotationCanvas.savedCtx = this.ctx, this.ctx = K, this.ctx.save(), this.ctx.setTransform(w, 0, 0, -k, 0, m * k), Hr(this.ctx);
        } else Hr(this.ctx), this.ctx.rect(g[0], g[1], f, m), this.ctx.clip(), this.endPath();
      }
      this.current = new pI(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...l), this.transform(...B);
    }
    endAnnotation() {
      this.annotationCanvas && (this.ctx.restore(), this.#A(), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
    }
    paintImageMaskXObject(a) {
      if (!this.contentVisible) return;
      const g = a.count;
      (a = this.getObject(a.data, a)).count = g;
      const l = this.ctx, B = this.processingType3;
      if (B && (B.compiled === void 0 && (B.compiled = (function(m) {
        const { width: w, height: k } = m;
        if (w > 1e3 || k > 1e3) return null;
        const F = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), v = w + 1;
        let L, J, K, X = new Uint8Array(v * (k + 1));
        const et = w + 7 & -8;
        let At = new Uint8Array(et * k), It = 0;
        for (const xt of m.data) {
          let Wt = 128;
          for (; Wt > 0; ) At[It++] = xt & Wt ? 0 : 255, Wt >>= 1;
        }
        let kt = 0;
        for (It = 0, At[It] !== 0 && (X[0] = 1, ++kt), J = 1; J < w; J++) At[It] !== At[It + 1] && (X[J] = At[It] ? 2 : 1, ++kt), It++;
        for (At[It] !== 0 && (X[J] = 2, ++kt), L = 1; L < k; L++) {
          It = L * et, K = L * v, At[It - et] !== At[It] && (X[K] = At[It] ? 1 : 8, ++kt);
          let xt = (At[It] ? 4 : 0) + (At[It - et] ? 8 : 0);
          for (J = 1; J < w; J++) xt = (xt >> 2) + (At[It + 1] ? 4 : 0) + (At[It - et + 1] ? 8 : 0), F[xt] && (X[K + J] = F[xt], ++kt), It++;
          if (At[It - et] !== At[It] && (X[K + J] = At[It] ? 2 : 4, ++kt), kt > 1e3) return null;
        }
        for (It = et * (k - 1), K = L * v, At[It] !== 0 && (X[K] = 8, ++kt), J = 1; J < w; J++) At[It] !== At[It + 1] && (X[K + J] = At[It] ? 4 : 8, ++kt), It++;
        if (At[It] !== 0 && (X[K + J] = 4, ++kt), kt > 1e3) return null;
        const Mt = new Int32Array([0, v, -1, 0, -v, 0, 0, 0, 1]), Ut = new Path2D();
        for (L = 0; kt && L <= k; L++) {
          let xt = L * v;
          const Wt = xt + w;
          for (; xt < Wt && !X[xt]; ) xt++;
          if (xt === Wt) continue;
          Ut.moveTo(xt % v, L);
          const eA = xt;
          let nA = X[xt];
          do {
            const EA = Mt[nA];
            do
              xt += EA;
            while (!X[xt]);
            const sA = X[xt];
            sA !== 5 && sA !== 10 ? (nA = sA, X[xt] = 0) : (nA = sA & 51 * nA >> 4, X[xt] &= nA >> 2 | nA << 2), Ut.lineTo(xt % v, xt / v | 0), X[xt] || --kt;
          } while (eA !== xt);
          --L;
        }
        return At = null, X = null, function(xt) {
          xt.save(), xt.scale(1 / w, -1 / k), xt.translate(0, -k), xt.fill(Ut), xt.beginPath(), xt.restore();
        };
      })(a)), B.compiled)) return void B.compiled(l);
      const Q = this._createMaskCanvas(a), f = Q.canvas;
      l.save(), l.setTransform(1, 0, 0, 1, 0, 0), l.drawImage(f, Q.offsetX, Q.offsetY), l.restore(), this.compose();
    }
    paintImageMaskXObjectRepeat(a, g, l = 0, B = 0, Q, f) {
      if (!this.contentVisible) return;
      a = this.getObject(a.data, a);
      const m = this.ctx;
      m.save();
      const w = vA(m);
      m.transform(g, l, B, Q, 0, 0);
      const k = this._createMaskCanvas(a);
      m.setTransform(1, 0, 0, 1, k.offsetX - w[4], k.offsetY - w[5]);
      for (let F = 0, v = f.length; F < v; F += 2) {
        const L = Pt.transform(w, [g, l, B, Q, f[F], f[F + 1]]), [J, K] = Pt.applyTransform([0, 0], L);
        m.drawImage(k.canvas, J, K);
      }
      m.restore(), this.compose();
    }
    paintImageMaskXObjectGroup(a) {
      if (!this.contentVisible) return;
      const g = this.ctx, l = this.current.fillColor, B = this.current.patternFill;
      for (const Q of a) {
        const { data: f, width: m, height: w, transform: k } = Q, F = this.cachedCanvases.getCanvas("maskCanvas", m, w), v = F.context;
        v.save(), yI(v, this.getObject(f, Q)), v.globalCompositeOperation = "source-in", v.fillStyle = B ? l.getPattern(v, this, Ui(g), Js) : l, v.fillRect(0, 0, m, w), v.restore(), g.save(), g.transform(...k), g.scale(1, -1), Ur(g, F.canvas, 0, 0, m, w, 0, -1, 1, 1), g.restore();
      }
      this.compose();
    }
    paintImageXObject(a) {
      if (!this.contentVisible) return;
      const g = this.getObject(a);
      g ? this.paintInlineImageXObject(g) : qt("Dependent image isn't ready yet");
    }
    paintImageXObjectRepeat(a, g, l, B) {
      if (!this.contentVisible) return;
      const Q = this.getObject(a);
      if (!Q) return void qt("Dependent image isn't ready yet");
      const f = Q.width, m = Q.height, w = [];
      for (let k = 0, F = B.length; k < F; k += 2) w.push({ transform: [g, 0, 0, l, B[k], B[k + 1]], x: 0, y: 0, w: f, h: m });
      this.paintInlineImageXObjectGroup(Q, w);
    }
    applyTransferMapsToCanvas(a) {
      return this.current.transferMaps !== "none" && (a.filter = this.current.transferMaps, a.drawImage(a.canvas, 0, 0), a.filter = "none"), a.canvas;
    }
    applyTransferMapsToBitmap(a) {
      if (this.current.transferMaps === "none") return a.bitmap;
      const { bitmap: g, width: l, height: B } = a, Q = this.cachedCanvases.getCanvas("inlineImage", l, B), f = Q.context;
      return f.filter = this.current.transferMaps, f.drawImage(g, 0, 0), f.filter = "none", Q.canvas;
    }
    paintInlineImageXObject(a) {
      if (!this.contentVisible) return;
      const g = a.width, l = a.height, B = this.ctx;
      if (this.save(), !e) {
        const { filter: m } = B;
        m !== "none" && m !== "" && (B.filter = "none");
      }
      let Q;
      if (B.scale(1 / g, -1 / l), a.bitmap) Q = this.applyTransferMapsToBitmap(a);
      else if (typeof HTMLElement == "function" && a instanceof HTMLElement || !a.data) Q = a;
      else {
        const m = this.cachedCanvases.getCanvas("inlineImage", g, l).context;
        mI(m, a), Q = this.applyTransferMapsToCanvas(m);
      }
      const f = this._scaleImage(Q, Ui(B));
      B.imageSmoothingEnabled = wI(vA(B), a.interpolate), Ur(B, f.img, 0, 0, f.paintWidth, f.paintHeight, 0, -l, g, l), this.compose(), this.restore();
    }
    paintInlineImageXObjectGroup(a, g) {
      if (!this.contentVisible) return;
      const l = this.ctx;
      let B;
      if (a.bitmap) B = a.bitmap;
      else {
        const Q = a.width, f = a.height, m = this.cachedCanvases.getCanvas("inlineImage", Q, f).context;
        mI(m, a), B = this.applyTransferMapsToCanvas(m);
      }
      for (const Q of g) l.save(), l.transform(...Q.transform), l.scale(1, -1), Ur(l, B, Q.x, Q.y, Q.w, Q.h, 0, -1, 1, 1), l.restore();
      this.compose();
    }
    paintSolidColorImageMask() {
      this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
    }
    markPoint(a) {
    }
    markPointProps(a, g) {
    }
    beginMarkedContent(a) {
      this.markedContentStack.push({ visible: !0 });
    }
    beginMarkedContentProps(a, g) {
      a === "OC" ? this.markedContentStack.push({ visible: this.optionalContentConfig.isVisible(g) }) : this.markedContentStack.push({ visible: !0 }), this.contentVisible = this.isContentVisible();
    }
    endMarkedContent() {
      this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
    }
    beginCompat() {
    }
    endCompat() {
    }
    consumePath(a) {
      const g = this.current.isEmptyClip();
      this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(a);
      const l = this.ctx;
      this.pendingClip && (g || (this.pendingClip === bI ? l.clip("evenodd") : l.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), l.beginPath();
    }
    getSinglePixelWidth() {
      if (!this._cachedGetSinglePixelWidth) {
        const a = vA(this.ctx);
        if (a[1] === 0 && a[2] === 0) this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(a[0]), Math.abs(a[3]));
        else {
          const g = Math.abs(a[0] * a[3] - a[2] * a[1]), l = Math.hypot(a[0], a[2]), B = Math.hypot(a[1], a[3]);
          this._cachedGetSinglePixelWidth = Math.max(l, B) / g;
        }
      }
      return this._cachedGetSinglePixelWidth;
    }
    getScaleForStroking() {
      if (this._cachedScaleForStroking[0] === -1) {
        const { lineWidth: a } = this.current, { a: g, b: l, c: B, d: Q } = this.ctx.getTransform();
        let f, m;
        if (l === 0 && B === 0) {
          const w = Math.abs(g), k = Math.abs(Q);
          if (w === k) if (a === 0) f = m = 1 / w;
          else {
            const F = w * a;
            f = m = F < 1 ? 1 / F : 1;
          }
          else if (a === 0) f = 1 / w, m = 1 / k;
          else {
            const F = w * a, v = k * a;
            f = F < 1 ? 1 / F : 1, m = v < 1 ? 1 / v : 1;
          }
        } else {
          const w = Math.abs(g * Q - l * B), k = Math.hypot(g, l), F = Math.hypot(B, Q);
          if (a === 0) f = F / w, m = k / w;
          else {
            const v = a * w;
            f = F > v ? F / v : 1, m = k > v ? k / v : 1;
          }
        }
        this._cachedScaleForStroking[0] = f, this._cachedScaleForStroking[1] = m;
      }
      return this._cachedScaleForStroking;
    }
    rescaleAndStroke(a) {
      const { ctx: g } = this, { lineWidth: l } = this.current, [B, Q] = this.getScaleForStroking();
      if (g.lineWidth = l || 1, B === 1 && Q === 1) return void g.stroke();
      const f = g.getLineDash();
      if (a && g.save(), g.scale(B, Q), f.length > 0) {
        const m = Math.max(B, Q);
        g.setLineDash(f.map(((w) => w / m))), g.lineDashOffset /= m;
      }
      g.stroke(), a && g.restore();
    }
    isContentVisible() {
      for (let a = this.markedContentStack.length - 1; a >= 0; a--) if (!this.markedContentStack[a].visible) return !1;
      return !0;
    }
  }
  for (const G in yt) pa.prototype[G] !== void 0 && (pa.prototype[yt[G]] = pa.prototype[G]);
  class Bn {
    static #t = null;
    static #A = "";
    static get workerPort() {
      return this.#t;
    }
    static set workerPort(a) {
      if (!(typeof Worker < "u" && a instanceof Worker) && a !== null) throw new Error("Invalid `workerPort` type.");
      this.#t = a;
    }
    static get workerSrc() {
      return this.#A;
    }
    static set workerSrc(a) {
      if (typeof a != "string") throw new Error("Invalid `workerSrc` type.");
      this.#A = a;
    }
  }
  const DI = 1, kI = 2, SI = 1, jg = 2, FI = 3, RI = 4, xI = 5, NI = 6, Jr = 7, Zg = 8;
  function ve(G) {
    switch (G instanceof Error || typeof G == "object" && G !== null || Xt('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), G.name) {
      case "AbortException":
        return new Us(G.message);
      case "MissingPDFException":
        return new Mi(G.message);
      case "PasswordException":
        return new da(G.message, G.code);
      case "UnexpectedResponseException":
        return new Ea(G.message, G.status);
      case "UnknownErrorException":
        return new Qa(G.message, G.details);
      default:
        return new Qa(G.message, G.toString());
    }
  }
  class dn {
    constructor(a, g, l) {
      this.sourceName = a, this.targetName = g, this.comObj = l, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (B) => {
        const Q = B.data;
        if (Q.targetName !== this.sourceName) return;
        if (Q.stream) return void this.#A(Q);
        if (Q.callback) {
          const m = Q.callbackId, w = this.callbackCapabilities[m];
          if (!w) throw new Error(`Cannot resolve callback ${m}`);
          if (delete this.callbackCapabilities[m], Q.callback === DI) w.resolve(Q.data);
          else {
            if (Q.callback !== kI) throw new Error("Unexpected callback case");
            w.reject(ve(Q.reason));
          }
          return;
        }
        const f = this.actionHandler[Q.action];
        if (!f) throw new Error(`Unknown action from worker: ${Q.action}`);
        if (Q.callbackId) {
          const m = this.sourceName, w = Q.sourceName;
          new Promise((function(k) {
            k(f(Q.data));
          })).then((function(k) {
            l.postMessage({ sourceName: m, targetName: w, callback: DI, callbackId: Q.callbackId, data: k });
          }), (function(k) {
            l.postMessage({ sourceName: m, targetName: w, callback: kI, callbackId: Q.callbackId, reason: ve(k) });
          }));
        } else Q.streamId ? this.#t(Q) : f(Q.data);
      }, l.addEventListener("message", this._onComObjOnMessage);
    }
    on(a, g) {
      const l = this.actionHandler;
      if (l[a]) throw new Error(`There is already an actionName called "${a}"`);
      l[a] = g;
    }
    send(a, g, l) {
      this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: a, data: g }, l);
    }
    sendWithPromise(a, g, l) {
      const B = this.callbackId++, Q = Promise.withResolvers();
      this.callbackCapabilities[B] = Q;
      try {
        this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: a, callbackId: B, data: g }, l);
      } catch (f) {
        Q.reject(f);
      }
      return Q.promise;
    }
    sendWithStream(a, g, l, B) {
      const Q = this.streamId++, f = this.sourceName, m = this.targetName, w = this.comObj;
      return new ReadableStream({ start: (k) => {
        const F = Promise.withResolvers();
        return this.streamControllers[Q] = { controller: k, startCall: F, pullCall: null, cancelCall: null, isClosed: !1 }, w.postMessage({ sourceName: f, targetName: m, action: a, streamId: Q, data: g, desiredSize: k.desiredSize }, B), F.promise;
      }, pull: (k) => {
        const F = Promise.withResolvers();
        return this.streamControllers[Q].pullCall = F, w.postMessage({ sourceName: f, targetName: m, stream: NI, streamId: Q, desiredSize: k.desiredSize }), F.promise;
      }, cancel: (k) => {
        wA(k instanceof Error, "cancel must have a valid reason");
        const F = Promise.withResolvers();
        return this.streamControllers[Q].cancelCall = F, this.streamControllers[Q].isClosed = !0, w.postMessage({ sourceName: f, targetName: m, stream: SI, streamId: Q, reason: ve(k) }), F.promise;
      } }, l);
    }
    #t(a) {
      const g = a.streamId, l = this.sourceName, B = a.sourceName, Q = this.comObj, f = this, m = this.actionHandler[a.action], w = { enqueue(k, F = 1, v) {
        if (this.isCancelled) return;
        const L = this.desiredSize;
        this.desiredSize -= F, L > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), Q.postMessage({ sourceName: l, targetName: B, stream: RI, streamId: g, chunk: k }, v);
      }, close() {
        this.isCancelled || (this.isCancelled = !0, Q.postMessage({ sourceName: l, targetName: B, stream: FI, streamId: g }), delete f.streamSinks[g]);
      }, error(k) {
        wA(k instanceof Error, "error must have a valid reason"), this.isCancelled || (this.isCancelled = !0, Q.postMessage({ sourceName: l, targetName: B, stream: xI, streamId: g, reason: ve(k) }));
      }, sinkCapability: Promise.withResolvers(), onPull: null, onCancel: null, isCancelled: !1, desiredSize: a.desiredSize, ready: null };
      w.sinkCapability.resolve(), w.ready = w.sinkCapability.promise, this.streamSinks[g] = w, new Promise((function(k) {
        k(m(a.data, w));
      })).then((function() {
        Q.postMessage({ sourceName: l, targetName: B, stream: Zg, streamId: g, success: !0 });
      }), (function(k) {
        Q.postMessage({ sourceName: l, targetName: B, stream: Zg, streamId: g, reason: ve(k) });
      }));
    }
    #A(a) {
      const g = a.streamId, l = this.sourceName, B = a.sourceName, Q = this.comObj, f = this.streamControllers[g], m = this.streamSinks[g];
      switch (a.stream) {
        case Zg:
          a.success ? f.startCall.resolve() : f.startCall.reject(ve(a.reason));
          break;
        case Jr:
          a.success ? f.pullCall.resolve() : f.pullCall.reject(ve(a.reason));
          break;
        case NI:
          if (!m) {
            Q.postMessage({ sourceName: l, targetName: B, stream: Jr, streamId: g, success: !0 });
            break;
          }
          m.desiredSize <= 0 && a.desiredSize > 0 && m.sinkCapability.resolve(), m.desiredSize = a.desiredSize, new Promise((function(w) {
            w(m.onPull?.());
          })).then((function() {
            Q.postMessage({ sourceName: l, targetName: B, stream: Jr, streamId: g, success: !0 });
          }), (function(w) {
            Q.postMessage({ sourceName: l, targetName: B, stream: Jr, streamId: g, reason: ve(w) });
          }));
          break;
        case RI:
          if (wA(f, "enqueue should have stream controller"), f.isClosed) break;
          f.controller.enqueue(a.chunk);
          break;
        case FI:
          if (wA(f, "close should have stream controller"), f.isClosed) break;
          f.isClosed = !0, f.controller.close(), this.#e(f, g);
          break;
        case xI:
          wA(f, "error should have stream controller"), f.controller.error(ve(a.reason)), this.#e(f, g);
          break;
        case jg:
          a.success ? f.cancelCall.resolve() : f.cancelCall.reject(ve(a.reason)), this.#e(f, g);
          break;
        case SI:
          if (!m) break;
          new Promise((function(w) {
            w(m.onCancel?.(ve(a.reason)));
          })).then((function() {
            Q.postMessage({ sourceName: l, targetName: B, stream: jg, streamId: g, success: !0 });
          }), (function(w) {
            Q.postMessage({ sourceName: l, targetName: B, stream: jg, streamId: g, reason: ve(w) });
          })), m.sinkCapability.reject(ve(a.reason)), m.isCancelled = !0, delete this.streamSinks[g];
          break;
        default:
          throw new Error("Unexpected stream case");
      }
    }
    async #e(a, g) {
      await Promise.allSettled([a.startCall?.promise, a.pullCall?.promise, a.cancelCall?.promise]), delete this.streamControllers[g];
    }
    destroy() {
      this.comObj.removeEventListener("message", this._onComObjOnMessage);
    }
  }
  class l2 {
    #t;
    #A;
    constructor({ parsedData: a, rawData: g }) {
      this.#t = a, this.#A = g;
    }
    getRaw() {
      return this.#A;
    }
    get(a) {
      return this.#t.get(a) ?? null;
    }
    getAll() {
      return Rg(this.#t);
    }
    has(a) {
      return this.#t.has(a);
    }
  }
  const rs = Symbol("INTERNAL");
  class I2 {
    #t = !1;
    #A = !1;
    #e = !1;
    #s = !0;
    constructor(a, { name: g, intent: l, usage: B }) {
      this.#t = !!(a & r), this.#A = !!(a & c), this.name = g, this.intent = l, this.usage = B;
    }
    get visible() {
      if (this.#e) return this.#s;
      if (!this.#s) return !1;
      const { print: a, view: g } = this.usage;
      return this.#t ? g?.viewState !== "OFF" : !this.#A || a?.printState !== "OFF";
    }
    _setVisible(a, g, l = !1) {
      a !== rs && Xt("Internal method `_setVisible` called."), this.#e = l, this.#s = g;
    }
  }
  class C2 {
    #t = null;
    #A = /* @__PURE__ */ new Map();
    #e = null;
    #s = null;
    constructor(a, g = r) {
      if (this.renderingIntent = g, this.name = null, this.creator = null, a !== null) {
        this.name = a.name, this.creator = a.creator, this.#s = a.order;
        for (const l of a.groups) this.#A.set(l.id, new I2(g, l));
        if (a.baseState === "OFF") for (const l of this.#A.values()) l._setVisible(rs, !1);
        for (const l of a.on) this.#A.get(l)._setVisible(rs, !0);
        for (const l of a.off) this.#A.get(l)._setVisible(rs, !1);
        this.#e = this.getHash();
      }
    }
    #a(a) {
      const g = a.length;
      if (g < 2) return !0;
      const l = a[0];
      for (let B = 1; B < g; B++) {
        const Q = a[B];
        let f;
        if (Array.isArray(Q)) f = this.#a(Q);
        else {
          if (!this.#A.has(Q)) return qt(`Optional content group not found: ${Q}`), !0;
          f = this.#A.get(Q).visible;
        }
        switch (l) {
          case "And":
            if (!f) return !1;
            break;
          case "Or":
            if (f) return !0;
            break;
          case "Not":
            return !f;
          default:
            return !0;
        }
      }
      return l === "And";
    }
    isVisible(a) {
      if (this.#A.size === 0) return !0;
      if (!a) return Zt("Optional content group not defined."), !0;
      if (a.type === "OCG") return this.#A.has(a.id) ? this.#A.get(a.id).visible : (qt(`Optional content group not found: ${a.id}`), !0);
      if (a.type === "OCMD") {
        if (a.expression) return this.#a(a.expression);
        if (!a.policy || a.policy === "AnyOn") {
          for (const g of a.ids) {
            if (!this.#A.has(g)) return qt(`Optional content group not found: ${g}`), !0;
            if (this.#A.get(g).visible) return !0;
          }
          return !1;
        }
        if (a.policy === "AllOn") {
          for (const g of a.ids) {
            if (!this.#A.has(g)) return qt(`Optional content group not found: ${g}`), !0;
            if (!this.#A.get(g).visible) return !1;
          }
          return !0;
        }
        if (a.policy === "AnyOff") {
          for (const g of a.ids) {
            if (!this.#A.has(g)) return qt(`Optional content group not found: ${g}`), !0;
            if (!this.#A.get(g).visible) return !0;
          }
          return !1;
        }
        if (a.policy === "AllOff") {
          for (const g of a.ids) {
            if (!this.#A.has(g)) return qt(`Optional content group not found: ${g}`), !0;
            if (this.#A.get(g).visible) return !1;
          }
          return !0;
        }
        return qt(`Unknown optional content policy ${a.policy}.`), !0;
      }
      return qt(`Unknown group type ${a.type}.`), !0;
    }
    setVisibility(a, g = !0) {
      const l = this.#A.get(a);
      l ? (l._setVisible(rs, !!g, !0), this.#t = null) : qt(`Optional content group not found: ${a}`);
    }
    setOCGState({ state: a, preserveRB: g }) {
      let l;
      for (const B of a) {
        switch (B) {
          case "ON":
          case "OFF":
          case "Toggle":
            l = B;
            continue;
        }
        const Q = this.#A.get(B);
        if (Q) switch (l) {
          case "ON":
            Q._setVisible(rs, !0);
            break;
          case "OFF":
            Q._setVisible(rs, !1);
            break;
          case "Toggle":
            Q._setVisible(rs, !Q.visible);
        }
      }
      this.#t = null;
    }
    get hasInitialVisibility() {
      return this.#e === null || this.getHash() === this.#e;
    }
    getOrder() {
      return this.#A.size ? this.#s ? this.#s.slice() : [...this.#A.keys()] : null;
    }
    getGroups() {
      return this.#A.size > 0 ? Rg(this.#A) : null;
    }
    getGroup(a) {
      return this.#A.get(a) || null;
    }
    getHash() {
      if (this.#t !== null) return this.#t;
      const a = new QI();
      for (const [g, l] of this.#A) a.update(`${g}:${l.visible}`);
      return this.#t = a.hexdigest();
    }
  }
  class u2 {
    constructor(a, { disableRange: g = !1, disableStream: l = !1 }) {
      wA(a, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
      const { length: B, initialData: Q, progressiveDone: f, contentDispositionFilename: m } = a;
      if (this._queuedChunks = [], this._progressiveDone = f, this._contentDispositionFilename = m, Q?.length > 0) {
        const w = Q instanceof Uint8Array && Q.byteLength === Q.buffer.byteLength ? Q.buffer : new Uint8Array(Q).buffer;
        this._queuedChunks.push(w);
      }
      this._pdfDataRangeTransport = a, this._isStreamingSupported = !l, this._isRangeSupported = !g, this._contentLength = B, this._fullRequestReader = null, this._rangeReaders = [], a.addRangeListener(((w, k) => {
        this._onReceiveData({ begin: w, chunk: k });
      })), a.addProgressListener(((w, k) => {
        this._onProgress({ loaded: w, total: k });
      })), a.addProgressiveReadListener(((w) => {
        this._onReceiveData({ chunk: w });
      })), a.addProgressiveDoneListener((() => {
        this._onProgressiveDone();
      })), a.transportReady();
    }
    _onReceiveData({ begin: a, chunk: g }) {
      const l = g instanceof Uint8Array && g.byteLength === g.buffer.byteLength ? g.buffer : new Uint8Array(g).buffer;
      a === void 0 ? this._fullRequestReader ? this._fullRequestReader._enqueue(l) : this._queuedChunks.push(l) : wA(this._rangeReaders.some((function(B) {
        return B._begin === a && (B._enqueue(l), !0);
      })), "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
    get _progressiveDataLength() {
      return this._fullRequestReader?._loaded ?? 0;
    }
    _onProgress(a) {
      a.total === void 0 ? this._rangeReaders[0]?.onProgress?.({ loaded: a.loaded }) : this._fullRequestReader?.onProgress?.({ loaded: a.loaded, total: a.total });
    }
    _onProgressiveDone() {
      this._fullRequestReader?.progressiveDone(), this._progressiveDone = !0;
    }
    _removeRangeReader(a) {
      const g = this._rangeReaders.indexOf(a);
      g >= 0 && this._rangeReaders.splice(g, 1);
    }
    getFullReader() {
      wA(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
      const a = this._queuedChunks;
      return this._queuedChunks = null, new B2(this, a, this._progressiveDone, this._contentDispositionFilename);
    }
    getRangeReader(a, g) {
      if (g <= this._progressiveDataLength) return null;
      const l = new d2(this, a, g);
      return this._pdfDataRangeTransport.requestDataRange(a, g), this._rangeReaders.push(l), l;
    }
    cancelAllRequests(a) {
      this._fullRequestReader?.cancel(a);
      for (const g of this._rangeReaders.slice(0)) g.cancel(a);
      this._pdfDataRangeTransport.abort();
    }
  }
  class B2 {
    constructor(a, g, l = !1, B = null) {
      this._stream = a, this._done = l || !1, this._filename = Mg(B) ? B : null, this._queuedChunks = g || [], this._loaded = 0;
      for (const Q of this._queuedChunks) this._loaded += Q.byteLength;
      this._requests = [], this._headersReady = Promise.resolve(), a._fullRequestReader = this, this.onProgress = null;
    }
    _enqueue(a) {
      this._done || (this._requests.length > 0 ? this._requests.shift().resolve({ value: a, done: !1 }) : this._queuedChunks.push(a), this._loaded += a.byteLength);
    }
    get headersReady() {
      return this._headersReady;
    }
    get filename() {
      return this._filename;
    }
    get isRangeSupported() {
      return this._stream._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._stream._isStreamingSupported;
    }
    get contentLength() {
      return this._stream._contentLength;
    }
    async read() {
      if (this._queuedChunks.length > 0)
        return { value: this._queuedChunks.shift(), done: !1 };
      if (this._done) return { value: void 0, done: !0 };
      const a = Promise.withResolvers();
      return this._requests.push(a), a.promise;
    }
    cancel(a) {
      this._done = !0;
      for (const g of this._requests) g.resolve({ value: void 0, done: !0 });
      this._requests.length = 0;
    }
    progressiveDone() {
      this._done || (this._done = !0);
    }
  }
  class d2 {
    constructor(a, g, l) {
      this._stream = a, this._begin = g, this._end = l, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
    }
    _enqueue(a) {
      if (!this._done) {
        if (this._requests.length === 0) this._queuedChunk = a;
        else {
          this._requests.shift().resolve({ value: a, done: !1 });
          for (const g of this._requests) g.resolve({ value: void 0, done: !0 });
          this._requests.length = 0;
        }
        this._done = !0, this._stream._removeRangeReader(this);
      }
    }
    get isStreamingSupported() {
      return !1;
    }
    async read() {
      if (this._queuedChunk) {
        const g = this._queuedChunk;
        return this._queuedChunk = null, { value: g, done: !1 };
      }
      if (this._done) return { value: void 0, done: !0 };
      const a = Promise.withResolvers();
      return this._requests.push(a), a.promise;
    }
    cancel(a) {
      this._done = !0;
      for (const g of this._requests) g.resolve({ value: void 0, done: !0 });
      this._requests.length = 0, this._stream._removeRangeReader(this);
    }
  }
  function Vg({ getResponseHeader: G, isHttp: a, rangeChunkSize: g, disableRange: l }) {
    const B = { allowRangeRequests: !1, suggestedLength: void 0 }, Q = parseInt(G("Content-Length"), 10);
    return !Number.isInteger(Q) || (B.suggestedLength = Q, Q <= 2 * g) || l || !a || G("Accept-Ranges") !== "bytes" || (G("Content-Encoding") || "identity") !== "identity" || (B.allowRangeRequests = !0), B;
  }
  function Xg(G) {
    const a = G("Content-Disposition");
    if (a) {
      let g = (function(l) {
        let B = !0, Q = f("filename\\*", "i").exec(l);
        if (Q) {
          Q = Q[1];
          let L = k(Q);
          return L = unescape(L), L = F(L), L = v(L), w(L);
        }
        if (Q = (function(L) {
          const J = [];
          let K;
          const X = f("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
          for (; (K = X.exec(L)) !== null; ) {
            let [, At, It, kt] = K;
            if (At = parseInt(At, 10), At in J) {
              if (At === 0) break;
            } else J[At] = [It, kt];
          }
          const et = [];
          for (let At = 0; At < J.length && At in J; ++At) {
            let [It, kt] = J[At];
            kt = k(kt), It && (kt = unescape(kt), At === 0 && (kt = F(kt))), et.push(kt);
          }
          return et.join("");
        })(l), Q) return w(v(Q));
        if (Q = f("filename", "i").exec(l), Q) {
          Q = Q[1];
          let L = k(Q);
          return L = v(L), w(L);
        }
        function f(L, J) {
          return new RegExp("(?:^|;)\\s*" + L + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', J);
        }
        function m(L, J) {
          if (L) {
            if (!/^[\x00-\xFF]+$/.test(J)) return J;
            try {
              const K = new TextDecoder(L, { fatal: !0 }), X = Gr(J);
              J = K.decode(X), B = !1;
            } catch {
            }
          }
          return J;
        }
        function w(L) {
          return B && /[\x80-\xff]/.test(L) && (L = m("utf-8", L), B && (L = m("iso-8859-1", L))), L;
        }
        function k(L) {
          if (L.startsWith('"')) {
            const J = L.slice(1).split('\\"');
            for (let K = 0; K < J.length; ++K) {
              const X = J[K].indexOf('"');
              X !== -1 && (J[K] = J[K].slice(0, X), J.length = K + 1), J[K] = J[K].replaceAll(/\\(.)/g, "$1");
            }
            L = J.join('"');
          }
          return L;
        }
        function F(L) {
          const J = L.indexOf("'");
          return J === -1 ? L : m(L.slice(0, J), L.slice(J + 1).replace(/^[^']*'/, ""));
        }
        function v(L) {
          return !L.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(L) ? L : L.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, (function(J, K, X, et) {
            if (X === "q" || X === "Q") return m(K, et = (et = et.replaceAll("_", " ")).replaceAll(/=([0-9a-fA-F]{2})/g, (function(At, It) {
              return String.fromCharCode(parseInt(It, 16));
            })));
            try {
              et = atob(et);
            } catch {
            }
            return m(K, et);
          }));
        }
        return "";
      })(a);
      if (g.includes("%")) try {
        g = decodeURIComponent(g);
      } catch {
      }
      if (Mg(g)) return g;
    }
    return null;
  }
  function Yr(G, a) {
    return G === 404 || G === 0 && a.startsWith("file:") ? new Mi('Missing PDF "' + a + '".') : new Ea(`Unexpected server response (${G}) while retrieving PDF "${a}".`, G);
  }
  function GI(G) {
    return G === 200 || G === 206;
  }
  function vI(G, a, g) {
    return { method: "GET", headers: G, signal: g.signal, mode: "cors", credentials: a ? "include" : "same-origin", redirect: "follow" };
  }
  function MI(G) {
    const a = new Headers();
    for (const g in G) {
      const l = G[g];
      l !== void 0 && a.append(g, l);
    }
    return a;
  }
  function LI(G) {
    return G instanceof Uint8Array ? G.buffer : G instanceof ArrayBuffer ? G : (qt(`getArrayBuffer - unexpected data format: ${G}`), new Uint8Array(G).buffer);
  }
  class UI {
    constructor(a) {
      this.source = a, this.isHttp = /^https?:/i.test(a.url), this.httpHeaders = this.isHttp && a.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
    }
    get _progressiveDataLength() {
      return this._fullRequestReader?._loaded ?? 0;
    }
    getFullReader() {
      return wA(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new Q2(this), this._fullRequestReader;
    }
    getRangeReader(a, g) {
      if (g <= this._progressiveDataLength) return null;
      const l = new E2(this, a, g);
      return this._rangeRequestReaders.push(l), l;
    }
    cancelAllRequests(a) {
      this._fullRequestReader?.cancel(a);
      for (const g of this._rangeRequestReaders.slice(0)) g.cancel(a);
    }
  }
  class Q2 {
    constructor(a) {
      this._stream = a, this._reader = null, this._loaded = 0, this._filename = null;
      const g = a.source;
      this._withCredentials = g.withCredentials || !1, this._contentLength = g.length, this._headersCapability = Promise.withResolvers(), this._disableRange = g.disableRange || !1, this._rangeChunkSize = g.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !g.disableStream, this._isRangeSupported = !g.disableRange, this._headers = MI(this._stream.httpHeaders);
      const l = g.url;
      fetch(l, vI(this._headers, this._withCredentials, this._abortController)).then(((B) => {
        if (!GI(B.status)) throw Yr(B.status, l);
        this._reader = B.body.getReader(), this._headersCapability.resolve();
        const Q = (w) => B.headers.get(w), { allowRangeRequests: f, suggestedLength: m } = Vg({ getResponseHeader: Q, isHttp: this._stream.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange });
        this._isRangeSupported = f, this._contentLength = m || this._contentLength, this._filename = Xg(Q), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new Us("Streaming is disabled."));
      })).catch(this._headersCapability.reject), this.onProgress = null;
    }
    get headersReady() {
      return this._headersCapability.promise;
    }
    get filename() {
      return this._filename;
    }
    get contentLength() {
      return this._contentLength;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      await this._headersCapability.promise;
      const { value: a, done: g } = await this._reader.read();
      return g ? { value: a, done: g } : (this._loaded += a.byteLength, this.onProgress?.({ loaded: this._loaded, total: this._contentLength }), { value: LI(a), done: !1 });
    }
    cancel(a) {
      this._reader?.cancel(a), this._abortController.abort();
    }
  }
  class E2 {
    constructor(a, g, l) {
      this._stream = a, this._reader = null, this._loaded = 0;
      const B = a.source;
      this._withCredentials = B.withCredentials || !1, this._readCapability = Promise.withResolvers(), this._isStreamingSupported = !B.disableStream, this._abortController = new AbortController(), this._headers = MI(this._stream.httpHeaders), this._headers.append("Range", `bytes=${g}-${l - 1}`);
      const Q = B.url;
      fetch(Q, vI(this._headers, this._withCredentials, this._abortController)).then(((f) => {
        if (!GI(f.status)) throw Yr(f.status, Q);
        this._readCapability.resolve(), this._reader = f.body.getReader();
      })).catch(this._readCapability.reject), this.onProgress = null;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      await this._readCapability.promise;
      const { value: a, done: g } = await this._reader.read();
      return g ? { value: a, done: g } : (this._loaded += a.byteLength, this.onProgress?.({ loaded: this._loaded }), { value: LI(a), done: !1 });
    }
    cancel(a) {
      this._reader?.cancel(a), this._abortController.abort();
    }
  }
  class f2 {
    constructor(a, g = {}) {
      this.url = a, this.isHttp = /^https?:/i.test(a), this.httpHeaders = this.isHttp && g.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = g.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
    }
    requestRange(a, g, l) {
      const B = { begin: a, end: g };
      for (const Q in l) B[Q] = l[Q];
      return this.request(B);
    }
    requestFull(a) {
      return this.request(a);
    }
    request(a) {
      const g = new XMLHttpRequest(), l = this.currXhrId++, B = this.pendingRequests[l] = { xhr: g };
      g.open("GET", this.url), g.withCredentials = this.withCredentials;
      for (const Q in this.httpHeaders) {
        const f = this.httpHeaders[Q];
        f !== void 0 && g.setRequestHeader(Q, f);
      }
      return this.isHttp && "begin" in a && "end" in a ? (g.setRequestHeader("Range", `bytes=${a.begin}-${a.end - 1}`), B.expectedStatus = 206) : B.expectedStatus = 200, g.responseType = "arraybuffer", a.onError && (g.onerror = function(Q) {
        a.onError(g.status);
      }), g.onreadystatechange = this.onStateChange.bind(this, l), g.onprogress = this.onProgress.bind(this, l), B.onHeadersReceived = a.onHeadersReceived, B.onDone = a.onDone, B.onError = a.onError, B.onProgress = a.onProgress, g.send(null), l;
    }
    onProgress(a, g) {
      const l = this.pendingRequests[a];
      l && l.onProgress?.(g);
    }
    onStateChange(a, g) {
      const l = this.pendingRequests[a];
      if (!l) return;
      const B = l.xhr;
      if (B.readyState >= 2 && l.onHeadersReceived && (l.onHeadersReceived(), delete l.onHeadersReceived), B.readyState !== 4 || !(a in this.pendingRequests)) return;
      if (delete this.pendingRequests[a], B.status === 0 && this.isHttp) return void l.onError?.(B.status);
      const Q = B.status || 200;
      if (!(Q === 200 && l.expectedStatus === 206) && Q !== l.expectedStatus) return void l.onError?.(B.status);
      const f = (function(m) {
        const w = m.response;
        return typeof w != "string" ? w : Gr(w).buffer;
      })(B);
      if (Q === 206) {
        const m = B.getResponseHeader("Content-Range"), w = /bytes (\d+)-(\d+)\/(\d+)/.exec(m);
        l.onDone({ begin: parseInt(w[1], 10), chunk: f });
      } else f ? l.onDone({ begin: 0, chunk: f }) : l.onError?.(B.status);
    }
    getRequestXhr(a) {
      return this.pendingRequests[a].xhr;
    }
    isPendingRequest(a) {
      return a in this.pendingRequests;
    }
    abortRequest(a) {
      const g = this.pendingRequests[a].xhr;
      delete this.pendingRequests[a], g.abort();
    }
  }
  class p2 {
    constructor(a) {
      this._source = a, this._manager = new f2(a.url, { httpHeaders: a.httpHeaders, withCredentials: a.withCredentials }), this._rangeChunkSize = a.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
    }
    _onRangeRequestReaderClosed(a) {
      const g = this._rangeRequestReaders.indexOf(a);
      g >= 0 && this._rangeRequestReaders.splice(g, 1);
    }
    getFullReader() {
      return wA(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new m2(this._manager, this._source), this._fullRequestReader;
    }
    getRangeReader(a, g) {
      const l = new y2(this._manager, a, g);
      return l.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(l), l;
    }
    cancelAllRequests(a) {
      this._fullRequestReader?.cancel(a);
      for (const g of this._rangeRequestReaders.slice(0)) g.cancel(a);
    }
  }
  class m2 {
    constructor(a, g) {
      this._manager = a;
      const l = { onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) };
      this._url = g.url, this._fullRequestId = a.requestFull(l), this._headersReceivedCapability = Promise.withResolvers(), this._disableRange = g.disableRange || !1, this._contentLength = g.length, this._rangeChunkSize = g.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
    }
    _onHeadersReceived() {
      const a = this._fullRequestId, g = this._manager.getRequestXhr(a), l = (f) => g.getResponseHeader(f), { allowRangeRequests: B, suggestedLength: Q } = Vg({ getResponseHeader: l, isHttp: this._manager.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange });
      B && (this._isRangeSupported = !0), this._contentLength = Q || this._contentLength, this._filename = Xg(l), this._isRangeSupported && this._manager.abortRequest(a), this._headersReceivedCapability.resolve();
    }
    _onDone(a) {
      if (a && (this._requests.length > 0 ? this._requests.shift().resolve({ value: a.chunk, done: !1 }) : this._cachedChunks.push(a.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
        for (const g of this._requests) g.resolve({ value: void 0, done: !0 });
        this._requests.length = 0;
      }
    }
    _onError(a) {
      this._storedError = Yr(a, this._url), this._headersReceivedCapability.reject(this._storedError);
      for (const g of this._requests) g.reject(this._storedError);
      this._requests.length = 0, this._cachedChunks.length = 0;
    }
    _onProgress(a) {
      this.onProgress?.({ loaded: a.loaded, total: a.lengthComputable ? a.total : this._contentLength });
    }
    get filename() {
      return this._filename;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    get contentLength() {
      return this._contentLength;
    }
    get headersReady() {
      return this._headersReceivedCapability.promise;
    }
    async read() {
      if (this._storedError) throw this._storedError;
      if (this._cachedChunks.length > 0)
        return { value: this._cachedChunks.shift(), done: !1 };
      if (this._done) return { value: void 0, done: !0 };
      const a = Promise.withResolvers();
      return this._requests.push(a), a.promise;
    }
    cancel(a) {
      this._done = !0, this._headersReceivedCapability.reject(a);
      for (const g of this._requests) g.resolve({ value: void 0, done: !0 });
      this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
    }
  }
  class y2 {
    constructor(a, g, l) {
      this._manager = a;
      const B = { onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) };
      this._url = a.url, this._requestId = a.requestRange(g, l, B), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
    }
    _close() {
      this.onClosed?.(this);
    }
    _onDone(a) {
      const g = a.chunk;
      this._requests.length > 0 ? this._requests.shift().resolve({ value: g, done: !1 }) : this._queuedChunk = g, this._done = !0;
      for (const l of this._requests) l.resolve({ value: void 0, done: !0 });
      this._requests.length = 0, this._close();
    }
    _onError(a) {
      this._storedError = Yr(a, this._url);
      for (const g of this._requests) g.reject(this._storedError);
      this._requests.length = 0, this._queuedChunk = null;
    }
    _onProgress(a) {
      this.isStreamingSupported || this.onProgress?.({ loaded: a.loaded });
    }
    get isStreamingSupported() {
      return !1;
    }
    async read() {
      if (this._storedError) throw this._storedError;
      if (this._queuedChunk !== null) {
        const g = this._queuedChunk;
        return this._queuedChunk = null, { value: g, done: !1 };
      }
      if (this._done) return { value: void 0, done: !0 };
      const a = Promise.withResolvers();
      return this._requests.push(a), a.promise;
    }
    cancel(a) {
      this._done = !0;
      for (const g of this._requests) g.resolve({ value: void 0, done: !0 });
      this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
    }
  }
  const w2 = /^[a-z][a-z0-9\-+.]+:/i;
  function HI(G, a, g) {
    return G.protocol === "http:" ? ns.get("http").request(G, { headers: a }, g) : ns.get("https").request(G, { headers: a }, g);
  }
  class b2 {
    constructor(a) {
      this.source = a, this.url = (function(g) {
        if (w2.test(g)) return new URL(g);
        const l = ns.get("url");
        return new URL(l.pathToFileURL(g));
      })(a.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && a.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
    }
    get _progressiveDataLength() {
      return this._fullRequestReader?._loaded ?? 0;
    }
    getFullReader() {
      return wA(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new S2(this) : new D2(this), this._fullRequestReader;
    }
    getRangeReader(a, g) {
      if (g <= this._progressiveDataLength) return null;
      const l = this.isFsUrl ? new F2(this, a, g) : new k2(this, a, g);
      return this._rangeRequestReaders.push(l), l;
    }
    cancelAllRequests(a) {
      this._fullRequestReader?.cancel(a);
      for (const g of this._rangeRequestReaders.slice(0)) g.cancel(a);
    }
  }
  class JI {
    constructor(a) {
      this._url = a.url, this._done = !1, this._storedError = null, this.onProgress = null;
      const g = a.source;
      this._contentLength = g.length, this._loaded = 0, this._filename = null, this._disableRange = g.disableRange || !1, this._rangeChunkSize = g.rangeChunkSize, this._rangeChunkSize || this._disableRange || (this._disableRange = !0), this._isStreamingSupported = !g.disableStream, this._isRangeSupported = !g.disableRange, this._readableStream = null, this._readCapability = Promise.withResolvers(), this._headersCapability = Promise.withResolvers();
    }
    get headersReady() {
      return this._headersCapability.promise;
    }
    get filename() {
      return this._filename;
    }
    get contentLength() {
      return this._contentLength;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      if (await this._readCapability.promise, this._done) return { value: void 0, done: !0 };
      if (this._storedError) throw this._storedError;
      const a = this._readableStream.read();
      return a === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += a.length, this.onProgress?.({ loaded: this._loaded, total: this._contentLength }), { value: new Uint8Array(a).buffer, done: !1 });
    }
    cancel(a) {
      this._readableStream ? this._readableStream.destroy(a) : this._error(a);
    }
    _error(a) {
      this._storedError = a, this._readCapability.resolve();
    }
    _setReadableStream(a) {
      this._readableStream = a, a.on("readable", (() => {
        this._readCapability.resolve();
      })), a.on("end", (() => {
        a.destroy(), this._done = !0, this._readCapability.resolve();
      })), a.on("error", ((g) => {
        this._error(g);
      })), !this._isStreamingSupported && this._isRangeSupported && this._error(new Us("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
    }
  }
  class YI {
    constructor(a) {
      this._url = a.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = Promise.withResolvers();
      const g = a.source;
      this._isStreamingSupported = !g.disableStream;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      if (await this._readCapability.promise, this._done) return { value: void 0, done: !0 };
      if (this._storedError) throw this._storedError;
      const a = this._readableStream.read();
      return a === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += a.length, this.onProgress?.({ loaded: this._loaded }), { value: new Uint8Array(a).buffer, done: !1 });
    }
    cancel(a) {
      this._readableStream ? this._readableStream.destroy(a) : this._error(a);
    }
    _error(a) {
      this._storedError = a, this._readCapability.resolve();
    }
    _setReadableStream(a) {
      this._readableStream = a, a.on("readable", (() => {
        this._readCapability.resolve();
      })), a.on("end", (() => {
        a.destroy(), this._done = !0, this._readCapability.resolve();
      })), a.on("error", ((g) => {
        this._error(g);
      })), this._storedError && this._readableStream.destroy(this._storedError);
    }
  }
  class D2 extends JI {
    constructor(a) {
      super(a), this._request = HI(this._url, a.httpHeaders, ((g) => {
        if (g.statusCode === 404) {
          const f = new Mi(`Missing PDF "${this._url}".`);
          return this._storedError = f, void this._headersCapability.reject(f);
        }
        this._headersCapability.resolve(), this._setReadableStream(g);
        const l = (f) => this._readableStream.headers[f.toLowerCase()], { allowRangeRequests: B, suggestedLength: Q } = Vg({ getResponseHeader: l, isHttp: a.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange });
        this._isRangeSupported = B, this._contentLength = Q || this._contentLength, this._filename = Xg(l);
      })), this._request.on("error", ((g) => {
        this._storedError = g, this._headersCapability.reject(g);
      })), this._request.end();
    }
  }
  class k2 extends YI {
    constructor(a, g, l) {
      super(a), this._httpHeaders = {};
      for (const B in a.httpHeaders) {
        const Q = a.httpHeaders[B];
        Q !== void 0 && (this._httpHeaders[B] = Q);
      }
      this._httpHeaders.Range = `bytes=${g}-${l - 1}`, this._request = HI(this._url, this._httpHeaders, ((B) => {
        if (B.statusCode !== 404) this._setReadableStream(B);
        else {
          const Q = new Mi(`Missing PDF "${this._url}".`);
          this._storedError = Q;
        }
      })), this._request.on("error", ((B) => {
        this._storedError = B;
      })), this._request.end();
    }
  }
  class S2 extends JI {
    constructor(a) {
      super(a);
      const g = ns.get("fs");
      g.promises.lstat(this._url).then(((l) => {
        this._contentLength = l.size, this._setReadableStream(g.createReadStream(this._url)), this._headersCapability.resolve();
      }), ((l) => {
        l.code === "ENOENT" && (l = new Mi(`Missing PDF "${this._url}".`)), this._storedError = l, this._headersCapability.reject(l);
      }));
    }
  }
  class F2 extends YI {
    constructor(a, g, l) {
      super(a);
      const B = ns.get("fs");
      this._setReadableStream(B.createReadStream(this._url, { start: g, end: l - 1 }));
    }
  }
  const Me = 30;
  class Le {
    #t = Promise.withResolvers();
    #A = null;
    #e = !1;
    #s = !!globalThis.FontInspector?.enabled;
    #a = null;
    #i = null;
    #r = 0;
    #o = 0;
    #h = null;
    #g = null;
    #c = 0;
    #n = 0;
    #l = /* @__PURE__ */ Object.create(null);
    #C = [];
    #I = null;
    #B = [];
    #d = /* @__PURE__ */ new WeakMap();
    #u = null;
    static #E = /* @__PURE__ */ new Map();
    static #p = /* @__PURE__ */ new Map();
    static #y = null;
    static #k = /* @__PURE__ */ new Set();
    constructor({ textContentSource: a, container: g, viewport: l }) {
      if (a instanceof ReadableStream) this.#I = a;
      else {
        if (typeof a != "object") throw new Error('No "textContentSource" parameter specified.');
        this.#I = new ReadableStream({ start(w) {
          w.enqueue(a), w.close();
        } });
      }
      this.#A = this.#g = g, this.#n = l.scale * (globalThis.devicePixelRatio || 1), this.#c = l.rotation, this.#i = { prevFontSize: null, prevFontFamily: null, div: null, properties: null, ctx: null };
      const { pageWidth: B, pageHeight: Q, pageX: f, pageY: m } = l.rawDims;
      this.#u = [1, 0, 0, -1, -f, m + Q], this.#o = B, this.#r = Q, Le.#b(), Hs(g, l), this.#t.promise.catch((() => {
      })).then((() => {
        Le.#k.delete(this), this.#i = null, this.#l = null;
      }));
    }
    render() {
      const a = () => {
        this.#h.read().then((({ value: g, done: l }) => {
          l ? this.#t.resolve() : (this.#a ??= g.lang, Object.assign(this.#l, g.styles), this.#S(g.items), a());
        }), this.#t.reject);
      };
      return this.#h = this.#I.getReader(), Le.#k.add(this), a(), this.#t.promise;
    }
    update({ viewport: a, onBefore: g = null }) {
      const l = a.scale * (globalThis.devicePixelRatio || 1), B = a.rotation;
      if (B !== this.#c && (g?.(), this.#c = B, Hs(this.#g, { rotation: B })), l !== this.#n) {
        g?.(), this.#n = l;
        const Q = { prevFontSize: null, prevFontFamily: null, div: null, properties: null, ctx: Le.#f(this.#a) };
        for (const f of this.#B) Q.properties = this.#d.get(f), Q.div = f, this.#w(Q);
      }
    }
    cancel() {
      const a = new Us("TextLayer task cancelled.");
      this.#h?.cancel(a).catch((() => {
      })), this.#h = null, this.#t.reject(a);
    }
    get textDivs() {
      return this.#B;
    }
    get textContentItemsStr() {
      return this.#C;
    }
    #S(a) {
      if (this.#e) return;
      this.#i.ctx ??= Le.#f(this.#a);
      const g = this.#B, l = this.#C;
      for (const B of a) {
        if (g.length > 1e5) return qt("Ignoring additional textDivs for performance reasons."), void (this.#e = !0);
        if (B.str !== void 0) l.push(B.str), this.#x(B);
        else if (B.type === "beginMarkedContentProps" || B.type === "beginMarkedContent") {
          const Q = this.#A;
          this.#A = document.createElement("span"), this.#A.classList.add("markedContent"), B.id !== null && this.#A.setAttribute("id", `${B.id}`), Q.append(this.#A);
        } else B.type === "endMarkedContent" && (this.#A = this.#A.parentNode);
      }
    }
    #x(a) {
      const g = document.createElement("span"), l = { angle: 0, canvasWidth: 0, hasText: a.str !== "", hasEOL: a.hasEOL, fontSize: 0 };
      this.#B.push(g);
      const B = Pt.transform(this.#u, a.transform);
      let Q = Math.atan2(B[1], B[0]);
      const f = this.#l[a.fontName];
      f.vertical && (Q += Math.PI / 2);
      const m = this.#s && f.fontSubstitution || f.fontFamily, w = Math.hypot(B[2], B[3]), k = w * Le.#D(m, this.#a);
      let F, v;
      Q === 0 ? (F = B[4], v = B[5] - k) : (F = B[4] + k * Math.sin(Q), v = B[5] - k * Math.cos(Q));
      const L = "calc(var(--scale-factor)*", J = g.style;
      this.#A === this.#g ? (J.left = `${(100 * F / this.#o).toFixed(2)}%`, J.top = `${(100 * v / this.#r).toFixed(2)}%`) : (J.left = `${L}${F.toFixed(2)}px)`, J.top = `${L}${v.toFixed(2)}px)`), J.fontSize = `${L}${(Le.#y * w).toFixed(2)}px)`, J.fontFamily = m, l.fontSize = w, g.setAttribute("role", "presentation"), g.textContent = a.str, g.dir = a.dir, this.#s && (g.dataset.fontName = f.fontSubstitutionLoadedName || a.fontName), Q !== 0 && (l.angle = Q * (180 / Math.PI));
      let K = !1;
      if (a.str.length > 1) K = !0;
      else if (a.str !== " " && a.transform[0] !== a.transform[3]) {
        const X = Math.abs(a.transform[0]), et = Math.abs(a.transform[3]);
        X !== et && Math.max(X, et) / Math.min(X, et) > 1.5 && (K = !0);
      }
      if (K && (l.canvasWidth = f.vertical ? a.height : a.width), this.#d.set(g, l), this.#i.div = g, this.#i.properties = l, this.#w(this.#i), l.hasText && this.#A.append(g), l.hasEOL) {
        const X = document.createElement("br");
        X.setAttribute("role", "presentation"), this.#A.append(X);
      }
    }
    #w(a) {
      const { div: g, properties: l, ctx: B, prevFontSize: Q, prevFontFamily: f } = a, { style: m } = g;
      let w = "";
      if (Le.#y > 1 && (w = `scale(${1 / Le.#y})`), l.canvasWidth !== 0 && l.hasText) {
        const { fontFamily: k } = m, { canvasWidth: F, fontSize: v } = l;
        Q === v && f === k || (B.font = `${v * this.#n}px ${k}`, a.prevFontSize = v, a.prevFontFamily = k);
        const { width: L } = B.measureText(g.textContent);
        L > 0 && (w = `scaleX(${F * this.#n / L}) ${w}`);
      }
      l.angle !== 0 && (w = `rotate(${l.angle}deg) ${w}`), w.length > 0 && (m.transform = w);
    }
    static cleanup() {
      if (!(this.#k.size > 0)) {
        this.#E.clear();
        for (const { canvas: a } of this.#p.values()) a.remove();
        this.#p.clear();
      }
    }
    static #f(a = null) {
      let g = this.#p.get(a ||= "");
      if (!g) {
        const l = document.createElement("canvas");
        l.className = "hiddenCanvasElement", l.lang = a, document.body.append(l), g = l.getContext("2d", { alpha: !1, willReadFrequently: !0 }), this.#p.set(a, g);
      }
      return g;
    }
    static #b() {
      if (this.#y !== null) return;
      const a = document.createElement("div");
      a.style.opacity = 0, a.style.lineHeight = 1, a.style.fontSize = "1px", a.style.position = "absolute", a.textContent = "X", document.body.append(a), this.#y = a.getBoundingClientRect().height, a.remove();
    }
    static #D(a, g) {
      const l = this.#E.get(a);
      if (l) return l;
      const B = this.#f(g), Q = B.font;
      B.canvas.width = B.canvas.height = Me, B.font = `30px ${a}`;
      const f = B.measureText("");
      let m = f.fontBoundingBoxAscent, w = Math.abs(f.fontBoundingBoxDescent);
      if (m) {
        const v = m / (m + w);
        return this.#E.set(a, v), B.canvas.width = B.canvas.height = 0, B.font = Q, v;
      }
      B.strokeStyle = "red", B.clearRect(0, 0, Me, Me), B.strokeText("g", 0, 0);
      let k = B.getImageData(0, 0, Me, Me).data;
      w = 0;
      for (let v = k.length - 1 - 3; v >= 0; v -= 4) if (k[v] > 0) {
        w = Math.ceil(v / 4 / Me);
        break;
      }
      B.clearRect(0, 0, Me, Me), B.strokeText("A", 0, Me), k = B.getImageData(0, 0, Me, Me).data, m = 0;
      for (let v = 0, L = k.length; v < L; v += 4) if (k[v] > 0) {
        m = Me - Math.floor(v / 4 / Me);
        break;
      }
      B.canvas.width = B.canvas.height = 0, B.font = Q;
      const F = m ? m / (m + w) : 0.8;
      return this.#E.set(a, F), F;
    }
  }
  class Qn {
    static textContent(a) {
      const g = [], l = { items: g, styles: /* @__PURE__ */ Object.create(null) };
      return (function B(Q) {
        if (!Q) return;
        let f = null;
        const m = Q.name;
        if (m === "#text") f = Q.value;
        else {
          if (!Qn.shouldBuildText(m)) return;
          Q?.attributes?.textContent ? f = Q.attributes.textContent : Q.value && (f = Q.value);
        }
        if (f !== null && g.push({ str: f }), Q.children) for (const w of Q.children) B(w);
      })(a), l;
    }
    static shouldBuildText(a) {
      return !(a === "textarea" || a === "input" || a === "option" || a === "select");
    }
  }
  const R2 = 65536, x2 = e ? class extends gI {
    _createCanvas(G, a) {
      return ns.get("canvas").createCanvas(G, a);
    }
  } : class extends gI {
    constructor({ ownerDocument: G = globalThis.document, enableHWA: a = !1 } = {}) {
      super({ enableHWA: a }), this._document = G;
    }
    _createCanvas(G, a) {
      const g = this._document.createElement("canvas");
      return g.width = G, g.height = a, g;
    }
  }, N2 = e ? class extends cI {
    _fetchData(G, a) {
      return fI(G).then(((g) => ({ cMapData: g, compressionType: a })));
    }
  } : lI, G2 = e ? class extends oI {
  } : class extends oI {
    #t;
    #A;
    #e;
    #s;
    #a;
    #i;
    #r = 0;
    constructor({ docId: G, ownerDocument: a = globalThis.document } = {}) {
      super(), this.#s = G, this.#a = a;
    }
    get #o() {
      return this.#A ||= /* @__PURE__ */ new Map();
    }
    get #h() {
      return this.#i ||= /* @__PURE__ */ new Map();
    }
    get #g() {
      if (!this.#e) {
        const G = this.#a.createElement("div"), { style: a } = G;
        a.visibility = "hidden", a.contain = "strict", a.width = a.height = 0, a.position = "absolute", a.top = a.left = 0, a.zIndex = -1;
        const g = this.#a.createElementNS(Li, "svg");
        g.setAttribute("width", 0), g.setAttribute("height", 0), this.#e = this.#a.createElementNS(Li, "defs"), G.append(g), g.append(this.#e), this.#a.body.append(G);
      }
      return this.#e;
    }
    #c(G) {
      if (G.length === 1) {
        const m = G[0], w = new Array(256);
        for (let F = 0; F < 256; F++) w[F] = m[F] / 255;
        const k = w.join(",");
        return [k, k, k];
      }
      const [a, g, l] = G, B = new Array(256), Q = new Array(256), f = new Array(256);
      for (let m = 0; m < 256; m++) B[m] = a[m] / 255, Q[m] = g[m] / 255, f[m] = l[m] / 255;
      return [B.join(","), Q.join(","), f.join(",")];
    }
    #n(G) {
      if (this.#t === void 0) {
        this.#t = "";
        const a = this.#a.URL;
        a !== this.#a.baseURI && (Mr(a) ? qt('#createUrl: ignore "data:"-URL for performance reasons.') : this.#t = a.split("#", 1)[0]);
      }
      return `url(${this.#t}#${G})`;
    }
    addFilter(G) {
      if (!G) return "none";
      let a = this.#o.get(G);
      if (a) return a;
      const [g, l, B] = this.#c(G), Q = G.length === 1 ? g : `${g}${l}${B}`;
      if (a = this.#o.get(Q), a) return this.#o.set(G, a), a;
      const f = `g_${this.#s}_transfer_map_${this.#r++}`, m = this.#n(f);
      this.#o.set(G, m), this.#o.set(Q, m);
      const w = this.#I(f);
      return this.#d(g, l, B, w), m;
    }
    addHCMFilter(G, a) {
      const g = `${G}-${a}`, l = "base";
      let B = this.#h.get(l);
      if (B?.key === g || (B ? (B.filter?.remove(), B.key = g, B.url = "none", B.filter = null) : (B = { key: g, url: "none", filter: null }, this.#h.set(l, B)), !G || !a)) return B.url;
      const Q = this.#E(G);
      G = Pt.makeHexColor(...Q);
      const f = this.#E(a);
      if (a = Pt.makeHexColor(...f), this.#g.style.color = "", G === "#000000" && a === "#ffffff" || G === a) return B.url;
      const m = new Array(256);
      for (let L = 0; L <= 255; L++) {
        const J = L / 255;
        m[L] = J <= 0.03928 ? J / 12.92 : ((J + 0.055) / 1.055) ** 2.4;
      }
      const w = m.join(","), k = `g_${this.#s}_hcm_filter`, F = B.filter = this.#I(k);
      this.#d(w, w, w, F), this.#C(F);
      const v = (L, J) => {
        const K = Q[L] / 255, X = f[L] / 255, et = new Array(J + 1);
        for (let At = 0; At <= J; At++) et[At] = K + At / J * (X - K);
        return et.join(",");
      };
      return this.#d(v(0, 5), v(1, 5), v(2, 5), F), B.url = this.#n(k), B.url;
    }
    addAlphaFilter(G) {
      let a = this.#o.get(G);
      if (a) return a;
      const [g] = this.#c([G]), l = `alpha_${g}`;
      if (a = this.#o.get(l), a) return this.#o.set(G, a), a;
      const B = `g_${this.#s}_alpha_map_${this.#r++}`, Q = this.#n(B);
      this.#o.set(G, Q), this.#o.set(l, Q);
      const f = this.#I(B);
      return this.#u(g, f), Q;
    }
    addLuminosityFilter(G) {
      let a, g, l = this.#o.get(G || "luminosity");
      if (l) return l;
      if (G ? ([a] = this.#c([G]), g = `luminosity_${a}`) : g = "luminosity", l = this.#o.get(g), l) return this.#o.set(G, l), l;
      const B = `g_${this.#s}_luminosity_map_${this.#r++}`, Q = this.#n(B);
      this.#o.set(G, Q), this.#o.set(g, Q);
      const f = this.#I(B);
      return this.#l(f), G && this.#u(a, f), Q;
    }
    addHighlightHCMFilter(G, a, g, l, B) {
      const Q = `${a}-${g}-${l}-${B}`;
      let f = this.#h.get(G);
      if (f?.key === Q || (f ? (f.filter?.remove(), f.key = Q, f.url = "none", f.filter = null) : (f = { key: Q, url: "none", filter: null }, this.#h.set(G, f)), !a || !g)) return f.url;
      const [m, w] = [a, g].map(this.#E.bind(this));
      let k = Math.round(0.2126 * m[0] + 0.7152 * m[1] + 0.0722 * m[2]), F = Math.round(0.2126 * w[0] + 0.7152 * w[1] + 0.0722 * w[2]), [v, L] = [l, B].map(this.#E.bind(this));
      F < k && ([k, F, v, L] = [F, k, L, v]), this.#g.style.color = "";
      const J = (et, At, It) => {
        const kt = new Array(256), Mt = (F - k) / It, Ut = et / 255, xt = (At - et) / (255 * It);
        let Wt = 0;
        for (let eA = 0; eA <= It; eA++) {
          const nA = Math.round(k + eA * Mt), EA = Ut + eA * xt;
          for (let sA = Wt; sA <= nA; sA++) kt[sA] = EA;
          Wt = nA + 1;
        }
        for (let eA = Wt; eA < 256; eA++) kt[eA] = kt[Wt - 1];
        return kt.join(",");
      }, K = `g_${this.#s}_hcm_${G}_filter`, X = f.filter = this.#I(K);
      return this.#C(X), this.#d(J(v[0], L[0], 5), J(v[1], L[1], 5), J(v[2], L[2], 5), X), f.url = this.#n(K), f.url;
    }
    destroy(G = !1) {
      G && this.#h.size !== 0 || (this.#e && (this.#e.parentNode.parentNode.remove(), this.#e = null), this.#A && (this.#A.clear(), this.#A = null), this.#r = 0);
    }
    #l(G) {
      const a = this.#a.createElementNS(Li, "feColorMatrix");
      a.setAttribute("type", "matrix"), a.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0"), G.append(a);
    }
    #C(G) {
      const a = this.#a.createElementNS(Li, "feColorMatrix");
      a.setAttribute("type", "matrix"), a.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), G.append(a);
    }
    #I(G) {
      const a = this.#a.createElementNS(Li, "filter");
      return a.setAttribute("color-interpolation-filters", "sRGB"), a.setAttribute("id", G), this.#g.append(a), a;
    }
    #B(G, a, g) {
      const l = this.#a.createElementNS(Li, a);
      l.setAttribute("type", "discrete"), l.setAttribute("tableValues", g), G.append(l);
    }
    #d(G, a, g, l) {
      const B = this.#a.createElementNS(Li, "feComponentTransfer");
      l.append(B), this.#B(B, "feFuncR", G), this.#B(B, "feFuncG", a), this.#B(B, "feFuncB", g);
    }
    #u(G, a) {
      const g = this.#a.createElementNS(Li, "feComponentTransfer");
      a.append(g), this.#B(g, "feFuncA", G);
    }
    #E(G) {
      return this.#g.style.color = G, Lg(getComputedStyle(this.#g).getPropertyValue("color"));
    }
  }, v2 = e ? class extends hI {
    _fetchData(G) {
      return fI(G);
    }
  } : II;
  function M2(G = {}) {
    typeof G == "string" || G instanceof URL ? G = { url: G } : (G instanceof ArrayBuffer || ArrayBuffer.isView(G)) && (G = { data: G });
    const a = new zg(), { docId: g } = a, l = G.url ? (function(mA) {
      if (mA instanceof URL) return mA.href;
      try {
        return new URL(mA, window.location).href;
      } catch {
        if (e && typeof mA == "string") return mA;
      }
      throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
    })(G.url) : null, B = G.data ? (function(mA) {
      if (e && Pn !== void 0 && mA instanceof Pn) throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
      if (mA instanceof Uint8Array && mA.byteLength === mA.buffer.byteLength) return mA;
      if (typeof mA == "string") return Gr(mA);
      if (mA instanceof ArrayBuffer || ArrayBuffer.isView(mA) || typeof mA == "object" && !isNaN(mA?.length)) return new Uint8Array(mA);
      throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
    })(G.data) : null, Q = G.httpHeaders || null, f = G.withCredentials === !0, m = G.password ?? null, w = G.range instanceof KI ? G.range : null, k = Number.isInteger(G.rangeChunkSize) && G.rangeChunkSize > 0 ? G.rangeChunkSize : R2;
    let F = G.worker instanceof $A ? G.worker : null;
    const v = G.verbosity, L = typeof G.docBaseUrl != "string" || Mr(G.docBaseUrl) ? null : G.docBaseUrl, J = typeof G.cMapUrl == "string" ? G.cMapUrl : null, K = G.cMapPacked !== !1, X = G.CMapReaderFactory || N2, et = typeof G.standardFontDataUrl == "string" ? G.standardFontDataUrl : null, At = G.StandardFontDataFactory || v2, It = G.stopAtErrors !== !0, kt = Number.isInteger(G.maxImageSize) && G.maxImageSize > -1 ? G.maxImageSize : -1, Mt = G.isEvalSupported !== !1, Ut = typeof G.isOffscreenCanvasSupported == "boolean" ? G.isOffscreenCanvasSupported : !e, xt = Number.isInteger(G.canvasMaxAreaInBytes) ? G.canvasMaxAreaInBytes : -1, Wt = typeof G.disableFontFace == "boolean" ? G.disableFontFace : e, eA = G.fontExtraProperties === !0, nA = G.enableXfa === !0, EA = G.ownerDocument || globalThis.document, sA = G.disableRange === !0, ke = G.disableStream === !0, ZA = G.disableAutoFetch === !0, kA = G.pdfBug === !0, se = G.enableHWA === !0, oi = w ? w.length : G.length ?? NaN, os = typeof G.useSystemFonts == "boolean" ? G.useSystemFonts : !e && !Wt, rA = typeof G.useWorkerFetch == "boolean" ? G.useWorkerFetch : X === lI && At === II && J && et && hn(J, document.baseURI) && hn(et, document.baseURI), dA = G.canvasFactory || new x2({ ownerDocument: EA, enableHWA: se }), qr = G.filterFactory || new G2({ docId: g, ownerDocument: EA });
    Jt(v);
    const ya = { canvasFactory: dA, filterFactory: qr };
    if (rA || (ya.cMapReaderFactory = new X({ baseUrl: J, isCompressed: K }), ya.standardFontDataFactory = new At({ baseUrl: et })), !F) {
      const mA = { verbosity: v, port: Bn.workerPort };
      F = mA.port ? $A.fromPort(mA) : new $A(mA), a._worker = F;
    }
    const Ue = { docId: g, apiVersion: "4.6.82", data: B, password: m, disableAutoFetch: ZA, rangeChunkSize: k, length: oi, docBaseUrl: L, enableXfa: nA, evaluatorOptions: { maxImageSize: kt, disableFontFace: Wt, ignoreErrors: It, isEvalSupported: Mt, isOffscreenCanvasSupported: Ut, canvasMaxAreaInBytes: xt, fontExtraProperties: eA, useSystemFonts: os, cMapUrl: rA ? J : null, standardFontDataUrl: rA ? et : null } }, Qe = { disableFontFace: Wt, fontExtraProperties: eA, ownerDocument: EA, pdfBug: kA, styleElement: null, loadingParams: { disableAutoFetch: ZA, enableXfa: nA } };
    return F.promise.then((function() {
      if (a.destroyed) throw new Error("Loading aborted");
      if (F.destroyed) throw new Error("Worker was destroyed");
      const mA = F.messageHandler.sendWithPromise("GetDocRequest", Ue, B ? [B.buffer] : null);
      let pn;
      if (w) pn = new u2(w, { disableRange: sA, disableStream: ke });
      else if (!B) {
        if (!l) throw new Error("getDocument - no `url` parameter provided.");
        pn = ((He) => e ? (function() {
          return typeof fetch < "u" && typeof Response < "u" && "body" in Response.prototype;
        })() && hn(He.url) ? new UI(He) : new b2(He) : hn(He.url) ? new UI(He) : new p2(He))({ url: l, length: oi, httpHeaders: Q, withCredentials: f, rangeChunkSize: k, disableRange: sA, disableStream: ke });
      }
      return mA.then(((He) => {
        if (a.destroyed) throw new Error("Loading aborted");
        if (F.destroyed) throw new Error("Worker was destroyed");
        const ae = new dn(g, He, F.port), gp = new J2(ae, a, pn, Qe, ya);
        a._transport = gp, ae.send("Ready", null);
      }));
    })).catch(a._capability.reject), a;
  }
  function TI(G) {
    return typeof G == "object" && Number.isInteger(G?.num) && G.num >= 0 && Number.isInteger(G?.gen) && G.gen >= 0;
  }
  class zg {
    static #t = 0;
    constructor() {
      this._capability = Promise.withResolvers(), this._transport = null, this._worker = null, this.docId = "d" + zg.#t++, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
    }
    get promise() {
      return this._capability.promise;
    }
    async destroy() {
      this.destroyed = !0;
      try {
        this._worker?.port && (this._worker._pendingDestroy = !0), await this._transport?.destroy();
      } catch (a) {
        throw this._worker?.port && delete this._worker._pendingDestroy, a;
      }
      this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
    }
  }
  class KI {
    constructor(a, g, l = !1, B = null) {
      this.length = a, this.initialData = g, this.progressiveDone = l, this.contentDispositionFilename = B, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = Promise.withResolvers();
    }
    addRangeListener(a) {
      this._rangeListeners.push(a);
    }
    addProgressListener(a) {
      this._progressListeners.push(a);
    }
    addProgressiveReadListener(a) {
      this._progressiveReadListeners.push(a);
    }
    addProgressiveDoneListener(a) {
      this._progressiveDoneListeners.push(a);
    }
    onDataRange(a, g) {
      for (const l of this._rangeListeners) l(a, g);
    }
    onDataProgress(a, g) {
      this._readyCapability.promise.then((() => {
        for (const l of this._progressListeners) l(a, g);
      }));
    }
    onDataProgressiveRead(a) {
      this._readyCapability.promise.then((() => {
        for (const g of this._progressiveReadListeners) g(a);
      }));
    }
    onDataProgressiveDone() {
      this._readyCapability.promise.then((() => {
        for (const a of this._progressiveDoneListeners) a();
      }));
    }
    transportReady() {
      this._readyCapability.resolve();
    }
    requestDataRange(a, g) {
      Xt("Abstract method PDFDataRangeTransport.requestDataRange");
    }
    abort() {
    }
  }
  class L2 {
    constructor(a, g) {
      this._pdfInfo = a, this._transport = g;
    }
    get annotationStorage() {
      return this._transport.annotationStorage;
    }
    get filterFactory() {
      return this._transport.filterFactory;
    }
    get numPages() {
      return this._pdfInfo.numPages;
    }
    get fingerprints() {
      return this._pdfInfo.fingerprints;
    }
    get isPureXfa() {
      return aA(this, "isPureXfa", !!this._transport._htmlForXfa);
    }
    get allXfaHtml() {
      return this._transport._htmlForXfa;
    }
    getPage(a) {
      return this._transport.getPage(a);
    }
    getPageIndex(a) {
      return this._transport.getPageIndex(a);
    }
    getDestinations() {
      return this._transport.getDestinations();
    }
    getDestination(a) {
      return this._transport.getDestination(a);
    }
    getPageLabels() {
      return this._transport.getPageLabels();
    }
    getPageLayout() {
      return this._transport.getPageLayout();
    }
    getPageMode() {
      return this._transport.getPageMode();
    }
    getViewerPreferences() {
      return this._transport.getViewerPreferences();
    }
    getOpenAction() {
      return this._transport.getOpenAction();
    }
    getAttachments() {
      return this._transport.getAttachments();
    }
    getJSActions() {
      return this._transport.getDocJSActions();
    }
    getOutline() {
      return this._transport.getOutline();
    }
    getOptionalContentConfig({ intent: a = "display" } = {}) {
      const { renderingIntent: g } = this._transport.getRenderingIntent(a);
      return this._transport.getOptionalContentConfig(g);
    }
    getPermissions() {
      return this._transport.getPermissions();
    }
    getMetadata() {
      return this._transport.getMetadata();
    }
    getMarkInfo() {
      return this._transport.getMarkInfo();
    }
    getData() {
      return this._transport.getData();
    }
    saveDocument() {
      return this._transport.saveDocument();
    }
    getDownloadInfo() {
      return this._transport.downloadInfoCapability.promise;
    }
    cleanup(a = !1) {
      return this._transport.startCleanup(a || this.isPureXfa);
    }
    destroy() {
      return this.loadingTask.destroy();
    }
    cachedPageNumber(a) {
      return this._transport.cachedPageNumber(a);
    }
    get loadingParams() {
      return this._transport.loadingParams;
    }
    get loadingTask() {
      return this._transport.loadingTask;
    }
    getFieldObjects() {
      return this._transport.getFieldObjects();
    }
    hasJSActions() {
      return this._transport.hasJSActions();
    }
    getCalculationOrderIds() {
      return this._transport.getCalculationOrderIds();
    }
  }
  class U2 {
    #t = null;
    #A = !1;
    constructor(a, g, l, B = !1) {
      this._pageIndex = a, this._pageInfo = g, this._transport = l, this._stats = B ? new CI() : null, this._pdfBug = B, this.commonObjs = l.commonObjs, this.objs = new qI(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
    }
    get pageNumber() {
      return this._pageIndex + 1;
    }
    get rotate() {
      return this._pageInfo.rotate;
    }
    get ref() {
      return this._pageInfo.ref;
    }
    get userUnit() {
      return this._pageInfo.userUnit;
    }
    get view() {
      return this._pageInfo.view;
    }
    getViewport({ scale: a, rotation: g = this.rotate, offsetX: l = 0, offsetY: B = 0, dontFlip: Q = !1 } = {}) {
      return new cn({ viewBox: this.view, scale: a, rotation: g, offsetX: l, offsetY: B, dontFlip: Q });
    }
    getAnnotations({ intent: a = "display" } = {}) {
      const { renderingIntent: g } = this._transport.getRenderingIntent(a);
      return this._transport.getAnnotations(this._pageIndex, g);
    }
    getJSActions() {
      return this._transport.getPageJSActions(this._pageIndex);
    }
    get filterFactory() {
      return this._transport.filterFactory;
    }
    get isPureXfa() {
      return aA(this, "isPureXfa", !!this._transport._htmlForXfa);
    }
    async getXfa() {
      return this._transport._htmlForXfa?.children[this._pageIndex] || null;
    }
    render({ canvasContext: a, viewport: g, intent: l = "display", annotationMode: B = E.ENABLE, transform: Q = null, background: f = null, optionalContentConfigPromise: m = null, annotationCanvasMap: w = null, pageColors: k = null, printAnnotationStorage: F = null, isEditing: v = !1 }) {
      this._stats?.time("Overall");
      const L = this._transport.getRenderingIntent(l, B, F, v), { renderingIntent: J, cacheKey: K } = L;
      this.#A = !1, this.#s(), m ||= this._transport.getOptionalContentConfig(J);
      let X = this._intentStates.get(K);
      X || (X = /* @__PURE__ */ Object.create(null), this._intentStates.set(K, X)), X.streamReaderCancelTimeout && (clearTimeout(X.streamReaderCancelTimeout), X.streamReaderCancelTimeout = null);
      const et = !!(J & c);
      X.displayReadyCapability || (X.displayReadyCapability = Promise.withResolvers(), X.operatorList = { fnArray: [], argsArray: [], lastChunk: !1, separateAnnots: null }, this._stats?.time("Page Request"), this._pumpOperatorList(L));
      const At = (Mt) => {
        X.renderTasks.delete(It), (this._maybeCleanupAfterRender || et) && (this.#A = !0), this.#e(!et), Mt ? (It.capability.reject(Mt), this._abortOperatorList({ intentState: X, reason: Mt instanceof Error ? Mt : new Error(Mt) })) : It.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"), globalThis.Stats?.enabled && globalThis.Stats.add(this.pageNumber, this._stats));
      }, It = new ma({ callback: At, params: { canvasContext: a, viewport: g, transform: Q, background: f }, objs: this.objs, commonObjs: this.commonObjs, annotationCanvasMap: w, operatorList: X.operatorList, pageIndex: this._pageIndex, canvasFactory: this._transport.canvasFactory, filterFactory: this._transport.filterFactory, useRequestAnimationFrame: !et, pdfBug: this._pdfBug, pageColors: k });
      (X.renderTasks ||= /* @__PURE__ */ new Set()).add(It);
      const kt = It.task;
      return Promise.all([X.displayReadyCapability.promise, m]).then((([Mt, Ut]) => {
        if (this.destroyed) At();
        else {
          if (this._stats?.time("Rendering"), !(Ut.renderingIntent & J)) throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
          It.initializeGraphics({ transparency: Mt, optionalContentConfig: Ut }), It.operatorListChanged();
        }
      })).catch(At), kt;
    }
    getOperatorList({ intent: a = "display", annotationMode: g = E.ENABLE, printAnnotationStorage: l = null, isEditing: B = !1 } = {}) {
      const Q = this._transport.getRenderingIntent(a, g, l, B, !0);
      let f, m = this._intentStates.get(Q.cacheKey);
      return m || (m = /* @__PURE__ */ Object.create(null), this._intentStates.set(Q.cacheKey, m)), m.opListReadCapability || (f = /* @__PURE__ */ Object.create(null), f.operatorListChanged = function() {
        m.operatorList.lastChunk && (m.opListReadCapability.resolve(m.operatorList), m.renderTasks.delete(f));
      }, m.opListReadCapability = Promise.withResolvers(), (m.renderTasks ||= /* @__PURE__ */ new Set()).add(f), m.operatorList = { fnArray: [], argsArray: [], lastChunk: !1, separateAnnots: null }, this._stats?.time("Page Request"), this._pumpOperatorList(Q)), m.opListReadCapability.promise;
    }
    streamTextContent({ includeMarkedContent: a = !1, disableNormalization: g = !1 } = {}) {
      return this._transport.messageHandler.sendWithStream("GetTextContent", { pageIndex: this._pageIndex, includeMarkedContent: a === !0, disableNormalization: g === !0 }, { highWaterMark: 100, size: (l) => l.items.length });
    }
    getTextContent(a = {}) {
      if (this._transport._htmlForXfa) return this.getXfa().then(((l) => Qn.textContent(l)));
      const g = this.streamTextContent(a);
      return new Promise((function(l, B) {
        const Q = g.getReader(), f = { items: [], styles: /* @__PURE__ */ Object.create(null), lang: null };
        (function m() {
          Q.read().then((function({ value: w, done: k }) {
            k ? l(f) : (f.lang ??= w.lang, Object.assign(f.styles, w.styles), f.items.push(...w.items), m());
          }), B);
        })();
      }));
    }
    getStructTree() {
      return this._transport.getStructTree(this._pageIndex);
    }
    _destroy() {
      this.destroyed = !0;
      const a = [];
      for (const g of this._intentStates.values()) if (this._abortOperatorList({ intentState: g, reason: new Error("Page was destroyed."), force: !0 }), !g.opListReadCapability) for (const l of g.renderTasks) a.push(l.completed), l.cancel();
      return this.objs.clear(), this.#A = !1, this.#s(), Promise.all(a);
    }
    cleanup(a = !1) {
      this.#A = !0;
      const g = this.#e(!1);
      return a && g && (this._stats &&= new CI()), g;
    }
    #e(a = !1) {
      if (this.#s(), !this.#A || this.destroyed) return !1;
      if (a) return this.#t = setTimeout((() => {
        this.#t = null, this.#e(!1);
      }), 5e3), !1;
      for (const { renderTasks: g, operatorList: l } of this._intentStates.values()) if (g.size > 0 || !l.lastChunk) return !1;
      return this._intentStates.clear(), this.objs.clear(), this.#A = !1, !0;
    }
    #s() {
      this.#t && (clearTimeout(this.#t), this.#t = null);
    }
    _startRenderPage(a, g) {
      const l = this._intentStates.get(g);
      l && (this._stats?.timeEnd("Page Request"), l.displayReadyCapability?.resolve(a));
    }
    _renderPageChunk(a, g) {
      for (let l = 0, B = a.length; l < B; l++) g.operatorList.fnArray.push(a.fnArray[l]), g.operatorList.argsArray.push(a.argsArray[l]);
      g.operatorList.lastChunk = a.lastChunk, g.operatorList.separateAnnots = a.separateAnnots;
      for (const l of g.renderTasks) l.operatorListChanged();
      a.lastChunk && this.#e(!0);
    }
    _pumpOperatorList({ renderingIntent: a, cacheKey: g, annotationStorageSerializable: l, modifiedIds: B }) {
      const { map: Q, transfer: f } = l, m = this._transport.messageHandler.sendWithStream("GetOperatorList", { pageIndex: this._pageIndex, intent: a, cacheKey: g, annotationStorage: Q, modifiedIds: B }, f).getReader(), w = this._intentStates.get(g);
      w.streamReader = m;
      const k = () => {
        m.read().then((({ value: F, done: v }) => {
          v ? w.streamReader = null : this._transport.destroyed || (this._renderPageChunk(F, w), k());
        }), ((F) => {
          if (w.streamReader = null, !this._transport.destroyed) {
            if (w.operatorList) {
              w.operatorList.lastChunk = !0;
              for (const v of w.renderTasks) v.operatorListChanged();
              this.#e(!0);
            }
            if (w.displayReadyCapability) w.displayReadyCapability.reject(F);
            else {
              if (!w.opListReadCapability) throw F;
              w.opListReadCapability.reject(F);
            }
          }
        }));
      };
      k();
    }
    _abortOperatorList({ intentState: a, reason: g, force: l = !1 }) {
      if (a.streamReader) {
        if (a.streamReaderCancelTimeout && (clearTimeout(a.streamReaderCancelTimeout), a.streamReaderCancelTimeout = null), !l) {
          if (a.renderTasks.size > 0) return;
          if (g instanceof vg) {
            let B = 100;
            return g.extraDelay > 0 && g.extraDelay < 1e3 && (B += g.extraDelay), void (a.streamReaderCancelTimeout = setTimeout((() => {
              a.streamReaderCancelTimeout = null, this._abortOperatorList({ intentState: a, reason: g, force: !0 });
            }), B));
          }
        }
        if (a.streamReader.cancel(new Us(g.message)).catch((() => {
        })), a.streamReader = null, !this._transport.destroyed) {
          for (const [B, Q] of this._intentStates) if (Q === a) {
            this._intentStates.delete(B);
            break;
          }
          this.cleanup();
        }
      }
    }
    get stats() {
      return this._stats;
    }
  }
  class H2 {
    #t = /* @__PURE__ */ new Set();
    #A = Promise.resolve();
    postMessage(a, g) {
      const l = { data: structuredClone(a, g ? { transfer: g } : null) };
      this.#A.then((() => {
        for (const B of this.#t) B.call(this, l);
      }));
    }
    addEventListener(a, g) {
      this.#t.add(g);
    }
    removeEventListener(a, g) {
      this.#t.delete(g);
    }
    terminate() {
      this.#t.clear();
    }
  }
  class $A {
    static #t = 0;
    static #A = !1;
    static #e;
    static {
      e && (this.#A = !0, Bn.workerSrc ||= "./pdf.worker.mjs"), this._isSameOrigin = (a, g) => {
        let l;
        try {
          if (l = new URL(a), !l.origin || l.origin === "null") return !1;
        } catch {
          return !1;
        }
        const B = new URL(g, l);
        return l.origin === B.origin;
      }, this._createCDNWrapper = (a) => {
        const g = `await import("${a}");`;
        return URL.createObjectURL(new Blob([g], { type: "text/javascript" }));
      };
    }
    constructor({ name: a = null, port: g = null, verbosity: l = Gt() } = {}) {
      if (this.name = a, this.destroyed = !1, this.verbosity = l, this._readyCapability = Promise.withResolvers(), this._port = null, this._webWorker = null, this._messageHandler = null, g) {
        if ($A.#e?.has(g)) throw new Error("Cannot use more than one PDFWorker per port.");
        return ($A.#e ||= /* @__PURE__ */ new WeakMap()).set(g, this), void this._initializeFromPort(g);
      }
      this._initialize();
    }
    get promise() {
      return e ? Promise.all([ns.promise, this._readyCapability.promise]) : this._readyCapability.promise;
    }
    #s() {
      this._readyCapability.resolve(), this._messageHandler.send("configure", { verbosity: this.verbosity });
    }
    get port() {
      return this._port;
    }
    get messageHandler() {
      return this._messageHandler;
    }
    _initializeFromPort(a) {
      this._port = a, this._messageHandler = new dn("main", "worker", a), this._messageHandler.on("ready", (function() {
      })), this.#s();
    }
    _initialize() {
      if ($A.#A || $A.#a) return void this._setupFakeWorker();
      let { workerSrc: a } = $A;
      try {
        $A._isSameOrigin(window.location.href, a) || (a = $A._createCDNWrapper(new URL(a, window.location).href));
        const g = new Worker(a, { type: "module" }), l = new dn("main", "worker", g), B = () => {
          Q.abort(), l.destroy(), g.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
        }, Q = new AbortController();
        g.addEventListener("error", (() => {
          this._webWorker || B();
        }), { signal: Q.signal }), l.on("test", ((m) => {
          Q.abort(), !this.destroyed && m ? (this._messageHandler = l, this._port = g, this._webWorker = g, this.#s()) : B();
        })), l.on("ready", ((m) => {
          if (Q.abort(), this.destroyed) B();
          else try {
            f();
          } catch {
            this._setupFakeWorker();
          }
        }));
        const f = () => {
          const m = new Uint8Array();
          l.send("test", m, [m.buffer]);
        };
        return void f();
      } catch {
        Zt("The worker has been disabled.");
      }
      this._setupFakeWorker();
    }
    _setupFakeWorker() {
      $A.#A || (qt("Setting up fake worker."), $A.#A = !0), $A._setupFakeWorkerGlobal.then(((a) => {
        if (this.destroyed) return void this._readyCapability.reject(new Error("Worker was destroyed"));
        const g = new H2();
        this._port = g;
        const l = "fake" + $A.#t++, B = new dn(l + "_worker", l, g);
        a.setup(B, g), this._messageHandler = new dn(l, l + "_worker", g), this.#s();
      })).catch(((a) => {
        this._readyCapability.reject(new Error(`Setting up fake worker failed: "${a.message}".`));
      }));
    }
    destroy() {
      this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), $A.#e?.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
    }
    static fromPort(a) {
      if (!a?.port) throw new Error("PDFWorker.fromPort - invalid method signature.");
      const g = this.#e?.get(a.port);
      if (g) {
        if (g._pendingDestroy) throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
        return g;
      }
      return new $A(a);
    }
    static get workerSrc() {
      if (Bn.workerSrc) return Bn.workerSrc;
      throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
    }
    static get #a() {
      try {
        return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
      } catch {
        return null;
      }
    }
    static get _setupFakeWorkerGlobal() {
      return aA(this, "_setupFakeWorkerGlobal", (async () => this.#a ? this.#a : (await import(this.workerSrc)).WorkerMessageHandler)());
    }
  }
  class J2 {
    #t = /* @__PURE__ */ new Map();
    #A = /* @__PURE__ */ new Map();
    #e = /* @__PURE__ */ new Map();
    #s = /* @__PURE__ */ new Map();
    #a = null;
    constructor(a, g, l, B, Q) {
      this.messageHandler = a, this.loadingTask = g, this.commonObjs = new qI(), this.fontLoader = new $f({ ownerDocument: B.ownerDocument, styleElement: B.styleElement }), this.loadingParams = B.loadingParams, this._params = B, this.canvasFactory = Q.canvasFactory, this.filterFactory = Q.filterFactory, this.cMapReaderFactory = Q.cMapReaderFactory, this.standardFontDataFactory = Q.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = l, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = Promise.withResolvers(), this.setupMessageHandler();
    }
    #i(a, g = null) {
      const l = this.#t.get(a);
      if (l) return l;
      const B = this.messageHandler.sendWithPromise(a, g);
      return this.#t.set(a, B), B;
    }
    get annotationStorage() {
      return aA(this, "annotationStorage", new Yg());
    }
    getRenderingIntent(a, g = E.ENABLE, l = null, B = !1, Q = !1) {
      let f = r, m = Jg;
      switch (a) {
        case "any":
          f = o;
          break;
        case "display":
          break;
        case "print":
          f = c;
          break;
        default:
          qt(`getRenderingIntent - invalid intent: ${a}`);
      }
      const w = f & c && l instanceof EI ? l : this.annotationStorage;
      switch (g) {
        case E.DISABLE:
          f += C;
          break;
        case E.ENABLE:
          break;
        case E.ENABLE_FORMS:
          f += h;
          break;
        case E.ENABLE_STORAGE:
          f += I, m = w.serializable;
          break;
        default:
          qt(`getRenderingIntent - invalid annotationMode: ${g}`);
      }
      B && (f += d), Q && (f += u);
      const { ids: k, hash: F } = w.modifiedIds;
      return { renderingIntent: f, cacheKey: [f, m.hash, F].join("_"), annotationStorageSerializable: m, modifiedIds: k };
    }
    destroy() {
      if (this.destroyCapability) return this.destroyCapability.promise;
      this.destroyed = !0, this.destroyCapability = Promise.withResolvers(), this.#a?.reject(new Error("Worker was destroyed during onPassword callback"));
      const a = [];
      for (const l of this.#A.values()) a.push(l._destroy());
      this.#A.clear(), this.#e.clear(), this.#s.clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
      const g = this.messageHandler.sendWithPromise("Terminate", null);
      return a.push(g), Promise.all(a).then((() => {
        this.commonObjs.clear(), this.fontLoader.clear(), this.#t.clear(), this.filterFactory.destroy(), Le.cleanup(), this._networkStream?.cancelAllRequests(new Us("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
      }), this.destroyCapability.reject), this.destroyCapability.promise;
    }
    setupMessageHandler() {
      const { messageHandler: a, loadingTask: g } = this;
      a.on("GetReader", ((l, B) => {
        wA(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (Q) => {
          this._lastProgress = { loaded: Q.loaded, total: Q.total };
        }, B.onPull = () => {
          this._fullReader.read().then((function({ value: Q, done: f }) {
            f ? B.close() : (wA(Q instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), B.enqueue(new Uint8Array(Q), 1, [Q]));
          })).catch(((Q) => {
            B.error(Q);
          }));
        }, B.onCancel = (Q) => {
          this._fullReader.cancel(Q), B.ready.catch(((f) => {
            if (!this.destroyed) throw f;
          }));
        };
      })), a.on("ReaderHeadersReady", ((l) => {
        const B = Promise.withResolvers(), Q = this._fullReader;
        return Q.headersReady.then((() => {
          Q.isStreamingSupported && Q.isRangeSupported || (this._lastProgress && g.onProgress?.(this._lastProgress), Q.onProgress = (f) => {
            g.onProgress?.({ loaded: f.loaded, total: f.total });
          }), B.resolve({ isStreamingSupported: Q.isStreamingSupported, isRangeSupported: Q.isRangeSupported, contentLength: Q.contentLength });
        }), B.reject), B.promise;
      })), a.on("GetRangeReader", ((l, B) => {
        wA(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
        const Q = this._networkStream.getRangeReader(l.begin, l.end);
        Q ? (B.onPull = () => {
          Q.read().then((function({ value: f, done: m }) {
            m ? B.close() : (wA(f instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), B.enqueue(new Uint8Array(f), 1, [f]));
          })).catch(((f) => {
            B.error(f);
          }));
        }, B.onCancel = (f) => {
          Q.cancel(f), B.ready.catch(((m) => {
            if (!this.destroyed) throw m;
          }));
        }) : B.close();
      })), a.on("GetDoc", (({ pdfInfo: l }) => {
        this._numPages = l.numPages, this._htmlForXfa = l.htmlForXfa, delete l.htmlForXfa, g._capability.resolve(new L2(l, this));
      })), a.on("DocException", (function(l) {
        let B;
        switch (l.name) {
          case "PasswordException":
            B = new da(l.message, l.code);
            break;
          case "InvalidPDFException":
            B = new gn(l.message);
            break;
          case "MissingPDFException":
            B = new Mi(l.message);
            break;
          case "UnexpectedResponseException":
            B = new Ea(l.message, l.status);
            break;
          case "UnknownErrorException":
            B = new Qa(l.message, l.details);
            break;
          default:
            Xt("DocException - expected a valid Error.");
        }
        g._capability.reject(B);
      })), a.on("PasswordRequest", ((l) => {
        if (this.#a = Promise.withResolvers(), g.onPassword) {
          const B = (Q) => {
            Q instanceof Error ? this.#a.reject(Q) : this.#a.resolve({ password: Q });
          };
          try {
            g.onPassword(B, l.code);
          } catch (Q) {
            this.#a.reject(Q);
          }
        } else this.#a.reject(new da(l.message, l.code));
        return this.#a.promise;
      })), a.on("DataLoaded", ((l) => {
        g.onProgress?.({ loaded: l.length, total: l.length }), this.downloadInfoCapability.resolve(l);
      })), a.on("StartRenderPage", ((l) => {
        this.destroyed || this.#A.get(l.pageIndex)._startRenderPage(l.transparency, l.cacheKey);
      })), a.on("commonobj", (([l, B, Q]) => {
        if (this.destroyed || this.commonObjs.has(l)) return null;
        switch (B) {
          case "Font":
            const { disableFontFace: f, fontExtraProperties: m, pdfBug: w } = this._params;
            if ("error" in Q) {
              const L = Q.error;
              qt(`Error during font loading: ${L}`), this.commonObjs.resolve(l, L);
              break;
            }
            const k = w && globalThis.FontInspector?.enabled ? (L, J) => globalThis.FontInspector.fontAdded(L, J) : null, F = new t2(Q, { disableFontFace: f, inspectFont: k });
            this.fontLoader.bind(F).catch((() => a.sendWithPromise("FontFallback", { id: l }))).finally((() => {
              !m && F.data && (F.data = null), this.commonObjs.resolve(l, F);
            }));
            break;
          case "CopyLocalImage":
            const { imageRef: v } = Q;
            wA(v, "The imageRef must be defined.");
            for (const L of this.#A.values()) for (const [, J] of L.objs) if (J?.ref === v) return J.dataLen ? (this.commonObjs.resolve(l, structuredClone(J)), J.dataLen) : null;
            break;
          case "FontPath":
          case "Image":
          case "Pattern":
            this.commonObjs.resolve(l, Q);
            break;
          default:
            throw new Error(`Got unknown common object type ${B}`);
        }
        return null;
      })), a.on("obj", (([l, B, Q, f]) => {
        if (this.destroyed) return;
        const m = this.#A.get(B);
        if (!m.objs.has(l)) if (m._intentStates.size !== 0) switch (Q) {
          case "Image":
            m.objs.resolve(l, f), f?.dataLen > 1e7 && (m._maybeCleanupAfterRender = !0);
            break;
          case "Pattern":
            m.objs.resolve(l, f);
            break;
          default:
            throw new Error(`Got unknown object type ${Q}`);
        }
        else f?.bitmap?.close();
      })), a.on("DocProgress", ((l) => {
        this.destroyed || g.onProgress?.({ loaded: l.loaded, total: l.total });
      })), a.on("FetchBuiltInCMap", ((l) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(l) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.")))), a.on("FetchStandardFontData", ((l) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(l) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."))));
    }
    getData() {
      return this.messageHandler.sendWithPromise("GetData", null);
    }
    saveDocument() {
      this.annotationStorage.size <= 0 && qt("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
      const { map: a, transfer: g } = this.annotationStorage.serializable;
      return this.messageHandler.sendWithPromise("SaveDocument", { isPureXfa: !!this._htmlForXfa, numPages: this._numPages, annotationStorage: a, filename: this._fullReader?.filename ?? null }, g).finally((() => {
        this.annotationStorage.resetModified();
      }));
    }
    getPage(a) {
      if (!Number.isInteger(a) || a <= 0 || a > this._numPages) return Promise.reject(new Error("Invalid page request."));
      const g = a - 1, l = this.#e.get(g);
      if (l) return l;
      const B = this.messageHandler.sendWithPromise("GetPage", { pageIndex: g }).then(((Q) => {
        if (this.destroyed) throw new Error("Transport destroyed");
        Q.refStr && this.#s.set(Q.refStr, a);
        const f = new U2(g, Q, this, this._params.pdfBug);
        return this.#A.set(g, f), f;
      }));
      return this.#e.set(g, B), B;
    }
    getPageIndex(a) {
      return TI(a) ? this.messageHandler.sendWithPromise("GetPageIndex", { num: a.num, gen: a.gen }) : Promise.reject(new Error("Invalid pageIndex request."));
    }
    getAnnotations(a, g) {
      return this.messageHandler.sendWithPromise("GetAnnotations", { pageIndex: a, intent: g });
    }
    getFieldObjects() {
      return this.#i("GetFieldObjects");
    }
    hasJSActions() {
      return this.#i("HasJSActions");
    }
    getCalculationOrderIds() {
      return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
    }
    getDestinations() {
      return this.messageHandler.sendWithPromise("GetDestinations", null);
    }
    getDestination(a) {
      return typeof a != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", { id: a });
    }
    getPageLabels() {
      return this.messageHandler.sendWithPromise("GetPageLabels", null);
    }
    getPageLayout() {
      return this.messageHandler.sendWithPromise("GetPageLayout", null);
    }
    getPageMode() {
      return this.messageHandler.sendWithPromise("GetPageMode", null);
    }
    getViewerPreferences() {
      return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
    }
    getOpenAction() {
      return this.messageHandler.sendWithPromise("GetOpenAction", null);
    }
    getAttachments() {
      return this.messageHandler.sendWithPromise("GetAttachments", null);
    }
    getDocJSActions() {
      return this.#i("GetDocJSActions");
    }
    getPageJSActions(a) {
      return this.messageHandler.sendWithPromise("GetPageJSActions", { pageIndex: a });
    }
    getStructTree(a) {
      return this.messageHandler.sendWithPromise("GetStructTree", { pageIndex: a });
    }
    getOutline() {
      return this.messageHandler.sendWithPromise("GetOutline", null);
    }
    getOptionalContentConfig(a) {
      return this.#i("GetOptionalContentConfig").then(((g) => new C2(g, a)));
    }
    getPermissions() {
      return this.messageHandler.sendWithPromise("GetPermissions", null);
    }
    getMetadata() {
      const a = "GetMetadata", g = this.#t.get(a);
      if (g) return g;
      const l = this.messageHandler.sendWithPromise(a, null).then(((B) => ({ info: B[0], metadata: B[1] ? new l2(B[1]) : null, contentDispositionFilename: this._fullReader?.filename ?? null, contentLength: this._fullReader?.contentLength ?? null })));
      return this.#t.set(a, l), l;
    }
    getMarkInfo() {
      return this.messageHandler.sendWithPromise("GetMarkInfo", null);
    }
    async startCleanup(a = !1) {
      if (!this.destroyed) {
        await this.messageHandler.sendWithPromise("Cleanup", null);
        for (const g of this.#A.values())
          if (!g.cleanup()) throw new Error(`startCleanup: Page ${g.pageNumber} is currently rendering.`);
        this.commonObjs.clear(), a || this.fontLoader.clear(), this.#t.clear(), this.filterFactory.destroy(!0), Le.cleanup();
      }
    }
    cachedPageNumber(a) {
      if (!TI(a)) return null;
      const g = a.gen === 0 ? `${a.num}R` : `${a.num}R${a.gen}`;
      return this.#s.get(g) ?? null;
    }
  }
  const Tr = Symbol("INITIAL_DATA");
  class qI {
    #t = /* @__PURE__ */ Object.create(null);
    #A(a) {
      return this.#t[a] ||= { ...Promise.withResolvers(), data: Tr };
    }
    get(a, g = null) {
      if (g) {
        const B = this.#A(a);
        return B.promise.then((() => g(B.data))), null;
      }
      const l = this.#t[a];
      if (!l || l.data === Tr) throw new Error(`Requesting object that isn't resolved yet ${a}.`);
      return l.data;
    }
    has(a) {
      const g = this.#t[a];
      return !!g && g.data !== Tr;
    }
    resolve(a, g = null) {
      const l = this.#A(a);
      l.data = g, l.resolve();
    }
    clear() {
      for (const a in this.#t) {
        const { data: g } = this.#t[a];
        g?.bitmap?.close();
      }
      this.#t = /* @__PURE__ */ Object.create(null);
    }
    *[Symbol.iterator]() {
      for (const a in this.#t) {
        const { data: g } = this.#t[a];
        g !== Tr && (yield [a, g]);
      }
    }
  }
  class Y2 {
    #t = null;
    constructor(a) {
      this.#t = a, this.onContinue = null;
    }
    get promise() {
      return this.#t.capability.promise;
    }
    cancel(a = 0) {
      this.#t.cancel(null, a);
    }
    get separateAnnots() {
      const { separateAnnots: a } = this.#t.operatorList;
      if (!a) return !1;
      const { annotationCanvasMap: g } = this.#t;
      return a.form || a.canvas && g?.size > 0;
    }
  }
  class ma {
    #t = null;
    static #A = /* @__PURE__ */ new WeakSet();
    constructor({ callback: a, params: g, objs: l, commonObjs: B, annotationCanvasMap: Q, operatorList: f, pageIndex: m, canvasFactory: w, filterFactory: k, useRequestAnimationFrame: F = !1, pdfBug: v = !1, pageColors: L = null }) {
      this.callback = a, this.params = g, this.objs = l, this.commonObjs = B, this.annotationCanvasMap = Q, this.operatorListIdx = null, this.operatorList = f, this._pageIndex = m, this.canvasFactory = w, this.filterFactory = k, this._pdfBug = v, this.pageColors = L, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = F === !0 && !1, this.cancelled = !1, this.capability = Promise.withResolvers(), this.task = new Y2(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = g.canvasContext.canvas;
    }
    get completed() {
      return this.capability.promise.catch((function() {
      }));
    }
    initializeGraphics({ transparency: a = !1, optionalContentConfig: g }) {
      if (this.cancelled) return;
      if (this._canvas) {
        if (ma.#A.has(this._canvas)) throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
        ma.#A.add(this._canvas);
      }
      this._pdfBug && globalThis.StepperManager?.enabled && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
      const { canvasContext: l, viewport: B, transform: Q, background: f } = this.params;
      this.gfx = new pa(l, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: g }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({ transform: Q, viewport: B, transparency: a, background: f }), this.operatorListIdx = 0, this.graphicsReady = !0, this.graphicsReadyCallback?.();
    }
    cancel(a = null, g = 0) {
      this.running = !1, this.cancelled = !0, this.gfx?.endDrawing(), this.#t && (window.cancelAnimationFrame(this.#t), this.#t = null), ma.#A.delete(this._canvas), this.callback(a || new vg(`Rendering cancelled, page ${this._pageIndex + 1}`, g));
    }
    operatorListChanged() {
      this.graphicsReady ? (this.stepper?.updateOperatorList(this.operatorList), this.running || this._continue()) : this.graphicsReadyCallback ||= this._continueBound;
    }
    _continue() {
      this.running = !0, this.cancelled || (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
    }
    _scheduleNext() {
      this._useRequestAnimationFrame ? this.#t = window.requestAnimationFrame((() => {
        this.#t = null, this._nextBound().catch(this._cancelBound);
      })) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
    }
    async _next() {
      this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), ma.#A.delete(this._canvas), this.callback())));
    }
  }
  const T2 = "4.6.82", K2 = "9b541910f";
  function PI(G) {
    return Math.floor(255 * Math.max(0, Math.min(1, G))).toString(16).padStart(2, "0");
  }
  function En(G) {
    return Math.max(0, Math.min(255, 255 * G));
  }
  class _I {
    static CMYK_G([a, g, l, B]) {
      return ["G", 1 - Math.min(1, 0.3 * a + 0.59 * l + 0.11 * g + B)];
    }
    static G_CMYK([a]) {
      return ["CMYK", 0, 0, 0, 1 - a];
    }
    static G_RGB([a]) {
      return ["RGB", a, a, a];
    }
    static G_rgb([a]) {
      return [a = En(a), a, a];
    }
    static G_HTML([a]) {
      const g = PI(a);
      return `#${g}${g}${g}`;
    }
    static RGB_G([a, g, l]) {
      return ["G", 0.3 * a + 0.59 * g + 0.11 * l];
    }
    static RGB_rgb(a) {
      return a.map(En);
    }
    static RGB_HTML(a) {
      return `#${a.map(PI).join("")}`;
    }
    static T_HTML() {
      return "#00000000";
    }
    static T_rgb() {
      return [null];
    }
    static CMYK_RGB([a, g, l, B]) {
      return ["RGB", 1 - Math.min(1, a + B), 1 - Math.min(1, l + B), 1 - Math.min(1, g + B)];
    }
    static CMYK_rgb([a, g, l, B]) {
      return [En(1 - Math.min(1, a + B)), En(1 - Math.min(1, l + B)), En(1 - Math.min(1, g + B))];
    }
    static CMYK_HTML(a) {
      const g = this.CMYK_RGB(a).slice(1);
      return this.RGB_HTML(g);
    }
    static RGB_CMYK([a, g, l]) {
      const B = 1 - a, Q = 1 - g, f = 1 - l;
      return ["CMYK", B, Q, f, Math.min(B, Q, f)];
    }
  }
  class OI {
    static setupStorage(a, g, l, B, Q) {
      const f = B.getValue(g, { value: null });
      switch (l.name) {
        case "textarea":
          if (f.value !== null && (a.textContent = f.value), Q === "print") break;
          a.addEventListener("input", ((m) => {
            B.setValue(g, { value: m.target.value });
          }));
          break;
        case "input":
          if (l.attributes.type === "radio" || l.attributes.type === "checkbox") {
            if (f.value === l.attributes.xfaOn ? a.setAttribute("checked", !0) : f.value === l.attributes.xfaOff && a.removeAttribute("checked"), Q === "print") break;
            a.addEventListener("change", ((m) => {
              B.setValue(g, { value: m.target.checked ? m.target.getAttribute("xfaOn") : m.target.getAttribute("xfaOff") });
            }));
          } else {
            if (f.value !== null && a.setAttribute("value", f.value), Q === "print") break;
            a.addEventListener("input", ((m) => {
              B.setValue(g, { value: m.target.value });
            }));
          }
          break;
        case "select":
          if (f.value !== null) {
            a.setAttribute("value", f.value);
            for (const m of l.children) m.attributes.value === f.value ? m.attributes.selected = !0 : m.attributes.hasOwnProperty("selected") && delete m.attributes.selected;
          }
          a.addEventListener("input", ((m) => {
            const w = m.target.options, k = w.selectedIndex === -1 ? "" : w[w.selectedIndex].value;
            B.setValue(g, { value: k });
          }));
      }
    }
    static setAttributes({ html: a, element: g, storage: l = null, intent: B, linkService: Q }) {
      const { attributes: f } = g, m = a instanceof HTMLAnchorElement;
      f.type === "radio" && (f.name = `${f.name}-${B}`);
      for (const [w, k] of Object.entries(f)) if (k != null) switch (w) {
        case "class":
          k.length && a.setAttribute(w, k.join(" "));
          break;
        case "dataId":
          break;
        case "id":
          a.setAttribute("data-element-id", k);
          break;
        case "style":
          Object.assign(a.style, k);
          break;
        case "textContent":
          a.textContent = k;
          break;
        default:
          (!m || w !== "href" && w !== "newWindow") && a.setAttribute(w, k);
      }
      m && Q.addLinkAttributes(a, f.href, f.newWindow), l && f.dataId && this.setupStorage(a, f.dataId, g, l);
    }
    static render(a) {
      const g = a.annotationStorage, l = a.linkService, B = a.xfaHtml, Q = a.intent || "display", f = document.createElement(B.name);
      B.attributes && this.setAttributes({ html: f, element: B, intent: Q, linkService: l });
      const m = Q !== "richText", w = a.div;
      if (w.append(f), a.viewport) {
        const v = `matrix(${a.viewport.transform.join(",")})`;
        w.style.transform = v;
      }
      m && w.setAttribute("class", "xfaLayer xfaFont");
      const k = [];
      if (B.children.length === 0) {
        if (B.value) {
          const v = document.createTextNode(B.value);
          f.append(v), m && Qn.shouldBuildText(B.name) && k.push(v);
        }
        return { textDivs: k };
      }
      const F = [[B, -1, f]];
      for (; F.length > 0; ) {
        const [v, L, J] = F.at(-1);
        if (L + 1 === v.children.length) {
          F.pop();
          continue;
        }
        const K = v.children[++F.at(-1)[1]];
        if (K === null) continue;
        const { name: X } = K;
        if (X === "#text") {
          const At = document.createTextNode(K.value);
          k.push(At), J.append(At);
          continue;
        }
        const et = K?.attributes?.xmlns ? document.createElementNS(K.attributes.xmlns, X) : document.createElement(X);
        if (J.append(et), K.attributes && this.setAttributes({ html: et, element: K, storage: g, intent: Q, linkService: l }), K.children?.length > 0) F.push([K, -1, et]);
        else if (K.value) {
          const At = document.createTextNode(K.value);
          m && Qn.shouldBuildText(X) && k.push(At), et.append(At);
        }
      }
      for (const v of w.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) v.setAttribute("readOnly", !0);
      return { textDivs: k };
    }
    static update(a) {
      const g = `matrix(${a.viewport.transform.join(",")})`;
      a.div.style.transform = g, a.div.hidden = !1;
    }
  }
  const fn = 1e3, Ys = /* @__PURE__ */ new WeakSet();
  function Hi(G) {
    return { width: G[2] - G[0], height: G[3] - G[1] };
  }
  class q2 {
    static create(a) {
      switch (a.data.annotationType) {
        case _:
          return new WI(a);
        case q:
          return new P2(a);
        case ot:
          switch (a.data.fieldType) {
            case "Tx":
              return new _2(a);
            case "Btn":
              return a.data.radioButton ? new jI(a) : a.data.checkBox ? new W2(a) : new j2(a);
            case "Ch":
              return new Z2(a);
            case "Sig":
              return new O2(a);
          }
          return new Ts(a);
        case lt:
          return new $g(a);
        case Y:
          return new ZI(a);
        case ht:
          return new X2(a);
        case ut:
          return new z2(a);
        case j:
          return new $2(a);
        case tt:
          return new VI(a);
        case H:
          return new Ap(a);
        case W:
          return new XI(a);
        case it:
          return new tp(a);
        case Z:
          return new ep(a);
        case st:
          return new ip(a);
        case dt:
          return new sp(a);
        case ct:
          return new ap(a);
        case M:
          return new zI(a);
        case $:
          return new np(a);
        default:
          return new YA(a);
      }
    }
  }
  class YA {
    #t = null;
    #A = !1;
    #e = null;
    constructor(a, { isRenderable: g = !1, ignoreBorder: l = !1, createQuadrilaterals: B = !1 } = {}) {
      this.isRenderable = g, this.data = a.data, this.layer = a.layer, this.linkService = a.linkService, this.downloadManager = a.downloadManager, this.imageResourcesPath = a.imageResourcesPath, this.renderForms = a.renderForms, this.svgFactory = a.svgFactory, this.annotationStorage = a.annotationStorage, this.enableScripting = a.enableScripting, this.hasJSActions = a.hasJSActions, this._fieldObjects = a.fieldObjects, this.parent = a.parent, g && (this.container = this._createContainer(l)), B && this._createQuadrilaterals();
    }
    static _hasPopupData({ titleObj: a, contentsObj: g, richText: l }) {
      return !!(a?.str || g?.str || l?.str);
    }
    get _isEditable() {
      return this.data.isEditable;
    }
    get hasPopupData() {
      return YA._hasPopupData(this.data);
    }
    updateEdited(a) {
      if (!this.container) return;
      this.#t ||= { rect: this.data.rect.slice(0) };
      const { rect: g } = a;
      g && this.#s(g), this.#e?.popup.updateEdited(a);
    }
    resetEdited() {
      this.#t && (this.#s(this.#t.rect), this.#e?.popup.resetEdited(), this.#t = null);
    }
    #s(a) {
      const { container: { style: g }, data: { rect: l, rotation: B }, parent: { viewport: { rawDims: { pageWidth: Q, pageHeight: f, pageX: m, pageY: w } } } } = this;
      l?.splice(0, 4, ...a);
      const { width: k, height: F } = Hi(a);
      g.left = 100 * (a[0] - m) / Q + "%", g.top = 100 * (f - a[3] + w) / f + "%", B === 0 ? (g.width = 100 * k / Q + "%", g.height = 100 * F / f + "%") : this.setRotation(B);
    }
    _createContainer(a) {
      const { data: g, parent: { page: l, viewport: B } } = this, Q = document.createElement("section");
      Q.setAttribute("data-annotation-id", g.id), this instanceof Ts || (Q.tabIndex = fn);
      const { style: f } = Q;
      if (f.zIndex = this.parent.zIndex++, g.popupRef && Q.setAttribute("aria-haspopup", "dialog"), g.alternativeText && (Q.title = g.alternativeText), g.noRotate && Q.classList.add("norotate"), !g.rect || this instanceof $g) {
        const { rotation: X } = g;
        return g.hasOwnCanvas || X === 0 || this.setRotation(X, Q), Q;
      }
      const { width: m, height: w } = Hi(g.rect);
      if (!a && g.borderStyle.width > 0) {
        f.borderWidth = `${g.borderStyle.width}px`;
        const X = g.borderStyle.horizontalCornerRadius, et = g.borderStyle.verticalCornerRadius;
        if (X > 0 || et > 0) {
          const It = `calc(${X}px * var(--scale-factor)) / calc(${et}px * var(--scale-factor))`;
          f.borderRadius = It;
        } else if (this instanceof jI) {
          const It = `calc(${m}px * var(--scale-factor)) / calc(${w}px * var(--scale-factor))`;
          f.borderRadius = It;
        }
        switch (g.borderStyle.style) {
          case V:
            f.borderStyle = "solid";
            break;
          case rt:
            f.borderStyle = "dashed";
            break;
          case Bt:
            qt("Unimplemented border style: beveled");
            break;
          case Rt:
            qt("Unimplemented border style: inset");
            break;
          case Ft:
            f.borderBottomStyle = "solid";
        }
        const At = g.borderColor || null;
        At ? (this.#A = !0, f.borderColor = Pt.makeHexColor(0 | At[0], 0 | At[1], 0 | At[2])) : f.borderWidth = 0;
      }
      const k = Pt.normalizeRect([g.rect[0], l.view[3] - g.rect[1] + l.view[1], g.rect[2], l.view[3] - g.rect[3] + l.view[1]]), { pageWidth: F, pageHeight: v, pageX: L, pageY: J } = B.rawDims;
      f.left = 100 * (k[0] - L) / F + "%", f.top = 100 * (k[1] - J) / v + "%";
      const { rotation: K } = g;
      return g.hasOwnCanvas || K === 0 ? (f.width = 100 * m / F + "%", f.height = 100 * w / v + "%") : this.setRotation(K, Q), Q;
    }
    setRotation(a, g = this.container) {
      if (!this.data.rect) return;
      const { pageWidth: l, pageHeight: B } = this.parent.viewport.rawDims, { width: Q, height: f } = Hi(this.data.rect);
      let m, w;
      a % 180 == 0 ? (m = 100 * Q / l, w = 100 * f / B) : (m = 100 * f / l, w = 100 * Q / B), g.style.width = `${m}%`, g.style.height = `${w}%`, g.setAttribute("data-main-rotation", (360 - a) % 360);
    }
    get _commonActions() {
      const a = (g, l, B) => {
        const Q = B.detail[g], f = Q[0], m = Q.slice(1);
        B.target.style[l] = _I[`${f}_HTML`](m), this.annotationStorage.setValue(this.data.id, { [l]: _I[`${f}_rgb`](m) });
      };
      return aA(this, "_commonActions", { display: (g) => {
        const { display: l } = g.detail, B = l % 2 == 1;
        this.container.style.visibility = B ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, { noView: B, noPrint: l === 1 || l === 2 });
      }, print: (g) => {
        this.annotationStorage.setValue(this.data.id, { noPrint: !g.detail.print });
      }, hidden: (g) => {
        const { hidden: l } = g.detail;
        this.container.style.visibility = l ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, { noPrint: l, noView: l });
      }, focus: (g) => {
        setTimeout((() => g.target.focus({ preventScroll: !1 })), 0);
      }, userName: (g) => {
        g.target.title = g.detail.userName;
      }, readonly: (g) => {
        g.target.disabled = g.detail.readonly;
      }, required: (g) => {
        this._setRequired(g.target, g.detail.required);
      }, bgColor: (g) => {
        a("bgColor", "backgroundColor", g);
      }, fillColor: (g) => {
        a("fillColor", "backgroundColor", g);
      }, fgColor: (g) => {
        a("fgColor", "color", g);
      }, textColor: (g) => {
        a("textColor", "color", g);
      }, borderColor: (g) => {
        a("borderColor", "borderColor", g);
      }, strokeColor: (g) => {
        a("strokeColor", "borderColor", g);
      }, rotation: (g) => {
        const l = g.detail.rotation;
        this.setRotation(l), this.annotationStorage.setValue(this.data.id, { rotation: l });
      } });
    }
    _dispatchEventFromSandbox(a, g) {
      const l = this._commonActions;
      for (const B of Object.keys(g.detail))
        (a[B] || l[B])?.(g);
    }
    _setDefaultPropertiesFromJS(a) {
      if (!this.enableScripting) return;
      const g = this.annotationStorage.getRawValue(this.data.id);
      if (!g) return;
      const l = this._commonActions;
      for (const [B, Q] of Object.entries(g)) {
        const f = l[B];
        f && (f({ detail: { [B]: Q }, target: a }), delete g[B]);
      }
    }
    _createQuadrilaterals() {
      if (!this.container) return;
      const { quadPoints: a } = this.data;
      if (!a) return;
      const [g, l, B, Q] = this.data.rect.map(((X) => Math.fround(X)));
      if (a.length === 8) {
        const [X, et, At, It] = a.subarray(2, 6);
        if (B === X && Q === et && g === At && l === It) return;
      }
      const { style: f } = this.container;
      let m;
      if (this.#A) {
        const { borderColor: X, borderWidth: et } = f;
        f.borderWidth = 0, m = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${X}" stroke-width="${et}">`], this.container.classList.add("hasBorder");
      }
      const w = B - g, k = Q - l, { svgFactory: F } = this, v = F.createElement("svg");
      v.classList.add("quadrilateralsContainer"), v.setAttribute("width", 0), v.setAttribute("height", 0);
      const L = F.createElement("defs");
      v.append(L);
      const J = F.createElement("clipPath"), K = `clippath_${this.data.id}`;
      J.setAttribute("id", K), J.setAttribute("clipPathUnits", "objectBoundingBox"), L.append(J);
      for (let X = 2, et = a.length; X < et; X += 8) {
        const At = a[X], It = a[X + 1], kt = a[X + 2], Mt = a[X + 3], Ut = F.createElement("rect"), xt = (kt - g) / w, Wt = (Q - It) / k, eA = (At - kt) / w, nA = (It - Mt) / k;
        Ut.setAttribute("x", xt), Ut.setAttribute("y", Wt), Ut.setAttribute("width", eA), Ut.setAttribute("height", nA), J.append(Ut), m?.push(`<rect vector-effect="non-scaling-stroke" x="${xt}" y="${Wt}" width="${eA}" height="${nA}"/>`);
      }
      this.#A && (m.push("</g></svg>')"), f.backgroundImage = m.join("")), this.container.append(v), this.container.style.clipPath = `url(#${K})`;
    }
    _createPopup() {
      const { container: a, data: g } = this;
      a.setAttribute("aria-haspopup", "dialog");
      const l = this.#e = new $g({ data: { color: g.color, titleObj: g.titleObj, modificationDate: g.modificationDate, contentsObj: g.contentsObj, richText: g.richText, parentRect: g.rect, borderStyle: 0, id: `popup_${g.id}`, rotation: g.rotation }, parent: this.parent, elements: [this] });
      this.parent.div.append(l.render());
    }
    render() {
      Xt("Abstract method `AnnotationElement.render` called");
    }
    _getElementsByName(a, g = null) {
      const l = [];
      if (this._fieldObjects) {
        const B = this._fieldObjects[a];
        if (B) for (const { page: Q, id: f, exportValues: m } of B) {
          if (Q === -1 || f === g) continue;
          const w = typeof m == "string" ? m : null, k = document.querySelector(`[data-element-id="${f}"]`);
          !k || Ys.has(k) ? l.push({ id: f, exportValue: w, domElement: k }) : qt(`_getElementsByName - element not allowed: ${f}`);
        }
        return l;
      }
      for (const B of document.getElementsByName(a)) {
        const { exportValue: Q } = B, f = B.getAttribute("data-element-id");
        f !== g && Ys.has(B) && l.push({ id: f, exportValue: Q, domElement: B });
      }
      return l;
    }
    show() {
      this.container && (this.container.hidden = !1), this.popup?.maybeShow();
    }
    hide() {
      this.container && (this.container.hidden = !0), this.popup?.forceHide();
    }
    getElementsToTriggerPopup() {
      return this.container;
    }
    addHighlightArea() {
      const a = this.getElementsToTriggerPopup();
      if (Array.isArray(a)) for (const g of a) g.classList.add("highlightArea");
      else a.classList.add("highlightArea");
    }
    _editOnDoubleClick() {
      if (!this._isEditable) return;
      const { annotationEditorType: a, data: { id: g } } = this;
      this.container.addEventListener("dblclick", (() => {
        this.linkService.eventBus?.dispatch("switchannotationeditormode", { source: this, mode: a, editId: g });
      }));
    }
  }
  class WI extends YA {
    constructor(a, g = null) {
      super(a, { isRenderable: !0, ignoreBorder: !!g?.ignoreBorder, createQuadrilaterals: !0 }), this.isTooltipOnly = a.data.isTooltipOnly;
    }
    render() {
      const { data: a, linkService: g } = this, l = document.createElement("a");
      l.setAttribute("data-element-id", a.id);
      let B = !1;
      return a.url ? (g.addLinkAttributes(l, a.url, a.newWindow), B = !0) : a.action ? (this._bindNamedAction(l, a.action), B = !0) : a.attachment ? (this.#A(l, a.attachment, a.attachmentDest), B = !0) : a.setOCGState ? (this.#e(l, a.setOCGState), B = !0) : a.dest ? (this._bindLink(l, a.dest), B = !0) : (a.actions && (a.actions.Action || a.actions["Mouse Up"] || a.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(l, a), B = !0), a.resetForm ? (this._bindResetFormAction(l, a.resetForm), B = !0) : this.isTooltipOnly && !B && (this._bindLink(l, ""), B = !0)), this.container.classList.add("linkAnnotation"), B && this.container.append(l), this.container;
    }
    #t() {
      this.container.setAttribute("data-internal-link", "");
    }
    _bindLink(a, g) {
      a.href = this.linkService.getDestinationHash(g), a.onclick = () => (g && this.linkService.goToDestination(g), !1), (g || g === "") && this.#t();
    }
    _bindNamedAction(a, g) {
      a.href = this.linkService.getAnchorUrl(""), a.onclick = () => (this.linkService.executeNamedAction(g), !1), this.#t();
    }
    #A(a, g, l = null) {
      a.href = this.linkService.getAnchorUrl(""), g.description && (a.title = g.description), a.onclick = () => (this.downloadManager?.openOrDownloadData(g.content, g.filename, l), !1), this.#t();
    }
    #e(a, g) {
      a.href = this.linkService.getAnchorUrl(""), a.onclick = () => (this.linkService.executeSetOCGState(g), !1), this.#t();
    }
    _bindJSAction(a, g) {
      a.href = this.linkService.getAnchorUrl("");
      const l = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
      for (const B of Object.keys(g.actions)) {
        const Q = l.get(B);
        Q && (a[Q] = () => (this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: g.id, name: B } }), !1));
      }
      a.onclick || (a.onclick = () => !1), this.#t();
    }
    _bindResetFormAction(a, g) {
      const l = a.onclick;
      if (l || (a.href = this.linkService.getAnchorUrl("")), this.#t(), !this._fieldObjects) return qt('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), void (l || (a.onclick = () => !1));
      a.onclick = () => {
        l?.();
        const { fields: B, refs: Q, include: f } = g, m = [];
        if (B.length !== 0 || Q.length !== 0) {
          const F = new Set(Q);
          for (const v of B) {
            const L = this._fieldObjects[v] || [];
            for (const { id: J } of L) F.add(J);
          }
          for (const v of Object.values(this._fieldObjects)) for (const L of v) F.has(L.id) === f && m.push(L);
        } else for (const F of Object.values(this._fieldObjects)) m.push(...F);
        const w = this.annotationStorage, k = [];
        for (const F of m) {
          const { id: v } = F;
          switch (k.push(v), F.type) {
            case "text": {
              const J = F.defaultValue || "";
              w.setValue(v, { value: J });
              break;
            }
            case "checkbox":
            case "radiobutton": {
              const J = F.defaultValue === F.exportValues;
              w.setValue(v, { value: J });
              break;
            }
            case "combobox":
            case "listbox": {
              const J = F.defaultValue || "";
              w.setValue(v, { value: J });
              break;
            }
            default:
              continue;
          }
          const L = document.querySelector(`[data-element-id="${v}"]`);
          L && (Ys.has(L) ? L.dispatchEvent(new Event("resetform")) : qt(`_bindResetFormAction - element not allowed: ${v}`));
        }
        return this.enableScripting && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: "app", ids: k, name: "ResetForm" } }), !1;
      };
    }
  }
  class P2 extends YA {
    constructor(a) {
      super(a, { isRenderable: !0 });
    }
    render() {
      this.container.classList.add("textAnnotation");
      const a = document.createElement("img");
      return a.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", a.setAttribute("data-l10n-id", "pdfjs-text-annotation-type"), a.setAttribute("data-l10n-args", JSON.stringify({ type: this.data.name })), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(a), this.container;
    }
  }
  class Ts extends YA {
    render() {
      return this.container;
    }
    showElementAndHideCanvas(a) {
      this.data.hasOwnCanvas && (a.previousSibling?.nodeName === "CANVAS" && (a.previousSibling.hidden = !0), a.hidden = !1);
    }
    _getKeyModifier(a) {
      return be.platform.isMac ? a.metaKey : a.ctrlKey;
    }
    _setEventListener(a, g, l, B, Q) {
      l.includes("mouse") ? a.addEventListener(l, ((f) => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: B, value: Q(f), shift: f.shiftKey, modifier: this._getKeyModifier(f) } });
      })) : a.addEventListener(l, ((f) => {
        if (l === "blur") {
          if (!g.focused || !f.relatedTarget) return;
          g.focused = !1;
        } else if (l === "focus") {
          if (g.focused) return;
          g.focused = !0;
        }
        Q && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: B, value: Q(f) } });
      }));
    }
    _setEventListeners(a, g, l, B) {
      for (const [Q, f] of l) (f === "Action" || this.data.actions?.[f]) && (f !== "Focus" && f !== "Blur" || (g ||= { focused: !1 }), this._setEventListener(a, g, Q, f, B), f !== "Focus" || this.data.actions?.Blur ? f !== "Blur" || this.data.actions?.Focus || this._setEventListener(a, g, "focus", "Focus", null) : this._setEventListener(a, g, "blur", "Blur", null));
    }
    _setBackgroundColor(a) {
      const g = this.data.backgroundColor || null;
      a.style.backgroundColor = g === null ? "transparent" : Pt.makeHexColor(g[0], g[1], g[2]);
    }
    _setTextStyle(a) {
      const g = ["left", "center", "right"], { fontColor: l } = this.data.defaultAppearanceData, B = this.data.defaultAppearanceData.fontSize || 9, Q = a.style;
      let f;
      const m = (w) => Math.round(10 * w) / 10;
      if (this.data.multiLine) {
        const w = Math.abs(this.data.rect[3] - this.data.rect[1] - 2), k = w / (Math.round(w / (n * B)) || 1);
        f = Math.min(B, m(k / n));
      } else {
        const w = Math.abs(this.data.rect[3] - this.data.rect[1] - 2);
        f = Math.min(B, m(w / n));
      }
      Q.fontSize = `calc(${f}px * var(--scale-factor))`, Q.color = Pt.makeHexColor(l[0], l[1], l[2]), this.data.textAlignment !== null && (Q.textAlign = g[this.data.textAlignment]);
    }
    _setRequired(a, g) {
      g ? a.setAttribute("required", !0) : a.removeAttribute("required"), a.setAttribute("aria-required", g);
    }
  }
  class _2 extends Ts {
    constructor(a) {
      super(a, { isRenderable: a.renderForms || a.data.hasOwnCanvas || !a.data.hasAppearance && !!a.data.fieldValue });
    }
    setPropertyOnSiblings(a, g, l, B) {
      const Q = this.annotationStorage;
      for (const f of this._getElementsByName(a.name, a.id)) f.domElement && (f.domElement[g] = l), Q.setValue(f.id, { [B]: l });
    }
    render() {
      const a = this.annotationStorage, g = this.data.id;
      this.container.classList.add("textWidgetAnnotation");
      let l = null;
      if (this.renderForms) {
        const B = a.getValue(g, { value: this.data.fieldValue });
        let Q = B.value || "";
        const f = a.getValue(g, { charLimit: this.data.maxLen }).charLimit;
        f && Q.length > f && (Q = Q.slice(0, f));
        let m = B.formattedValue || this.data.textContent?.join(`
`) || null;
        m && this.data.comb && (m = m.replaceAll(/\s+/g, ""));
        const w = { userValue: Q, formattedValue: m, lastCommittedValue: null, commitKey: 1, focused: !1 };
        this.data.multiLine ? (l = document.createElement("textarea"), l.textContent = m ?? Q, this.data.doNotScroll && (l.style.overflowY = "hidden")) : (l = document.createElement("input"), l.type = "text", l.setAttribute("value", m ?? Q), this.data.doNotScroll && (l.style.overflowX = "hidden")), this.data.hasOwnCanvas && (l.hidden = !0), Ys.add(l), l.setAttribute("data-element-id", g), l.disabled = this.data.readOnly, l.name = this.data.fieldName, l.tabIndex = fn, this._setRequired(l, this.data.required), f && (l.maxLength = f), l.addEventListener("input", ((F) => {
          a.setValue(g, { value: F.target.value }), this.setPropertyOnSiblings(l, "value", F.target.value, "value"), w.formattedValue = null;
        })), l.addEventListener("resetform", ((F) => {
          const v = this.data.defaultFieldValue ?? "";
          l.value = w.userValue = v, w.formattedValue = null;
        }));
        let k = (F) => {
          const { formattedValue: v } = w;
          v != null && (F.target.value = v), F.target.scrollLeft = 0;
        };
        if (this.enableScripting && this.hasJSActions) {
          l.addEventListener("focus", ((v) => {
            if (w.focused) return;
            const { target: L } = v;
            w.userValue && (L.value = w.userValue), w.lastCommittedValue = L.value, w.commitKey = 1, this.data.actions?.Focus || (w.focused = !0);
          })), l.addEventListener("updatefromsandbox", ((v) => {
            this.showElementAndHideCanvas(v.target);
            const L = { value(J) {
              w.userValue = J.detail.value ?? "", a.setValue(g, { value: w.userValue.toString() }), J.target.value = w.userValue;
            }, formattedValue(J) {
              const { formattedValue: K } = J.detail;
              w.formattedValue = K, K != null && J.target !== document.activeElement && (J.target.value = K), a.setValue(g, { formattedValue: K });
            }, selRange(J) {
              J.target.setSelectionRange(...J.detail.selRange);
            }, charLimit: (J) => {
              const { charLimit: K } = J.detail, { target: X } = J;
              if (K === 0) return void X.removeAttribute("maxLength");
              X.setAttribute("maxLength", K);
              let et = w.userValue;
              !et || et.length <= K || (et = et.slice(0, K), X.value = w.userValue = et, a.setValue(g, { value: et }), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: g, name: "Keystroke", value: et, willCommit: !0, commitKey: 1, selStart: X.selectionStart, selEnd: X.selectionEnd } }));
            } };
            this._dispatchEventFromSandbox(L, v);
          })), l.addEventListener("keydown", ((v) => {
            w.commitKey = 1;
            let L = -1;
            if (v.key === "Escape" ? L = 0 : v.key !== "Enter" || this.data.multiLine ? v.key === "Tab" && (w.commitKey = 3) : L = 2, L === -1) return;
            const { value: J } = v.target;
            w.lastCommittedValue !== J && (w.lastCommittedValue = J, w.userValue = J, this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: g, name: "Keystroke", value: J, willCommit: !0, commitKey: L, selStart: v.target.selectionStart, selEnd: v.target.selectionEnd } }));
          }));
          const F = k;
          k = null, l.addEventListener("blur", ((v) => {
            if (!w.focused || !v.relatedTarget) return;
            this.data.actions?.Blur || (w.focused = !1);
            const { value: L } = v.target;
            w.userValue = L, w.lastCommittedValue !== L && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: g, name: "Keystroke", value: L, willCommit: !0, commitKey: w.commitKey, selStart: v.target.selectionStart, selEnd: v.target.selectionEnd } }), F(v);
          })), this.data.actions?.Keystroke && l.addEventListener("beforeinput", ((v) => {
            w.lastCommittedValue = null;
            const { data: L, target: J } = v, { value: K, selectionStart: X, selectionEnd: et } = J;
            let At = X, It = et;
            switch (v.inputType) {
              case "deleteWordBackward": {
                const kt = K.substring(0, X).match(/\w*[^\w]*$/);
                kt && (At -= kt[0].length);
                break;
              }
              case "deleteWordForward": {
                const kt = K.substring(X).match(/^[^\w]*\w*/);
                kt && (It += kt[0].length);
                break;
              }
              case "deleteContentBackward":
                X === et && (At -= 1);
                break;
              case "deleteContentForward":
                X === et && (It += 1);
            }
            v.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: g, name: "Keystroke", value: K, change: L || "", willCommit: !1, selStart: At, selEnd: It } });
          })), this._setEventListeners(l, w, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], ((v) => v.target.value));
        }
        if (k && l.addEventListener("blur", k), this.data.comb) {
          const F = (this.data.rect[2] - this.data.rect[0]) / f;
          l.classList.add("comb"), l.style.letterSpacing = `calc(${F}px * var(--scale-factor) - 1ch)`;
        }
      } else l = document.createElement("div"), l.textContent = this.data.fieldValue, l.style.verticalAlign = "middle", l.style.display = "table-cell", this.data.hasOwnCanvas && (l.hidden = !0);
      return this._setTextStyle(l), this._setBackgroundColor(l), this._setDefaultPropertiesFromJS(l), this.container.append(l), this.container;
    }
  }
  class O2 extends Ts {
    constructor(a) {
      super(a, { isRenderable: !!a.data.hasOwnCanvas });
    }
  }
  class W2 extends Ts {
    constructor(a) {
      super(a, { isRenderable: a.renderForms });
    }
    render() {
      const a = this.annotationStorage, g = this.data, l = g.id;
      let B = a.getValue(l, { value: g.exportValue === g.fieldValue }).value;
      typeof B == "string" && (B = B !== "Off", a.setValue(l, { value: B })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
      const Q = document.createElement("input");
      return Ys.add(Q), Q.setAttribute("data-element-id", l), Q.disabled = g.readOnly, this._setRequired(Q, this.data.required), Q.type = "checkbox", Q.name = g.fieldName, B && Q.setAttribute("checked", !0), Q.setAttribute("exportValue", g.exportValue), Q.tabIndex = fn, Q.addEventListener("change", ((f) => {
        const { name: m, checked: w } = f.target;
        for (const k of this._getElementsByName(m, l)) {
          const F = w && k.exportValue === g.exportValue;
          k.domElement && (k.domElement.checked = F), a.setValue(k.id, { value: F });
        }
        a.setValue(l, { value: w });
      })), Q.addEventListener("resetform", ((f) => {
        const m = g.defaultFieldValue || "Off";
        f.target.checked = m === g.exportValue;
      })), this.enableScripting && this.hasJSActions && (Q.addEventListener("updatefromsandbox", ((f) => {
        const m = { value(w) {
          w.target.checked = w.detail.value !== "Off", a.setValue(l, { value: w.target.checked });
        } };
        this._dispatchEventFromSandbox(m, f);
      })), this._setEventListeners(Q, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], ((f) => f.target.checked))), this._setBackgroundColor(Q), this._setDefaultPropertiesFromJS(Q), this.container.append(Q), this.container;
    }
  }
  class jI extends Ts {
    constructor(a) {
      super(a, { isRenderable: a.renderForms });
    }
    render() {
      this.container.classList.add("buttonWidgetAnnotation", "radioButton");
      const a = this.annotationStorage, g = this.data, l = g.id;
      let B = a.getValue(l, { value: g.fieldValue === g.buttonValue }).value;
      if (typeof B == "string" && (B = B !== g.buttonValue, a.setValue(l, { value: B })), B) for (const f of this._getElementsByName(g.fieldName, l)) a.setValue(f.id, { value: !1 });
      const Q = document.createElement("input");
      if (Ys.add(Q), Q.setAttribute("data-element-id", l), Q.disabled = g.readOnly, this._setRequired(Q, this.data.required), Q.type = "radio", Q.name = g.fieldName, B && Q.setAttribute("checked", !0), Q.tabIndex = fn, Q.addEventListener("change", ((f) => {
        const { name: m, checked: w } = f.target;
        for (const k of this._getElementsByName(m, l)) a.setValue(k.id, { value: !1 });
        a.setValue(l, { value: w });
      })), Q.addEventListener("resetform", ((f) => {
        const m = g.defaultFieldValue;
        f.target.checked = m != null && m === g.buttonValue;
      })), this.enableScripting && this.hasJSActions) {
        const f = g.buttonValue;
        Q.addEventListener("updatefromsandbox", ((m) => {
          const w = { value: (k) => {
            const F = f === k.detail.value;
            for (const v of this._getElementsByName(k.target.name)) {
              const L = F && v.id === l;
              v.domElement && (v.domElement.checked = L), a.setValue(v.id, { value: L });
            }
          } };
          this._dispatchEventFromSandbox(w, m);
        })), this._setEventListeners(Q, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], ((m) => m.target.checked));
      }
      return this._setBackgroundColor(Q), this._setDefaultPropertiesFromJS(Q), this.container.append(Q), this.container;
    }
  }
  class j2 extends WI {
    constructor(a) {
      super(a, { ignoreBorder: a.data.hasAppearance });
    }
    render() {
      const a = super.render();
      a.classList.add("buttonWidgetAnnotation", "pushButton");
      const g = a.lastChild;
      return this.enableScripting && this.hasJSActions && g && (this._setDefaultPropertiesFromJS(g), g.addEventListener("updatefromsandbox", ((l) => {
        this._dispatchEventFromSandbox({}, l);
      }))), a;
    }
  }
  class Z2 extends Ts {
    constructor(a) {
      super(a, { isRenderable: a.renderForms });
    }
    render() {
      this.container.classList.add("choiceWidgetAnnotation");
      const a = this.annotationStorage, g = this.data.id, l = a.getValue(g, { value: this.data.fieldValue }), B = document.createElement("select");
      Ys.add(B), B.setAttribute("data-element-id", g), B.disabled = this.data.readOnly, this._setRequired(B, this.data.required), B.name = this.data.fieldName, B.tabIndex = fn;
      let Q = this.data.combo && this.data.options.length > 0;
      this.data.combo || (B.size = this.data.options.length, this.data.multiSelect && (B.multiple = !0)), B.addEventListener("resetform", ((F) => {
        const v = this.data.defaultFieldValue;
        for (const L of B.options) L.selected = L.value === v;
      }));
      for (const F of this.data.options) {
        const v = document.createElement("option");
        v.textContent = F.displayValue, v.value = F.exportValue, l.value.includes(F.exportValue) && (v.setAttribute("selected", !0), Q = !1), B.append(v);
      }
      let f = null;
      if (Q) {
        const F = document.createElement("option");
        F.value = " ", F.setAttribute("hidden", !0), F.setAttribute("selected", !0), B.prepend(F), f = () => {
          F.remove(), B.removeEventListener("input", f), f = null;
        }, B.addEventListener("input", f);
      }
      const m = (F) => {
        const v = F ? "value" : "textContent", { options: L, multiple: J } = B;
        return J ? Array.prototype.filter.call(L, ((K) => K.selected)).map(((K) => K[v])) : L.selectedIndex === -1 ? null : L[L.selectedIndex][v];
      };
      let w = m(!1);
      const k = (F) => {
        const v = F.target.options;
        return Array.prototype.map.call(v, ((L) => ({ displayValue: L.textContent, exportValue: L.value })));
      };
      return this.enableScripting && this.hasJSActions ? (B.addEventListener("updatefromsandbox", ((F) => {
        const v = { value(L) {
          f?.();
          const J = L.detail.value, K = new Set(Array.isArray(J) ? J : [J]);
          for (const X of B.options) X.selected = K.has(X.value);
          a.setValue(g, { value: m(!0) }), w = m(!1);
        }, multipleSelection(L) {
          B.multiple = !0;
        }, remove(L) {
          const J = B.options, K = L.detail.remove;
          J[K].selected = !1, B.remove(K), J.length > 0 && Array.prototype.findIndex.call(J, ((X) => X.selected)) === -1 && (J[0].selected = !0), a.setValue(g, { value: m(!0), items: k(L) }), w = m(!1);
        }, clear(L) {
          for (; B.length !== 0; ) B.remove(0);
          a.setValue(g, { value: null, items: [] }), w = m(!1);
        }, insert(L) {
          const { index: J, displayValue: K, exportValue: X } = L.detail.insert, et = B.children[J], At = document.createElement("option");
          At.textContent = K, At.value = X, et ? et.before(At) : B.append(At), a.setValue(g, { value: m(!0), items: k(L) }), w = m(!1);
        }, items(L) {
          const { items: J } = L.detail;
          for (; B.length !== 0; ) B.remove(0);
          for (const K of J) {
            const { displayValue: X, exportValue: et } = K, At = document.createElement("option");
            At.textContent = X, At.value = et, B.append(At);
          }
          B.options.length > 0 && (B.options[0].selected = !0), a.setValue(g, { value: m(!0), items: k(L) }), w = m(!1);
        }, indices(L) {
          const J = new Set(L.detail.indices);
          for (const K of L.target.options) K.selected = J.has(K.index);
          a.setValue(g, { value: m(!0) }), w = m(!1);
        }, editable(L) {
          L.target.disabled = !L.detail.editable;
        } };
        this._dispatchEventFromSandbox(v, F);
      })), B.addEventListener("input", ((F) => {
        const v = m(!0), L = m(!1);
        a.setValue(g, { value: v }), F.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: g, name: "Keystroke", value: w, change: L, changeEx: v, willCommit: !1, commitKey: 1, keyDown: !1 } });
      })), this._setEventListeners(B, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], ((F) => F.target.value))) : B.addEventListener("input", (function(F) {
        a.setValue(g, { value: m(!0) });
      })), this.data.combo && this._setTextStyle(B), this._setBackgroundColor(B), this._setDefaultPropertiesFromJS(B), this.container.append(B), this.container;
    }
  }
  class $g extends YA {
    constructor(a) {
      const { data: g, elements: l } = a;
      super(a, { isRenderable: YA._hasPopupData(g) }), this.elements = l, this.popup = null;
    }
    render() {
      this.container.classList.add("popupAnnotation");
      const a = this.popup = new V2({ container: this.container, color: this.data.color, titleObj: this.data.titleObj, modificationDate: this.data.modificationDate, contentsObj: this.data.contentsObj, richText: this.data.richText, rect: this.data.rect, parentRect: this.data.parentRect || null, parent: this.parent, elements: this.elements, open: this.data.open }), g = [];
      for (const l of this.elements) l.popup = a, g.push(l.data.id), l.addHighlightArea();
      return this.container.setAttribute("aria-controls", g.map(((l) => `${rI}${l}`)).join(",")), this.container;
    }
  }
  class V2 {
    #t = this.#x.bind(this);
    #A = this.#D.bind(this);
    #e = this.#b.bind(this);
    #s = this.#f.bind(this);
    #a = null;
    #i = null;
    #r = null;
    #o = null;
    #h = null;
    #g = null;
    #c = null;
    #n = !1;
    #l = null;
    #C = null;
    #I = null;
    #B = null;
    #d = null;
    #u = null;
    #E = !1;
    constructor({ container: a, color: g, elements: l, titleObj: B, modificationDate: Q, contentsObj: f, richText: m, parent: w, rect: k, parentRect: F, open: v }) {
      this.#i = a, this.#d = B, this.#r = f, this.#B = m, this.#g = w, this.#a = g, this.#I = k, this.#c = F, this.#h = l, this.#o = BI.toDateObject(Q), this.trigger = l.flatMap(((L) => L.getElementsToTriggerPopup()));
      for (const L of this.trigger) L.addEventListener("click", this.#s), L.addEventListener("mouseenter", this.#e), L.addEventListener("mouseleave", this.#A), L.classList.add("popupTriggerArea");
      for (const L of l) L.container?.addEventListener("keydown", this.#t);
      this.#i.hidden = !0, v && this.#f();
    }
    render() {
      if (this.#l) return;
      const a = this.#l = document.createElement("div");
      if (a.className = "popup", this.#a) {
        const Q = a.style.outlineColor = Pt.makeHexColor(...this.#a);
        CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? a.style.backgroundColor = `color-mix(in srgb, ${Q} 30%, white)` : a.style.backgroundColor = Pt.makeHexColor(...this.#a.map(((m) => Math.floor(0.7 * (255 - m) + m))));
      }
      const g = document.createElement("span");
      g.className = "header";
      const l = document.createElement("h1");
      if (g.append(l), { dir: l.dir, str: l.textContent } = this.#d, a.append(g), this.#o) {
        const Q = document.createElement("span");
        Q.classList.add("popupDate"), Q.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string"), Q.setAttribute("data-l10n-args", JSON.stringify({ dateObj: this.#o.valueOf() })), g.append(Q);
      }
      const B = this.#p;
      if (B) OI.render({ xfaHtml: B, intent: "richText", div: a }), a.lastChild.classList.add("richText", "popupContent");
      else {
        const Q = this._formatContents(this.#r);
        a.append(Q);
      }
      this.#i.append(a);
    }
    get #p() {
      const a = this.#B, g = this.#r;
      return !a?.str || g?.str && g.str !== a.str ? null : this.#B.html || null;
    }
    get #y() {
      return this.#p?.attributes?.style?.fontSize || 0;
    }
    get #k() {
      return this.#p?.attributes?.style?.color || null;
    }
    #S(a) {
      const g = [], l = { str: a, html: { name: "div", attributes: { dir: "auto" }, children: [{ name: "p", children: g }] } }, B = { style: { color: this.#k, fontSize: this.#y ? `calc(${this.#y}px * var(--scale-factor))` : "" } };
      for (const Q of a.split(`
`)) g.push({ name: "span", value: Q, attributes: B });
      return l;
    }
    _formatContents({ str: a, dir: g }) {
      const l = document.createElement("p");
      l.classList.add("popupContent"), l.dir = g;
      const B = a.split(/(?:\r\n?|\n)/);
      for (let Q = 0, f = B.length; Q < f; ++Q) {
        const m = B[Q];
        l.append(document.createTextNode(m)), Q < f - 1 && l.append(document.createElement("br"));
      }
      return l;
    }
    #x(a) {
      a.altKey || a.shiftKey || a.ctrlKey || a.metaKey || (a.key === "Enter" || a.key === "Escape" && this.#n) && this.#f();
    }
    updateEdited({ rect: a, popupContent: g }) {
      this.#u ||= { contentsObj: this.#r, richText: this.#B }, a && (this.#C = null), g && (this.#B = this.#S(g), this.#r = null), this.#l?.remove(), this.#l = null;
    }
    resetEdited() {
      this.#u && ({ contentsObj: this.#r, richText: this.#B } = this.#u, this.#u = null, this.#l?.remove(), this.#l = null, this.#C = null);
    }
    #w() {
      if (this.#C !== null) return;
      const { page: { view: a }, viewport: { rawDims: { pageWidth: g, pageHeight: l, pageX: B, pageY: Q } } } = this.#g;
      let f = !!this.#c, m = f ? this.#c : this.#I;
      for (const J of this.#h) if (!m || Pt.intersect(J.data.rect, m) !== null) {
        m = J.data.rect, f = !0;
        break;
      }
      const w = Pt.normalizeRect([m[0], a[3] - m[1] + a[1], m[2], a[3] - m[3] + a[1]]), k = f ? m[2] - m[0] + 5 : 0, F = w[0] + k, v = w[1];
      this.#C = [100 * (F - B) / g, 100 * (v - Q) / l];
      const { style: L } = this.#i;
      L.left = `${this.#C[0]}%`, L.top = `${this.#C[1]}%`;
    }
    #f() {
      this.#n = !this.#n, this.#n ? (this.#b(), this.#i.addEventListener("click", this.#s), this.#i.addEventListener("keydown", this.#t)) : (this.#D(), this.#i.removeEventListener("click", this.#s), this.#i.removeEventListener("keydown", this.#t));
    }
    #b() {
      this.#l || this.render(), this.isVisible ? this.#n && this.#i.classList.add("focused") : (this.#w(), this.#i.hidden = !1, this.#i.style.zIndex = parseInt(this.#i.style.zIndex) + 1e3);
    }
    #D() {
      this.#i.classList.remove("focused"), !this.#n && this.isVisible && (this.#i.hidden = !0, this.#i.style.zIndex = parseInt(this.#i.style.zIndex) - 1e3);
    }
    forceHide() {
      this.#E = this.isVisible, this.#E && (this.#i.hidden = !0);
    }
    maybeShow() {
      this.#E && (this.#l || this.#b(), this.#E = !1, this.#i.hidden = !1);
    }
    get isVisible() {
      return this.#i.hidden === !1;
    }
  }
  class ZI extends YA {
    constructor(a) {
      super(a, { isRenderable: !0, ignoreBorder: !0 }), this.textContent = a.data.textContent, this.textPosition = a.data.textPosition, this.annotationEditorType = p.FREETEXT;
    }
    render() {
      if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
        const a = document.createElement("div");
        a.classList.add("annotationTextContent"), a.setAttribute("role", "comment");
        for (const g of this.textContent) {
          const l = document.createElement("span");
          l.textContent = g, a.append(l);
        }
        this.container.append(a);
      }
      return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
    }
  }
  class X2 extends YA {
    #t = null;
    constructor(a) {
      super(a, { isRenderable: !0, ignoreBorder: !0 });
    }
    render() {
      this.container.classList.add("lineAnnotation");
      const a = this.data, { width: g, height: l } = Hi(a.rect), B = this.svgFactory.create(g, l, !0), Q = this.#t = this.svgFactory.createElement("svg:line");
      return Q.setAttribute("x1", a.rect[2] - a.lineCoordinates[0]), Q.setAttribute("y1", a.rect[3] - a.lineCoordinates[1]), Q.setAttribute("x2", a.rect[2] - a.lineCoordinates[2]), Q.setAttribute("y2", a.rect[3] - a.lineCoordinates[3]), Q.setAttribute("stroke-width", a.borderStyle.width || 1), Q.setAttribute("stroke", "transparent"), Q.setAttribute("fill", "transparent"), B.append(Q), this.container.append(B), !a.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
      return this.#t;
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  class z2 extends YA {
    #t = null;
    constructor(a) {
      super(a, { isRenderable: !0, ignoreBorder: !0 });
    }
    render() {
      this.container.classList.add("squareAnnotation");
      const a = this.data, { width: g, height: l } = Hi(a.rect), B = this.svgFactory.create(g, l, !0), Q = a.borderStyle.width, f = this.#t = this.svgFactory.createElement("svg:rect");
      return f.setAttribute("x", Q / 2), f.setAttribute("y", Q / 2), f.setAttribute("width", g - Q), f.setAttribute("height", l - Q), f.setAttribute("stroke-width", Q || 1), f.setAttribute("stroke", "transparent"), f.setAttribute("fill", "transparent"), B.append(f), this.container.append(B), !a.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
      return this.#t;
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  class $2 extends YA {
    #t = null;
    constructor(a) {
      super(a, { isRenderable: !0, ignoreBorder: !0 });
    }
    render() {
      this.container.classList.add("circleAnnotation");
      const a = this.data, { width: g, height: l } = Hi(a.rect), B = this.svgFactory.create(g, l, !0), Q = a.borderStyle.width, f = this.#t = this.svgFactory.createElement("svg:ellipse");
      return f.setAttribute("cx", g / 2), f.setAttribute("cy", l / 2), f.setAttribute("rx", g / 2 - Q / 2), f.setAttribute("ry", l / 2 - Q / 2), f.setAttribute("stroke-width", Q || 1), f.setAttribute("stroke", "transparent"), f.setAttribute("fill", "transparent"), B.append(f), this.container.append(B), !a.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
      return this.#t;
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  class VI extends YA {
    #t = null;
    constructor(a) {
      super(a, { isRenderable: !0, ignoreBorder: !0 }), this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
    }
    render() {
      this.container.classList.add(this.containerClassName);
      const { data: { rect: a, vertices: g, borderStyle: l, popupRef: B } } = this;
      if (!g) return this.container;
      const { width: Q, height: f } = Hi(a), m = this.svgFactory.create(Q, f, !0);
      let w = [];
      for (let F = 0, v = g.length; F < v; F += 2) {
        const L = g[F] - a[0], J = a[3] - g[F + 1];
        w.push(`${L},${J}`);
      }
      w = w.join(" ");
      const k = this.#t = this.svgFactory.createElement(this.svgElementName);
      return k.setAttribute("points", w), k.setAttribute("stroke-width", l.width || 1), k.setAttribute("stroke", "transparent"), k.setAttribute("fill", "transparent"), m.append(k), this.container.append(m), !B && this.hasPopupData && this._createPopup(), this.container;
    }
    getElementsToTriggerPopup() {
      return this.#t;
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  class tp extends VI {
    constructor(a) {
      super(a), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
    }
  }
  class Ap extends YA {
    constructor(a) {
      super(a, { isRenderable: !0, ignoreBorder: !0 });
    }
    render() {
      return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
  }
  class XI extends YA {
    #t = [];
    constructor(a) {
      super(a, { isRenderable: !0, ignoreBorder: !0 }), this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = p.INK;
    }
    render() {
      this.container.classList.add(this.containerClassName);
      const { data: { rect: a, inkLists: g, borderStyle: l, popupRef: B } } = this, { width: Q, height: f } = Hi(a), m = this.svgFactory.create(Q, f, !0);
      for (const w of g) {
        let k = [];
        for (let v = 0, L = w.length; v < L; v += 2) {
          const J = w[v] - a[0], K = a[3] - w[v + 1];
          k.push(`${J},${K}`);
        }
        k = k.join(" ");
        const F = this.svgFactory.createElement(this.svgElementName);
        this.#t.push(F), F.setAttribute("points", k), F.setAttribute("stroke-width", l.width || 1), F.setAttribute("stroke", "transparent"), F.setAttribute("fill", "transparent"), !B && this.hasPopupData && this._createPopup(), m.append(F);
      }
      return this.container.append(m), this.container;
    }
    getElementsToTriggerPopup() {
      return this.#t;
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  class ep extends YA {
    constructor(a) {
      super(a, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 });
    }
    render() {
      return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container;
    }
  }
  class ip extends YA {
    constructor(a) {
      super(a, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 });
    }
    render() {
      return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
    }
  }
  class sp extends YA {
    constructor(a) {
      super(a, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 });
    }
    render() {
      return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
    }
  }
  class ap extends YA {
    constructor(a) {
      super(a, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 });
    }
    render() {
      return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
    }
  }
  class zI extends YA {
    constructor(a) {
      super(a, { isRenderable: !0, ignoreBorder: !0 });
    }
    render() {
      return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
    }
  }
  class np extends YA {
    #t = null;
    constructor(a) {
      super(a, { isRenderable: !0 });
      const { file: g } = this.data;
      this.filename = g.filename, this.content = g.content, this.linkService.eventBus?.dispatch("fileattachmentannotation", { source: this, ...g });
    }
    render() {
      this.container.classList.add("fileAttachmentAnnotation");
      const { container: a, data: g } = this;
      let l;
      g.hasAppearance || g.fillAlpha === 0 ? l = document.createElement("div") : (l = document.createElement("img"), l.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(g.name) ? "paperclip" : "pushpin"}.svg`, g.fillAlpha && g.fillAlpha < 1 && (l.style = `filter: opacity(${Math.round(100 * g.fillAlpha)}%);`)), l.addEventListener("dblclick", this.#A.bind(this)), this.#t = l;
      const { isMac: B } = be.platform;
      return a.addEventListener("keydown", ((Q) => {
        Q.key === "Enter" && (B ? Q.metaKey : Q.ctrlKey) && this.#A();
      })), !g.popupRef && this.hasPopupData ? this._createPopup() : l.classList.add("popupTriggerArea"), a.append(l), a;
    }
    getElementsToTriggerPopup() {
      return this.#t;
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
    #A() {
      this.downloadManager?.openOrDownloadData(this.content, this.filename);
    }
  }
  class rp {
    #t = null;
    #A = null;
    #e = /* @__PURE__ */ new Map();
    constructor({ div: a, accessibilityManager: g, annotationCanvasMap: l, annotationEditorUIManager: B, page: Q, viewport: f }) {
      this.div = a, this.#t = g, this.#A = l, this.page = Q, this.viewport = f, this.zIndex = 0, this._annotationEditorUIManager = B;
    }
    hasEditableAnnotations() {
      return this.#e.size > 0;
    }
    #s(a, g) {
      const l = a.firstChild || a;
      l.id = `${rI}${g}`, this.div.append(a), this.#t?.moveElementInDOM(this.div, a, l, !1);
    }
    async render(a) {
      const { annotations: g } = a, l = this.div;
      Hs(l, this.viewport);
      const B = /* @__PURE__ */ new Map(), Q = { data: null, layer: l, linkService: a.linkService, downloadManager: a.downloadManager, imageResourcesPath: a.imageResourcesPath || "", renderForms: a.renderForms !== !1, svgFactory: new Gg(), annotationStorage: a.annotationStorage || new Yg(), enableScripting: a.enableScripting === !0, hasJSActions: a.hasJSActions, fieldObjects: a.fieldObjects, parent: this, elements: null };
      for (const f of g) {
        if (f.noHTML) continue;
        const m = f.annotationType === lt;
        if (m) {
          const F = B.get(f.id);
          if (!F) continue;
          Q.elements = F;
        } else {
          const { width: F, height: v } = Hi(f.rect);
          if (F <= 0 || v <= 0) continue;
        }
        Q.data = f;
        const w = q2.create(Q);
        if (!w.isRenderable) continue;
        if (!m && f.popupRef) {
          const F = B.get(f.popupRef);
          F ? F.push(w) : B.set(f.popupRef, [w]);
        }
        const k = w.render();
        f.hidden && (k.style.visibility = "hidden"), this.#s(k, f.id), w._isEditable && (this.#e.set(w.data.id, w), this._annotationEditorUIManager?.renderAnnotationElement(w));
      }
      this.#a();
    }
    update({ viewport: a }) {
      const g = this.div;
      this.viewport = a, Hs(g, { rotation: a.rotation }), this.#a(), g.hidden = !1;
    }
    #a() {
      if (!this.#A) return;
      const a = this.div;
      for (const [g, l] of this.#A) {
        const B = a.querySelector(`[data-annotation-id="${g}"]`);
        if (!B) continue;
        l.className = "annotationContent";
        const { firstChild: Q } = B;
        Q ? Q.nodeName === "CANVAS" ? Q.replaceWith(l) : Q.classList.contains("annotationContent") ? Q.after(l) : Q.before(l) : B.append(l);
      }
      this.#A.clear();
    }
    getEditableAnnotations() {
      return Array.from(this.#e.values());
    }
    getEditableAnnotation(a) {
      return this.#e.get(a);
    }
  }
  const Kr = /\r\n?|\n/g;
  class jA extends $t {
    #t;
    #A = "";
    #e = `${this.id}-editor`;
    #s = null;
    #a;
    #i = null;
    static _freeTextDefaultContent = "";
    static _internalPadding = 0;
    static _defaultColor = null;
    static _defaultFontSize = 10;
    static get _keyboardManager() {
      const a = jA.prototype, g = (Q) => Q.isEmpty(), l = ss.TRANSLATE_SMALL, B = ss.TRANSLATE_BIG;
      return aA(this, "_keyboardManager", new In([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], a.commitOrRemove, { bubbles: !0 }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], a.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], a._translateEmpty, { args: [-l, 0], checker: g }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], a._translateEmpty, { args: [-B, 0], checker: g }], [["ArrowRight", "mac+ArrowRight"], a._translateEmpty, { args: [l, 0], checker: g }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], a._translateEmpty, { args: [B, 0], checker: g }], [["ArrowUp", "mac+ArrowUp"], a._translateEmpty, { args: [0, -l], checker: g }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], a._translateEmpty, { args: [0, -B], checker: g }], [["ArrowDown", "mac+ArrowDown"], a._translateEmpty, { args: [0, l], checker: g }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], a._translateEmpty, { args: [0, B], checker: g }]]));
    }
    static _type = "freetext";
    static _editorType = p.FREETEXT;
    constructor(a) {
      super({ ...a, name: "freeTextEditor" }), this.#t = a.color || jA._defaultColor || $t._defaultLineColor, this.#a = a.fontSize || jA._defaultFontSize;
    }
    static initialize(a, g) {
      $t.initialize(a, g, { strings: ["pdfjs-free-text-default-content"] });
      const l = getComputedStyle(document.documentElement);
      this._internalPadding = parseFloat(l.getPropertyValue("--freetext-padding"));
    }
    static updateDefaultParams(a, g) {
      switch (a) {
        case y.FREETEXT_SIZE:
          jA._defaultFontSize = g;
          break;
        case y.FREETEXT_COLOR:
          jA._defaultColor = g;
      }
    }
    updateParams(a, g) {
      switch (a) {
        case y.FREETEXT_SIZE:
          this.#r(g);
          break;
        case y.FREETEXT_COLOR:
          this.#o(g);
      }
    }
    static get defaultPropertiesToUpdate() {
      return [[y.FREETEXT_SIZE, jA._defaultFontSize], [y.FREETEXT_COLOR, jA._defaultColor || $t._defaultLineColor]];
    }
    get propertiesToUpdate() {
      return [[y.FREETEXT_SIZE, this.#a], [y.FREETEXT_COLOR, this.#t]];
    }
    #r(a) {
      const g = (B) => {
        this.editorDiv.style.fontSize = `calc(${B}px * var(--scale-factor))`, this.translate(0, -(B - this.#a) * this.parentScale), this.#a = B, this.#g();
      }, l = this.#a;
      this.addCommands({ cmd: g.bind(this, a), undo: g.bind(this, l), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: !0, type: y.FREETEXT_SIZE, overwriteIfSameType: !0, keepUndo: !0 });
    }
    #o(a) {
      const g = (B) => {
        this.#t = this.editorDiv.style.color = B;
      }, l = this.#t;
      this.addCommands({ cmd: g.bind(this, a), undo: g.bind(this, l), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: !0, type: y.FREETEXT_COLOR, overwriteIfSameType: !0, keepUndo: !0 });
    }
    _translateEmpty(a, g) {
      this._uiManager.translateSelectedEditors(a, g, !0);
    }
    getInitialTranslation() {
      const a = this.parentScale;
      return [-jA._internalPadding * a, -(jA._internalPadding + this.#a) * a];
    }
    rebuild() {
      this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
    }
    enableEditMode() {
      if (this.isInEditMode()) return;
      this.parent.setEditingState(!1), this.parent.updateToolbar(p.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.#s = new AbortController();
      const a = this._uiManager.combinedSignal(this.#s);
      this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), { signal: a }), this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), { signal: a }), this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), { signal: a }), this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), { signal: a }), this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), { signal: a });
    }
    disableEditMode() {
      this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", this.#e), this._isDraggable = !0, this.#s?.abort(), this.#s = null, this.div.focus({ preventScroll: !0 }), this.isEditing = !1, this.parent.div.classList.add("freetextEditing"));
    }
    focusin(a) {
      this._focusEventsAllowed && (super.focusin(a), a.target !== this.editorDiv && this.editorDiv.focus());
    }
    onceAdded() {
      this.width || (this.enableEditMode(), this.editorDiv.focus(), this._initialOptions?.isCentered && this.center(), this._initialOptions = null);
    }
    isEmpty() {
      return !this.editorDiv || this.editorDiv.innerText.trim() === "";
    }
    remove() {
      this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freetextEditing")), super.remove();
    }
    #h() {
      const a = [];
      this.editorDiv.normalize();
      for (const g of this.editorDiv.childNodes) a.push(jA.#c(g));
      return a.join(`
`);
    }
    #g() {
      const [a, g] = this.parentDimensions;
      let l;
      if (this.isAttachedToDOM) l = this.div.getBoundingClientRect();
      else {
        const { currentLayer: B, div: Q } = this, f = Q.style.display, m = Q.classList.contains("hidden");
        Q.classList.remove("hidden"), Q.style.display = "hidden", B.div.append(this.div), l = Q.getBoundingClientRect(), Q.remove(), Q.style.display = f, Q.classList.toggle("hidden", m);
      }
      this.rotation % 180 == this.parentRotation % 180 ? (this.width = l.width / a, this.height = l.height / g) : (this.width = l.height / a, this.height = l.width / g), this.fixAndSetPosition();
    }
    commit() {
      if (!this.isInEditMode()) return;
      super.commit(), this.disableEditMode();
      const a = this.#A, g = this.#A = this.#h().trimEnd();
      if (a === g) return;
      const l = (B) => {
        this.#A = B, B ? (this.#n(), this._uiManager.rebuild(this), this.#g()) : this.remove();
      };
      this.addCommands({ cmd: () => {
        l(g);
      }, undo: () => {
        l(a);
      }, mustExec: !1 }), this.#g();
    }
    shouldGetKeyboardEvents() {
      return this.isInEditMode();
    }
    enterInEditMode() {
      this.enableEditMode(), this.editorDiv.focus();
    }
    dblclick(a) {
      this.enterInEditMode();
    }
    keydown(a) {
      a.target === this.div && a.key === "Enter" && (this.enterInEditMode(), a.preventDefault());
    }
    editorDivKeydown(a) {
      jA._keyboardManager.exec(this, a);
    }
    editorDivFocus(a) {
      this.isEditing = !0;
    }
    editorDivBlur(a) {
      this.isEditing = !1;
    }
    editorDivInput(a) {
      this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
    }
    disableEditing() {
      this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
    }
    enableEditing() {
      this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
    }
    render() {
      if (this.div) return this.div;
      let a, g;
      this.width && (a = this.x, g = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", this.#e), this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text"), this.enableEditing(), $t._l10nPromise.get("pdfjs-free-text-default-content").then(((B) => this.editorDiv?.setAttribute("default-content", B))), this.editorDiv.contentEditable = !0;
      const { style: l } = this.editorDiv;
      if (l.fontSize = `calc(${this.#a}px * var(--scale-factor))`, l.color = this.#t, this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), Lr(this, this.div, ["dblclick", "keydown"]), this.width) {
        const [B, Q] = this.parentDimensions;
        if (this.annotationElementId) {
          const { position: f } = this.#i;
          let [m, w] = this.getInitialTranslation();
          [m, w] = this.pageTranslationToScreen(m, w);
          const [k, F] = this.pageDimensions, [v, L] = this.pageTranslation;
          let J, K;
          switch (this.rotation) {
            case 0:
              J = a + (f[0] - v) / k, K = g + this.height - (f[1] - L) / F;
              break;
            case 90:
              J = a + (f[0] - v) / k, K = g - (f[1] - L) / F, [m, w] = [w, -m];
              break;
            case 180:
              J = a - this.width + (f[0] - v) / k, K = g - (f[1] - L) / F, [m, w] = [-m, -w];
              break;
            case 270:
              J = a + (f[0] - v - this.height * F) / k, K = g + (f[1] - L - this.width * k) / F, [m, w] = [-w, m];
          }
          this.setAt(J * B, K * Q, m, w);
        } else this.setAt(a * B, g * Q, this.width * B, this.height * Q);
        this.#n(), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
      } else this._isDraggable = !1, this.editorDiv.contentEditable = !0;
      return this.div;
    }
    static #c(a) {
      return (a.nodeType === Node.TEXT_NODE ? a.nodeValue : a.innerText).replaceAll(Kr, "");
    }
    editorDivPaste(a) {
      const g = a.clipboardData || window.clipboardData, { types: l } = g;
      if (l.length === 1 && l[0] === "text/plain") return;
      a.preventDefault();
      const B = jA.#C(g.getData("text") || "").replaceAll(Kr, `
`);
      if (!B) return;
      const Q = window.getSelection();
      if (!Q.rangeCount) return;
      this.editorDiv.normalize(), Q.deleteFromDocument();
      const f = Q.getRangeAt(0);
      if (!B.includes(`
`)) return f.insertNode(document.createTextNode(B)), this.editorDiv.normalize(), void Q.collapseToStart();
      const { startContainer: m, startOffset: w } = f, k = [], F = [];
      if (m.nodeType === Node.TEXT_NODE) {
        const J = m.parentElement;
        if (F.push(m.nodeValue.slice(w).replaceAll(Kr, "")), J !== this.editorDiv) {
          let K = k;
          for (const X of this.editorDiv.childNodes) X !== J ? K.push(jA.#c(X)) : K = F;
        }
        k.push(m.nodeValue.slice(0, w).replaceAll(Kr, ""));
      } else if (m === this.editorDiv) {
        let J = k, K = 0;
        for (const X of this.editorDiv.childNodes) K++ === w && (J = F), J.push(jA.#c(X));
      }
      this.#A = `${k.join(`
`)}${B}${F.join(`
`)}`, this.#n();
      const v = new Range();
      let L = k.reduce(((J, K) => J + K.length), 0);
      for (const { firstChild: J } of this.editorDiv.childNodes) if (J.nodeType === Node.TEXT_NODE) {
        const K = J.nodeValue.length;
        if (L <= K) {
          v.setStart(J, L), v.setEnd(J, L);
          break;
        }
        L -= K;
      }
      Q.removeAllRanges(), Q.addRange(v);
    }
    #n() {
      if (this.editorDiv.replaceChildren(), this.#A) for (const a of this.#A.split(`
`)) {
        const g = document.createElement("div");
        g.append(a ? document.createTextNode(a) : document.createElement("br")), this.editorDiv.append(g);
      }
    }
    #l() {
      return this.#A.replaceAll(" ", " ");
    }
    static #C(a) {
      return a.replaceAll(" ", " ");
    }
    get contentDiv() {
      return this.editorDiv;
    }
    static deserialize(a, g, l) {
      let B = null;
      if (a instanceof ZI) {
        const { data: { defaultAppearanceData: { fontSize: f, fontColor: m }, rect: w, rotation: k, id: F }, textContent: v, textPosition: L, parent: { page: { pageNumber: J } } } = a;
        if (!v || v.length === 0) return null;
        B = a = { annotationType: p.FREETEXT, color: Array.from(m), fontSize: f, value: v.join(`
`), position: L, pageIndex: J - 1, rect: w.slice(0), rotation: k, id: F, deleted: !1 };
      }
      const Q = super.deserialize(a, g, l);
      return Q.#a = a.fontSize, Q.#t = Pt.makeHexColor(...a.color), Q.#A = jA.#C(a.value), Q.annotationElementId = a.id || null, Q.#i = B, Q;
    }
    serialize(a = !1) {
      if (this.isEmpty()) return null;
      if (this.deleted) return { pageIndex: this.pageIndex, id: this.annotationElementId, deleted: !0 };
      const g = jA._internalPadding * this.parentScale, l = this.getRect(g, g), B = $t._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#t), Q = { annotationType: p.FREETEXT, color: B, fontSize: this.#a, value: this.#l(), pageIndex: this.pageIndex, rect: l, rotation: this.rotation, structTreeParentId: this._structTreeParentId };
      return a ? Q : this.annotationElementId && !this.#I(Q) ? null : (Q.id = this.annotationElementId, Q);
    }
    #I(a) {
      const { value: g, fontSize: l, color: B, pageIndex: Q } = this.#i;
      return this._hasBeenMoved || a.value !== g || a.fontSize !== l || a.color.some(((f, m) => f !== B[m])) || a.pageIndex !== Q;
    }
    renderAnnotationElement(a) {
      const g = super.renderAnnotationElement(a);
      if (this.deleted) return g;
      const { style: l } = g;
      l.fontSize = `calc(${this.#a}px * var(--scale-factor))`, l.color = this.#t, g.replaceChildren();
      for (const Q of this.#A.split(`
`)) {
        const f = document.createElement("div");
        f.append(Q ? document.createTextNode(Q) : document.createElement("br")), g.append(f);
      }
      const B = jA._internalPadding * this.parentScale;
      return a.updateEdited({ rect: this.getRect(B, B), popupContent: this.#A }), g;
    }
    resetAnnotationElement(a) {
      super.resetAnnotationElement(a), a.resetEdited();
    }
  }
  class $I {
    #t;
    #A = [];
    #e = [];
    constructor(a, g = 0, l = 0, B = !0) {
      let Q = 1 / 0, f = -1 / 0, m = 1 / 0, w = -1 / 0;
      const k = 10 ** -4;
      for (const { x: et, y: At, width: It, height: kt } of a) {
        const Mt = Math.floor((et - g) / k) * k, Ut = Math.ceil((et + It + g) / k) * k, xt = Math.floor((At - g) / k) * k, Wt = Math.ceil((At + kt + g) / k) * k, eA = [Mt, xt, Wt, !0], nA = [Ut, xt, Wt, !1];
        this.#A.push(eA, nA), Q = Math.min(Q, Mt), f = Math.max(f, Ut), m = Math.min(m, xt), w = Math.max(w, Wt);
      }
      const F = f - Q + 2 * l, v = w - m + 2 * l, L = Q - l, J = m - l, K = this.#A.at(B ? -1 : -2), X = [K[0], K[2]];
      for (const et of this.#A) {
        const [At, It, kt] = et;
        et[0] = (At - L) / F, et[1] = (It - J) / v, et[2] = (kt - J) / v;
      }
      this.#t = { x: L, y: J, width: F, height: v, lastPoint: X };
    }
    getOutlines() {
      this.#A.sort(((g, l) => g[0] - l[0] || g[1] - l[1] || g[2] - l[2]));
      const a = [];
      for (const g of this.#A) g[3] ? (a.push(...this.#o(g)), this.#i(g)) : (this.#r(g), a.push(...this.#o(g)));
      return this.#s(a);
    }
    #s(a) {
      const g = [], l = /* @__PURE__ */ new Set();
      for (const f of a) {
        const [m, w, k] = f;
        g.push([m, w, f], [m, k, f]);
      }
      g.sort(((f, m) => f[1] - m[1] || f[0] - m[0]));
      for (let f = 0, m = g.length; f < m; f += 2) {
        const w = g[f][2], k = g[f + 1][2];
        w.push(k), k.push(w), l.add(w), l.add(k);
      }
      const B = [];
      let Q;
      for (; l.size > 0; ) {
        const f = l.values().next().value;
        let [m, w, k, F, v] = f;
        l.delete(f);
        let L = m, J = w;
        for (Q = [m, k], B.push(Q); ; ) {
          let K;
          if (l.has(F)) K = F;
          else {
            if (!l.has(v)) break;
            K = v;
          }
          l.delete(K), [m, w, k, F, v] = K, L !== m && (Q.push(L, J, m, J === w ? w : k), L = m), J = J === w ? k : w;
        }
        Q.push(L, J);
      }
      return new op(B, this.#t);
    }
    #a(a) {
      const g = this.#e;
      let l = 0, B = g.length - 1;
      for (; l <= B; ) {
        const Q = l + B >> 1, f = g[Q][0];
        if (f === a) return Q;
        f < a ? l = Q + 1 : B = Q - 1;
      }
      return B + 1;
    }
    #i([, a, g]) {
      const l = this.#a(a);
      this.#e.splice(l, 0, [a, g]);
    }
    #r([, a, g]) {
      const l = this.#a(a);
      for (let B = l; B < this.#e.length; B++) {
        const [Q, f] = this.#e[B];
        if (Q !== a) break;
        if (Q === a && f === g) return void this.#e.splice(B, 1);
      }
      for (let B = l - 1; B >= 0; B--) {
        const [Q, f] = this.#e[B];
        if (Q !== a) break;
        if (Q === a && f === g) return void this.#e.splice(B, 1);
      }
    }
    #o(a) {
      const [g, l, B] = a, Q = [[g, l, B]], f = this.#a(B);
      for (let m = 0; m < f; m++) {
        const [w, k] = this.#e[m];
        for (let F = 0, v = Q.length; F < v; F++) {
          const [, L, J] = Q[F];
          if (!(k <= L || J <= w)) if (L >= w) if (J > k) Q[F][1] = k;
          else {
            if (v === 1) return [];
            Q.splice(F, 1), F--, v--;
          }
          else Q[F][2] = w, J > k && Q.push([g, k, J]);
        }
      }
      return Q;
    }
  }
  class t0 {
    toSVGPath() {
      throw new Error("Abstract method `toSVGPath` must be implemented.");
    }
    get box() {
      throw new Error("Abstract getter `box` must be implemented.");
    }
    serialize(a, g) {
      throw new Error("Abstract method `serialize` must be implemented.");
    }
    get free() {
      return this instanceof tc;
    }
  }
  class op extends t0 {
    #t;
    #A;
    constructor(a, g) {
      super(), this.#A = a, this.#t = g;
    }
    toSVGPath() {
      const a = [];
      for (const g of this.#A) {
        let [l, B] = g;
        a.push(`M${l} ${B}`);
        for (let Q = 2; Q < g.length; Q += 2) {
          const f = g[Q], m = g[Q + 1];
          f === l ? (a.push(`V${m}`), B = m) : m === B && (a.push(`H${f}`), l = f);
        }
        a.push("Z");
      }
      return a.join(" ");
    }
    serialize([a, g, l, B], Q) {
      const f = [], m = l - a, w = B - g;
      for (const k of this.#A) {
        const F = new Array(k.length);
        for (let v = 0; v < k.length; v += 2) F[v] = a + k[v] * m, F[v + 1] = B - k[v + 1] * w;
        f.push(F);
      }
      return f;
    }
    get box() {
      return this.#t;
    }
  }
  class Ks {
    #t;
    #A = [];
    #e;
    #s;
    #a = [];
    #i = new Float64Array(18);
    #r;
    #o;
    #h;
    #g;
    #c;
    #n;
    #l = [];
    static #C = 8;
    static #I = 2;
    static #B = Ks.#C + Ks.#I;
    constructor({ x: a, y: g }, l, B, Q, f, m = 0) {
      this.#t = l, this.#n = Q * B, this.#s = f, this.#i.set([NaN, NaN, NaN, NaN, a, g], 6), this.#e = m, this.#g = Ks.#C * B, this.#h = Ks.#B * B, this.#c = B, this.#l.push(a, g);
    }
    get free() {
      return !0;
    }
    isEmpty() {
      return isNaN(this.#i[8]);
    }
    #d() {
      const a = this.#i.subarray(4, 6), g = this.#i.subarray(16, 18), [l, B, Q, f] = this.#t;
      return [(this.#r + (a[0] - g[0]) / 2 - l) / Q, (this.#o + (a[1] - g[1]) / 2 - B) / f, (this.#r + (g[0] - a[0]) / 2 - l) / Q, (this.#o + (g[1] - a[1]) / 2 - B) / f];
    }
    add({ x: a, y: g }) {
      this.#r = a, this.#o = g;
      const [l, B, Q, f] = this.#t;
      let [m, w, k, F] = this.#i.subarray(8, 12);
      const v = a - k, L = g - F, J = Math.hypot(v, L);
      if (J < this.#h) return !1;
      const K = J - this.#g, X = K / J, et = X * v, At = X * L;
      let It = m, kt = w;
      m = k, w = F, k += et, F += At, this.#l?.push(a, g);
      const Mt = et / K, Ut = -At / K * this.#n, xt = Mt * this.#n;
      return this.#i.set(this.#i.subarray(2, 8), 0), this.#i.set([k + Ut, F + xt], 4), this.#i.set(this.#i.subarray(14, 18), 12), this.#i.set([k - Ut, F - xt], 16), isNaN(this.#i[6]) ? (this.#a.length === 0 && (this.#i.set([m + Ut, w + xt], 2), this.#a.push(NaN, NaN, NaN, NaN, (m + Ut - l) / Q, (w + xt - B) / f), this.#i.set([m - Ut, w - xt], 14), this.#A.push(NaN, NaN, NaN, NaN, (m - Ut - l) / Q, (w - xt - B) / f)), this.#i.set([It, kt, m, w, k, F], 6), !this.isEmpty()) : (this.#i.set([It, kt, m, w, k, F], 6), Math.abs(Math.atan2(kt - w, It - m) - Math.atan2(At, et)) < Math.PI / 2 ? ([m, w, k, F] = this.#i.subarray(2, 6), this.#a.push(NaN, NaN, NaN, NaN, ((m + k) / 2 - l) / Q, ((w + F) / 2 - B) / f), [m, w, It, kt] = this.#i.subarray(14, 18), this.#A.push(NaN, NaN, NaN, NaN, ((It + m) / 2 - l) / Q, ((kt + w) / 2 - B) / f), !0) : ([It, kt, m, w, k, F] = this.#i.subarray(0, 6), this.#a.push(((It + 5 * m) / 6 - l) / Q, ((kt + 5 * w) / 6 - B) / f, ((5 * m + k) / 6 - l) / Q, ((5 * w + F) / 6 - B) / f, ((m + k) / 2 - l) / Q, ((w + F) / 2 - B) / f), [k, F, m, w, It, kt] = this.#i.subarray(12, 18), this.#A.push(((It + 5 * m) / 6 - l) / Q, ((kt + 5 * w) / 6 - B) / f, ((5 * m + k) / 6 - l) / Q, ((5 * w + F) / 6 - B) / f, ((m + k) / 2 - l) / Q, ((w + F) / 2 - B) / f), !0));
    }
    toSVGPath() {
      if (this.isEmpty()) return "";
      const a = this.#a, g = this.#A, l = this.#i.subarray(4, 6), B = this.#i.subarray(16, 18), [Q, f, m, w] = this.#t, [k, F, v, L] = this.#d();
      if (isNaN(this.#i[6]) && !this.isEmpty()) return `M${(this.#i[2] - Q) / m} ${(this.#i[3] - f) / w} L${(this.#i[4] - Q) / m} ${(this.#i[5] - f) / w} L${k} ${F} L${v} ${L} L${(this.#i[16] - Q) / m} ${(this.#i[17] - f) / w} L${(this.#i[14] - Q) / m} ${(this.#i[15] - f) / w} Z`;
      const J = [];
      J.push(`M${a[4]} ${a[5]}`);
      for (let K = 6; K < a.length; K += 6) isNaN(a[K]) ? J.push(`L${a[K + 4]} ${a[K + 5]}`) : J.push(`C${a[K]} ${a[K + 1]} ${a[K + 2]} ${a[K + 3]} ${a[K + 4]} ${a[K + 5]}`);
      J.push(`L${(l[0] - Q) / m} ${(l[1] - f) / w} L${k} ${F} L${v} ${L} L${(B[0] - Q) / m} ${(B[1] - f) / w}`);
      for (let K = g.length - 6; K >= 6; K -= 6) isNaN(g[K]) ? J.push(`L${g[K + 4]} ${g[K + 5]}`) : J.push(`C${g[K]} ${g[K + 1]} ${g[K + 2]} ${g[K + 3]} ${g[K + 4]} ${g[K + 5]}`);
      return J.push(`L${g[4]} ${g[5]} Z`), J.join(" ");
    }
    getOutlines() {
      const a = this.#a, g = this.#A, l = this.#i, B = l.subarray(4, 6), Q = l.subarray(16, 18), [f, m, w, k] = this.#t, F = new Float64Array((this.#l?.length ?? 0) + 2);
      for (let At = 0, It = F.length - 2; At < It; At += 2) F[At] = (this.#l[At] - f) / w, F[At + 1] = (this.#l[At + 1] - m) / k;
      F[F.length - 2] = (this.#r - f) / w, F[F.length - 1] = (this.#o - m) / k;
      const [v, L, J, K] = this.#d();
      if (isNaN(l[6]) && !this.isEmpty()) {
        const At = new Float64Array(36);
        return At.set([NaN, NaN, NaN, NaN, (l[2] - f) / w, (l[3] - m) / k, NaN, NaN, NaN, NaN, (l[4] - f) / w, (l[5] - m) / k, NaN, NaN, NaN, NaN, v, L, NaN, NaN, NaN, NaN, J, K, NaN, NaN, NaN, NaN, (l[16] - f) / w, (l[17] - m) / k, NaN, NaN, NaN, NaN, (l[14] - f) / w, (l[15] - m) / k], 0), new tc(At, F, this.#t, this.#c, this.#e, this.#s);
      }
      const X = new Float64Array(this.#a.length + 24 + this.#A.length);
      let et = a.length;
      for (let At = 0; At < et; At += 2) isNaN(a[At]) ? X[At] = X[At + 1] = NaN : (X[At] = a[At], X[At + 1] = a[At + 1]);
      X.set([NaN, NaN, NaN, NaN, (B[0] - f) / w, (B[1] - m) / k, NaN, NaN, NaN, NaN, v, L, NaN, NaN, NaN, NaN, J, K, NaN, NaN, NaN, NaN, (Q[0] - f) / w, (Q[1] - m) / k], et), et += 24;
      for (let At = g.length - 6; At >= 6; At -= 6) for (let It = 0; It < 6; It += 2) isNaN(g[At + It]) ? (X[et] = X[et + 1] = NaN, et += 2) : (X[et] = g[At + It], X[et + 1] = g[At + It + 1], et += 2);
      return X.set([NaN, NaN, NaN, NaN, g[4], g[5]], et), new tc(X, F, this.#t, this.#c, this.#e, this.#s);
    }
  }
  class tc extends t0 {
    #t;
    #A = null;
    #e;
    #s;
    #a;
    #i;
    #r;
    constructor(a, g, l, B, Q, f) {
      super(), this.#r = a, this.#a = g, this.#t = l, this.#i = B, this.#e = Q, this.#s = f, this.#g(f);
      const { x: m, y: w, width: k, height: F } = this.#A;
      for (let v = 0, L = a.length; v < L; v += 2) a[v] = (a[v] - m) / k, a[v + 1] = (a[v + 1] - w) / F;
      for (let v = 0, L = g.length; v < L; v += 2) g[v] = (g[v] - m) / k, g[v + 1] = (g[v + 1] - w) / F;
    }
    toSVGPath() {
      const a = [`M${this.#r[4]} ${this.#r[5]}`];
      for (let g = 6, l = this.#r.length; g < l; g += 6) isNaN(this.#r[g]) ? a.push(`L${this.#r[g + 4]} ${this.#r[g + 5]}`) : a.push(`C${this.#r[g]} ${this.#r[g + 1]} ${this.#r[g + 2]} ${this.#r[g + 3]} ${this.#r[g + 4]} ${this.#r[g + 5]}`);
      return a.push("Z"), a.join(" ");
    }
    serialize([a, g, l, B], Q) {
      const f = l - a, m = B - g;
      let w, k;
      switch (Q) {
        case 0:
          w = this.#o(this.#r, a, B, f, -m), k = this.#o(this.#a, a, B, f, -m);
          break;
        case 90:
          w = this.#h(this.#r, a, g, f, m), k = this.#h(this.#a, a, g, f, m);
          break;
        case 180:
          w = this.#o(this.#r, l, g, -f, m), k = this.#o(this.#a, l, g, -f, m);
          break;
        case 270:
          w = this.#h(this.#r, l, B, -f, -m), k = this.#h(this.#a, l, B, -f, -m);
      }
      return { outline: Array.from(w), points: [Array.from(k)] };
    }
    #o(a, g, l, B, Q) {
      const f = new Float64Array(a.length);
      for (let m = 0, w = a.length; m < w; m += 2) f[m] = g + a[m] * B, f[m + 1] = l + a[m + 1] * Q;
      return f;
    }
    #h(a, g, l, B, Q) {
      const f = new Float64Array(a.length);
      for (let m = 0, w = a.length; m < w; m += 2) f[m] = g + a[m + 1] * B, f[m + 1] = l + a[m] * Q;
      return f;
    }
    #g(a) {
      const g = this.#r;
      let l = g[4], B = g[5], Q = l, f = B, m = l, w = B, k = l, F = B;
      const v = a ? Math.max : Math.min;
      for (let et = 6, At = g.length; et < At; et += 6) {
        if (isNaN(g[et])) Q = Math.min(Q, g[et + 4]), f = Math.min(f, g[et + 5]), m = Math.max(m, g[et + 4]), w = Math.max(w, g[et + 5]), F < g[et + 5] ? (k = g[et + 4], F = g[et + 5]) : F === g[et + 5] && (k = v(k, g[et + 4]));
        else {
          const It = Pt.bezierBoundingBox(l, B, ...g.slice(et, et + 6));
          Q = Math.min(Q, It[0]), f = Math.min(f, It[1]), m = Math.max(m, It[2]), w = Math.max(w, It[3]), F < It[3] ? (k = It[2], F = It[3]) : F === It[3] && (k = v(k, It[2]));
        }
        l = g[et + 4], B = g[et + 5];
      }
      const L = Q - this.#e, J = f - this.#e, K = m - Q + 2 * this.#e, X = w - f + 2 * this.#e;
      this.#A = { x: L, y: J, width: K, height: X, lastPoint: [k, F] };
    }
    get box() {
      return this.#A;
    }
    getNewOutline(a, g) {
      const { x: l, y: B, width: Q, height: f } = this.#A, [m, w, k, F] = this.#t, v = Q * k, L = f * F, J = l * k + m, K = B * F + w, X = new Ks({ x: this.#a[0] * v + J, y: this.#a[1] * L + K }, this.#t, this.#i, a, this.#s, g ?? this.#e);
      for (let et = 2; et < this.#a.length; et += 2) X.add({ x: this.#a[et] * v + J, y: this.#a[et + 1] * L + K });
      return X.getOutlines();
    }
  }
  class fi {
    #t = this.#I.bind(this);
    #A = this.#d.bind(this);
    #e = null;
    #s = null;
    #a;
    #i = null;
    #r = !1;
    #o = !1;
    #h = null;
    #g;
    #c = null;
    #n;
    static get _keyboardManager() {
      return aA(this, "_keyboardManager", new In([[["Escape", "mac+Escape"], fi.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], fi.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], fi.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], fi.prototype._moveToPrevious], [["Home", "mac+Home"], fi.prototype._moveToBeginning], [["End", "mac+End"], fi.prototype._moveToEnd]]));
    }
    constructor({ editor: a = null, uiManager: g = null }) {
      a ? (this.#o = !1, this.#n = y.HIGHLIGHT_COLOR, this.#h = a) : (this.#o = !0, this.#n = y.HIGHLIGHT_DEFAULT_COLOR), this.#c = a?._uiManager || g, this.#g = this.#c._eventBus, this.#a = a?.color || this.#c?.highlightColors.values().next().value || "#FFFF98";
    }
    renderButton() {
      const a = this.#e = document.createElement("button");
      a.className = "colorPicker", a.tabIndex = "0", a.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button"), a.setAttribute("aria-haspopup", !0);
      const g = this.#c._signal;
      a.addEventListener("click", this.#B.bind(this), { signal: g }), a.addEventListener("keydown", this.#t, { signal: g });
      const l = this.#s = document.createElement("span");
      return l.className = "swatch", l.setAttribute("aria-hidden", !0), l.style.backgroundColor = this.#a, a.append(l), a;
    }
    renderMainDropdown() {
      const a = this.#i = this.#l();
      return a.setAttribute("aria-orientation", "horizontal"), a.setAttribute("aria-labelledby", "highlightColorPickerLabel"), a;
    }
    #l() {
      const a = document.createElement("div"), g = this.#c._signal;
      a.addEventListener("contextmenu", je, { signal: g }), a.className = "dropdown", a.role = "listbox", a.setAttribute("aria-multiselectable", !1), a.setAttribute("aria-orientation", "vertical"), a.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
      for (const [l, B] of this.#c.highlightColors) {
        const Q = document.createElement("button");
        Q.tabIndex = "0", Q.role = "option", Q.setAttribute("data-color", B), Q.title = l, Q.setAttribute("data-l10n-id", `pdfjs-editor-colorpicker-${l}`);
        const f = document.createElement("span");
        Q.append(f), f.className = "swatch", f.style.backgroundColor = B, Q.setAttribute("aria-selected", B === this.#a), Q.addEventListener("click", this.#C.bind(this, B), { signal: g }), a.append(Q);
      }
      return a.addEventListener("keydown", this.#t, { signal: g }), a;
    }
    #C(a, g) {
      g.stopPropagation(), this.#g.dispatch("switchannotationeditorparams", { source: this, type: this.#n, value: a });
    }
    _colorSelectFromKeyboard(a) {
      if (a.target === this.#e) return void this.#B(a);
      const g = a.target.getAttribute("data-color");
      g && this.#C(g, a);
    }
    _moveToNext(a) {
      this.#u ? a.target !== this.#e ? a.target.nextSibling?.focus() : this.#i.firstChild?.focus() : this.#B(a);
    }
    _moveToPrevious(a) {
      a.target !== this.#i?.firstChild && a.target !== this.#e ? (this.#u || this.#B(a), a.target.previousSibling?.focus()) : this.#u && this._hideDropdownFromKeyboard();
    }
    _moveToBeginning(a) {
      this.#u ? this.#i.firstChild?.focus() : this.#B(a);
    }
    _moveToEnd(a) {
      this.#u ? this.#i.lastChild?.focus() : this.#B(a);
    }
    #I(a) {
      fi._keyboardManager.exec(this, a);
    }
    #B(a) {
      if (this.#u) return void this.hideDropdown();
      if (this.#r = a.detail === 0, window.addEventListener("pointerdown", this.#A, { signal: this.#c._signal }), this.#i) return void this.#i.classList.remove("hidden");
      const g = this.#i = this.#l();
      this.#e.append(g);
    }
    #d(a) {
      this.#i?.contains(a.target) || this.hideDropdown();
    }
    hideDropdown() {
      this.#i?.classList.add("hidden"), window.removeEventListener("pointerdown", this.#A);
    }
    get #u() {
      return this.#i && !this.#i.classList.contains("hidden");
    }
    _hideDropdownFromKeyboard() {
      this.#o || (this.#u ? (this.hideDropdown(), this.#e.focus({ preventScroll: !0, focusVisible: this.#r })) : this.#h?.unselect());
    }
    updateColor(a) {
      if (this.#s && (this.#s.style.backgroundColor = a), !this.#i) return;
      const g = this.#c.highlightColors.values();
      for (const l of this.#i.children) l.setAttribute("aria-selected", g.next().value === a);
    }
    destroy() {
      this.#e?.remove(), this.#e = null, this.#s = null, this.#i?.remove(), this.#i = null;
    }
  }
  class _A extends $t {
    #t = null;
    #A = 0;
    #e;
    #s = null;
    #a = null;
    #i = null;
    #r = null;
    #o = 0;
    #h = null;
    #g = null;
    #c = null;
    #n = !1;
    #l = null;
    #C;
    #I = null;
    #B = "";
    #d;
    #u = "";
    static _defaultColor = null;
    static _defaultOpacity = 1;
    static _defaultThickness = 12;
    static _l10nPromise;
    static _type = "highlight";
    static _editorType = p.HIGHLIGHT;
    static _freeHighlightId = -1;
    static _freeHighlight = null;
    static _freeHighlightClipId = "";
    static get _keyboardManager() {
      const a = _A.prototype;
      return aA(this, "_keyboardManager", new In([[["ArrowLeft", "mac+ArrowLeft"], a._moveCaret, { args: [0] }], [["ArrowRight", "mac+ArrowRight"], a._moveCaret, { args: [1] }], [["ArrowUp", "mac+ArrowUp"], a._moveCaret, { args: [2] }], [["ArrowDown", "mac+ArrowDown"], a._moveCaret, { args: [3] }]]));
    }
    constructor(a) {
      super({ ...a, name: "highlightEditor" }), this.color = a.color || _A._defaultColor, this.#d = a.thickness || _A._defaultThickness, this.#C = a.opacity || _A._defaultOpacity, this.#e = a.boxes || null, this.#u = a.methodOfCreation || "", this.#B = a.text || "", this._isDraggable = !1, a.highlightId > -1 ? (this.#n = !0, this.#p(a), this.#w()) : (this.#t = a.anchorNode, this.#A = a.anchorOffset, this.#r = a.focusNode, this.#o = a.focusOffset, this.#E(), this.#w(), this.rotate(this.rotation));
    }
    get telemetryInitialData() {
      return { action: "added", type: this.#n ? "free_highlight" : "highlight", color: this._uiManager.highlightColorNames.get(this.color), thickness: this.#d, methodOfCreation: this.#u };
    }
    get telemetryFinalData() {
      return { type: "highlight", color: this._uiManager.highlightColorNames.get(this.color) };
    }
    static computeTelemetryFinalData(a) {
      return { numberOfColors: a.get("color").size };
    }
    #E() {
      const a = new $I(this.#e, 1e-3);
      this.#g = a.getOutlines(), { x: this.x, y: this.y, width: this.width, height: this.height } = this.#g.box;
      const g = new $I(this.#e, 25e-4, 1e-3, this._uiManager.direction === "ltr");
      this.#i = g.getOutlines();
      const { lastPoint: l } = this.#i.box;
      this.#l = [(l[0] - this.x) / this.width, (l[1] - this.y) / this.height];
    }
    #p({ highlightOutlines: a, highlightId: g, clipPathId: l }) {
      if (this.#g = a, this.#i = a.getNewOutline(this.#d / 2 + 1.5, 25e-4), g >= 0) this.#c = g, this.#s = l, this.parent.drawLayer.finalizeLine(g, a), this.#I = this.parent.drawLayer.highlightOutline(this.#i);
      else if (this.parent) {
        const k = this.parent.viewport.rotation;
        this.parent.drawLayer.updateLine(this.#c, a), this.parent.drawLayer.updateBox(this.#c, _A.#f(this.#g.box, (k - this.rotation + 360) % 360)), this.parent.drawLayer.updateLine(this.#I, this.#i), this.parent.drawLayer.updateBox(this.#I, _A.#f(this.#i.box, k));
      }
      const { x: B, y: Q, width: f, height: m } = a.box;
      switch (this.rotation) {
        case 0:
          this.x = B, this.y = Q, this.width = f, this.height = m;
          break;
        case 90: {
          const [k, F] = this.parentDimensions;
          this.x = Q, this.y = 1 - B, this.width = f * F / k, this.height = m * k / F;
          break;
        }
        case 180:
          this.x = 1 - B, this.y = 1 - Q, this.width = f, this.height = m;
          break;
        case 270: {
          const [k, F] = this.parentDimensions;
          this.x = 1 - Q, this.y = B, this.width = f * F / k, this.height = m * k / F;
          break;
        }
      }
      const { lastPoint: w } = this.#i.box;
      this.#l = [(w[0] - B) / f, (w[1] - Q) / m];
    }
    static initialize(a, g) {
      $t.initialize(a, g), _A._defaultColor ||= g.highlightColors?.values().next().value || "#fff066";
    }
    static updateDefaultParams(a, g) {
      switch (a) {
        case y.HIGHLIGHT_DEFAULT_COLOR:
          _A._defaultColor = g;
          break;
        case y.HIGHLIGHT_THICKNESS:
          _A._defaultThickness = g;
      }
    }
    translateInPage(a, g) {
    }
    get toolbarPosition() {
      return this.#l;
    }
    updateParams(a, g) {
      switch (a) {
        case y.HIGHLIGHT_COLOR:
          this.#y(g);
          break;
        case y.HIGHLIGHT_THICKNESS:
          this.#k(g);
      }
    }
    static get defaultPropertiesToUpdate() {
      return [[y.HIGHLIGHT_DEFAULT_COLOR, _A._defaultColor], [y.HIGHLIGHT_THICKNESS, _A._defaultThickness]];
    }
    get propertiesToUpdate() {
      return [[y.HIGHLIGHT_COLOR, this.color || _A._defaultColor], [y.HIGHLIGHT_THICKNESS, this.#d || _A._defaultThickness], [y.HIGHLIGHT_FREE, this.#n]];
    }
    #y(a) {
      const g = (B) => {
        this.color = B, this.parent?.drawLayer.changeColor(this.#c, B), this.#a?.updateColor(B);
      }, l = this.color;
      this.addCommands({ cmd: g.bind(this, a), undo: g.bind(this, l), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: !0, type: y.HIGHLIGHT_COLOR, overwriteIfSameType: !0, keepUndo: !0 }), this._reportTelemetry({ action: "color_changed", color: this._uiManager.highlightColorNames.get(a) }, !0);
    }
    #k(a) {
      const g = this.#d, l = (B) => {
        this.#d = B, this.#S(B);
      };
      this.addCommands({ cmd: l.bind(this, a), undo: l.bind(this, g), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: !0, type: y.INK_THICKNESS, overwriteIfSameType: !0, keepUndo: !0 }), this._reportTelemetry({ action: "thickness_changed", thickness: a }, !0);
    }
    async addEditToolbar() {
      const a = await super.addEditToolbar();
      return a ? (this._uiManager.highlightColors && (this.#a = new fi({ editor: this }), a.addColorPicker(this.#a)), a) : null;
    }
    disableEditing() {
      super.disableEditing(), this.div.classList.toggle("disabled", !0);
    }
    enableEditing() {
      super.enableEditing(), this.div.classList.toggle("disabled", !1);
    }
    fixAndSetPosition() {
      return super.fixAndSetPosition(this.#N());
    }
    getBaseTranslation() {
      return [0, 0];
    }
    getRect(a, g) {
      return super.getRect(a, g, this.#N());
    }
    onceAdded() {
      this.parent.addUndoableEditor(this), this.div.focus();
    }
    remove() {
      this.#x(), this._reportTelemetry({ action: "deleted" }), super.remove();
    }
    rebuild() {
      this.parent && (super.rebuild(), this.div !== null && (this.#w(), this.isAttachedToDOM || this.parent.add(this)));
    }
    setParent(a) {
      let g = !1;
      this.parent && !a ? this.#x() : a && (this.#w(a), g = !this.parent && this.div?.classList.contains("selectedEditor")), super.setParent(a), this.show(this._isVisible), g && this.select();
    }
    #S(a) {
      if (!this.#n) return;
      this.#p({ highlightOutlines: this.#g.getNewOutline(a / 2) }), this.fixAndSetPosition();
      const [g, l] = this.parentDimensions;
      this.setDims(this.width * g, this.height * l);
    }
    #x() {
      this.#c !== null && this.parent && (this.parent.drawLayer.remove(this.#c), this.#c = null, this.parent.drawLayer.remove(this.#I), this.#I = null);
    }
    #w(a = this.parent) {
      this.#c === null && ({ id: this.#c, clipPathId: this.#s } = a.drawLayer.highlight(this.#g, this.color, this.#C), this.#I = a.drawLayer.highlightOutline(this.#i), this.#h && (this.#h.style.clipPath = this.#s));
    }
    static #f({ x: a, y: g, width: l, height: B }, Q) {
      switch (Q) {
        case 90:
          return { x: 1 - g - B, y: a, width: B, height: l };
        case 180:
          return { x: 1 - a - l, y: 1 - g - B, width: l, height: B };
        case 270:
          return { x: g, y: 1 - a - l, width: B, height: l };
      }
      return { x: a, y: g, width: l, height: B };
    }
    rotate(a) {
      const { drawLayer: g } = this.parent;
      let l;
      this.#n ? (a = (a - this.rotation + 360) % 360, l = _A.#f(this.#g.box, a)) : l = _A.#f(this, a), g.rotate(this.#c, a), g.rotate(this.#I, a), g.updateBox(this.#c, l), g.updateBox(this.#I, _A.#f(this.#i.box, a));
    }
    render() {
      if (this.div) return this.div;
      const a = super.render();
      this.#B && (a.setAttribute("aria-label", this.#B), a.setAttribute("role", "mark")), this.#n ? a.classList.add("free") : this.div.addEventListener("keydown", this.#b.bind(this), { signal: this._uiManager._signal });
      const g = this.#h = document.createElement("div");
      a.append(g), g.setAttribute("aria-hidden", "true"), g.className = "internal", g.style.clipPath = this.#s;
      const [l, B] = this.parentDimensions;
      return this.setDims(this.width * l, this.height * B), Lr(this, this.#h, ["pointerover", "pointerleave"]), this.enableEditing(), a;
    }
    pointerover() {
      this.parent.drawLayer.addClass(this.#I, "hovered");
    }
    pointerleave() {
      this.parent.drawLayer.removeClass(this.#I, "hovered");
    }
    #b(a) {
      _A._keyboardManager.exec(this, a);
    }
    _moveCaret(a) {
      switch (this.parent.unselect(this), a) {
        case 0:
        case 2:
          this.#D(!0);
          break;
        case 1:
        case 3:
          this.#D(!1);
      }
    }
    #D(a) {
      if (!this.#t) return;
      const g = window.getSelection();
      a ? g.setPosition(this.#t, this.#A) : g.setPosition(this.#r, this.#o);
    }
    select() {
      super.select(), this.#I && (this.parent?.drawLayer.removeClass(this.#I, "hovered"), this.parent?.drawLayer.addClass(this.#I, "selected"));
    }
    unselect() {
      super.unselect(), this.#I && (this.parent?.drawLayer.removeClass(this.#I, "selected"), this.#n || this.#D(!1));
    }
    get _mustFixPosition() {
      return !this.#n;
    }
    show(a = this._isVisible) {
      super.show(a), this.parent && (this.parent.drawLayer.show(this.#c, a), this.parent.drawLayer.show(this.#I, a));
    }
    #N() {
      return this.#n ? this.rotation : 0;
    }
    #G() {
      if (this.#n) return null;
      const [a, g] = this.pageDimensions, [l, B] = this.pageTranslation, Q = this.#e, f = new Float32Array(8 * Q.length);
      let m = 0;
      for (const { x: w, y: k, width: F, height: v } of Q) {
        const L = w * a + l, J = (1 - k - v) * g + B;
        f[m] = f[m + 4] = L, f[m + 1] = f[m + 3] = J, f[m + 2] = f[m + 6] = L + F * a, f[m + 5] = f[m + 7] = J + v * g, m += 8;
      }
      return f;
    }
    #m(a) {
      return this.#g.serialize(a, this.#N());
    }
    static startHighlighting(a, g, { target: l, x: B, y: Q }) {
      const { x: f, y: m, width: w, height: k } = l.getBoundingClientRect(), F = new AbortController(), v = a.combinedSignal(F), L = (J) => {
        F.abort(), this.#R(a, J);
      };
      window.addEventListener("blur", L, { signal: v }), window.addEventListener("pointerup", L, { signal: v }), window.addEventListener("pointerdown", ((J) => {
        J.preventDefault(), J.stopPropagation();
      }), { capture: !0, passive: !1, signal: v }), window.addEventListener("contextmenu", je, { signal: v }), l.addEventListener("pointermove", this.#Q.bind(this, a), { signal: v }), this._freeHighlight = new Ks({ x: B, y: Q }, [f, m, w, k], a.scale, this._defaultThickness / 2, g, 1e-3), { id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = a.drawLayer.highlight(this._freeHighlight, this._defaultColor, this._defaultOpacity, !0);
    }
    static #Q(a, g) {
      this._freeHighlight.add(g) && a.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
    }
    static #R(a, g) {
      this._freeHighlight.isEmpty() ? a.drawLayer.removeFreeHighlight(this._freeHighlightId) : a.createAndAddNewEditor(g, !1, { highlightId: this._freeHighlightId, highlightOutlines: this._freeHighlight.getOutlines(), clipPathId: this._freeHighlightClipId, methodOfCreation: "main_toolbar" }), this._freeHighlightId = -1, this._freeHighlight = null, this._freeHighlightClipId = "";
    }
    static deserialize(a, g, l) {
      const B = super.deserialize(a, g, l), { rect: [Q, f, m, w], color: k, quadPoints: F } = a;
      B.color = Pt.makeHexColor(...k), B.#C = a.opacity;
      const [v, L] = B.pageDimensions;
      B.width = (m - Q) / v, B.height = (w - f) / L;
      const J = B.#e = [];
      for (let K = 0; K < F.length; K += 8) J.push({ x: (F[4] - m) / v, y: (w - (1 - F[K + 5])) / L, width: (F[K + 2] - F[K]) / v, height: (F[K + 5] - F[K + 1]) / L });
      return B.#E(), B;
    }
    serialize(a = !1) {
      if (this.isEmpty() || a) return null;
      const g = this.getRect(0, 0), l = $t._colorManager.convert(this.color);
      return { annotationType: p.HIGHLIGHT, color: l, opacity: this.#C, thickness: this.#d, quadPoints: this.#G(), outlines: this.#m(g), pageIndex: this.pageIndex, rect: g, rotation: this.#N(), structTreeParentId: this._structTreeParentId };
    }
    static canCreateNewEmptyEditor() {
      return !1;
    }
  }
  class ie extends $t {
    #t = 0;
    #A = 0;
    #e = null;
    #s = new Path2D();
    #a = !1;
    #i = null;
    #r = !1;
    #o = !1;
    #h = null;
    #g = null;
    #c = 0;
    #n = 0;
    #l = null;
    static _defaultColor = null;
    static _defaultOpacity = 1;
    static _defaultThickness = 1;
    static _type = "ink";
    static _editorType = p.INK;
    constructor(a) {
      super({ ...a, name: "inkEditor" }), this.color = a.color || null, this.thickness = a.thickness || null, this.opacity = a.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
    }
    static initialize(a, g) {
      $t.initialize(a, g);
    }
    static updateDefaultParams(a, g) {
      switch (a) {
        case y.INK_THICKNESS:
          ie._defaultThickness = g;
          break;
        case y.INK_COLOR:
          ie._defaultColor = g;
          break;
        case y.INK_OPACITY:
          ie._defaultOpacity = g / 100;
      }
    }
    updateParams(a, g) {
      switch (a) {
        case y.INK_THICKNESS:
          this.#C(g);
          break;
        case y.INK_COLOR:
          this.#I(g);
          break;
        case y.INK_OPACITY:
          this.#B(g);
      }
    }
    static get defaultPropertiesToUpdate() {
      return [[y.INK_THICKNESS, ie._defaultThickness], [y.INK_COLOR, ie._defaultColor || $t._defaultLineColor], [y.INK_OPACITY, Math.round(100 * ie._defaultOpacity)]];
    }
    get propertiesToUpdate() {
      return [[y.INK_THICKNESS, this.thickness || ie._defaultThickness], [y.INK_COLOR, this.color || ie._defaultColor || $t._defaultLineColor], [y.INK_OPACITY, Math.round(100 * (this.opacity ?? ie._defaultOpacity))]];
    }
    #C(a) {
      const g = (B) => {
        this.thickness = B, this.#H();
      }, l = this.thickness;
      this.addCommands({ cmd: g.bind(this, a), undo: g.bind(this, l), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: !0, type: y.INK_THICKNESS, overwriteIfSameType: !0, keepUndo: !0 });
    }
    #I(a) {
      const g = (B) => {
        this.color = B, this.#f();
      }, l = this.color;
      this.addCommands({ cmd: g.bind(this, a), undo: g.bind(this, l), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: !0, type: y.INK_COLOR, overwriteIfSameType: !0, keepUndo: !0 });
    }
    #B(a) {
      const g = (B) => {
        this.opacity = B, this.#f();
      };
      a /= 100;
      const l = this.opacity;
      this.addCommands({ cmd: g.bind(this, a), undo: g.bind(this, l), post: this._uiManager.updateUI.bind(this._uiManager, this), mustExec: !0, type: y.INK_OPACITY, overwriteIfSameType: !0, keepUndo: !0 });
    }
    rebuild() {
      this.parent && (super.rebuild(), this.div !== null && (this.canvas || (this.#G(), this.#m()), this.isAttachedToDOM || (this.parent.add(this), this.#Q()), this.#H()));
    }
    remove() {
      this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, this.#e && (clearTimeout(this.#e), this.#e = null), this.#h?.disconnect(), this.#h = null, super.remove());
    }
    setParent(a) {
      !this.parent && a ? this._uiManager.removeShouldRescale(this) : this.parent && a === null && this._uiManager.addShouldRescale(this), super.setParent(a);
    }
    onScaleChanging() {
      const [a, g] = this.parentDimensions, l = this.width * a, B = this.height * g;
      this.setDimensions(l, B);
    }
    enableEditMode() {
      this.#a || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, this.#b());
    }
    disableEditMode() {
      this.isInEditMode() && this.canvas !== null && (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.#D());
    }
    onceAdded() {
      this._isDraggable = !this.isEmpty();
    }
    isEmpty() {
      return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
    }
    #d() {
      const { parentRotation: a, parentDimensions: [g, l] } = this;
      switch (a) {
        case 90:
          return [0, l, l, g];
        case 180:
          return [g, l, g, l];
        case 270:
          return [g, 0, l, g];
        default:
          return [0, 0, g, l];
      }
    }
    #u() {
      const { ctx: a, color: g, opacity: l, thickness: B, parentScale: Q, scaleFactor: f } = this;
      a.lineWidth = B * Q / f, a.lineCap = "round", a.lineJoin = "round", a.miterLimit = 10, a.strokeStyle = `${g}${(function(m) {
        return Math.round(Math.min(255, Math.max(1, 255 * m))).toString(16).padStart(2, "0");
      })(l)}`;
    }
    #E(a, g) {
      this.canvas.addEventListener("contextmenu", je, { signal: this._uiManager._signal }), this.#D(), this.#i = new AbortController();
      const l = this._uiManager.combinedSignal(this.#i);
      this.canvas.addEventListener("pointerleave", this.canvasPointerleave.bind(this), { signal: l }), this.canvas.addEventListener("pointermove", this.canvasPointermove.bind(this), { signal: l }), this.canvas.addEventListener("pointerup", this.canvasPointerup.bind(this), { signal: l }), this.isEditing = !0, this.#o || (this.#o = !0, this.#Q(), this.thickness ||= ie._defaultThickness, this.color ||= ie._defaultColor || $t._defaultLineColor, this.opacity ??= ie._defaultOpacity), this.currentPath.push([a, g]), this.#r = !1, this.#u(), this.#l = () => {
        this.#S(), this.#l && window.requestAnimationFrame(this.#l);
      }, window.requestAnimationFrame(this.#l);
    }
    #p(a, g) {
      const [l, B] = this.currentPath.at(-1);
      if (this.currentPath.length > 1 && a === l && g === B) return;
      const Q = this.currentPath;
      let f = this.#s;
      if (Q.push([a, g]), this.#r = !0, Q.length <= 2) return f.moveTo(...Q[0]), void f.lineTo(a, g);
      Q.length === 3 && (this.#s = f = new Path2D(), f.moveTo(...Q[0])), this.#x(f, ...Q.at(-3), ...Q.at(-2), a, g);
    }
    #y() {
      if (this.currentPath.length === 0) return;
      const a = this.currentPath.at(-1);
      this.#s.lineTo(...a);
    }
    #k(a, g) {
      let l;
      if (this.#l = null, a = Math.min(Math.max(a, 0), this.canvas.width), g = Math.min(Math.max(g, 0), this.canvas.height), this.#p(a, g), this.#y(), this.currentPath.length !== 1) l = this.#w();
      else {
        const f = [a, g];
        l = [[f, f.slice(), f.slice(), f]];
      }
      const B = this.#s, Q = this.currentPath;
      this.currentPath = [], this.#s = new Path2D(), this.addCommands({ cmd: () => {
        this.allRawPaths.push(Q), this.paths.push(l), this.bezierPath2D.push(B), this._uiManager.rebuild(this);
      }, undo: () => {
        this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (this.#G(), this.#m()), this.#H());
      }, mustExec: !0 });
    }
    #S() {
      if (!this.#r) return;
      this.#r = !1, Math.ceil(this.thickness * this.parentScale);
      const a = this.currentPath.slice(-3), g = a.map(((Q) => Q[0])), l = a.map(((Q) => Q[1]));
      Math.min(...g), Math.max(...g), Math.min(...l), Math.max(...l);
      const { ctx: B } = this;
      B.save(), B.clearRect(0, 0, this.canvas.width, this.canvas.height);
      for (const Q of this.bezierPath2D) B.stroke(Q);
      B.stroke(this.#s), B.restore();
    }
    #x(a, g, l, B, Q, f, m) {
      const w = (g + B) / 2, k = (l + Q) / 2, F = (B + f) / 2, v = (Q + m) / 2;
      a.bezierCurveTo(w + 2 * (B - w) / 3, k + 2 * (Q - k) / 3, F + 2 * (B - F) / 3, v + 2 * (Q - v) / 3, F, v);
    }
    #w() {
      const a = this.currentPath;
      if (a.length <= 2) return [[a[0], a[0], a.at(-1), a.at(-1)]];
      const g = [];
      let l, [B, Q] = a[0];
      for (l = 1; l < a.length - 2; l++) {
        const [L, J] = a[l], [K, X] = a[l + 1], et = (L + K) / 2, At = (J + X) / 2, It = [B + 2 * (L - B) / 3, Q + 2 * (J - Q) / 3], kt = [et + 2 * (L - et) / 3, At + 2 * (J - At) / 3];
        g.push([[B, Q], It, kt, [et, At]]), [B, Q] = [et, At];
      }
      const [f, m] = a[l], [w, k] = a[l + 1], F = [B + 2 * (f - B) / 3, Q + 2 * (m - Q) / 3], v = [w + 2 * (f - w) / 3, k + 2 * (m - k) / 3];
      return g.push([[B, Q], F, v, [w, k]]), g;
    }
    #f() {
      if (this.isEmpty()) return void this.#v();
      this.#u();
      const { canvas: a, ctx: g } = this;
      g.setTransform(1, 0, 0, 1, 0, 0), g.clearRect(0, 0, a.width, a.height), this.#v();
      for (const l of this.bezierPath2D) g.stroke(l);
    }
    commit() {
      this.#a || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), this.#a = !0, this.div.classList.add("disabled"), this.#H(!0), this.select(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({ preventScroll: !0 }));
    }
    focusin(a) {
      this._focusEventsAllowed && (super.focusin(a), this.enableEditMode());
    }
    #b() {
      if (this.#g) return;
      this.#g = new AbortController();
      const a = this._uiManager.combinedSignal(this.#g);
      this.canvas.addEventListener("pointerdown", this.canvasPointerdown.bind(this), { signal: a });
    }
    #D() {
      this.pointerdownAC?.abort(), this.pointerdownAC = null;
    }
    canvasPointerdown(a) {
      a.button === 0 && this.isInEditMode() && !this.#a && (this.setInForeground(), a.preventDefault(), this.div.contains(document.activeElement) || this.div.focus({ preventScroll: !0 }), this.#E(a.offsetX, a.offsetY));
    }
    canvasPointermove(a) {
      a.preventDefault(), this.#p(a.offsetX, a.offsetY);
    }
    canvasPointerup(a) {
      a.preventDefault(), this.#N(a);
    }
    canvasPointerleave(a) {
      this.#N(a);
    }
    #N(a) {
      this.#i?.abort(), this.#i = null, this.#b(), this.#e && clearTimeout(this.#e), this.#e = setTimeout((() => {
        this.#e = null, this.canvas.removeEventListener("contextmenu", je);
      }), 10), this.#k(a.offsetX, a.offsetY), this.addToAnnotationStorage(), this.setInBackground();
    }
    #G() {
      this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", this.canvas.setAttribute("data-l10n-id", "pdfjs-ink-canvas"), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
    }
    #m() {
      this.#h = new ResizeObserver(((a) => {
        const g = a[0].contentRect;
        g.width && g.height && this.setDimensions(g.width, g.height);
      })), this.#h.observe(this.div), this._uiManager._signal.addEventListener("abort", (() => {
        this.#h?.disconnect(), this.#h = null;
      }), { once: !0 });
    }
    get isResizable() {
      return !this.isEmpty() && this.#a;
    }
    render() {
      if (this.div) return this.div;
      let a, g;
      this.width && (a = this.x, g = this.y), super.render(), this.div.setAttribute("data-l10n-id", "pdfjs-ink");
      const [l, B, Q, f] = this.#d();
      if (this.setAt(l, B, 0, 0), this.setDims(Q, f), this.#G(), this.width) {
        const [m, w] = this.parentDimensions;
        this.setAspectRatio(this.width * m, this.height * w), this.setAt(a * m, g * w, this.width * m, this.height * w), this.#o = !0, this.#Q(), this.setDims(this.width * m, this.height * w), this.#f(), this.div.classList.add("disabled");
      } else this.div.classList.add("editing"), this.enableEditMode();
      return this.#m(), this.div;
    }
    #Q() {
      if (!this.#o) return;
      const [a, g] = this.parentDimensions;
      this.canvas.width = Math.ceil(this.width * a), this.canvas.height = Math.ceil(this.height * g), this.#v();
    }
    setDimensions(a, g) {
      const l = Math.round(a), B = Math.round(g);
      if (this.#c === l && this.#n === B) return;
      this.#c = l, this.#n = B, this.canvas.style.visibility = "hidden";
      const [Q, f] = this.parentDimensions;
      this.width = a / Q, this.height = g / f, this.fixAndSetPosition(), this.#a && this.#R(a, g), this.#Q(), this.#f(), this.canvas.style.visibility = "visible", this.fixDims();
    }
    #R(a, g) {
      const l = this.#T(), B = (a - l) / this.#A, Q = (g - l) / this.#t;
      this.scaleFactor = Math.min(B, Q);
    }
    #v() {
      const a = this.#T() / 2;
      this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + a, this.translationY * this.scaleFactor + a);
    }
    static #M(a) {
      const g = new Path2D();
      for (let l = 0, B = a.length; l < B; l++) {
        const [Q, f, m, w] = a[l];
        l === 0 && g.moveTo(...Q), g.bezierCurveTo(f[0], f[1], m[0], m[1], w[0], w[1]);
      }
      return g;
    }
    static #K(a, g, l) {
      const [B, Q, f, m] = g;
      switch (l) {
        case 0:
          for (let w = 0, k = a.length; w < k; w += 2) a[w] += B, a[w + 1] = m - a[w + 1];
          break;
        case 90:
          for (let w = 0, k = a.length; w < k; w += 2) {
            const F = a[w];
            a[w] = a[w + 1] + B, a[w + 1] = F + Q;
          }
          break;
        case 180:
          for (let w = 0, k = a.length; w < k; w += 2) a[w] = f - a[w], a[w + 1] += Q;
          break;
        case 270:
          for (let w = 0, k = a.length; w < k; w += 2) {
            const F = a[w];
            a[w] = f - a[w + 1], a[w + 1] = m - F;
          }
          break;
        default:
          throw new Error("Invalid rotation");
      }
      return a;
    }
    static #J(a, g, l) {
      const [B, Q, f, m] = g;
      switch (l) {
        case 0:
          for (let w = 0, k = a.length; w < k; w += 2) a[w] -= B, a[w + 1] = m - a[w + 1];
          break;
        case 90:
          for (let w = 0, k = a.length; w < k; w += 2) {
            const F = a[w];
            a[w] = a[w + 1] - Q, a[w + 1] = F - B;
          }
          break;
        case 180:
          for (let w = 0, k = a.length; w < k; w += 2) a[w] = f - a[w], a[w + 1] -= Q;
          break;
        case 270:
          for (let w = 0, k = a.length; w < k; w += 2) {
            const F = a[w];
            a[w] = m - a[w + 1], a[w + 1] = f - F;
          }
          break;
        default:
          throw new Error("Invalid rotation");
      }
      return a;
    }
    #L(a, g, l, B) {
      const Q = [], f = this.thickness / 2, m = a * g + f, w = a * l + f;
      for (const k of this.paths) {
        const F = [], v = [];
        for (let L = 0, J = k.length; L < J; L++) {
          const [K, X, et, At] = k[L];
          if (K[0] === At[0] && K[1] === At[1] && J === 1) {
            const EA = a * K[0] + m, sA = a * K[1] + w;
            F.push(EA, sA), v.push(EA, sA);
            break;
          }
          const It = a * K[0] + m, kt = a * K[1] + w, Mt = a * X[0] + m, Ut = a * X[1] + w, xt = a * et[0] + m, Wt = a * et[1] + w, eA = a * At[0] + m, nA = a * At[1] + w;
          L === 0 && (F.push(It, kt), v.push(It, kt)), F.push(Mt, Ut, xt, Wt, eA, nA), v.push(Mt, Ut), L === J - 1 && v.push(eA, nA);
        }
        Q.push({ bezier: ie.#K(F, B, this.rotation), points: ie.#K(v, B, this.rotation) });
      }
      return Q;
    }
    #U() {
      let a = 1 / 0, g = -1 / 0, l = 1 / 0, B = -1 / 0;
      for (const Q of this.paths) for (const [f, m, w, k] of Q) {
        const F = Pt.bezierBoundingBox(...f, ...m, ...w, ...k);
        a = Math.min(a, F[0]), l = Math.min(l, F[1]), g = Math.max(g, F[2]), B = Math.max(B, F[3]);
      }
      return [a, l, g, B];
    }
    #T() {
      return this.#a ? Math.ceil(this.thickness * this.parentScale) : 0;
    }
    #H(a = !1) {
      if (this.isEmpty()) return;
      if (!this.#a) return void this.#f();
      const g = this.#U(), l = this.#T();
      this.#A = Math.max($t.MIN_SIZE, g[2] - g[0]), this.#t = Math.max($t.MIN_SIZE, g[3] - g[1]);
      const B = Math.ceil(l + this.#A * this.scaleFactor), Q = Math.ceil(l + this.#t * this.scaleFactor), [f, m] = this.parentDimensions;
      this.width = B / f, this.height = Q / m, this.setAspectRatio(B, Q);
      const w = this.translationX, k = this.translationY;
      this.translationX = -g[0], this.translationY = -g[1], this.#Q(), this.#f(), this.#c = B, this.#n = Q, this.setDims(B, Q);
      const F = a ? l / this.scaleFactor / 2 : 0;
      this.translate(w - this.translationX - F, k - this.translationY - F);
    }
    static deserialize(a, g, l) {
      if (a instanceof XI) return null;
      const B = super.deserialize(a, g, l);
      B.thickness = a.thickness, B.color = Pt.makeHexColor(...a.color), B.opacity = a.opacity;
      const [Q, f] = B.pageDimensions, m = B.width * Q, w = B.height * f, k = B.parentScale, F = a.thickness / 2;
      B.#a = !0, B.#c = Math.round(m), B.#n = Math.round(w);
      const { paths: v, rect: L, rotation: J } = a;
      for (let { bezier: X } of v) {
        X = ie.#J(X, L, J);
        const et = [];
        B.paths.push(et);
        let At = k * (X[0] - F), It = k * (X[1] - F);
        for (let Mt = 2, Ut = X.length; Mt < Ut; Mt += 6) {
          const xt = k * (X[Mt] - F), Wt = k * (X[Mt + 1] - F), eA = k * (X[Mt + 2] - F), nA = k * (X[Mt + 3] - F), EA = k * (X[Mt + 4] - F), sA = k * (X[Mt + 5] - F);
          et.push([[At, It], [xt, Wt], [eA, nA], [EA, sA]]), At = EA, It = sA;
        }
        const kt = this.#M(et);
        B.bezierPath2D.push(kt);
      }
      const K = B.#U();
      return B.#A = Math.max($t.MIN_SIZE, K[2] - K[0]), B.#t = Math.max($t.MIN_SIZE, K[3] - K[1]), B.#R(m, w), B;
    }
    serialize() {
      if (this.isEmpty()) return null;
      const a = this.getRect(0, 0), g = $t._colorManager.convert(this.ctx.strokeStyle);
      return { annotationType: p.INK, color: g, thickness: this.thickness, opacity: this.opacity, paths: this.#L(this.scaleFactor / this.parentScale, this.translationX, this.translationY, a), pageIndex: this.pageIndex, rect: a, rotation: this.rotation, structTreeParentId: this._structTreeParentId };
    }
  }
  class Ac extends $t {
    #t = null;
    #A = null;
    #e = null;
    #s = null;
    #a = null;
    #i = "";
    #r = null;
    #o = null;
    #h = null;
    #g = !1;
    #c = !1;
    static _type = "stamp";
    static _editorType = p.STAMP;
    constructor(a) {
      super({ ...a, name: "stampEditor" }), this.#s = a.bitmapUrl, this.#a = a.bitmapFile;
    }
    static initialize(a, g) {
      $t.initialize(a, g);
    }
    static get supportedTypes() {
      return aA(this, "supportedTypes", ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"].map(((a) => `image/${a}`)));
    }
    static get supportedTypesStr() {
      return aA(this, "supportedTypesStr", this.supportedTypes.join(","));
    }
    static isHandlingMimeForPasting(a) {
      return this.supportedTypes.includes(a);
    }
    static paste(a, g) {
      g.pasteEditor(p.STAMP, { bitmapFile: a.getAsFile() });
    }
    altTextFinish() {
      this._uiManager.useNewAltTextFlow && (this.div.hidden = !1), super.altTextFinish();
    }
    get telemetryFinalData() {
      return { type: "stamp", hasAltText: !!this.altTextData?.altText };
    }
    static computeTelemetryFinalData(a) {
      const g = a.get("hasAltText");
      return { hasAltText: g.get(!0) ?? 0, hasNoAltText: g.get(!1) ?? 0 };
    }
    #n(a, g = !1) {
      a ? (this.#t = a.bitmap, g || (this.#A = a.id, this.#g = a.isSvg), a.file && (this.#i = a.file.name), this.#I()) : this.remove();
    }
    #l() {
      if (this.#e = null, this._uiManager.enableWaiting(!1), this.#r) {
        if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#t) return this._editToolbar.hide(), void this._uiManager.editAltText(this, !0);
        if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#t) {
          this._reportTelemetry({ action: "pdfjs.image.image_added", data: { alt_text_modal: !1, alt_text_type: "empty" } });
          try {
            this.mlGuessAltText();
          } catch {
          }
        }
        this.div.focus();
      }
    }
    async mlGuessAltText(a = null, g = !0) {
      if (this.hasAltTextData()) return null;
      const { mlManager: l } = this._uiManager;
      if (!l) throw new Error("No ML.");
      if (!await l.isEnabledFor("altText")) throw new Error("ML isn't enabled for alt text.");
      const { data: B, width: Q, height: f } = a || this.copyCanvas(null, !0).imageData, m = await l.guess({ name: "altText", request: { data: B, width: Q, height: f, channels: B.length / (Q * f) } });
      if (!m) throw new Error("No response from the AI service.");
      if (m.error) throw new Error("Error from the AI service.");
      if (m.cancel) return null;
      if (!m.output) throw new Error("No valid response from the AI service.");
      const w = m.output;
      return await this.setGuessedAltText(w), g && !this.hasAltTextData() && (this.altTextData = { alt: w, decorative: !1 }), w;
    }
    #C() {
      if (this.#A) return this._uiManager.enableWaiting(!0), void this._uiManager.imageManager.getFromId(this.#A).then(((l) => this.#n(l, !0))).finally((() => this.#l()));
      if (this.#s) {
        const l = this.#s;
        return this.#s = null, this._uiManager.enableWaiting(!0), void (this.#e = this._uiManager.imageManager.getFromUrl(l).then(((B) => this.#n(B))).finally((() => this.#l())));
      }
      if (this.#a) {
        const l = this.#a;
        return this.#a = null, this._uiManager.enableWaiting(!0), void (this.#e = this._uiManager.imageManager.getFromFile(l).then(((B) => this.#n(B))).finally((() => this.#l())));
      }
      const a = document.createElement("input");
      a.type = "file", a.accept = Ac.supportedTypesStr;
      const g = this._uiManager._signal;
      this.#e = new Promise(((l) => {
        a.addEventListener("change", (async () => {
          if (a.files && a.files.length !== 0) {
            this._uiManager.enableWaiting(!0);
            const B = await this._uiManager.imageManager.getFromFile(a.files[0]);
            this._reportTelemetry({ action: "pdfjs.image.image_selected", data: { alt_text_modal: this._uiManager.useNewAltTextFlow } }), this.#n(B);
          } else this.remove();
          l();
        }), { signal: g }), a.addEventListener("cancel", (() => {
          this.remove(), l();
        }), { signal: g });
      })).finally((() => this.#l())), a.click();
    }
    remove() {
      this.#A && (this.#t = null, this._uiManager.imageManager.deleteId(this.#A), this.#r?.remove(), this.#r = null, this.#o?.disconnect(), this.#o = null, this.#h && (clearTimeout(this.#h), this.#h = null)), super.remove();
    }
    rebuild() {
      this.parent ? (super.rebuild(), this.div !== null && (this.#A && this.#r === null && this.#C(), this.isAttachedToDOM || this.parent.add(this))) : this.#A && this.#C();
    }
    onceAdded() {
      this._isDraggable = !0, this.div.focus();
    }
    isEmpty() {
      return !(this.#e || this.#t || this.#s || this.#a || this.#A);
    }
    get isResizable() {
      return !0;
    }
    render() {
      if (this.div) return this.div;
      let a, g;
      if (this.width && (a = this.x, g = this.y), super.render(), this.div.hidden = !0, this.addAltTextButton(), this.#t ? this.#I() : this.#C(), this.width) {
        const [l, B] = this.parentDimensions;
        this.setAt(a * l, g * B, this.width * l, this.height * B);
      }
      return this.div;
    }
    #I() {
      const { div: a } = this;
      let { width: g, height: l } = this.#t;
      const [B, Q] = this.pageDimensions, f = 0.75;
      if (this.width) g = this.width * B, l = this.height * Q;
      else if (g > f * B || l > f * Q) {
        const F = Math.min(f * B / g, f * Q / l);
        g *= F, l *= F;
      }
      const [m, w] = this.parentDimensions;
      this.setDims(g * m / B, l * w / Q), this._uiManager.enableWaiting(!1);
      const k = this.#r = document.createElement("canvas");
      a.append(k), this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow || (a.hidden = !1), this.#u(g, l), this.#p(), this.#c || (this.parent.addUndoableEditor(this), this.#c = !0), this._reportTelemetry({ action: "inserted_image" }), this.#i && k.setAttribute("aria-label", this.#i);
    }
    copyCanvas(a, g = !1) {
      a || (a = 224);
      const { width: l, height: B } = this.#t, Q = document.createElement("canvas");
      let f = this.#t, m = l, w = B;
      if (l > a || B > a) {
        const X = Math.min(a / l, a / B);
        m = Math.floor(l * X), w = Math.floor(B * X), this.#g || (f = this.#d(m, w));
      }
      Q.width = m, Q.height = w;
      const k = Q.getContext("2d");
      k.filter = this._uiManager.hcmFilter;
      let F = "white", v = "#cfcfd8";
      this._uiManager.hcmFilter !== "none" ? v = "black" : window.matchMedia?.("(prefers-color-scheme: dark)").matches && (F = "#8f8f9d", v = "#42414d");
      const L = 15, J = new OffscreenCanvas(30, 30), K = J.getContext("2d");
      if (K.fillStyle = F, K.fillRect(0, 0, 30, 30), K.fillStyle = v, K.fillRect(0, 0, L, L), K.fillRect(L, L, L, L), k.fillStyle = k.createPattern(J, "repeat"), k.fillRect(0, 0, m, w), g) {
        const X = new OffscreenCanvas(m, w), et = X.getContext("2d", { willReadFrequently: !0 });
        et.drawImage(f, 0, 0, f.width, f.height, 0, 0, m, w);
        const At = et.getImageData(0, 0, m, w).data;
        return k.drawImage(X, 0, 0), { canvas: Q, imageData: { width: m, height: w, data: At } };
      }
      return k.drawImage(f, 0, 0, f.width, f.height, 0, 0, m, w), { canvas: Q, imageData: null };
    }
    #B(a, g) {
      const [l, B] = this.parentDimensions;
      this.width = a / l, this.height = g / B, this.setDims(a, g), this._initialOptions?.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, this.#h !== null && clearTimeout(this.#h), this.#h = setTimeout((() => {
        this.#h = null, this.#u(a, g);
      }), 200);
    }
    #d(a, g) {
      const { width: l, height: B } = this.#t;
      let Q = l, f = B, m = this.#t;
      for (; Q > 2 * a || f > 2 * g; ) {
        const w = Q, k = f;
        Q > 2 * a && (Q = Q >= 16384 ? Math.floor(Q / 2) - 1 : Math.ceil(Q / 2)), f > 2 * g && (f = f >= 16384 ? Math.floor(f / 2) - 1 : Math.ceil(f / 2));
        const F = new OffscreenCanvas(Q, f);
        F.getContext("2d").drawImage(m, 0, 0, w, k, 0, 0, Q, f), m = F.transferToImageBitmap();
      }
      return m;
    }
    #u(a, g) {
      a = Math.ceil(a), g = Math.ceil(g);
      const l = this.#r;
      if (!l || l.width === a && l.height === g) return;
      l.width = a, l.height = g;
      const B = this.#g ? this.#t : this.#d(a, g), Q = l.getContext("2d");
      Q.filter = this._uiManager.hcmFilter, Q.drawImage(B, 0, 0, B.width, B.height, 0, 0, a, g);
    }
    getImageForAltText() {
      return this.#r;
    }
    #E(a) {
      if (a) {
        if (this.#g) {
          const l = this._uiManager.imageManager.getSvgUrl(this.#A);
          if (l) return l;
        }
        const g = document.createElement("canvas");
        return { width: g.width, height: g.height } = this.#t, g.getContext("2d").drawImage(this.#t, 0, 0), g.toDataURL();
      }
      if (this.#g) {
        const [g, l] = this.pageDimensions, B = Math.round(this.width * g * fa.PDF_TO_CSS_UNITS), Q = Math.round(this.height * l * fa.PDF_TO_CSS_UNITS), f = new OffscreenCanvas(B, Q);
        return f.getContext("2d").drawImage(this.#t, 0, 0, this.#t.width, this.#t.height, 0, 0, B, Q), f.transferToImageBitmap();
      }
      return structuredClone(this.#t);
    }
    #p() {
      this._uiManager._signal && (this.#o = new ResizeObserver(((a) => {
        const g = a[0].contentRect;
        g.width && g.height && this.#B(g.width, g.height);
      })), this.#o.observe(this.div), this._uiManager._signal.addEventListener("abort", (() => {
        this.#o?.disconnect(), this.#o = null;
      }), { once: !0 }));
    }
    static deserialize(a, g, l) {
      if (a instanceof zI) return null;
      const B = super.deserialize(a, g, l), { rect: Q, bitmapUrl: f, bitmapId: m, isSvg: w, accessibilityData: k } = a;
      m && l.imageManager.isValidId(m) ? B.#A = m : B.#s = f, B.#g = w;
      const [F, v] = B.pageDimensions;
      return B.width = (Q[2] - Q[0]) / F, B.height = (Q[3] - Q[1]) / v, k && (B.altTextData = k), B;
    }
    serialize(a = !1, g = null) {
      if (this.isEmpty()) return null;
      const l = { annotationType: p.STAMP, bitmapId: this.#A, pageIndex: this.pageIndex, rect: this.getRect(0, 0), rotation: this.rotation, isSvg: this.#g, structTreeParentId: this._structTreeParentId };
      if (a) return l.bitmapUrl = this.#E(!0), l.accessibilityData = this.serializeAltText(!0), l;
      const { decorative: B, altText: Q } = this.serializeAltText(!1);
      if (!B && Q && (l.accessibilityData = { type: "Figure", alt: Q }), g === null) return l;
      g.stamps ||= /* @__PURE__ */ new Map();
      const f = this.#g ? (l.rect[2] - l.rect[0]) * (l.rect[3] - l.rect[1]) : null;
      if (g.stamps.has(this.#A)) {
        if (this.#g) {
          const m = g.stamps.get(this.#A);
          f > m.area && (m.area = f, m.serialized.bitmap.close(), m.serialized.bitmap = this.#E(!1));
        }
      } else g.stamps.set(this.#A, { area: f, serialized: l }), l.bitmap = this.#E(!1);
      return l;
    }
  }
  class Ji {
    #t;
    #A = !1;
    #e = null;
    #s = null;
    #a = null;
    #i = /* @__PURE__ */ new Map();
    #r = !1;
    #o = !1;
    #h = !1;
    #g = null;
    #c = null;
    #n;
    static _initialized = !1;
    static #l = new Map([jA, ie, Ac, _A].map(((a) => [a._editorType, a])));
    constructor({ uiManager: a, pageIndex: g, div: l, accessibilityManager: B, annotationLayer: Q, drawLayer: f, textLayer: m, viewport: w, l10n: k }) {
      const F = [...Ji.#l.values()];
      if (!Ji._initialized) {
        Ji._initialized = !0;
        for (const v of F) v.initialize(k, a);
      }
      a.registerEditorTypes(F), this.#n = a, this.pageIndex = g, this.div = l, this.#t = B, this.#e = Q, this.viewport = w, this.#g = m, this.drawLayer = f, this.#n.addLayer(this);
    }
    get isEmpty() {
      return this.#i.size === 0;
    }
    get isInvisible() {
      return this.isEmpty && this.#n.getMode() === p.NONE;
    }
    updateToolbar(a) {
      this.#n.updateToolbar(a);
    }
    updateMode(a = this.#n.getMode()) {
      switch (this.#u(), a) {
        case p.NONE:
          return this.disableTextSelection(), this.togglePointerEvents(!1), this.toggleAnnotationLayerPointerEvents(!0), void this.disableClick();
        case p.INK:
          this.addInkEditorIfNeeded(!1), this.disableTextSelection(), this.togglePointerEvents(!0), this.disableClick();
          break;
        case p.HIGHLIGHT:
          this.enableTextSelection(), this.togglePointerEvents(!1), this.disableClick();
          break;
        default:
          this.disableTextSelection(), this.togglePointerEvents(!0), this.enableClick();
      }
      this.toggleAnnotationLayerPointerEvents(!1);
      const { classList: g } = this.div;
      for (const l of Ji.#l.values()) g.toggle(`${l._type}Editing`, a === l._editorType);
      this.div.hidden = !1;
    }
    hasTextLayer(a) {
      return a === this.#g?.div;
    }
    addInkEditorIfNeeded(a) {
      if (this.#n.getMode() === p.INK) {
        if (!a) {
          for (const g of this.#i.values()) if (g.isEmpty()) return void g.setInBackground();
        }
        this.createAndAddNewEditor({ offsetX: 0, offsetY: 0 }, !1).setInBackground();
      }
    }
    setEditingState(a) {
      this.#n.setEditingState(a);
    }
    addCommands(a) {
      this.#n.addCommands(a);
    }
    toggleDrawing(a = !1) {
      this.div.classList.toggle("drawing", !a);
    }
    togglePointerEvents(a = !1) {
      this.div.classList.toggle("disabled", !a);
    }
    toggleAnnotationLayerPointerEvents(a = !1) {
      this.#e?.div.classList.toggle("disabled", !a);
    }
    enable() {
      this.div.tabIndex = 0, this.togglePointerEvents(!0);
      const a = /* @__PURE__ */ new Set();
      for (const l of this.#i.values()) l.enableEditing(), l.show(!0), l.annotationElementId && (this.#n.removeChangedExistingAnnotation(l), a.add(l.annotationElementId));
      if (!this.#e) return;
      const g = this.#e.getEditableAnnotations();
      for (const l of g) {
        if (l.hide(), this.#n.isDeletedAnnotationElement(l.data.id) || a.has(l.data.id)) continue;
        const B = this.deserialize(l);
        B && (this.addOrRebuild(B), B.enableEditing());
      }
    }
    disable() {
      this.#h = !0, this.div.tabIndex = -1, this.togglePointerEvents(!1);
      const a = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Map();
      for (const B of this.#i.values()) B.disableEditing(), B.annotationElementId && (B.serialize() === null ? (g.set(B.annotationElementId, B), this.getEditableAnnotation(B.annotationElementId)?.show(), B.remove()) : a.set(B.annotationElementId, B));
      if (this.#e) {
        const B = this.#e.getEditableAnnotations();
        for (const Q of B) {
          const { id: f } = Q.data;
          if (this.#n.isDeletedAnnotationElement(f)) continue;
          let m = g.get(f);
          m ? (m.resetAnnotationElement(Q), m.show(!1), Q.show()) : (m = a.get(f), m && (this.#n.addChangedExistingAnnotation(m), m.renderAnnotationElement(Q), m.show(!1)), Q.show());
        }
      }
      this.#u(), this.isEmpty && (this.div.hidden = !0);
      const { classList: l } = this.div;
      for (const B of Ji.#l.values()) l.remove(`${B._type}Editing`);
      this.disableTextSelection(), this.toggleAnnotationLayerPointerEvents(!0), this.#h = !1;
    }
    getEditableAnnotation(a) {
      return this.#e?.getEditableAnnotation(a) || null;
    }
    setActiveEditor(a) {
      this.#n.getActive() !== a && this.#n.setActiveEditor(a);
    }
    enableTextSelection() {
      if (this.div.tabIndex = -1, this.#g?.div && !this.#c) {
        this.#c = new AbortController();
        const a = this.#n.combinedSignal(this.#c);
        this.#g.div.addEventListener("pointerdown", this.#C.bind(this), { signal: a }), this.#g.div.classList.add("highlighting");
      }
    }
    disableTextSelection() {
      this.div.tabIndex = 0, this.#g?.div && this.#c && (this.#c.abort(), this.#c = null, this.#g.div.classList.remove("highlighting"));
    }
    #C(a) {
      this.#n.unselectAll();
      const { target: g } = a;
      if (g === this.#g.div || g.classList.contains("endOfContent") && this.#g.div.contains(g)) {
        const { isMac: l } = be.platform;
        if (a.button !== 0 || a.ctrlKey && l) return;
        this.#n.showAllEditors("highlight", !0, !0), this.#g.div.classList.add("free"), this.toggleDrawing(), _A.startHighlighting(this, this.#n.direction === "ltr", a), this.#g.div.addEventListener("pointerup", (() => {
          this.#g.div.classList.remove("free"), this.toggleDrawing(!0);
        }), { once: !0, signal: this.#n._signal }), a.preventDefault();
      }
    }
    enableClick() {
      if (this.#s) return;
      this.#s = new AbortController();
      const a = this.#n.combinedSignal(this.#s);
      this.div.addEventListener("pointerdown", this.pointerdown.bind(this), { signal: a }), this.div.addEventListener("pointerup", this.pointerup.bind(this), { signal: a });
    }
    disableClick() {
      this.#s?.abort(), this.#s = null;
    }
    attach(a) {
      this.#i.set(a.id, a);
      const { annotationElementId: g } = a;
      g && this.#n.isDeletedAnnotationElement(g) && this.#n.removeDeletedAnnotationElement(a);
    }
    detach(a) {
      this.#i.delete(a.id), this.#t?.removePointerInTextLayer(a.contentDiv), !this.#h && a.annotationElementId && this.#n.addDeletedAnnotationElement(a);
    }
    remove(a) {
      this.detach(a), this.#n.removeEditor(a), a.div.remove(), a.isAttachedToDOM = !1, this.#o || this.addInkEditorIfNeeded(!1);
    }
    changeParent(a) {
      a.parent !== this && (a.parent && a.annotationElementId && (this.#n.addDeletedAnnotationElement(a.annotationElementId), $t.deleteAnnotationElement(a), a.annotationElementId = null), this.attach(a), a.parent?.detach(a), a.setParent(this), a.div && a.isAttachedToDOM && (a.div.remove(), this.div.append(a.div)));
    }
    add(a) {
      if (a.parent !== this || !a.isAttachedToDOM) {
        if (this.changeParent(a), this.#n.addEditor(a), this.attach(a), !a.isAttachedToDOM) {
          const g = a.render();
          this.div.append(g), a.isAttachedToDOM = !0;
        }
        a.fixAndSetPosition(), a.onceAdded(), this.#n.addToAnnotationStorage(a), a._reportTelemetry(a.telemetryInitialData);
      }
    }
    moveEditorInDOM(a) {
      if (!a.isAttachedToDOM) return;
      const { activeElement: g } = document;
      a.div.contains(g) && !this.#a && (a._focusEventsAllowed = !1, this.#a = setTimeout((() => {
        this.#a = null, a.div.contains(document.activeElement) ? a._focusEventsAllowed = !0 : (a.div.addEventListener("focusin", (() => {
          a._focusEventsAllowed = !0;
        }), { once: !0, signal: this.#n._signal }), g.focus());
      }), 0)), a._structTreeParentId = this.#t?.moveElementInDOM(this.div, a.div, a.contentDiv, !0);
    }
    addOrRebuild(a) {
      a.needsToBeRebuilt() ? (a.parent ||= this, a.rebuild(), a.show()) : this.add(a);
    }
    addUndoableEditor(a) {
      this.addCommands({ cmd: () => a._uiManager.rebuild(a), undo: () => {
        a.remove();
      }, mustExec: !1 });
    }
    getNextId() {
      return this.#n.getId();
    }
    get #I() {
      return Ji.#l.get(this.#n.getMode());
    }
    combinedSignal(a) {
      return this.#n.combinedSignal(a);
    }
    #B(a) {
      const g = this.#I;
      return g ? new g.prototype.constructor(a) : null;
    }
    canCreateNewEmptyEditor() {
      return this.#I?.canCreateNewEmptyEditor();
    }
    pasteEditor(a, g) {
      this.#n.updateToolbar(a), this.#n.updateMode(a);
      const { offsetX: l, offsetY: B } = this.#d(), Q = this.getNextId(), f = this.#B({ parent: this, id: Q, x: l, y: B, uiManager: this.#n, isCentered: !0, ...g });
      f && this.add(f);
    }
    deserialize(a) {
      return Ji.#l.get(a.annotationType ?? a.annotationEditorType)?.deserialize(a, this, this.#n) || null;
    }
    createAndAddNewEditor(a, g, l = {}) {
      const B = this.getNextId(), Q = this.#B({ parent: this, id: B, x: a.offsetX, y: a.offsetY, uiManager: this.#n, isCentered: g, ...l });
      return Q && this.add(Q), Q;
    }
    #d() {
      const { x: a, y: g, width: l, height: B } = this.div.getBoundingClientRect(), Q = Math.max(0, a), f = Math.max(0, g), m = (Q + Math.min(window.innerWidth, a + l)) / 2 - a, w = (f + Math.min(window.innerHeight, g + B)) / 2 - g, [k, F] = this.viewport.rotation % 180 == 0 ? [m, w] : [w, m];
      return { offsetX: k, offsetY: F };
    }
    addNewEditor() {
      this.createAndAddNewEditor(this.#d(), !0);
    }
    setSelected(a) {
      this.#n.setSelected(a);
    }
    toggleSelected(a) {
      this.#n.toggleSelected(a);
    }
    isSelected(a) {
      return this.#n.isSelected(a);
    }
    unselect(a) {
      this.#n.unselect(a);
    }
    pointerup(a) {
      const { isMac: g } = be.platform;
      a.button !== 0 || a.ctrlKey && g || a.target === this.div && this.#r && (this.#r = !1, this.#A ? this.#n.getMode() !== p.STAMP ? this.createAndAddNewEditor(a, !1) : this.#n.unselectAll() : this.#A = !0);
    }
    pointerdown(a) {
      if (this.#n.getMode() === p.HIGHLIGHT && this.enableTextSelection(), this.#r) return void (this.#r = !1);
      const { isMac: g } = be.platform;
      if (a.button !== 0 || a.ctrlKey && g || a.target !== this.div) return;
      this.#r = !0;
      const l = this.#n.getActive();
      this.#A = !l || l.isEmpty();
    }
    findNewParent(a, g, l) {
      const B = this.#n.findParent(g, l);
      return B !== null && B !== this && (B.changeParent(a), !0);
    }
    destroy() {
      this.#n.getActive()?.parent === this && (this.#n.commitOrRemove(), this.#n.setActiveEditor(null)), this.#a && (clearTimeout(this.#a), this.#a = null);
      for (const a of this.#i.values()) this.#t?.removePointerInTextLayer(a.contentDiv), a.setParent(null), a.isAttachedToDOM = !1, a.div.remove();
      this.div = null, this.#i.clear(), this.#n.removeLayer(this);
    }
    #u() {
      this.#o = !0;
      for (const a of this.#i.values()) a.isEmpty() && a.remove();
      this.#o = !1;
    }
    render({ viewport: a }) {
      this.viewport = a, Hs(this.div, a);
      for (const g of this.#n.getEditors(this.pageIndex)) this.add(g), g.rebuild();
      this.updateMode();
    }
    update({ viewport: a }) {
      this.#n.commitOrRemove(), this.#u();
      const g = this.viewport.rotation, l = a.rotation;
      if (this.viewport = a, Hs(this.div, { rotation: l }), g !== l) for (const B of this.#i.values()) B.rotate(l);
      this.addInkEditorIfNeeded(!1);
    }
    get pageDimensions() {
      const { pageWidth: a, pageHeight: g } = this.viewport.rawDims;
      return [a, g];
    }
    get scale() {
      return this.#n.viewParameters.realScale;
    }
  }
  class ge {
    #t = null;
    #A = 0;
    #e = /* @__PURE__ */ new Map();
    #s = /* @__PURE__ */ new Map();
    constructor({ pageIndex: a }) {
      this.pageIndex = a;
    }
    setParent(a) {
      if (this.#t) {
        if (this.#t !== a) {
          if (this.#e.size > 0) for (const g of this.#e.values()) g.remove(), a.append(g);
          this.#t = a;
        }
      } else this.#t = a;
    }
    static get _svgFactory() {
      return aA(this, "_svgFactory", new Gg());
    }
    static #a(a, { x: g = 0, y: l = 0, width: B = 1, height: Q = 1 } = {}) {
      const { style: f } = a;
      f.top = 100 * l + "%", f.left = 100 * g + "%", f.width = 100 * B + "%", f.height = 100 * Q + "%";
    }
    #i(a) {
      const g = ge._svgFactory.create(1, 1, !0);
      return this.#t.append(g), g.setAttribute("aria-hidden", !0), ge.#a(g, a), g;
    }
    #r(a, g) {
      const l = ge._svgFactory.createElement("clipPath");
      a.append(l);
      const B = `clip_${g}`;
      l.setAttribute("id", B), l.setAttribute("clipPathUnits", "objectBoundingBox");
      const Q = ge._svgFactory.createElement("use");
      return l.append(Q), Q.setAttribute("href", `#${g}`), Q.classList.add("clip"), B;
    }
    highlight(a, g, l, B = !1) {
      const Q = this.#A++, f = this.#i(a.box);
      f.classList.add("highlight"), a.free && f.classList.add("free");
      const m = ge._svgFactory.createElement("defs");
      f.append(m);
      const w = ge._svgFactory.createElement("path");
      m.append(w);
      const k = `path_p${this.pageIndex}_${Q}`;
      w.setAttribute("id", k), w.setAttribute("d", a.toSVGPath()), B && this.#s.set(Q, w);
      const F = this.#r(m, k), v = ge._svgFactory.createElement("use");
      return f.append(v), f.setAttribute("fill", g), f.setAttribute("fill-opacity", l), v.setAttribute("href", `#${k}`), this.#e.set(Q, f), { id: Q, clipPathId: `url(#${F})` };
    }
    highlightOutline(a) {
      const g = this.#A++, l = this.#i(a.box);
      l.classList.add("highlightOutline");
      const B = ge._svgFactory.createElement("defs");
      l.append(B);
      const Q = ge._svgFactory.createElement("path");
      B.append(Q);
      const f = `path_p${this.pageIndex}_${g}`;
      let m;
      if (Q.setAttribute("id", f), Q.setAttribute("d", a.toSVGPath()), Q.setAttribute("vector-effect", "non-scaling-stroke"), a.free) {
        l.classList.add("free");
        const F = ge._svgFactory.createElement("mask");
        B.append(F), m = `mask_p${this.pageIndex}_${g}`, F.setAttribute("id", m), F.setAttribute("maskUnits", "objectBoundingBox");
        const v = ge._svgFactory.createElement("rect");
        F.append(v), v.setAttribute("width", "1"), v.setAttribute("height", "1"), v.setAttribute("fill", "white");
        const L = ge._svgFactory.createElement("use");
        F.append(L), L.setAttribute("href", `#${f}`), L.setAttribute("stroke", "none"), L.setAttribute("fill", "black"), L.setAttribute("fill-rule", "nonzero"), L.classList.add("mask");
      }
      const w = ge._svgFactory.createElement("use");
      l.append(w), w.setAttribute("href", `#${f}`), m && w.setAttribute("mask", `url(#${m})`);
      const k = w.cloneNode();
      return l.append(k), w.classList.add("mainOutline"), k.classList.add("secondaryOutline"), this.#e.set(g, l), g;
    }
    finalizeLine(a, g) {
      const l = this.#s.get(a);
      this.#s.delete(a), this.updateBox(a, g.box), l.setAttribute("d", g.toSVGPath());
    }
    updateLine(a, g) {
      this.#e.get(a).firstChild.firstChild.setAttribute("d", g.toSVGPath());
    }
    removeFreeHighlight(a) {
      this.remove(a), this.#s.delete(a);
    }
    updatePath(a, g) {
      this.#s.get(a).setAttribute("d", g.toSVGPath());
    }
    updateBox(a, g) {
      ge.#a(this.#e.get(a), g);
    }
    show(a, g) {
      this.#e.get(a).classList.toggle("hidden", !g);
    }
    rotate(a, g) {
      this.#e.get(a).setAttribute("data-main-rotation", g);
    }
    changeColor(a, g) {
      this.#e.get(a).setAttribute("fill", g);
    }
    changeOpacity(a, g) {
      this.#e.get(a).setAttribute("fill-opacity", g);
    }
    addClass(a, g) {
      this.#e.get(a).classList.add(g);
    }
    removeClass(a, g) {
      this.#e.get(a).classList.remove(g);
    }
    remove(a) {
      this.#t !== null && (this.#e.get(a).remove(), this.#e.delete(a));
    }
    destroy() {
      this.#t = null;
      for (const a of this.#e.values()) a.remove();
      this.#e.clear();
    }
  }
  return { AbortException: t.AbortException, AnnotationEditorLayer: t.AnnotationEditorLayer, AnnotationEditorParamsType: t.AnnotationEditorParamsType, AnnotationEditorType: t.AnnotationEditorType, AnnotationEditorUIManager: t.AnnotationEditorUIManager, AnnotationLayer: t.AnnotationLayer, AnnotationMode: t.AnnotationMode, CMapCompressionType: t.CMapCompressionType, ColorPicker: t.ColorPicker, DOMSVGFactory: t.DOMSVGFactory, DrawLayer: t.DrawLayer, FeatureTest: t.FeatureTest, GlobalWorkerOptions: t.GlobalWorkerOptions, ImageKind: t.ImageKind, InvalidPDFException: t.InvalidPDFException, MissingPDFException: t.MissingPDFException, OPS: t.OPS, PDFDataRangeTransport: t.PDFDataRangeTransport, PDFDateString: t.PDFDateString, PDFWorker: t.PDFWorker, PasswordResponses: t.PasswordResponses, PermissionFlag: t.PermissionFlag, PixelsPerInch: t.PixelsPerInch, RenderingCancelledException: t.RenderingCancelledException, TextLayer: t.TextLayer, UnexpectedResponseException: t.UnexpectedResponseException, Util: t.Util, VerbosityLevel: t.VerbosityLevel, XfaLayer: t.XfaLayer, build: t.build, createValidAbsoluteUrl: t.createValidAbsoluteUrl, fetchData: t.fetchData, getDocument: t.getDocument, getFilenameFromUrl: t.getFilenameFromUrl, getPdfFilenameFromUrl: t.getPdfFilenameFromUrl, getXfaPageViewport: t.getXfaPageViewport, isDataScheme: t.isDataScheme, isPdfFile: t.isPdfFile, noContextMenu: t.noContextMenu, normalizeUnicode: t.normalizeUnicode, setLayerDimensions: t.setLayerDimensions, shadow: t.shadow, version: t.version };
}
function dD() {
  return BD();
}
!p9 && typeof self < "u" && typeof (au = self).postMessage == "function" && "onmessage" in au && fr.initializeFromPort(self), Promise.withResolvers ??= function() {
  let A, t;
  return { promise: new Promise(((e, i) => {
    A = e, t = i;
  })), resolve: A, reject: t };
};
const QD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  resolvePDFJS: dD
}, Symbol.toStringTag, { value: "Module" }));
//# sourceMappingURL=pdf_worker.js.map
